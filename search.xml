<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/26-%E5%86%99%E4%BD%9C%E6%9C%AC%E4%B9%A6%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"/>
      <url>/2022/10/31/model-mysql/mysql/26-%E5%86%99%E4%BD%9C%E6%9C%AC%E4%B9%A6%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<h1 id="第26章-写作本书时用到的一些重要的参考资料"><a href="#第26章-写作本书时用到的一些重要的参考资料" class="headerlink" title="第26章 写作本书时用到的一些重要的参考资料"></a>第26章 写作本书时用到的一些重要的参考资料</h1><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>&amp;emsp;&amp;emsp;我不生产知识，只是知识的搬运工。写作本小册的时间主要用在了两个方面：</p><ul><li><p>搞清楚事情的本质是什么。</p><p>  &amp;emsp;&amp;emsp;这个过程就是研究源码、书籍和资料。</p></li><li><p>如何把我已经知道的知识表达出来。</p><p>  &amp;emsp;&amp;emsp;这个过程就是我不停的在地上走过来走过去，梳理知识结构，斟酌用词用句，不停的将已经写好的文章推倒重来，只是想给大家一个不错的用户体验。</p></li></ul><p>&amp;emsp;&amp;emsp;这两个方面用的时间基本上是一半一半吧，在搞清楚事情的本质是什么阶段，除了直接阅读<code>MySQL</code>的源码之外，查看参考资料也是一种比较偷懒的学习方式。本书只是<code>MySQL</code>进阶的一个入门，想了解更多关于<code>MySQL</code>的知识，大家可以从下面这些资料里找点灵感。</p><h2 id="一些链接"><a href="#一些链接" class="headerlink" title="一些链接"></a>一些链接</h2><ul><li><p>MySQL官方文档：<a href="https://dev.mysql.com/doc/refman/5.7/en/">https://dev.mysql.com/doc/refman/5.7/en/</a></p><p>  &amp;emsp;&amp;emsp;<code>MySQL</code>官方文档是写作本书时参考最多的一个资料。说实话，文档写的非常通俗易懂，唯一的缺点就是太长了，导致大家看的时候无从下手。</p></li><li><p>MySQL Internals Manual：<a href="https://dev.mysql.com/doc/internals/en/">https://dev.mysql.com/doc/internals/en/</a></p><p>  &amp;emsp;&amp;emsp;介绍MySQL如何实现各种功能的文档，写的比较好，但是太少了，有很多章节直接跳过了。</p></li><li><p>何登成的github：<a href="https://github.com/hedengcheng/tech">https://github.com/hedengcheng/tech</a></p><p>  &amp;emsp;&amp;emsp;登博的博客非常好，对事务、优化这讨论的细节也非常多，不过由于大多是PPT结构，字太少，对上下文不清楚的同学可能会一脸懵逼。</p></li><li><p>orczhou的博客：<a href="http://www.orczhou.com/">http://www.orczhou.com/</a></p></li><li><p>Jeremy Cole的博客：<a href="https://blog.jcole.us/innodb/">https://blog.jcole.us/innodb/</a></p><p>  &amp;emsp;&amp;emsp;Jeremy Cole大神不仅写作了<code>innodb_ruby</code>这个非常棒的解析<code>InnoDB</code>存储结构的工具，还对这些存储结构写了一系列的博客，在我几乎要放弃深入研究表空间结构的时候，是他老人家的博客把我又从深渊里拉了回来。</p></li><li><p>那海蓝蓝（李海翔）的博客：<a href="https://blog.csdn.net/fly2nn">https://blog.csdn.net/fly2nn</a></p></li><li><p>taobao月报：<a href="http://mysql.taobao.org/monthly/">http://mysql.taobao.org/monthly/</a></p><p>  &amp;emsp;&amp;emsp;因为MySQL的源码非常多，经常让大家无从下手，而taobao月报就是一个非常好的源码阅读指南。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吐槽一下，这个taobao月报也只能当作源码阅读指南看，如果真的不看源码光看月报，那只能当作天书看，十有八九被绕进去出不来了。</span><br></pre></td></tr></table></figure></li><li><p>MySQL Server Blog：<a href="http://mysqlserverteam.com/">http://mysqlserverteam.com/</a></p><p>  &amp;emsp;&amp;emsp;MySQL team的博客，一手资料，在我不知道看什么的时候给了很多启示。</p></li><li><p>mysql_lover的博客：<a href="https://blog.csdn.net/mysql_lover/">https://blog.csdn.net/mysql_lover&#x2F;</a></p></li><li><p>Jorgen’s point of view：<a href="https://jorgenloland.blogspot.com/">https://jorgenloland.blogspot.com/</a></p></li><li><p>mariadb的关于查询优化的文档：<a href="https://mariadb.com/kb/en/library/query-optimizations/">https://mariadb.com/kb/en/library/query-optimizations/</a></p><p>  &amp;emsp;&amp;emsp;不得不说mariadb的文档相比MySQL的来说就非常有艺术性了（里边儿有很多漂亮的插图），我很怀疑MySQL文档是程序员直接写的，mariadb的文档是产品经理写的。当我们想研究某个功能的原理，在MySQL文档干巴巴的说明中找不到头脑时，可以参考一下mariadb娓娓道来的风格。</p></li><li><p>Reconstructing Data Manipulation Queries from Redo Logs：<a href="https://www.sba-research.org/wp-content/uploads/publications/WSDF2012_InnoDB.pdf">https://www.sba-research.org/wp-content/uploads/publications/WSDF2012_InnoDB.pdf</a></p></li><li><p>关于InnoDB事务的一个PPT：<a href="https://mariadb.org/wp-content/uploads/2018/02/Deep-Dive_-InnoDB-Transactions-and-Write-Paths.pdf">https://mariadb.org/wp-content/uploads/2018/02/Deep-Dive_-InnoDB-Transactions-and-Write-Paths.pdf</a></p></li><li><p>非官方优化文档：<a href="http://www.unofficialmysqlguide.com/optimizer-trace.html">http://www.unofficialmysqlguide.com/optimizer-trace.html</a></p><p>  &amp;emsp;&amp;emsp;这个文档非常好，非常非常好～</p></li><li><p>MySQL8.0的源码文档：<a href="https://dev.mysql.com/doc/dev/mysql-server">https://dev.mysql.com/doc/dev/mysql-server</a></p></li></ul><h2 id="一些书籍"><a href="#一些书籍" class="headerlink" title="一些书籍"></a>一些书籍</h2><ul><li><p>《数据库查询优化器的艺术》李海翔著</p><p>  &amp;emsp;&amp;emsp;大家可以把这本书当作源码观看指南来看，不过讲的是5.6的源码，5.7里重构了一些，不过大体的思路还是可以参考的。</p></li><li><p>《MySQL运维内参》周彦伟、王竹峰、强昌金著</p><p>  &amp;emsp;&amp;emsp;内参里有许多代码细节，是一个阅读源码的比较好的指南。</p></li><li><p>《Effectiv MySQL：Optimizing SQL Statements》Ronald Bradford著</p><p>  &amp;emsp;&amp;emsp;小册子，可以一口气看完，对了解MySQL查询优化的大概内容还是有些好处滴。</p></li><li><p>《高性能MySQL》瓦茨 (Baron Schwartz) &#x2F; 扎伊采夫 (Peter Zaitsev) &#x2F; 特卡琴科 (Vadim Tkachenko) 著</p><p>  &amp;emsp;&amp;emsp;经典，对于第三版的内容来说，如果把第2章和第3章的内容放到最后就更好了。不过作者更愿意把MySQL当作一个黑盒去讲述，主要是说明了如何更好的使用MySQL这个软件，这一点从第二版向第三版的转变上就可以看出来，第二版中涉及的许多的底层细节都在第三版中移除了。总而言之它是MySQL进阶的一个非常好的入门读物。</p></li><li><p>《数据库事务处理的艺术》李海翔著</p><p>  同《数据库查询优化器的艺术》。</p></li><li><p>《MySQL技术内幕 : InnoDB存储引擎 第2版》姜承尧著</p><p>  &amp;emsp;&amp;emsp;学习MySQL内核进阶阅读的第一本书。</p></li><li><p>《MySQL技术内幕 第5版》 Paul DuBois 著</p><p>  &amp;emsp;&amp;emsp;这本书是对于MySQL使用层面的一个非常详细的介绍，也就是说它并不涉及MySQL的任何内核原理，甚至连索引结构都懒得讲。像是一个老妈子在给你不停的介绍吃饭怎么吃，喝水怎么喝，怎么上厕所的各种絮叨。整体风格比较像MySQL的官方文档，如果有想从使用层面从头了解MySQL的同学可以尝试的看看。</p></li><li><p>《数据库系统概念》（美）Abraham Silberschatz &#x2F; （美）Henry F.Korth &#x2F; （美）S.Sudarshan 著</p><p>  &amp;emsp;&amp;emsp;这本书对于入门数据库原理来说非常好，不过看起来学术气味比较大一些，毕竟是一本正经的教科书，里边有不少的公式什么的。</p></li><li><p>《事务处理 概念与技术》Jim Gray &#x2F; Andreas Reuter 著</p><p>  &amp;emsp;&amp;emsp;这本书只是象征性的看了1～5章，说实话看不太懂，总是get不到作者要表达的点。不过听说业界非常推崇这本书，而恰巧我也看过一点，就写上了，有兴趣的同学可以去看看。</p></li></ul><h2 id="说点不好的"><a href="#说点不好的" class="headerlink" title="说点不好的"></a>说点不好的</h2><p>&amp;emsp;&amp;emsp;上面尽说这些参考资料如何如何好了，主要是因为在我写作过程中的确参考到了，没有这些资料可能三五年都无法把小册写完。但是除了MySQL的文档以及《高性能MySQL》、《Effectiv MySQL：Optimizing SQL Statements》这两本书之外，其余的资料在大部分时间都是看的我头晕眼花，四肢乏力，不看个十遍八遍基本无法理清楚作者想要表达的点，这也是我写本小册的初衷—<span style="color:red">让天下没有难学的知识</span>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>&amp;emsp;&amp;emsp;希望这是各位2019年最爽的一次知识付费，如果各位因为阅读本小册而顺利通过面试，或者解决了工作中的很多技术问题，觉得29.9实在是太物超所值，希望各位能来给点打赏（本人很穷，靠救济生活～ 添加好友可以问关于小册的问题，不过希望不要扯犊子聊八卦了，我其实挺忙的～ 微信号：xiaohaizi4919）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：请允许我鄙视一下那些打着知识付费骗钱的人，除了不生产一点社会价值外，反而生产了数不清的焦虑，让人们连幸福感都丧失掉了。也请各位警惕那些说只要你交几百块钱，就能得到诸如境界上的提升、开阔了眼界、追赶上行业发展趋势之类的课程/知识付费，这类抽象而无法验证的主题都是骗人的。</span><br></pre></td></tr></table></figure><p><img src="/../images/26-01.png"></p><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/24-%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%9A%E5%B9%85%E9%9D%A2%E5%AD%94-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC/"/>
      <url>/2022/10/31/model-mysql/mysql/24-%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%9A%E5%B9%85%E9%9D%A2%E5%AD%94-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC/</url>
      
        <content type="html"><![CDATA[<h1 id="第24章-一条记录的多幅面孔-事务的隔离级别与MVCC"><a href="#第24章-一条记录的多幅面孔-事务的隔离级别与MVCC" class="headerlink" title="第24章 一条记录的多幅面孔-事务的隔离级别与MVCC"></a>第24章 一条记录的多幅面孔-事务的隔离级别与MVCC</h1><h2 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h2><p>&amp;emsp;&amp;emsp;为了故事的顺利发展，我们需要创建一个表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE hero (</span><br><span class="line">    number INT,</span><br><span class="line">    name VARCHAR(100),</span><br><span class="line">    country varchar(100),</span><br><span class="line">    PRIMARY KEY (number)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：注意我们把这个hero表的主键命名为number，而不是id，主要是想和后边要用到的事务id做区别，大家不用大惊小怪～ </span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;然后向这个表里插入一条数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO hero VALUES(1, &#x27;刘备&#x27;, &#x27;蜀&#x27;);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;现在表里的数据就是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM hero;</span><br><span class="line">+--------+--------+---------+</span><br><span class="line">| number | name   | country |</span><br><span class="line">+--------+--------+---------+</span><br><span class="line">|      1 | 刘备   | 蜀      |</span><br><span class="line">+--------+--------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>&amp;emsp;&amp;emsp;我们知道<code>MySQL</code>是一个<code>客户端／服务器</code>架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话（<code>Session</code>）。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。在事务简介的章节中我们说过事务有一个称之为<code>隔离性</code>的特性，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样子的话对性能影响太大，我们既想保持事务的<code>隔离性</code>，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，鱼和熊掌不可得兼，舍一部分<code>隔离性</code>而取性能者也。</p><h3 id="事务并发执行遇到的问题"><a href="#事务并发执行遇到的问题" class="headerlink" title="事务并发执行遇到的问题"></a>事务并发执行遇到的问题</h3><p>&amp;emsp;&amp;emsp;怎么个舍弃法呢？我们先得看一下访问相同数据的事务在不保证串行执行（也就是执行完一个再执行另一个）的情况下可能会出现哪些问题：</p><ul><li><p>脏写（<code>Dirty Write</code>）</p><p>  &amp;emsp;&amp;emsp;如果<span style="color:red">一个事务修改了另一个未提交事务修改过的数据</span>，那就意味着发生了<code>脏写</code>，示意图如下：</p><p>  <img src="/../images/24-01.png"></p><p>  &amp;emsp;&amp;emsp;如上图，<code>Session A</code>和<code>Session B</code>各开启了一个事务，<code>Session B</code>中的事务先将<code>number</code>列为<code>1</code>的记录的<code>name</code>列更新为<code>&#39;关羽&#39;</code>，然后<code>Session A</code>中的事务接着又把这条<code>number</code>列为<code>1</code>的记录的<code>name</code>列更新为<code>张飞</code>。如果之后<code>Session B</code>中的事务进行了回滚，那么<code>Session A</code>中的更新也将不复存在，这种现象就称之为<code>脏写</code>。这时<code>Session A</code>中的事务就很懵逼，我明明把数据更新了，最后也提交事务了，怎么到最后说自己什么也没干呢？</p></li><li><p>脏读（<code>Dirty Read</code>）</p><p>  &amp;emsp;&amp;emsp;如果<span style="color:red">一个事务读到了另一个未提交事务修改过的数据</span>，那就意味着发生了<code>脏读</code>，示意图如下：</p><p>  <img src="/../images/24-02.png"></p><p>  &amp;emsp;&amp;emsp;如上图，<code>Session A</code>和<code>Session B</code>各开启了一个事务，<code>Session B</code>中的事务先将<code>number</code>列为<code>1</code>的记录的<code>name</code>列更新为<code>&#39;关羽&#39;</code>，然后<code>Session A</code>中的事务再去查询这条<code>number</code>为<code>1</code>的记录，如果du到列<code>name</code>的值为<code>&#39;关羽&#39;</code>，而<code>Session B</code>中的事务稍后进行了回滚，那么<code>Session A</code>中的事务相当于读到了一个不存在的数据，这种现象就称之为<code>脏读</code>。</p></li><li><p>不可重复读（Non-Repeatable Read）</p><p>  &amp;emsp;&amp;emsp;如果<span style="color:red">一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值</span>，那就意味着发生了<code>不可重复读</code>，示意图如下：</p><p>  <img src="/../images/24-03.png"></p><p>  &amp;emsp;&amp;emsp;如上图，我们在<code>Session B</code>中提交了几个隐式事务（注意是隐式事务，意味着语句结束事务就提交了），这些事务都修改了<code>number</code>列为<code>1</code>的记录的列<code>name</code>的值，每次事务提交之后，如果<code>Session A</code>中的事务都可以查看到最新的值，这种现象也被称之为<code>不可重复读</code>。</p></li><li><p>幻读（Phantom）</p><p>  &amp;emsp;&amp;emsp;如果<span style="color:red">一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来</span>，那就意味着发生了<code>幻读</code>，示意图如下：</p><p>  <img src="/../images/24-04.png"></p><p>  &amp;emsp;&amp;emsp;如上图，<code>Session A</code>中的事务先根据条件<code>number &gt; 0</code>这个条件查询表<code>hero</code>，得到了<code>name</code>列值为<code>&#39;刘备&#39;</code>的记录；之后<code>Session B</code>中提交了一个隐式事务，该事务向表<code>hero</code>中插入了一条新记录；之后<code>Session A</code>中的事务再根据相同的条件<code>number &gt; 0</code>查询表<code>hero</code>，得到的结果集中包含<code>Session B</code>中的事务新插入的那条记录，这种现象也被称之为<code>幻读</code>。</p><p>  &amp;emsp;&amp;emsp;有的同学会有疑问，那如果<code>Session B</code>中是删除了一些符合<code>number &gt; 0</code>的记录而不是插入新记录，那<code>Session A</code>中之后再根据<code>number &gt; 0</code>的条件读取的记录变少了，这种现象算不算<code>幻读</code>呢？明确说一下，这种现象不属于<code>幻读</code>，<code>幻读</code>强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：那对于先前已经读到的记录，之后又读取不到这种情况，算什么呢？其实这相当于对每一条记录都发生了不可重复读的现象。幻读只是重点强调了读取到了之前读取没有获取到的记录。</span><br></pre></td></tr></table></figure></li></ul><h3 id="SQL标准中的四种隔离级别"><a href="#SQL标准中的四种隔离级别" class="headerlink" title="SQL标准中的四种隔离级别"></a>SQL标准中的四种隔离级别</h3><p>&amp;emsp;&amp;emsp;我们上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题也有轻重缓急之分，我们给这些问题按照严重性来排一下序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们上面所说的舍弃一部分隔离性来换取一部分性能在这里就体现在：<span style="color:red">设立一些隔离级别，隔离级别越低，越严重的问题就越可能发生</span>。有一帮人（并不是设计<code>MySQL</code>的大佬们）制定了一个所谓的<code>SQL标准</code>，在标准中设立了4个<code>隔离级别</code>：</p><ul><li><code>READ UNCOMMITTED</code>：未提交读。</li><li><code>READ COMMITTED</code>：已提交读。</li><li><code>REPEATABLE READ</code>：可重复读。</li><li><code>SERIALIZABLE</code>：可串行化。</li></ul><p>&amp;emsp;&amp;emsp;<code>SQL标准</code>中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center"><code>READ UNCOMMITTED</code></td><td align="center">Possible</td><td align="center">Possible</td><td align="center">Possible</td></tr><tr><td align="center"><code>READ COMMITTED</code></td><td align="center">Not Possible</td><td align="center">Possible</td><td align="center">Possible</td></tr><tr><td align="center"><code>REPEATABLE READ</code></td><td align="center">Not Possible</td><td align="center">Not Possible</td><td align="center">Possible</td></tr><tr><td align="center"><code>SERIALIZABLE</code></td><td align="center">Not Possible</td><td align="center">Not Possible</td><td align="center">Not Possible</td></tr></tbody></table><p>也就是说：</p><ul><li><code>READ UNCOMMITTED</code>隔离级别下，可能发生<code>脏读</code>、<code>不可重复读</code>和<code>幻读</code>问题。</li><li><code>READ COMMITTED</code>隔离级别下，可能发生<code>不可重复读</code>和<code>幻读</code>问题，但是不可以发生<code>脏读</code>问题。</li><li><code>REPEATABLE READ</code>隔离级别下，可能发生<code>幻读</code>问题，但是不可以发生<code>脏读</code>和<code>不可重复读</code>的问题。</li><li><code>SERIALIZABLE</code>隔离级别下，各种问题都不可以发生。</li></ul><p>&amp;emsp;&amp;emsp;<code>脏写</code>是怎么回事儿？怎么里边都没写呢？<span style="color:red">这是因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生</span>。</p><h3 id="MySQL中支持的四种隔离级别"><a href="#MySQL中支持的四种隔离级别" class="headerlink" title="MySQL中支持的四种隔离级别"></a>MySQL中支持的四种隔离级别</h3><p>&amp;emsp;&amp;emsp;不同的数据库厂商对<code>SQL标准</code>中规定的四种隔离级别支持不一样，比方说<code>Oracle</code>就只支持<code>READ COMMITTED</code>和<code>SERIALIZABLE</code>隔离级别。本书中所讨论的<code>MySQL</code>虽然支持4种隔离级别，但与<code>SQL标准</code>中所规定的各级隔离级别允许发生的问题却有些出入，<span style="color:red">MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的</span>（关于如何禁止我们之后会详细说明的）。</p><p>&amp;emsp;&amp;emsp;<code>MySQL</code>的默认隔离级别为<code>REPEATABLE READ</code>，我们可以手动修改一下事务的隔离级别。</p><h4 id="如何设置事务的隔离级别"><a href="#如何设置事务的隔离级别" class="headerlink" title="如何设置事务的隔离级别"></a>如何设置事务的隔离级别</h4><p>&amp;emsp;&amp;emsp;我们可以通过下面的语句修改事务的隔离级别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;其中的<code>level</code>可选值有4个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">level: &#123;</span><br><span class="line">     REPEATABLE READ</span><br><span class="line">   | READ COMMITTED</span><br><span class="line">   | READ UNCOMMITTED</span><br><span class="line">   | SERIALIZABLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;设置事务的隔离级别的语句中，在<code>SET</code>关键字后可以放置<code>GLOBAL</code>关键字、<code>SESSION</code>关键字或者什么都不放，这样会对不同范围的事务产生不同的影响，具体如下：</p><ul><li><p>使用<code>GLOBAL</code>关键字（在全局范围影响）：</p><p>  比方说这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure><p>  则：</p><ul><li>只对执行完该语句之后产生的会话起作用。</li><li>当前已经存在的会话无效。</li></ul></li><li><p>使用<code>SESSION</code>关键字（在会话范围影响）：</p><p>  比方说这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure><p>  则：</p><ul><li>对当前会话的所有后续的事务有效</li><li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务。</li><li>如果在事务之间执行，则对后续的事务有效。</li></ul></li><li><p>上述两个关键字都不用（只对执行语句后的下一个事务产生影响）：</p><p>  比方说这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure><p>  则：</p><ul><li>只对当前会话中下一个即将开启的事务有效。</li><li>下一个事务执行完后，后续事务将恢复到之前的隔离级别。</li><li>该语句不能在已经开启的事务中间执行，会报错的。</li></ul></li></ul><p>&amp;emsp;&amp;emsp;如果我们在服务器启动时想改变事务的默认隔离级别，可以修改启动参数<code>transaction-isolation</code>的值，比方说我们在启动服务器时指定了<code>--transaction-isolation=SERIALIZABLE</code>，那么事务的默认隔离级别就从原来的<code>REPEATABLE READ</code>变成了<code>SERIALIZABLE</code>。</p><p>&amp;emsp;&amp;emsp;想要查看当前会话默认的隔离级别可以通过查看系统变量<code>transaction_isolation</code>的值来确定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;transaction_isolation&#x27;;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| Variable_name         | Value           |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| transaction_isolation | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;或者使用更简便的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| REPEATABLE-READ         |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：我们也可以使用设置系统变量transaction_isolation的方式来设置事务的隔离级别，不过我们前面介绍过，一般系统变量只有GLOBAL和SESSION两个作用范围，而这个transaction_isolation却有3个（与上面 SET TRANSACTION ISOLATION LEVEL的语法相对应），设置语法上有些特殊，更多详情可以参见文档：https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_transaction_isolation。另外，transaction_isolation是在MySQL 5.7.20的版本中引入来替换tx_isolation的，如果你使用的是之前版本的MySQL，请将上述用到系统变量transaction_isolation的地方替换为tx_isolation。</span><br></pre></td></tr></table></figure><h2 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h2><h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p>&amp;emsp;&amp;emsp;我们前面说过，对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列（<code>row_id</code>并不是必要的，我们创建的表中有主键或者非NULL的UNIQUE键时都不会包含<code>row_id</code>列）：</p><ul><li><code>trx_id</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的<code>事务id</code>赋值给<code>trx_id</code>隐藏列。</li><li><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo日志</code>中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><p>&amp;emsp;&amp;emsp;比方说我们的表<code>hero</code>现在只包含一条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM hero;</span><br><span class="line">+--------+--------+---------+</span><br><span class="line">| number | name   | country |</span><br><span class="line">+--------+--------+---------+</span><br><span class="line">|      1 | 刘备   | 蜀      |</span><br><span class="line">+--------+--------+---------+</span><br><span class="line">1 row in set (0.07 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;假设插入该记录的<code>事务id</code>为<code>80</code>，那么此刻该条记录的示意图如下所示：</p><p><img src="/../images/24-05.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：实际上insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。虽然真正的insert undo日志占用的存储空间被释放了，但是roll_pointer的值并不会被清除，roll_pointer属性占用7个字节，第一个比特位就标记着它指向的undo日志的类型，如果该比特位的值为1时，就代表着它zhi向的undo日志类型为insert undo。所以我们之后在画图时都会把insert undo给去掉，大家留意一下就好了。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;假设之后两个<code>事务id</code>分别为<code>100</code>、<code>200</code>的事务对这条记录进行<code>UPDATE</code>操作，操作流程如下：</p><p><img src="/../images/24-06.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：能不能在两个事务中交叉更新同一条记录呢？这不就是一个事务修改了另一个未提交事务修改过的数据，沦为了脏写了么？InnoDB使用锁来保证不会有脏写情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。关于锁的更多细节我们后续的文章中再介绍～</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;每次对记录进行改动，都会记录一条<code>undo日志</code>，每条<code>undo日志</code>也都有一个<code>roll_pointer</code>属性（<code>INSERT</code>操作对应的<code>undo日志</code>没有该属性，因为该记录并没有更早的版本），可以将这些<code>undo日志</code>都连起来，串成一个链表，所以现在的情况就像下图一样：</p><p><img src="/../images/24-07.png"></p><p>&amp;emsp;&amp;emsp;对该记录每次更新后，都会将旧值放到一条<code>undo日志</code>中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被<code>roll_pointer</code>属性连接成一个链表，我们把这个链表称之为<code>版本链</code>，<span style="color:red">版本链的头节点就是当前记录最新的值</span>。另外，每个版本中还包含生成该版本时对应的<code>事务id</code>，这个信息很重要，我们稍后就会用到。</p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>&amp;emsp;&amp;emsp;对于使用<code>READ UNCOMMITTED</code>隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了；对于使用<code>SERIALIZABLE</code>隔离级别的事务来说，设计<code>InnoDB</code>的大佬规定使用加锁的方式来访问记录（加锁是什么我们后续文章中说）；对于使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：<span style="color:red">需要判断一下版本链中的哪个版本是当前事务可见的</span>。为此，设计<code>InnoDB</code>的大佬提出了一个<code>ReadView</code>的概念，这个<code>ReadView</code>中主要包含4个比较重要的内容：</p><ul><li><p><code>m_ids</code>：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务的<code>事务id</code>列表。</p></li><li><p><code>min_trx_id</code>：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务中最小的<code>事务id</code>，也就是<code>m_ids</code>中的最小值。</p></li><li><p><code>max_trx_id</code>：表示生成<code>ReadView</code>时系统中应该分配给下一个事务的<code>id</code>值。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。</span><br></pre></td></tr></table></figure></li><li><p><code>creator_trx_id</code>：表示生成该<code>ReadView</code>的事务的<code>事务id</code>。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：我们前面说过，只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;有了这个<code>ReadView</code>，这样在访问某条记录时，只需要按照下面的步骤判断记录的某个版本是否可见：</p><ul><li>如果被访问版本的<code>trx_id</code>属性值与<code>ReadView</code>中的<code>creator_trx_id</code>值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id</code>属性值小于<code>ReadView</code>中的<code>min_trx_id</code>值，表明生成该版本的事务在当前事务生成<code>ReadView</code>前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id</code>属性值大于<code>ReadView</code>中的<code>max_trx_id</code>值，表明生成该版本的事务在当前事务生成<code>ReadView</code>后才开启，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id</code>属性值在<code>ReadView</code>的<code>min_trx_id</code>和<code>max_trx_id</code>之间，那就需要判断一下<code>trx_id</code>属性值是不是在<code>m_ids</code>列表中，如果在，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建<code>ReadView</code>时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><p>&amp;emsp;&amp;emsp;如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上面的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p><p>&amp;emsp;&amp;emsp;在<code>MySQL</code>中，<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的的一个非常大的区别就是<span style="color:red">它们生成ReadView的时机不同</span>。我们还是以表<code>hero</code>为例来，假设现在表<code>hero</code>中只有一条由<code>事务id</code>为<code>80</code>的事务插入的一条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM hero;</span><br><span class="line">+--------+--------+---------+</span><br><span class="line">| number | name   | country |</span><br><span class="line">+--------+--------+---------+</span><br><span class="line">|      1 | 刘备   | 蜀      |</span><br><span class="line">+--------+--------+---------+</span><br><span class="line">1 row in set (0.07 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;接下来看一下<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>所谓的<span style="color:red">生成ReadView的时机不同</span>到底不同在哪里。</p><h4 id="READ-COMMITTED-——-每次读取数据前都生成一个ReadView"><a href="#READ-COMMITTED-——-每次读取数据前都生成一个ReadView" class="headerlink" title="READ COMMITTED —— 每次读取数据前都生成一个ReadView"></a>READ COMMITTED —— 每次读取数据前都生成一个ReadView</h4><p>&amp;emsp;&amp;emsp;比方说现在系统里有两个<code>事务id</code>分别为<code>100</code>、<code>200</code>的事务在执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &#x27;关羽&#x27; WHERE number = 1;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &#x27;张飞&#x27; WHERE number = 1;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：再次强调一遍，事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务id是递增的。所以我们才在Transaction 200中更新一些别的表的记录，目的是让它分配事务id。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;此刻，表<code>hero</code>中<code>number</code>为<code>1</code>的记录得到的版本链表如下所示：</p><p><img src="/../images/24-08.png"></p><p>&amp;emsp;&amp;emsp;假设现在有一个使用<code>READ COMMITTED</code>隔离级别的事务开始执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200未提交</span><br><span class="line">SELECT * FROM hero WHERE number = 1; # 得到的列name的值为&#x27;刘备&#x27;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个<code>SELECT1</code>的执行过程如下：</p><ul><li>在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[100, 200]</code>，<code>min_trx_id</code>为<code>100</code>，<code>max_trx_id</code>为<code>201</code>，<code>creator_trx_id</code>为<code>0</code>。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>name</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>name</code>的内容是<code>&#39;关羽&#39;</code>，该版本的<code>trx_id</code>值也为<code>100</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>name</code>的内容是<code>&#39;刘备&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>，小于<code>ReadView</code>中的<code>min_trx_id</code>值<code>100</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>name</code>为<code>&#39;刘备&#39;</code>的记录。</li></ul><p>&amp;emsp;&amp;emsp;之后，我们把<code>事务id</code>为<code>100</code>的事务提交一下，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &#x27;关羽&#x27; WHERE number = 1;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &#x27;张飞&#x27; WHERE number = 1;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;然后再到<code>事务id</code>为<code>200</code>的事务中更新一下表<code>hero</code>中<code>number</code>为<code>1</code>的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &#x27;赵云&#x27; WHERE number = 1;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &#x27;诸葛亮&#x27; WHERE number = 1;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;此刻，表<code>hero</code>中<code>number</code>为<code>1</code>的记录的版本链就长这样：</p><p><img src="/../images/24-09.png"></p><p>&amp;emsp;&amp;emsp;然后再到刚才使用<code>READ COMMITTED</code>隔离级别的事务中继续查找这个<code>number</code>为<code>1</code>的记录，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200均未提交</span><br><span class="line">SELECT * FROM hero WHERE number = 1; # 得到的列name的值为&#x27;刘备&#x27;</span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction 100提交，Transaction 200未提交</span><br><span class="line">SELECT * FROM hero WHERE number = 1; # 得到的列name的值为&#x27;张飞&#x27;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个<code>SELECT2</code>的执行过程如下：</p><ul><li>在执行<code>SELECT</code>语句时会<span style="color:red">又会单独生成</span>一个<code>ReadView</code>，该<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[200]</code>（<code>事务id</code>为<code>100</code>的那个事务已经提交了，所以再次生成快照时就没有它了），<code>min_trx_id</code>为<code>200</code>，<code>max_trx_id</code>为<code>201</code>，<code>creator_trx_id</code>为<code>0</code>。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>name</code>的内容是<code>&#39;诸葛亮&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>name</code>的内容是<code>&#39;赵云&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>name</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，小于<code>ReadView</code>中的<code>min_trx_id</code>值<code>200</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>name</code>为<code>&#39;张飞&#39;</code>的记录。</li></ul><p>&amp;emsp;&amp;emsp;以此类推，如果之后<code>事务id</code>为<code>200</code>的记录也提交了，再此在使用<code>READ COMMITTED</code>隔离级别的事务中查询表<code>hero</code>中<code>number</code>值为<code>1</code>的记录时，得到的结果就是<code>&#39;诸葛亮&#39;</code>了，具体流程我们就不分析了。总结一下就是：<span style="color:red">使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView</span>。</p><h4 id="REPEATABLE-READ-——-在第一次读取数据时生成一个ReadView"><a href="#REPEATABLE-READ-——-在第一次读取数据时生成一个ReadView" class="headerlink" title="REPEATABLE READ —— 在第一次读取数据时生成一个ReadView"></a>REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</h4><p>&amp;emsp;&amp;emsp;对于使用<code>REPEATABLE READ</code>隔离级别的事务来说，只会在第一次执行查询语句时生成一个<code>ReadView</code>，之后的查询就不会重复生成了。我们还是用例子看一下是什么效果。</p><p>&amp;emsp;&amp;emsp;比方说现在系统里有两个<code>事务id</code>分别为<code>100</code>、<code>200</code>的事务在执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &#x27;关羽&#x27; WHERE number = 1;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &#x27;张飞&#x27; WHERE number = 1;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;此刻，表<code>hero</code>中<code>number</code>为<code>1</code>的记录得到的版本链表如下所示：</p><p><img src="/../images/24-10.png"></p><p>&amp;emsp;&amp;emsp;假设现在有一个使用<code>REPEATABLE READ</code>隔离级别的事务开始执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200未提交</span><br><span class="line">SELECT * FROM hero WHERE number = 1; # 得到的列name的值为&#x27;刘备&#x27;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个<code>SELECT1</code>的执行过程如下：</p><ul><li>在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[100, 200]</code>，<code>min_trx_id</code>为<code>100</code>，<code>max_trx_id</code>为<code>201</code>，<code>creator_trx_id</code>为<code>0</code>。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>name</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>name</code>的内容是<code>&#39;关羽&#39;</code>，该版本的<code>trx_id</code>值也为<code>100</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>name</code>的内容是<code>&#39;刘备&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>，小于<code>ReadView</code>中的<code>min_trx_id</code>值<code>100</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>name</code>为<code>&#39;刘备&#39;</code>的记录。</li></ul><p>&amp;emsp;&amp;emsp;之后，我们把<code>事务id</code>为<code>100</code>的事务提交一下，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &#x27;关羽&#x27; WHERE number = 1;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &#x27;张飞&#x27; WHERE number = 1;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;然后再到<code>事务id</code>为<code>200</code>的事务中更新一下表<code>hero</code>中<code>number</code>为<code>1</code>的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &#x27;赵云&#x27; WHERE number = 1;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name = &#x27;诸葛亮&#x27; WHERE number = 1;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;此刻，表<code>hero</code>中<code>number</code>为<code>1</code>的记录的版本链就长这样：</p><p><img src="/../images/24-11.png"></p><p>&amp;emsp;&amp;emsp;然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个<code>number</code>为<code>1</code>的记录，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200均未提交</span><br><span class="line">SELECT * FROM hero WHERE number = 1; # 得到的列name的值为&#x27;刘备&#x27;</span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction 100提交，Transaction 200未提交</span><br><span class="line">SELECT * FROM hero WHERE number = 1; # 得到的列name的值仍为&#x27;刘备&#x27;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个<code>SELECT2</code>的执行过程如下：</p><ul><li>因为当前事务的隔离级别为<code>REPEATABLE READ</code>，而之前在执行<code>SELECT1</code>时已经生成过<code>ReadView</code>了，所以此时直接复用之前的<code>ReadView</code>，之前的<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[100, 200]</code>，<code>min_trx_id</code>为<code>100</code>，<code>max_trx_id</code>为<code>201</code>，<code>creator_trx_id</code>为<code>0</code>。</li><li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>name</code>的内容是<code>&#39;诸葛亮&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li><li>下一个版本的列<code>name</code>的内容是<code>&#39;赵云&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li><li>下一个版本的列<code>name</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，而<code>m_ids</code>列表中是包含值为<code>100</code>的<code>事务id</code>的，所以该版本也不符合要求，同理下一个列<code>name</code>的内容是<code>&#39;关羽&#39;</code>的版本也不符合要求。继续跳到下一个版本。</li><li>下一个版本的列<code>name</code>的内容是<code>&#39;刘备&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>，小于<code>ReadView</code>中的<code>min_trx_id</code>值<code>100</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>&#39;刘备&#39;</code>的记录。</li></ul><p>&amp;emsp;&amp;emsp;也就是说两次<code>SELECT</code>查询得到的结果是重复的，记录的列<code>c</code>值都是<code>&#39;刘备&#39;</code>，这就是<code>可重复读</code>的含义。如果我们之后再把<code>事务id</code>为<code>200</code>的记录提交了，然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个<code>number</code>为<code>1</code>的记录，得到的结果还是<code>&#39;刘备&#39;</code>，具体执行过程大家可以自己分析一下。</p><h3 id="MVCC小结"><a href="#MVCC小结" class="headerlink" title="MVCC小结"></a>MVCC小结</h3><p>&amp;emsp;&amp;emsp;从上面的描述中我们可以看出来，所谓的<code>MVCC</code>（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行普通的<code>SEELCT</code>操作时访问记录的版本链的过程，这样子可以使不同事务的<code>读-写</code>、<code>写-读</code>操作并发执行，从而提升系统性能。<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是：<span style="color:red">生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除，而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服务的，大家可以对比上面举的例子自己试想一下怎么使用。另外，所谓的MVCC只是在我们进行普通的SEELCT查询时才生效，截止到目前我们所见的所有SELECT语句都算是普通的查询，至于什么是个不普通的查询，我们稍后再说～</span><br></pre></td></tr></table></figure><h2 id="关于purge"><a href="#关于purge" class="headerlink" title="关于purge"></a>关于purge</h2><p>大家有没有发现两件事儿：</p><ul><li>我们说<code>insert undo</code>在事务提交之后就可以被释放掉了，而<code>update undo</code>由于还需要支持<code>MVCC</code>，不能立即删除掉。</li><li>为了支持<code>MVCC</code>，对于<code>delete mark</code>操作来说，仅仅是在记录上打一个删除标记，并没有真正将它删除掉。</li></ul><p>&amp;emsp;&amp;emsp;随着系统的运行，在确定系统中包含最早产生的那个<code>ReadView</code>的事务不会再访问某些<code>update undo日志</code>以及被打了删除标记的记录后，有一个后台运行的<code>purge线程</code>会把它们真正的删除掉。关于更多的purge细节，我们将放到纸质书中进行详细介绍，不见不散～</p><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/25-%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E8%80%81%E5%A4%A7%E9%9A%BE-%E9%94%81/"/>
      <url>/2022/10/31/model-mysql/mysql/25-%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E8%80%81%E5%A4%A7%E9%9A%BE-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="第25章-工作面试老大难-锁"><a href="#第25章-工作面试老大难-锁" class="headerlink" title="第25章 工作面试老大难-锁"></a>第25章 工作面试老大难-锁</h1><h2 id="解决并发事务带来问题的两种基本方式"><a href="#解决并发事务带来问题的两种基本方式" class="headerlink" title="解决并发事务带来问题的两种基本方式"></a>解决并发事务带来问题的两种基本方式</h2><p>&amp;emsp;&amp;emsp;上一章介绍了事务并发执行时可能带来的各种问题，并发事务访问相同记录的情况大致可以划分为3种：</p><ul><li><p><code>读-读</code>情况：即并发事务相继读取相同的记录。</p><p>  &amp;emsp;&amp;emsp;读取操作本身不会对记录有一毛钱影响，并不会引起什么问题，所以允许这种情况的发生。</p></li><li><p><code>写-写</code>情况：即并发事务相继对相同的记录做出改动。</p><p>  &amp;emsp;&amp;emsp;我们前面说过，在这种情况下会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过<code>锁</code>来实现的。这个所谓的<code>锁</code>其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有<code>锁结构</code>和记录进行关联的，如图所示：</p><p>  <img src="/../images/25-01.png"></p><p>  &amp;emsp;&amp;emsp;当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的<code>锁结构</code>，当没有的时候就会在内存中生成一个<code>锁结构</code>与之关联。比方说事务<code>T1</code>要对这条记录做改动，就需要生成一个<code>锁结构</code>与之关联：</p><p>  <img src="/../images/25-02.png">        </p><p>  &amp;emsp;&amp;emsp;其实在<code>锁结构</code>里有很多信息，不过为了简化理解，我们现在只把两个比较重要的属性拿了出来：</p><ul><li><code>trx信息</code>：代表这个锁结构是哪个事务生成的。</li><li><code>is_waiting</code>：代表当前事务是否在等待。</li></ul><p>  &amp;emsp;&amp;emsp;如图所示，当事务<code>T1</code>改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务为这条记录加锁，所以<code>is_waiting</code>属性就是<code>false</code>，我们把这个场景就称之为<span style="color:red">获取锁成功，或者加锁成功</span>，然后就可以继续执行操作了。</p><p>  &amp;emsp;&amp;emsp;在事务<code>T1</code>提交之前，另一个事务<code>T2</code>也想对该记录做改动，那么先去看看有没有<code>锁结构</code>与这条记录关联，发现有一个<code>锁结构</code>与之关联后，然后也生成了一个<code>锁结构</code>与这条记录关联，不过<code>锁结构</code>的<code>is_waiting</code>属性值为<code>true</code>，表示当前事务需要等待，我们把这个场景就称之为<span style="color:red">获取锁失败，或者加锁失败，或者没有成功的获取到锁</span>，画个图表示就是这样：</p><p>  <img src="/../images/25-03.png"></p><p>  &amp;emsp;&amp;emsp;在事务<code>T1</code>提交之后，就会把该事务生成的<code>锁结构</code>释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务<code>T2</code>还在等待获取锁，所以把事务<code>T2</code>对应的锁结构的<code>is_waiting</code>属性设置为<code>false</code>，然后把该事务对应的线程唤醒，让它继续执行，此时事务<code>T2</code>就算获取到锁了。效果图就是这样：</p><p>  <img src="/../images/25-04.png">            </p><p>  &amp;emsp;&amp;emsp;我们总结一下后续内容中可能用到的几种说法，以免大家混淆：</p><ul><li><p>不加锁</p><p>  &amp;emsp;&amp;emsp;意思就是不需要在内存中生成对应的<code>锁结构</code>，可以直接执行操作。</p></li><li><p>获取锁成功，或者加锁成功</p><p>  &amp;emsp;&amp;emsp;意思就是在内存中生成了对应的<code>锁结构</code>，而且锁结构的<code>is_waiting</code>属性为<code>false</code>，也就是事务可以继续执行操作。</p></li><li><p>获取锁失败，或者加锁失败，或者没有获取到锁</p><p>  &amp;emsp;&amp;emsp;意思就是在内存中生成了对应的<code>锁结构</code>，不过锁结构的<code>is_waiting</code>属性为<code>true</code>，也就是事务需要等待，不可以继续执行操作。</p></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：这里只是对锁结构做了一个非常简单的描述，我们后边会详细介绍介绍锁结构的，稍安勿躁。</span><br></pre></td></tr></table></figure></li><li><p><code>读-写</code>或<code>写-读</code>情况：也就是一个事务进行读取操作，另一个进行改动操作。</p><p>  &amp;emsp;&amp;emsp;我们前面说过，这种情况下可能发生<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>的问题。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：幻读问题的产生是因为某个事务读了一个范围的记录，之后别的事务在该范围内插入了新记录，该事务再次读取该范围的记录时，可以读到新插入的记录，所以幻读问题准确的说并不是因为读取和写入一条相同记录而产生的，这一点要注意一下。</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;<code>SQL标准</code>规定不同隔离级别下可能发生的问题不一样：</p><ul><li>在<code>READ UNCOMMITTED</code>隔离级别下，<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>都可能发生。</li><li>在<code>READ COMMITTED</code>隔离级别下，<code>不可重复读</code>、<code>幻读</code>可能发生，<code>脏读</code>不可以发生。</li><li>在<code>REPEATABLE READ</code>隔离级别下，<code>幻读</code>可能发生，<code>脏读</code>和<code>不可重复读</code>不可以发生。</li><li>在<code>SERIALIZABLE</code>隔离级别下，上述问题都不可以发生。</li></ul><p>  &amp;emsp;&amp;emsp;不过各个数据库厂商对<code>SQL标准</code>的支持都可能不一样，与<code>SQL标准</code>不同的一点就是，<code>MySQL</code>在<code>REPEATABLE READ</code>隔离级别实际上就已经解决了<code>幻读</code>问题。</p><p>  &amp;emsp;&amp;emsp;怎么解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题呢？其实有两种可选的解决方案：</p><ul><li><p>方案一：读操作利用多版本并发控制（<code>MVCC</code>），写操作进行<code>加锁</code>。</p><p>  &amp;emsp;&amp;emsp;所谓的<code>MVCC</code>我们在前一章有过详细的描述，就是通过生成一个<code>ReadView</code>，然后通过<code>ReadView</code>找到符合条件的记录版本（历史版本是由<code>undo日志</code>构建的），其实就像是在生成<code>ReadView</code>的那个时刻做了一次时间静止（就像用相机拍了一个快照），查询语句只能读到在生成<code>ReadView</code>之前已提交事务所做的更改，在生成<code>ReadView</code>之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用<code>MVCC</code>时，<code>读-写</code>操作并不冲突。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：我们说过普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。在READ COMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象；REPEATABLE READ隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都复用这个ReadView，这样也就避免了不可重复读和幻读的问题。</span><br></pre></td></tr></table></figure></li><li><p>方案二：读、写操作都采用<code>加锁</code>的方式。</p><p>  &amp;emsp;&amp;emsp;如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，比方在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行<code>加锁</code>操作，这样也就意味着<code>读</code>操作和<code>写</code>操作也像<code>写-写</code>操作那样排队执行。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小贴士：</span><br><span class="line">我们说脏读的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。不可重复读的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。我们说幻读问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，我们把新插入的那些记录称之为幻影记录。采用加锁的方式解决幻读问题就有那么一丢丢麻烦了，因为当前事务在第一次读取记录时那些幻影记录并不存在，所以读取的时候加锁就有点尴尬 —— 因为你并不知道给谁加锁，没关系，这难不倒设计InnoDB的大佬的，我们稍后揭晓答案，稍安勿躁。</span><br></pre></td></tr></table></figure></li></ul><p>  &amp;emsp;&amp;emsp;很明显，采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，性能更高，采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要排队执行，影响性能。一般情况下我们当然愿意采用<code>MVCC</code>来解决<code>读-写</code>操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用<code>加锁</code>的方式执行，那也是没有办法的事。</p></li></ul><h3 id="一致性读（Consistent-Reads）"><a href="#一致性读（Consistent-Reads）" class="headerlink" title="一致性读（Consistent Reads）"></a>一致性读（Consistent Reads）</h3><p>&amp;emsp;&amp;emsp;事务利用<code>MVCC</code>进行的读取操作称之为<code>一致性读</code>，或者<code>一致性无锁读</code>，有的地方也称之为<code>快照读</code>。所有普通的<code>SELECT</code>语句（<code>plain SELECT</code>）在<code>READ COMMITTED</code>、<code>REPEATABLE READ</code>隔离级别下都算是<code>一致性读</code>，比方说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t;</span><br><span class="line">SELECT * FROM t1 INNER JOIN t2 ON t1.col1 = t2.col2</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;<code>一致性读</code>并不会对表中的任何记录做<code>加锁</code>操作，其他事务可以自由的对表中的记录做改动。</p><h3 id="锁定读（Locking-Reads）"><a href="#锁定读（Locking-Reads）" class="headerlink" title="锁定读（Locking Reads）"></a>锁定读（Locking Reads）</h3><h4 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h4><p>&amp;emsp;&amp;emsp;我们前面说过，并发事务的<code>读-读</code>情况并不会引起什么问题，不过对于<code>写-写</code>、<code>读-写</code>或<code>写-读</code>这些情况可能会引起一些问题，需要使用<code>MVCC</code>或者<code>加锁</code>的方式来解决它们。在使用<code>加锁</code>的方式解决问题时，由于既要允许<code>读-读</code>情况不受影响，又要使<code>写-写</code>、<code>读-写</code>或<code>写-读</code>情况中的操作相互阻塞，所以设计<code>MySQL</code>的大佬给锁分了个类：</p><ul><li><code>共享锁</code>，英文名：<code>Shared  Locks</code>，简称<code>S锁</code>。在事务要读取一条记录时，需要先获取该记录的<code>S锁</code>。</li><li><code>独占锁</code>，也常称<code>排他锁</code>，英文名：<code>Exclusive Locks</code>，简称<code>X锁</code>。在事务要改动一条记录时，需要先获取该记录的<code>X锁</code>。</li></ul><p>&amp;emsp;&amp;emsp;假如事务<code>T1</code>首先获取了一条记录的<code>S锁</code>之后，事务<code>T2</code>接着也要访问这条记录：</p><ul><li>如果事务<code>T2</code>想要再获取一个记录的<code>S锁</code>，那么事务<code>T2</code>也会获得该锁，也就意味着事务<code>T1</code>和<code>T2</code>在该记录上同时持有<code>S锁</code>。</li><li>如果事务<code>T2</code>想要再获取一个记录的<code>X锁</code>，那么此操作会被阻塞，直到事务<code>T1</code>提交之后将<code>S锁</code>释放掉。</li></ul><p>&amp;emsp;&amp;emsp;如果事务<code>T1</code>首先获取了一条记录的<code>X锁</code>之后，那么不管事务<code>T2</code>接着想获取该记录的<code>S锁</code>还是<code>X锁</code>都会被阻塞，直到事务<code>T1</code>提交。</p><p>&amp;emsp;&amp;emsp;所以我们说<code>S锁</code>和<code>S锁</code>是兼容的，<code>S锁</code>和<code>X锁</code>是不兼容的，<code>X锁</code>和<code>X锁</code>也是不兼容的，画个表表示一下就是这样：</p><table><thead><tr><th align="center">兼容性</th><th align="center"><code>X</code></th><th align="center"><code>S</code></th></tr></thead><tbody><tr><td align="center"><code>X</code></td><td align="center">不兼容</td><td align="center">不兼容</td></tr><tr><td align="center"><code>S</code></td><td align="center">不兼容</td><td align="center">兼容</td></tr></tbody></table><h4 id="锁定读的语句"><a href="#锁定读的语句" class="headerlink" title="锁定读的语句"></a>锁定读的语句</h4><p>&amp;emsp;&amp;emsp;我们前面说在采用<code>加锁</code>方式解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题时，读取一条记录时需要获取一下该记录的<code>S锁</code>，其实这是不严谨的，有时候想在读取记录时就获取记录的<code>X锁</code>，来禁止别的事务读写该记录，为此设计<code>MySQL</code>的大佬提出了两种比较特殊的<code>SELECT</code>语句格式：</p><ul><li><p>对读取的记录加<code>S锁</code>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;也就是在普通的<code>SELECT</code>语句后边加<code>LOCK IN SHARE MODE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加<code>S锁</code>，这样允许别的事务继续获取这些记录的<code>S锁</code>（比方说别的事务也使用<code>SELECT ... LOCK IN SHARE MODE</code>语句来读取这些记录），但是不能获取这些记录的<code>X锁</code>（比方说使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的<code>X锁</code>，那么它们会阻塞，直到当前事务提交之后将这些记录上的<code>S锁</code>释放掉。</p></li><li><p>对读取的记录加<code>X锁</code>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;也就是在普通的<code>SELECT</code>语句后边加<code>FOR UPDATE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加<code>X锁</code>，这样既不允许别的事务获取这些记录的<code>S锁</code>（比方说别的事务使用<code>SELECT ... LOCK IN SHARE MODE</code>语句来读取这些记录），也不允许获取这些记录的<code>X锁</code>（比方也说使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的<code>S锁</code>或者<code>X锁</code>，那么它们会阻塞，直到当前事务提交之后将这些记录上的<code>X锁</code>释放掉。</p></li></ul><p>&amp;emsp;&amp;emsp;关于更多<code>锁定读</code>的加锁细节我们稍后会详细介绍，稍安勿躁。</p><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p>&amp;emsp;&amp;emsp;平常所用到的<code>写操作</code>无非是<code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>这三种：</p><ul><li><p><code>DELETE</code>：</p><p>  &amp;emsp;&amp;emsp;对一条记录做<code>DELETE</code>操作的过程其实是先在<code>B+</code>树中定位到这条记录的位置，然后获取一下这条记录的<code>X锁</code>，然后再执行<code>delete mark</code>操作。我们也可以把这个定位待删除记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</p></li><li><p><code>UPDATE</code>：</p><p>  &amp;emsp;&amp;emsp;在对一条记录做<code>UPDATE</code>操作时分为三种情况：</p><ul><li>如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</li><li>如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在<code>B+</code>树中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>，新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</li><li>如果修改了该记录的键值，则相当于在原记录上做<code>DELETE</code>操作之后再来一次<code>INSERT</code>操作，加锁操作就需要按照<code>DELETE</code>和<code>INSERT</code>的规则进行了。</li></ul></li><li><p><code>INSERT</code>：</p><p>  &amp;emsp;&amp;emsp;一般情况下，新插入一条记录的操作并不加锁，设计<code>InnoDB</code>的大佬通过一种称之为<code>隐式锁</code>的东东来保护这条新插入的记录在本事务提交前不被别的事务访问，更多细节我们后边看～</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：当然，在一些特殊情况下INSERT操作也是会获取锁的，具体情况我们后边介绍。</span><br></pre></td></tr></table></figure></li></ul><h2 id="多粒度锁"><a href="#多粒度锁" class="headerlink" title="多粒度锁"></a>多粒度锁</h2><p>&amp;emsp;&amp;emsp;我们前面提到的<code>锁</code>都是针对记录的，也可以被称之为<code>行级锁</code>或者<code>行锁</code>，对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细；其实一个事务也可以在<code>表</code>级别进行加锁，自然就被称之为<code>表级锁</code>或者<code>表锁</code>，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。给表加的锁也可以分为<code>共享锁</code>（<code>S锁</code>）和<code>独占锁</code>（<code>X锁</code>）：</p><ul><li><p>给表加<code>S锁</code>：</p><p>  &amp;emsp;&amp;emsp;如果一个事务给表加了<code>S锁</code>，那么：</p><ul><li>别的事务可以继续获得该表的<code>S锁</code></li><li>别的事务可以继续获得该表中的某些记录的<code>S锁</code></li><li>别的事务不可以继续获得该表的<code>X锁</code></li><li>别的事务不可以继续获得该表中的某些记录的<code>X锁</code></li></ul></li><li><p>给表加<code>X锁</code>：</p><p>  &amp;emsp;&amp;emsp;如果一个事务给表加了<code>X锁</code>（意味着该事务要独占这个表），那么：</p><ul><li>别的事务不可以继续获得该表的<code>S锁</code></li><li>别的事务不可以继续获得该表中的某些记录的<code>S锁</code></li><li>别的事务不可以继续获得该表的<code>X锁</code></li><li>别的事务不可以继续获得该表中的某些记录的<code>X锁</code></li></ul></li></ul><p>&amp;emsp;&amp;emsp;上面看着有点啰嗦，为了更好的理解这个表级别的<code>S锁</code>和<code>X锁</code>，我们举一个现实生活中的例子。不知道各位同学都上过大学没，我们以大学教学楼中的教室为例来分析一下加锁的情况：</p><ul><li>教室一般都是公用的，我们可以随便选教室进去上自习。当然，教室不是自家的，一间教室可以容纳很多同学同时上自习，每当一个人进去上自习，就相当于在教室门口挂了一把<code>S锁</code>，如果很多同学都进去上自习，相当于教室门口挂了很多把<code>S锁</code>（类似行级别的<code>S锁</code>）。</li><li>有的时候教室会进行检修，比方说换地板，换天花板，换灯管什么的，这些维修项目并不能同时开展。如果教室针对某个项目进行检修，就不允许别的同学来上自习，也不允许其他维修项目进行，此时相当于教室门口会挂一把<code>X锁</code>（类似行级别的<code>X锁</code>）。</li></ul><p>&amp;emsp;&amp;emsp;上面提到的这两种锁都是针对<code>教室</code>而言的，不过有时候我们会有一些特殊的需求：</p><ul><li><p>有领导要来参观教学楼的环境。</p><p>  &amp;emsp;&amp;emsp;校领导考虑并不想影响同学们上自习，但是此时不能有教室处于维修状态，所以可以在教学楼门口放置一把<code>S锁</code>（类似表级别的<code>S锁</code>）。此时：</p><ul><li>来上自习的学生们看到教学楼门口有<code>S锁</code>，可以继续进入教学楼上自习。</li><li>修理工看到教学楼门口有<code>S锁</code>，则先在教学楼门口等着，什么时候领导走了，把教学楼的<code>S锁</code>撤掉再进入教学楼维修。</li></ul></li><li><p>学校要占用教学楼进行考试。</p><p>  &amp;emsp;&amp;emsp;此时不允许教学楼中有正在上自习的教室，也不允许对教室进行维修。所以可以在教学楼门口放置一把<code>X锁</code>（类似表级别的<code>X锁</code>）。此时：</p><ul><li>来上自习的学生们看到教学楼门口有<code>X锁</code>，则需要在教学楼门口等着，什么时候考试结束，把教学楼的<code>X锁</code>撤掉再进入教学楼上自习。</li><li>修理工看到教学楼门口有<code>X锁</code>，则先在教学楼门口等着，什么时候考试结束，把教学楼的<code>X锁</code>撤掉再进入教学楼维修。</li></ul></li></ul><p>&amp;emsp;&amp;emsp;但是这里头有两个问题：</p><ul><li>如果我们想对教学楼整体上<code>S锁</code>，首先需要确保教学楼中的没有正在维修的教室，如果有正在维修的教室，需要等到维修结束才可以对教学楼整体上<code>S锁</code>。</li><li>如果我们想对教学楼整体上<code>X锁</code>，首先需要确保教学楼中的没有上自习的教室以及正在维修的教室，如果有上自习的教室或者正在维修的教室，需要等到全部上自习的同学都上完自习离开，以及维修工维修完教室离开后才可以对教学楼整体上<code>X锁</code>。</li></ul><p>&amp;emsp;&amp;emsp;我们在对教学楼整体上锁（<code>表锁</code>）时，怎么知道教学楼中有没有教室已经被上锁（<code>行锁</code>）了呢？依次检查每一间教室门口有没有上锁？那这效率也太慢了吧！遍历是不可能遍历的，这辈子也不可能遍历的，于是乎设计<code>InnoDB</code>的大佬们提出了一种称之为<code>意向锁</code>（英文名：<code>Intention Locks</code>）的东东：</p><ul><li>意向共享锁，英文名：<code>Intention Shared Lock</code>，简称<code>IS锁</code>。当事务准备在某条记录上加<code>S锁</code>时，需要先在表级别加一个<code>IS锁</code>。</li><li>意向独占锁，英文名：<code>Intention Exclusive Lock</code>，简称<code>IX锁</code>。当事务准备在某条记录上加<code>X锁</code>时，需要先在表级别加一个<code>IX锁</code>。</li></ul><p>&amp;emsp;&amp;emsp;视角回到教学楼和教室上来：</p><ul><li>如果有学生到教室中上自习，那么他先在整栋教学楼门口放一把<code>IS锁</code>（表级锁），然后再到教室门口放一把<code>S锁</code>（行锁）。</li><li>如果有维修工到教室中维修，那么它先在整栋教学楼门口放一把<code>IX锁</code>（表级锁），然后再到教室门口放一把<code>X锁</code>（行锁）。</li></ul><p>&amp;emsp;&amp;emsp;之后：</p><ul><li>如果有领导要参观教学楼，也就是想在教学楼门口前放<code>S锁</code>（表锁）时，首先要看一下教学楼门口有没有<code>IX锁</code>，如果有，意味着有教室在维修，需要等到维修结束把<code>IX锁</code>撤掉后才可以在整栋教学楼上加<code>S锁</code>。</li><li>如果有考试要占用教学楼，也就是想在教学楼门口前放<code>X锁</code>（表锁）时，首先要看一下教学楼门口有没有<code>IS锁</code>或<code>IX锁</code>，如果有，意味着有教室在上自习或者维修，需要等到学生们上完自习以及维修结束把<code>IS锁</code>和<code>IX锁</code>撤掉后才可以在整栋教学楼上加<code>X锁</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：学生在教学楼门口加IS锁时，是不关心教学楼门口是否有IX锁的，维修工在教学楼门口加IX锁时，是不关心教学楼门口是否有IS锁或者其他IX锁的。IS和IX锁只是为了判断当前时间教学楼里有没有被占用的教室用的，也就是在对教学楼加S锁或者X锁时才会用到。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;总结一下：<span style="color:red">IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的</span>。我们画个表来看一下表级别的各种锁的兼容性：</p><table><thead><tr><th align="center">兼容性</th><th align="center"><code>X</code></th><th align="center"><code>IX</code></th><th align="center"><code>S</code></th><th align="center"><code>IS</code></th></tr></thead><tbody><tr><td align="center"><code>X</code></td><td align="center">不兼容</td><td align="center">不兼容</td><td align="center">不兼容</td><td align="center">不兼容</td></tr><tr><td align="center"><code>IX</code></td><td align="center">不兼容</td><td align="center">兼容</td><td align="center">不兼容</td><td align="center">兼容</td></tr><tr><td align="center"><code>S</code></td><td align="center">不兼容</td><td align="center">不兼容</td><td align="center">兼容</td><td align="center">兼容</td></tr><tr><td align="center"><code>IS</code></td><td align="center">不兼容</td><td align="center">兼容</td><td align="center">兼容</td><td align="center">兼容</td></tr></tbody></table><h2 id="MySQL中的行锁和表锁"><a href="#MySQL中的行锁和表锁" class="headerlink" title="MySQL中的行锁和表锁"></a>MySQL中的行锁和表锁</h2><p>&amp;emsp;&amp;emsp;上面说的都算是些理论知识，其实<code>MySQL</code>支持多种存储引擎，不同存储引擎对锁的支持也是不一样的。当然，我们重点还是讨论<code>InnoDB</code>存储引擎中的锁，其他的存储引擎只是稍微提一下～</p><h3 id="其他存储引擎中的锁"><a href="#其他存储引擎中的锁" class="headerlink" title="其他存储引擎中的锁"></a>其他存储引擎中的锁</h3><p>&amp;emsp;&amp;emsp;对于<code>MyISAM</code>、<code>MEMORY</code>、<code>MERGE</code>这些存储引擎来说，它们只支持表级锁，而且这些引擎并不支持事务，所以使用这些存储引擎的锁一般都是针对当前会话来说的。比方说在<code>Session 1</code>中对一个表执行<code>SELECT</code>操作，就相当于为这个表加了一个表级别的<code>S锁</code>，如果在<code>SELECT</code>操作未完成时，<code>Session 2</code>中对这个表执行<code>UPDATE</code>操作，相当于要获取表的<code>X锁</code>，此操作会被阻塞，直到<code>Session 1</code>中的<code>SELECT</code>操作完成，释放掉表级别的<code>S锁</code>后，<code>Session 2</code>中对这个表执行<code>UPDATE</code>操作才能继续获取<code>X锁</code>，然后执行具体的更新语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：因为使用MyISAM、MEMORY、MERGE这些存储引擎的表在同一时刻只允许一个会话对表进行写操作，所以这些存储引擎实际上最好用在只读，或者大部分都是读操作，或者单用户的情景下。另外，在MyISAM存储引擎中有一个称之为Concurrent Inserts的特性，支持在对MyISAM表读取时同时插入记录，这样可以提升一些插入速度。关于更多Concurrent Inserts的细节，我们就不介绍了，详情可以参考文档。</span><br></pre></td></tr></table></figure><h3 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h3><p>&amp;emsp;&amp;emsp;<code>InnoDB</code>存储引擎既支持表锁，也支持行锁。表锁实现简单，占用资源较少，不过粒度很粗，有时候你仅仅需要锁住几条记录，但使用表锁的话相当于为表中的所有记录都加锁，所以性能比较差。行锁粒度更细，可以实现更精准的并发控制。下面我们详细看一下。</p><h4 id="InnoDB中的表级锁"><a href="#InnoDB中的表级锁" class="headerlink" title="InnoDB中的表级锁"></a>InnoDB中的表级锁</h4><ul><li><p>表级别的<code>S锁</code>、<code>X锁</code></p><p>  &amp;emsp;&amp;emsp;在对某个表执行<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句时，<code>InnoDB</code>存储引擎是不会为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。</p><p>  &amp;emsp;&amp;emsp;另外，在对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类的<code>DDL</code>语句时，其他事务对这个表并发执行诸如<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>的语句会发生阻塞，同理，某个事务中对某个表执行<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句时，在其他会话中对这个表执行<code>DDL</code>语句也会发生阻塞。这个过程其实是通过在<code>server层</code>使用一种称之为<code>元数据锁</code>（英文名：<code>Metadata Locks</code>，简称<code>MDL</code>）东东来实现的，一般情况下也不会使用<code>InnoDB</code>存储引擎自己提供的表级别的<code>S锁</code>和<code>X锁</code>。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：在事务简介的章节中我们说过，DDL语句执行时会隐式的提交当前会话中的事务，这主要是DDL语句的执行一般都会在若干个特殊事务中完成，在开启这些特殊事务前，需要将当前会话中的事务提交掉。另外，关于MDL锁并不是我们本章所要讨论的范围，大家可以参阅文档了解～</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;其实这个<code>InnoDB</code>存储引擎提供的表级<code>S锁</code>或者<code>X锁</code>是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复过程中用到。不过我们还是可以手动获取一下的，比方说在系统变量<code>autocommit=0，innodb_table_locks = 1</code>时，手动获取<code>InnoDB</code>存储引擎提供的表<code>t</code>的<code>S锁</code>或者<code>X锁</code>可以这么写：</p><ul><li><code>LOCK TABLES t READ</code>：<code>InnoDB</code>存储引擎会对表<code>t</code>加表级别的<code>S锁</code>。</li><li><code>LOCK TABLES t WRITE</code>：<code>InnoDB</code>存储引擎会对表<code>t</code>加表级别的<code>X锁</code>。</li></ul><p>  &amp;emsp;&amp;emsp;不过请尽量避免在使用<code>InnoDB</code>存储引擎的表上使用<code>LOCK TABLES</code>这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。<code>InnoDB</code>的厉害之处还是实现了更细粒度的行锁，关于表级别的<code>S锁</code>和<code>X锁</code>大家了解一下就罢了。  </p></li><li><p>表级别的<code>IS锁</code>、<code>IX锁</code></p><p>  &amp;emsp;&amp;emsp;当我们在对使用<code>InnoDB</code>存储引擎的表的某些记录加<code>S锁</code>之前，那就需要先在表级别加一个<code>IS锁</code>，当我们在对使用<code>InnoDB</code>存储引擎的表的某些记录加<code>X锁</code>之前，那就需要先在表级别加一个<code>IX锁</code>。<code>IS锁</code>和<code>IX锁</code>的使命只是为了后续在加表级别的<code>S锁</code>和<code>X锁</code>时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。更多关于<code>IS锁</code>和<code>IX锁</code>的解释我们上面都介绍过了，就不赘述了。</p></li><li><p>表级别的<code>AUTO-INC锁</code></p><p>  &amp;emsp;&amp;emsp;在使用<code>MySQL</code>过程中，我们可以为表的某个列添加<code>AUTO_INCREMENT</code>属性，之后在插入记录时，可以不指定该列的值，系统会自动为它赋上递增的值，比方说我们有一个表：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    c VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;由于这个表的<code>id</code>字段声明了<code>AUTO_INCREMENT</code>，也就意味着在书写插入语句时不需要为其赋值，比方说这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t(c) VALUES(&#x27;aa&#x27;), (&#x27;bb&#x27;);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;上面的插入语句并没有为<code>id</code>列显式赋值，所以系统会自动为它赋上递增的值，效果就是这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t;</span><br><span class="line">+----+------+</span><br><span class="line">| id | c    |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | aa   |</span><br><span class="line">|  2 | bb   |</span><br><span class="line">+----+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;系统实现这种自动给<code>AUTO_INCREMENT</code>修饰的列递增赋值的原理主要是两个：</p><ul><li><p>采用<code>AUTO-INC</code>锁，也就是在执行插入语句时就在表级别加一个<code>AUTO-INC</code>锁，然后为每条待插入记录的<code>AUTO_INCREMENT</code>修饰的列分配递增的值，在该语句执行结束后，再把<code>AUTO-INC</code>锁释放掉。这样一个事务在持有<code>AUTO-INC</code>锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。</p><p>  &amp;emsp;&amp;emsp;如果我们的插入语句在执行前不可以确定具体要插入多少条记录（无法预计即将插入记录的数量），比方说使用<code>INSERT ... SELECT</code>、<code>REPLACE ... SELECT</code>或者<code>LOAD DATA</code>这种插入语句，一般是使用<code>AUTO-INC</code>锁为<code>AUTO_INCREMENT</code>修饰的列生成对应的值。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：需要注意一下的是，这个AUTO-INC锁的作用范围只是单个插入语句，插入语句执行完成后，这个锁就被释放了，跟我们之前介绍的锁在事务结束时释放是不一样的。</span><br></pre></td></tr></table></figure></li><li><p>采用一个轻量级的锁，在为插入语句生成<code>AUTO_INCREMENT</code>修饰的列的值时获取一下这个轻量级锁，然后生成本次插入语句需要用到的<code>AUTO_INCREMENT</code>列的值之后，就把该轻量级锁释放掉，并不需要等到整个插入语句执行完才释放锁。</p><p>  &amp;emsp;&amp;emsp;如果我们的插入语句在执行前就可以确定具体要插入多少条记录，比方说我们上面举的关于表<code>t</code>的例子中，在语句执行前就可以确定要插入2条记录，那么一般采用轻量级锁的方式对<code>AUTO_INCREMENT</code>修饰的列进行赋值。这种方式可以避免锁定表，可以提升插入性能。</p></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：设计InnoDB的大佬提供了一个称之为innodb_autoinc_lock_mode的系统变量来控制到底使用上述两种方式中的哪种来为AUTO_INCREMENT修饰的列进行赋值，当innodb_autoinc_lock_mode值为0时，一律采用AUTO-INC锁；当innodb_autoinc_lock_mode值为2时，一律采用轻量级锁；当innodb_autoinc_lock_mode值为1时，两种方式混着来（也就是在插入记录数量确定时采用轻量级锁，不确定时使用AUTO-INC锁）。不过当innodb_autoinc_lock_mode值为2时，可能会造成不同事务中的插入语句为AUTO_INCREMENT修饰的列生成的值是交叉的，在有主从复制的场景中是不安全的。</span><br></pre></td></tr></table></figure></li></ul><h4 id="InnoDB中的行级锁"><a href="#InnoDB中的行级锁" class="headerlink" title="InnoDB中的行级锁"></a>InnoDB中的行级锁</h4><p>&amp;emsp;&amp;emsp;很遗憾的通知大家一个不好的消息，上面讲的都是铺垫，本章真正的重点才刚刚开始[手动偷笑]。</p><p><code>行锁</code>，也称为<code>记录锁</code>，顾名思义就是在<span style="color:red">记录上加的锁</span>。不过设计<code>InnoDB</code>的大佬很有才，一个<code>行锁</code>玩出了各种花样，也就是把<code>行锁</code>分成了各种类型。换句话说即使对同一条记录加<code>行锁</code>，如果类型不同，起到的功效也是不同的。为了故事的顺利发展，我们还是先将之前介绍<code>MVCC</code>时用到的表抄一遍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE hero (</span><br><span class="line">    number INT,</span><br><span class="line">    name VARCHAR(100),</span><br><span class="line">    country varchar(100),</span><br><span class="line">    PRIMARY KEY (number),</span><br><span class="line">    KEY idx_name (name)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们主要是想用这个表存储三国时的英雄，然后向这个表里插入几条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO hero VALUES</span><br><span class="line">    (1, &#x27;l刘备&#x27;, &#x27;蜀&#x27;),</span><br><span class="line">    (3, &#x27;z诸葛亮&#x27;, &#x27;蜀&#x27;),</span><br><span class="line">    (8, &#x27;c曹操&#x27;, &#x27;魏&#x27;),</span><br><span class="line">    (15, &#x27;x荀彧&#x27;, &#x27;魏&#x27;),</span><br><span class="line">    (20, &#x27;s孙权&#x27;, &#x27;吴&#x27;);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;现在表里的数据就是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM hero;</span><br><span class="line">+--------+------------+---------+</span><br><span class="line">| number | name       | country |</span><br><span class="line">+--------+------------+---------+</span><br><span class="line">|      1 | l刘备      | 蜀      |</span><br><span class="line">|      3 | z诸葛亮    | 蜀      |</span><br><span class="line">|      8 | c曹操      | 魏      |</span><br><span class="line">|     15 | x荀彧      | 魏      |</span><br><span class="line">|     20 | s孙权      | 吴      |</span><br><span class="line">+--------+------------+---------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：不是说好的存储三国时的英雄么，你在搞什么，为什么要在&#x27;刘备&#x27;、&#x27;曹操&#x27;、&#x27;孙权&#x27;前面加上&#x27;l&#x27;、&#x27;c&#x27;、&#x27;s&#x27;这几个字母呀？这个主要是因为我们采用utf8字符集，该字符集并没有对应的按照汉语拼音进行排序的比较规则，也就是说&#x27;刘备&#x27;、&#x27;曹操&#x27;、&#x27;孙权&#x27;这几个字符串的排序并不是按照它们汉语拼音进行排序的，我怕大家懵逼，所以在汉字前面加上了汉字对应的拼音的第一个字母，这样在排序时就是按照汉语拼音进行排序，大家也不懵逼了。另外，我们故意把各条记录number列的值搞得很分散，后边会用到，稍安勿躁～</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们把<code>hero</code>表中的聚簇索引的示意图画一下：</p><p><img src="/../images/25-05.png"></p><p>&amp;emsp;&amp;emsp;当然，我们把<code>B+树</code>的索引结构做了一个超级简化，只把索引中的记录给拿了出来，我们这里只是想强调聚簇索引中的记录是按照主键大小排序的，并且省略掉了聚簇索引中的隐藏列，大家心里明白就好（不理解索引结构的同学可以去前面的文章中查看）。</p><p>&amp;emsp;&amp;emsp;现在准备工作做完了，下面我们来看看都有哪些常用的<code>行锁类型</code>。</p><ul><li><p><code>Record Locks</code>：</p><p>  &amp;emsp;&amp;emsp;我们前面提到的记录锁就是这种类型，也就是仅仅把一条记录锁上，我决定给这种类型的锁起一个比较不正经的名字：<code>正经记录锁</code>（请允许我皮一下，我实在不知道该叫什么名好）。官方的类型名称为：<code>LOCK_REC_NOT_GAP</code>。比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>正经记录锁</code>的示意图如下：</p><p>  <img src="/../images/25-06.png"></p><p>  &amp;emsp;&amp;emsp;<code>正经记录锁</code>是有<code>S锁</code>和<code>X锁</code>之分的，让我们分别称之为<code>S型正经记录锁</code>和<code>X型正经记录锁</code>吧（听起来有点怪怪的），当一个事务获取了一条记录的<code>S型正经记录锁</code>后，其他事务也可以继续获取该记录的<code>S型正经记录锁</code>，但不可以继续获取<code>X型正经记录锁</code>；当一个事务获取了一条记录的<code>X型正经记录锁</code>后，其他事务既不可以继续获取该记录的<code>S型正经记录锁</code>，也不可以继续获取<code>X型正经记录锁</code>；</p></li><li><p><code>Gap Locks</code>：</p><p>  &amp;emsp;&amp;emsp;我们说<code>MySQL</code>在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用<code>MVCC</code>方案解决，也可以采用<code>加锁</code>方案解决。但是在使用<code>加锁</code>方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上<code>正经记录锁</code>。不过这难不倒设计<code>InnoDB</code>的大佬，他们提出了一种称之为<code>Gap Locks</code>的锁，官方的类型名称为：<code>LOCK_GAP</code>，我们也可以简称为<code>gap锁</code>。比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>gap锁</code>的示意图如下：</p><p>  <img src="/../images/25-07.png"></p><p>  &amp;emsp;&amp;emsp;如图中为<code>number</code>值为<code>8</code>的记录加了<code>gap锁</code>，意味着不允许别的事务在<code>number</code>值为<code>8</code>的记录前面的<code>间隙</code>插入新记录，其实就是<code>number</code>列的值<code>(3, 8)</code>这个区间的新记录是不允许立即插入的。比方说有另外一个事务再想插入一条<code>number</code>值为<code>4</code>的新记录，它定位到该条新记录的下一条记录的<code>number</code>值为8，而这条记录上又有一个<code>gap锁</code>，所以就会阻塞插入操作，直到拥有这个<code>gap锁</code>的事务提交了之后，<code>number</code>列的值在区间<code>(3, 8)</code>中的新记录才可以被插入。</p><p>  &amp;emsp;&amp;emsp;这个<code>gap锁</code>的提出<span style="color:red">仅仅是为了防止插入幻影记录而提出的</span>，虽然有<code>共享gap锁</code>和<code>独占gap锁</code>这样的说法，但是它们起到的作用都是相同的。而且如果你对一条记录加了<code>gap锁</code>（不论是<code>共享gap锁</code>还是<code>独占gap锁</code>），并不会限制其他事务对这条记录加<code>正经记录锁</code>或者继续加<code>gap锁</code>，再强调一遍，<code>gap锁</code>的作用仅仅是为了防止插入幻影记录的而已。</p><p>  &amp;emsp;&amp;emsp;不知道大家发现了一个问题没，给一条记录加了<code>gap锁</code>只是不允许其他事务往这条记录前面的间隙插入新记录，那对于最后一条记录之后的间隙，也就是<code>hero</code>表中<code>number</code>值为<code>20</code>的记录之后的间隙该咋办呢？也就是说给哪条记录加<code>gap锁</code>才能阻止其他事务插入<code>number</code>值在<code>(20, +∞)</code>这个区间的新记录呢？这时候应该想起我们在前面介绍<code>数据页</code>时介绍的两条伪记录了：</p><ul><li><code>Infimum</code>记录，表示该页面中最小的记录。</li><li><code>Supremum</code>记录，表示该页面中最大的记录。</li></ul><p>  &amp;emsp;&amp;emsp;为了实现阻止其他事务插入<code>number</code>值在<code>(20, +∞)</code>这个区间的新记录，我们可以给索引中的最后一条记录，也就是<code>number</code>值为<code>20</code>的那条记录所在页面的<code>Supremum</code>记录加上一个<code>gap锁</code>，画个图就是这样：</p><p>  <img src="/../images/25-08.png"></p><p>  &amp;emsp;&amp;emsp;这样就可以阻止其他事务插入<code>number</code>值在<code>(20, +∞)</code>这个区间的新记录。为了大家理解方便，之后的索引示意图中都会把这个<code>Supremum</code>记录画出来。  </p></li><li><p><code>Next-Key Locks</code>：</p><p>  &amp;emsp;&amp;emsp;有时候我们既想锁住某条记录，又想阻止其他事务在该记录前面的<code>间隙</code>插入新记录，所以设计<code>InnoDB</code>的大佬们就提出了一种称之为<code>Next-Key Locks</code>的锁，官方的类型名称为：<code>LOCK_ORDINARY</code>，我们也可以简称为<code>next-key锁</code>。比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>next-key锁</code>的示意图如下：</p><p>  <img src="/../images/25-09.png"></p><p>  &amp;emsp;&amp;emsp;<code>next-key锁</code>的本质就是一个<code>正经记录锁</code>和一个<code>gap锁</code>的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前面的<code>间隙</code>。</p></li><li><p><code>Insert Intention Locks</code>：</p><p>  &amp;emsp;&amp;emsp;我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>，后边就不强调了），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。但是设计<code>InnoDB</code>的大佬规定事务在等待的时候也需要在内存中生成一个<code>锁结构</code>，表明有事务想在某个<code>间隙</code>中插入新记录，但是现在在等待。设计<code>InnoDB</code>的大佬就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们也可以称为<code>插入意向锁</code>。</p><p>  &amp;emsp;&amp;emsp;比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>插入意向锁</code>的示意图如下：</p><p>  <img src="/../images/25-10.png"></p><p>  &amp;emsp;&amp;emsp;为了让大家彻底理解这个<code>插入意向锁</code>的功能，我们还是举个例子然后画个图表示一下。比方说现在<code>T1</code>为<code>number</code>值为<code>8</code>的记录加了一个<code>gap锁</code>，然后<code>T2</code>和<code>T3</code>分别想向<code>hero</code>表中插入<code>number</code>值分别为<code>4</code>、<code>5</code>的两条记录，所以现在为<code>number</code>值为<code>8</code>的记录加的锁的示意图就如下所示：</p><p>  <img src="/../images/25-11.png">    </p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：我们在锁结构中又新添了一个type属性，表明该锁的类型。稍后会全面介绍InnoDB存储引擎中的一个锁结构到底长什么样。</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;从图中可以看到，由于<code>T1</code>持有<code>gap锁</code>，所以<code>T2</code>和<code>T3</code>需要生成一个<code>插入意向锁</code>的<code>锁结构</code>并且处于等待状态。当<code>T1</code>提交后会把它获取到的锁都释放掉，这样<code>T2</code>和<code>T3</code>就能获取到对应的<code>插入意向锁</code>了（本质上就是把插入意向锁对应锁结构的<code>is_waiting</code>属性改为<code>false</code>），<code>T2</code>和<code>T3</code>之间也并不会相互阻塞，它们可以同时获取到<code>number</code>值为8的<code>插入意向锁</code>，然后执行插入操作。事实上<span style="color:red">插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁</span>（<code>插入意向锁</code>就是这么鸡肋）。</p></li><li><p>隐式锁</p><p>  &amp;emsp;&amp;emsp;我们前面说一个事务在执行<code>INSERT</code>操作时，如果即将插入的<code>间隙</code>已经被其他事务加了<code>gap锁</code>，那么本次<code>INSERT</code>操作会阻塞，并且当前事务会在该间隙上加一个<code>插入意向锁</code>，否则一般情况下<code>INSERT</code>操作是不加锁的。那如果一个事务首先插入了一条记录（此时并没有与该记录关联的锁结构），然后另一个事务：</p><ul><li><p>立即使用<code>SELECT ... LOCK IN SHARE MODE</code>语句读取这条事务，也就是在要获取这条记录的<code>S锁</code>，或者使用<code>SELECT ... FOR UPDATE</code>语句读取这条事务或者直接修改这条记录，也就是要获取这条记录的<code>X锁</code>，该咋办？</p><p>  &amp;emsp;&amp;emsp;如果允许这种情况的发生，那么可能产生<code>脏读</code>问题。</p></li><li><p>立即修改这条记录，也就是要获取这条记录的<code>X锁</code>，该咋办？</p><p>  &amp;emsp;&amp;emsp;如果允许这种情况的发生，那么可能产生<code>脏写</code>问题。</p></li></ul><p>  &amp;emsp;&amp;emsp;这时候我们前面介绍了很多遍的<code>事务id</code>又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下：</p><ul><li>情景一：对于聚簇索引记录来说，有一个<code>trx_id</code>隐藏列，该隐藏列记录着最后改动该记录的<code>事务id</code>。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的<code>trx_id</code>隐藏列代表的的就是当前事务的<code>事务id</code>，如果其他事务此时想对该记录添加<code>S锁</code>或者<code>X锁</code>时，首先会看一下该记录的<code>trx_id</code>隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个<code>X锁</code>（也就是为当前事务创建一个锁结构，<code>is_waiting</code>属性是<code>false</code>），然后自己进入等待状态（也就是为自己也创建一个锁结构，<code>is_waiting</code>属性是<code>true</code>）。</li><li>情景二：对于二级索引记录来说，本身并没有<code>trx_id</code>隐藏列，但是在二级索引页面的<code>Page Header</code>部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的<code>事务id</code>，如果<code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活跃<code>事务id</code>，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复<code>情景一</code>的做法。</li></ul><p>  &amp;emsp;&amp;emsp;通过上面的叙述我们知道，一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于<code>事务id</code>这个牛逼的东东的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：除了插入意向锁，在一些特殊情况下INSERT还会获取一些锁，我们稍后介绍。</span><br></pre></td></tr></table></figure></li></ul><h3 id="InnoDB锁的内存结构"><a href="#InnoDB锁的内存结构" class="headerlink" title="InnoDB锁的内存结构"></a>InnoDB锁的内存结构</h3><p>&amp;emsp;&amp;emsp;我们前面说对一条记录加锁的本质就是在内存中创建一个<code>锁结构</code>与之关联，那么是不是一个事务对多条记录加锁，就要创建多个<code>锁结构</code>呢？比方说事务<code>T1</code>要执行下面这个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 事务T1</span><br><span class="line">SELECT * FROM hero LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;很显然这条语句需要为<code>hero表</code>中的所有记录进行加锁，那是不是需要为每条记录都生成一个<code>锁结构</code>呢？其实理论上创建多个<code>锁结构</code>没问题，反而更容易理解，但是谁知道你在一个事务里想对多少记录加锁呢，如果一个事务要获取10000条记录的锁，要生成10000个这样的结构也太亏了吧！所以设计<code>InnoDB</code>的大佬本着勤俭节约的传统美德，决定在对不同记录加锁时，如果符合下面这些条件：</p><ul><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>等待状态是一样的</li></ul><p>&amp;emsp;&amp;emsp;那么这些记录的锁就可以被放到一个<code>锁结构</code>中。当然，这么空口白牙的说有点儿抽象，我们还是画个图来看看<code>InnoDB</code>存储引擎中的<code>锁结构</code>具体长什么样吧：</p><p><img src="/../images/25-12.png"></p><p>&amp;emsp;&amp;emsp;我们看看这个结构里边的各种信息都是干嘛的：</p><ul><li><p><code>锁所在的事务信息</code>：</p><p>  &amp;emsp;&amp;emsp;不论是<code>表锁</code>还是<code>行锁</code>，都是在事务执行过程中生成的，哪个事务生成了这个<code>锁结构</code>，这里就记载着这个事务的信息。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：实际上这个所谓的`锁所在的事务信息`在内存结构中只是一个指针而已，所以不会占用多大内存空间，通过指针可以找到内存中关于该事务的更多信息，比方说事务id是什么。下面介绍的所谓的`索引信息`其实也是一个指针。</span><br></pre></td></tr></table></figure></li><li><p><code>索引信息</code>：</p><p>  &amp;emsp;&amp;emsp;对于<code>行锁</code>来说，需要记录一下加锁的记录是属于哪个索引的。</p></li><li><p><code>表锁／行锁信息</code>：</p><p>  <code>表锁结构</code>和<code>行锁结构</code>在这个位置的内容是不同的：</p><ul><li><p>表锁：</p><p>  记载着这是对哪个表加的锁，还有其他的一些信息。</p></li><li><p>行锁：</p><p>  记载了三个重要的信息：</p><ul><li><code>Space ID</code>：记录所在表空间。</li><li><code>Page Number</code>：记录所在页号。</li><li><code>n_bits</code>：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个<code>n_bits</code>属性代表使用了多少比特位。</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：并不是该页面中有多少记录，n_bits属性的值就是多少。为了让之后在页面中插入了新记录后也不至于重新分配锁结构，所以n_bits的值一般都比页面中记录条数多一些。</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>type_mode</code>：</p><p>  &amp;emsp;&amp;emsp;这是一个32位的数，被分成了<code>lock_mode</code>、<code>lock_type</code>和<code>rec_lock_type</code>三个部分，如图所示：</p><p>  <img src="/../images/25-13.png"></p><ul><li><p>锁的模式（<code>lock_mode</code>），占用低4位，可选的值如下：</p><ul><li><code>LOCK_IS</code>（十进制的<code>0</code>）：表示共享意向锁，也就是<code>IS锁</code>。</li><li><code>LOCK_IX</code>（十进制的<code>1</code>）：表示独占意向锁，也就是<code>IX锁</code>。</li><li><code>LOCK_S</code>（十进制的<code>2</code>）：表示共享锁，也就是<code>S锁</code>。</li><li><code>LOCK_X</code>（十进制的<code>3</code>）：表示独占锁，也就是<code>X锁</code>。</li><li><code>LOCK_AUTO_INC</code>（十进制的<code>4</code>）：表示<code>AUTO-INC锁</code>。</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</span><br></pre></td></tr></table></figure></li><li><p>锁的类型（<code>lock_type</code>），占用第5～8位，不过现阶段只有第5位和第6位被使用：</p><ul><li><code>LOCK_TABLE</code>（十进制的<code>16</code>），也就是当第5个比特位置为1时，表示表级锁。 </li><li><code>LOCK_REC</code>（十进制的<code>32</code>），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li><p>行锁的具体类型（<code>rec_lock_type</code>），使用其余的位来表示。只有在<code>lock_type</code>的值为<code>LOCK_REC</code>时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：</p><ul><li><code>LOCK_ORDINARY</code>（十进制的<code>0</code>）：表示<code>next-key锁</code>。</li><li><code>LOCK_GAP</code>（十进制的<code>512</code>）：也就是当第10个比特位置为1时，表示<code>gap锁</code>。    </li><li><code>LOCK_REC_NOT_GAP</code>（十进制的<code>1024</code>）：也就是当第11个比特位置为1时，表示<code>正经记录锁</code>。</li><li><code>LOCK_INSERT_INTENTION</code>（十进制的<code>2048</code>）：也就是当第12个比特位置为1时，表示插入意向锁。</li><li>其他的类型：还有一些不常用的类型我们就不多说了。</li></ul><p>  &amp;emsp;&amp;emsp;怎么还没看见<code>is_waiting</code>属性呢？这主要还是设计<code>InnoDB</code>的大佬太抠门了，一个比特位也不想浪费，所以他们把<code>is_waiting</code>属性也放到了<code>type_mode</code>这个32位的数字中：</p><ul><li><code>LOCK_WAIT</code>（十进制的<code>256</code>） ：也就是当第9个比特位置为<code>1</code>时，表示<code>is_waiting</code>为<code>true</code>，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为<code>0</code>时，表示<code>is_waiting</code>为<code>false</code>，也就是当前事务获取锁成功。</li></ul></li></ul></li><li><p><code>其他信息</code>：</p><p>  &amp;emsp;&amp;emsp;为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表，为了简化讨论，我们忽略这部分信息～</p></li><li><p><code>一堆比特位</code>：</p><p>  &amp;emsp;&amp;emsp;如果是<code>行锁结构</code>的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上面提到的<code>n_bits</code>属性表示的。我们前面介绍InnoDB记录结构的时候说过，页面中的每条记录在<code>记录头信息</code>中都包含一个<code>heap_no</code>属性，伪记录<code>Infimum</code>的<code>heap_no</code>值为<code>0</code>，<code>Supremum</code>的<code>heap_no</code>值为<code>1</code>，之后每插入一条记录，<code>heap_no</code>值就增1。<code>锁结构</code>最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个<code>heap_no</code>，不过为了编码方便，映射方式有点怪：</p><p>  <img src="/../images/25-14.png"></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：这么怪的映射方式纯粹是为了敲代码方便，大家不要大惊小怪，只需要知道一个比特位映射到页内的一条记录就好了。</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;可能上面的描述大家觉得还是有些抽象，我们还是举个例子说明一下。比方说现在有两个事务<code>T1</code>和<code>T2</code>想对<code>hero</code>表中的记录进行加锁，<code>hero</code>表中记录比较少，假设这些记录都存储在所在的表空间号为<code>67</code>，页号为<code>3</code>的页面上，那么如果：</p><ul><li><p><code>T1</code>想对<code>number</code>值为<code>15</code>的这条记录加<code>S型正常记录锁</code>，在对记录加行锁之前，需要先加表级别的<code>IS</code>锁，也就是会生成一个表级锁的内存结构，不过我们这里不关心表级锁，所以就忽略掉了～ 接下来分析一下生成行锁结构的过程：</p><ul><li><p>事务<code>T1</code>要进行加锁，所以锁结构的<code>锁所在事务信息</code>指的就是<code>T1</code>。</p></li><li><p>直接对聚簇索引进行加锁，所以索引信息指的其实就是<code>PRIMARY</code>索引。</p></li><li><p>由于是行锁，所以接下来需要记录的是三个重要信息：</p><ul><li><p><code>Space ID</code>：表空间号为<code>67</code>。</p></li><li><p><code>Page Number</code>：页号为<code>3</code>。</p></li><li><p><code>n_bits</code>：我们的<code>hero</code>表中现在只插入了5条用户记录，但是在初始分配比特位时会多分配一些，这主要是为了在之后新增记录时不用频繁分配比特位。其实计算<code>n_bits</code>有一个公式：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n_bits = (1 + ((n_recs + LOCK_PAGE_BITMAP_MARGIN) / 8)) * 8</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;其中<code>n_recs</code>指的是当前页面中一共有多少条记录（算上伪记录和在垃圾链表中的记录），比方说现在<code>hero</code>表一共有7条记录（5条用户记录和2条伪记录），所以<code>n_recs</code>的值就是<code>7</code>，<code>LOCK_PAGE_BITMAP_MARGIN</code>是一个固定的值<code>64</code>，所以本次加锁的<code>n_bits</code>值就是：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n_bits = (1 + ((7 + 64) / 8)) * 8 = 72</span><br></pre></td></tr></table></figure></li><li><p><code>type_mode</code>是由三部分组成的：</p><ul><li><code>lock_mode</code>，这是对记录加<code>S锁</code>，它的值为<code>LOCK_S</code>。</li><li><code>lock_type</code>，这是对记录进行加锁，也就是行锁，所以它的值为<code>LOCK_REC</code>。</li><li><code>rec_lock_type</code>，这是对记录加<code>正经记录锁</code>，也就是类型为<code>LOCK_REC_NOT_GAP</code>的锁。另外，由于当前没有其他事务对该记录加锁，所以应当获取到锁，也就是<code>LOCK_WAIT</code>代表的二进制位应该是0。</li></ul></li></ul><p>  &amp;emsp;&amp;emsp;综上所属，此次加锁的<code>type_mode</code>的值应该是：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_mode = LOCK_S | LOCK_REC | LOCK_REC_NOT_GAP</span><br></pre></td></tr></table></figure><p>  也就是：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_mode = 2 | 32 | 1024 = 1058</span><br></pre></td></tr></table></figure>      </p></li><li><p>其他信息</p><p>  略～</p></li><li><p>一堆比特位</p><p>  &amp;emsp;&amp;emsp;因为<code>number</code>值为<code>15</code>的记录<code>heap_no</code>值为<code>5</code>，根据上面列举的比特位和<code>heap_no</code>的映射图来看，应该是第一个字节从低位往高位数第6个比特位被置为1，就像这样：</p><p>  <img src="/../images/25-15.png"></p></li></ul><p>  &amp;emsp;&amp;emsp;综上所述，事务<code>T1</code>为<code>number</code>值为5的记录加锁生成的锁结构就如下图所示：</p><p>  <img src="/../images/25-16.png">  </p></li><li><p><code>T2</code>想对<code>number</code>值为<code>3</code>、<code>8</code>、<code>15</code>的这三条记录加<code>X型的next-key锁</code>，在对记录加行锁之前，需要先加表级别的<code>IX</code>锁，也就是会生成一个表级锁的内存结构，不过我们这里不关心表级锁，所以就忽略掉了～</p><p>  &amp;emsp;&amp;emsp;现在<code>T2</code>要为3条记录加锁，<code>number</code>为<code>3</code>、<code>8</code>的两条记录由于没有其他事务加锁，所以可以成功获取这条记录的<code>X型next-key锁</code>，也就是生成的锁结构的<code>is_waiting</code>属性为<code>false</code>；但是<code>number</code>为<code>15</code>的记录已经被<code>T1</code>加了<code>S型正经记录锁</code>，<code>T2</code>是不能获取到该记录的<code>X型next-key锁</code>的，也就是生成的锁结构的<code>is_waiting</code>属性为<code>true</code>。因为等待状态不相同，所以这时候会生成两个<code>锁结构</code>。这两个锁结构中相同的属性如下：</p><ul><li><p>事务<code>T2</code>要进行加锁，所以锁结构的<code>锁所在事务信息</code>指的就是<code>T2</code>。</p></li><li><p>直接对聚簇索引进行加锁，所以索引信息指的其实就是<code>PRIMARY</code>索引。</p></li><li><p>由于是行锁，所以接下来需要记录是三个重要信息：</p><ul><li><code>Space ID</code>：表空间号为<code>67</code>。</li><li><code>Page Number</code>：页号为<code>3</code>。</li><li><code>n_bits</code>：此属性生成策略同<code>T1</code>中一样，该属性的值为<code>72</code>。</li><li><code>type_mode</code>是由三部分组成的：<ul><li><code>lock_mode</code>，这是对记录加<code>X锁</code>，它的值为<code>LOCK_X</code>。</li><li><code>lock_type</code>，这是对记录进行加锁，也就是行锁，所以它的值为<code>LOCK_REC</code>。</li><li><code>rec_lock_type</code>，这是对记录加<code>next-key锁</code>，也就是类型为<code>LOCK_ORDINARY</code>的锁。</li></ul></li></ul></li><li><p>其他信息</p><p>  略～</p></li></ul><p>  &amp;emsp;&amp;emsp;不同的属性如下：</p><ul><li><p>为<code>number</code>为<code>3</code>、<code>8</code>的记录生成的<code>锁结构</code>：</p><ul><li><p><code>type_mode</code>值。</p><p>  &amp;emsp;&amp;emsp;由于可以获取到锁，所以<code>is_waiting</code>属性为<code>false</code>，也就是<code>LOCK_WAIT</code>代表的二进制位被置0。所以：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_mode = LOCK_X | LOCK_REC |LOCK_ORDINARY</span><br></pre></td></tr></table></figure><p>  也就是</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_mode = 3 | 32 | 0 = 35</span><br></pre></td></tr></table></figure></li><li><p><code>一堆比特位</code></p><p>  &amp;emsp;&amp;emsp;因为<code>number</code>值为<code>3</code>、<code>8</code>的记录<code>heap_no</code>值分别为<code>3</code>、<code>4</code>，根据上面列举的比特位和<code>heap_no</code>的映射图来看，应该是第一个字节从低位往高位数第4、5个比特位被置为1，就像这样：</p></li></ul><p>  <img src="/../images/25-17.png"></p><p>  &amp;emsp;&amp;emsp;综上所述，事务<code>T2</code>为<code>number</code>值为<code>3</code>、<code>8</code>两条记录加锁生成的锁结构就如下图所示：</p><p>  <img src="/../images/25-18.png"></p></li><li><p>为<code>number</code>为<code>15</code>的记录生成的<code>锁结构</code>：</p><ul><li><p><code>type_mode</code>值。</p><p>  &amp;emsp;&amp;emsp;由于可以获取到锁，所以<code>is_waiting</code>属性为<code>true</code>，也就是<code>LOCK_WAIT</code>代表的二进制位被置1。所以：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_mode = LOCK_X | LOCK_REC |LOCK_ORDINARY | LOCK_WAIT</span><br></pre></td></tr></table></figure><p>  也就是</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_mode = 3 | 32 | 0 | 256 = 291</span><br></pre></td></tr></table></figure></li><li><p><code>一堆比特位</code></p><p>  &amp;emsp;&amp;emsp;因为<code>number</code>值为<code>15</code>的记录<code>heap_no</code>值为<code>5</code>，根据上面列举的比特位和<code>heap_no</code>的映射图来看，应该是第一个字节从低位往高位数第6个比特位被置为1，就像这样：</p></li></ul><p> <img src="/../images/25-19.png"></p><p> &amp;emsp;&amp;emsp;综上所述，事务<code>T2</code>为<code>number</code>值为<code>15</code>的记录加锁生成的锁结构就如下图所示：</p><p> <img src="/../images/25-20.png"></p></li></ul></li></ul><p>&amp;emsp;&amp;emsp;综上所述，事务<code>T1</code>先获取<code>number</code>值为<code>15</code>的<code>S型正经记录锁</code>，然后事务<code>T2</code>获取<code>number</code>值为<code>3</code>、<code>8</code>、<code>15</code>的<code>X型正经记录锁</code>共需要生成3个锁结构。噗～ 关于锁结构我本来就想写一点点的，没想到一些起来就停不下了，大家乐呵乐呵看～</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：上面事务T2在对number值分别为3、8、15这三条记录加锁的情景中，是按照先对number值为3的记录加锁、再对number值为8的记录加锁，最后对number值为15的记录加锁的顺序进行的，如果我们一开始就对number值为15的记录加锁，那么该事务在为number值为15的记录生成一个锁结构后，直接就进入等待状态，就不为number值为3、8的两条记录生成锁结构了。在事务T1提交后会把在number值为15的记录上获取的锁释放掉，然后事务T2就可以获取该记录上的锁，这时再对number值为3、8的两条记录加锁时，就可以复用之前为number值为15的记录加锁时生成的锁结构了。</span><br></pre></td></tr></table></figure><h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><p>&amp;emsp;&amp;emsp;欢迎各位关注我的微信公众号「我们都是小青蛙」，那里有更多技术干货与特色扯犊子文章（后续会在公众号中发布各种不同的语句具体的加锁情况分析，敬请期待）。</p><p><img src="/../images/25-21.png"></p><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/00-%E4%B8%87%E9%87%8C%E9%95%BF%E5%BE%81%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%89-%E5%A6%82%E4%BD%95%E6%84%89%E5%BF%AB%E7%9A%84%E9%98%85%E8%AF%BB%E6%9C%AC%E5%B0%8F%E5%86%8C/"/>
      <url>/2022/10/31/model-mysql/mysql/00-%E4%B8%87%E9%87%8C%E9%95%BF%E5%BE%81%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%89-%E5%A6%82%E4%BD%95%E6%84%89%E5%BF%AB%E7%9A%84%E9%98%85%E8%AF%BB%E6%9C%AC%E5%B0%8F%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="第0章-万里长征第一步（非常重要）-如何愉快的阅读本小册"><a href="#第0章-万里长征第一步（非常重要）-如何愉快的阅读本小册" class="headerlink" title="第0章 万里长征第一步（非常重要）-如何愉快的阅读本小册"></a>第0章 万里长征第一步（非常重要）-如何愉快的阅读本小册</h1><h2 id="购买前警告⚠️"><a href="#购买前警告⚠️" class="headerlink" title="购买前警告⚠️"></a>购买前警告⚠️</h2><ul><li>此小册并非数据库入门书籍，需要各位知道增删改查是什么意思，并且能用 SQL 语言写出来，当然并不要求各位知道的太多，你甚至可以不知道连接的语法都可以。不过如果你连<code>SELECT</code>、<code>INSERT</code>这些单词都没听说过那本小册并不适合你。</li><li>此小册非正经科学专著，亦非十二五国家级规划教材，也没有大段代码和详细论证，有的全是图，喜欢正经论述的同学请避免购买本小册。</li><li>此小册作者乃一无业游民，非专业大佬，没有任何职称，只是单单喜欢把复杂问题讲清楚的那种快感，所以喜欢作者有 Google、Facebook 高级开发工程师，二百年工作经验等 Title 的同学请谨慎购买。</li><li>此小册是用于介绍 MySQL 的工作原理以及对我们程序猿的影响，并不是介绍概念设计、逻辑设计、物理设计、范式化之类的数据库设计方面的知识，希望了解上述这些知识的同学来错地方了。</li><li>文章标题中的<span style="color:red">“从根儿上理解MySQL”</span>其实是专门雇了 UC 震惊部小编起的，纯属为了吸引大家眼球。严格意义上说，本书只是介绍<code>MySQL</code>内核的一些核心概念的小白进阶书籍。大家读完本小册也不会一下子晋升业界大佬，当上 CTO，迎娶白富美，走上人生巅峰。希望本小册能够帮助大家解决一些工作、面试过程中的问题，逐渐成为一个更好的工程师，有兴趣的小伙伴可以再深入研究一下 MySQL，说不定你就是下一个数据库泰斗啦。</li></ul><h2 id="购买并阅读本小册的建议"><a href="#购买并阅读本小册的建议" class="headerlink" title="购买并阅读本小册的建议"></a>购买并阅读本小册的建议</h2><p><img src="/../images/00-01.png"></p><ul><li><p>本小册是一本待出版的纸质书籍，并非一些杂碎文章的集合，是非常有结构和套路的，所以大家阅读时千万不能当作厕所蹲坑、吃饭看手机时的所谓<code>碎片化读物</code>。碎片化阅读只适合听听矮大紧、罗胖子他们扯扯犊子，开阔一下视野用的。对于专业的技术知识来说，大家必须付出一个完整的时间段进行体系化学习，这样尊重知识，工资才能尊重你。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">顺便说一句，我已经好久都不听罗胖子扯犊子了，刚开始办罗辑思维的时候觉得他扯的还可以，越往后越觉得都钻钱眼儿里了，天天在鼓吹焦虑，让大家去买他们的鸡汤课。不过听听矮大紧就挺好啊，不累～</span><br></pre></td></tr></table></figure></li><li><p>本小册是由 Markdown 写成，在电脑端阅读体验十分舒服，当然你非要用小手机看我也不拦着你，但是效果打了折扣是你的损失。</p></li><li><p>为了保证最好的阅读体验，不用一个没学过的概念去介绍另一个新概念，本小册的章节有严重的依赖性，比如你在没读<code>InnoDB</code>数据页结构前千万不要就去读<code>B+</code>树索引，所以大家最好从前看到尾，<span style="color:red">不要跳着看！不要跳着看！不要跳着看！</span>，当然，不听劝告我也不能说什么，祝你好运。</p></li><li><p>大家可能买过别的小册，有的小册一篇文章可能用5分钟、10分钟读完，不过我的小册子每一篇文章都比较长，因为我把高耦合的部分都集中在一篇文章中了。文章中埋着各种伏笔，所以大家看的时候可能不会觉察出来很突兀的转变，所以在阅读一篇文章的时候千万<span style="color:red">不要跳着看！不要跳着看！不要跳着看！</span></p></li><li><p>大家在看本小册之前应该断断续续看过一些与本小册内容相关的知识，只是不成体系，细节学习的不够。对于这部分读者来说，希望大家像倚天屠龙记里的张无忌一样，在学张三丰的太极剑法时先忘记之前的武功，忘的越干净，学的越得真传。这样才能跟着我的套路走下去。</p></li><li><p>如果你真的是个小白的话，那这里头的数字都是假的：<br>  <img src="/../images/00-02.png"></p><p>  &amp;emsp;&amp;emsp;一篇文章能用2个小时左右的时间掌握就很不错了。说句扫大家兴的话，虽然我已经很努力的想让大家的学习效率提升n倍，但是不幸的是想掌握一门核心技术仍然需要大家多看几遍（不然工资那么好涨啊～）。</p></li></ul><h2 id="关于工具"><a href="#关于工具" class="headerlink" title="关于工具"></a>关于工具</h2><p>&amp;emsp;&amp;emsp;本小册中会涉及很多 InnoDB 的存储结构的知识，比如记录结构、页结构、索引结构、表空间结构等等，这些知识是所有后续知识的基础，所以是重中之重，需要大家认真对待。Jeremy Cole 已经使用 Ruby 开发了一个简易的解析这些基础结构的工具，github地址是：<a href="https://github.com/jeremycole/innodb_ruby">innodb_ruby的github地址</a>，大家可以按照说明安装上这个工具，可以更好的理解 InnoDB 中的一些存储结构（此工具虽然是针对<code>MySQL 5.6</code>的，但是幸好<code>MySQL</code>的基础存储结构基本没多大变化，所以大部分场景下这个<code>innodb_ruby</code>工具还是可以使用的）。</p><h2 id="关于盗版"><a href="#关于盗版" class="headerlink" title="关于盗版"></a>关于盗版</h2><p>&amp;emsp;&amp;emsp;在写这本小册之前，我天真的以为只需要找几本参考书，看看 MySQL 的官方文档，遇到不会的地方百度谷歌一下就可以在 3 个月内解决这本书，后来的现实证明我真的想的太美了。不仅花了大量的时间阅读各种书籍和源码，而且有的时候知识耦合太厉害，为了更加模块化的把知识表述清楚，我又花了大量的时间来思考如何写作才能符合用户认知习惯，还花了非常多的时间来画各种图表，总之就是心累啊～<br>我希望的是：<span style="color:red">各位同学可以用很低的成本来更快速学会一些看起来生涩难懂的知识</span>，但是毕竟我不是马云，不能一心一意做公益，希望各位通过正规渠道获得小册，尊重一下版权。<br>还有各位写博客的同学，引用的少了叫借鉴，引用的多了就，就有点那个了。希望各位不要大段大段的复制粘贴，用自己的话写出来的知识才是自己的东西。<br>我知道不论我们怎样强调版权意识，总是有一部分小伙伴喜欢不劳而获，总是喜欢想尽各种渠道来弄一份盗版的看，希望这部分同学看完别忘了关注公众号【我们都是小青蛙】，给我填个粉儿也算是赞助一下我（下面是二维码，觉得有帮助的话希望可以打赏一下，毕竟本人很穷。另外，公众号中有若干篇小册的补充文章，包括三篇极其重要的语句加锁分析）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：我一直有个想法，就是如何降低教育成本。现在教育的盈利收费模式都太单一，就是直接跟学生收上课费，导致课程成为一种2C的商品，价格高低其实和内容质量并不是很相关，所以课程提供商会投入更大的精力做他们的渠道营销。所以现在的在线教育市场就是渠道为王，招生为王。我们其实可以换一种思路，在线教育的优势其实是传播费用更低，一个人上课和一千万人上课的费用区别其实就是服务器使用的多少罢了，所以我们可能并不需要那么多语文老师、数学老师，我们用专业的导演、专业的声优、专业的动画制作、专业的后期、专业的剪辑、专业的编剧组成的团队为某个科目制作一个专业的课程就好了嘛（顺便说一句，我就可以转行做课程编剧了）！把课程当作电影、电视剧来卖，只要在课程中植入广告，或者在播放平台上加广告就好了嘛，我们也可以在课程里培养偶像，来做一波粉丝经济。这样课程生产方也赚钱，学生们也省钱，最主要的是可以更大层度上促进教育公平，多好。</span><br></pre></td></tr></table></figure><h2 id="关于错误"><a href="#关于错误" class="headerlink" title="关于错误"></a>关于错误</h2><h3 id="准确性问题"><a href="#准确性问题" class="headerlink" title="准确性问题"></a>准确性问题</h3><p>&amp;emsp;&amp;emsp;我不是神，并不是书中的所有内容我都一一对照源码来验证准确性（阅读的大部分源码是关于查询优化和事务处理的），如果各位发现了文中有准确性问题请直接联系我，我会加入 Bug 列表中修正的。</p><h3 id="阅读体验问题"><a href="#阅读体验问题" class="headerlink" title="阅读体验问题"></a>阅读体验问题</h3><p>&amp;emsp;&amp;emsp;大家知道大部分人在长大之后就忘记了自己小时候的样子，我写本书的初衷就是有很多资料我看不懂，看的我脑壳疼，之后才决定从小白的角度出发来写一本小白都能看懂的技术书籍。但是由于后来自己学的东西越来越多，可能有些地方我已经忘掉了小白的想法是怎么样的，所以大家在阅读过程中有任何阅读不畅快的地方都可以给我提，我也会加入bug列表中逐一优化。</p><h2 id="关于转发"><a href="#关于转发" class="headerlink" title="关于转发"></a>关于转发</h2><p>&amp;emsp;&amp;emsp;如果你从本小册中获取到了自己想要的知识，并且这个过程是比较轻松愉快的，希望各位能帮助转发本小册，解放一下学不懂这些知识的童鞋们，多节省一下他们的学习时间以及让学习过程不再那么痛苦。大家的技术都长进了，咱国家的技术也就慢慢强起来了。</p><h2 id="关于疑惑"><a href="#关于疑惑" class="headerlink" title="关于疑惑"></a>关于疑惑</h2><p>&amp;emsp;&amp;emsp;虽然我觉得文章写的已经很清晰了，但毕竟只是“我觉得”，不是大家觉得。传道授业解惑，<span style="color:red">解惑</span>很重要。在学习一门知识时，我们最容易让一些问题绊住脚步，大家在阅读小册时如果发现了任何你觉得让你很困惑的问题，都可以直接加微信 xiaohaizi4919 问我，或者到群里提问题（最好到群里提，这样大家都能看到，也省的重复提问），我在力所能及的范围内尽力帮大家解答。<br><img src="/../images/00-03.jpg"></p><h2 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h2><p>&amp;emsp;&amp;emsp;如果有的同学购买本小册后觉得并不是自己的菜，那很遗憾，我不能给你退款，钱是掘金这个平台收的。不过我还是觉得绝大部分同学读过后肯定有物超所值的感受，面试一般的数据库问题再也难不倒各位了，工作中一般的数据库问题也都是小菜一碟了，想继续研究 MySQL 源码的同学也找到方向了，如果你觉得 29.9 元不能表达你淘到宝的喜悦之情，那这好说，给我发红包就好了。</p><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/08-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%B6-MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/10/31/model-mysql/mysql/08-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%B6-MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="第8章-数据的家-MySQL的数据目录"><a href="#第8章-数据的家-MySQL的数据目录" class="headerlink" title="第8章 数据的家-MySQL的数据目录"></a>第8章 数据的家-MySQL的数据目录</h1><h2 id="数据库和文件系统的关系"><a href="#数据库和文件系统的关系" class="headerlink" title="数据库和文件系统的关系"></a>数据库和文件系统的关系</h2><p>&amp;emsp;&amp;emsp;我们知道像<code>InnoDB</code>、<code>MyISAM</code>这样的存储引擎都是把表存储在磁盘上的，而操作系统用来管理磁盘的那个东东又被称为<code>文件系统</code>，所以用专业一点的话来表述就是：<span style="color:red">像 <em><strong>InnoDB</strong></em> 、 <em><strong>MyISAM</strong></em> 这样的存储引擎都是把表存储在文件系统上的</span>。当我们想读取数据的时候，这些存储引擎会从文件系统中把数据读出来返回给我们，当我们想写入数据的时候，这些存储引擎会把这些数据又写回文件系统。本章就是要介绍一下<code>InnoDB</code>和<code>MyISAM</code>这两个存储引擎的数据如何在文件系统中存储的。</p><h2 id="MySQL数据目录"><a href="#MySQL数据目录" class="headerlink" title="MySQL数据目录"></a>MySQL数据目录</h2><p>&amp;emsp;&amp;emsp;MySQL服务器程序在启动时会到文件系统的某个目录下加载一些文件，之后在运行过程中产生的数据也都会存储到这个目录下的某些文件中，这个目录就称为<code>数据目录</code>，我们下面就要详细唠唠这个目录下具体都有哪些重要的东西。</p><h3 id="数据目录和安装目录的区别"><a href="#数据目录和安装目录的区别" class="headerlink" title="数据目录和安装目录的区别"></a>数据目录和安装目录的区别</h3><p>&amp;emsp;&amp;emsp;我们之前只接触过<code>MySQL</code>的安装目录（在安装<code>MySQL</code>的时候我们可以自己指定），我们重点强调过这个<code>安装目录</code>下非常重要的<code>bin</code>目录，它里边存储了许多关于控制客户端程序和服务器程序的命令（许多可执行文件，比如<code>mysql</code>，<code>mysqld</code>，<code>mysqld_safe</code>等等等等好几十个）。而<code>数据目录</code>是用来存储<code>MySQL</code>在运行过程中产生的数据，一定要和本章要讨论的<code>安装目录</code>区别开！<span style="color:red">一定要区分开</span>！<span style="color:red">一定要区分开</span>！<span style="color:red">一定要区分开</span>！</p><h3 id="如何确定MySQL中的数据目录"><a href="#如何确定MySQL中的数据目录" class="headerlink" title="如何确定MySQL中的数据目录"></a>如何确定MySQL中的数据目录</h3><p>&amp;emsp;&amp;emsp;那说了半天，到底<code>MySQL</code>把数据都存到哪个路径下呢？其实<code>数据目录</code>对应着一个系统变量<code>datadir</code>，我们在使用客户端与服务器建立连接之后查看这个系统变量的值就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;datadir&#x27;;</span><br><span class="line">+---------------+-----------------------+</span><br><span class="line">| Variable_name | Value                 |</span><br><span class="line">+---------------+-----------------------+</span><br><span class="line">| datadir       | /usr/local/var/mysql/ |</span><br><span class="line">+---------------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;从结果中可以看出，<span style="color:red">在我的计算机上</span><code>MySQL</code>的数据目录就是<code>/usr/local/var/mysql/</code>，你用你的计算机试试呗～</p><h2 id="数据目录的结构"><a href="#数据目录的结构" class="headerlink" title="数据目录的结构"></a>数据目录的结构</h2><p>&amp;emsp;&amp;emsp;<code>MySQL</code>在运行过程中都会产生哪些数据呢？当然会包含我们创建的数据库、表、视图和触发器等等的用户数据，除了这些用户数据，为了程序更好的运行，<code>MySQL</code>也会创建一些其他的额外数据，我们接下来细细的品味一下这个<code>数据目录</code>下的内容。</p><h3 id="数据库在文件系统中的表示"><a href="#数据库在文件系统中的表示" class="headerlink" title="数据库在文件系统中的表示"></a>数据库在文件系统中的表示</h3><p>&amp;emsp;&amp;emsp;每当我们使用<code>CREATE DATABASE 数据库名</code>语句创建一个数据库的时候，在文件系统上实际发生了什么呢？其实很简单，<span style="color:red">每个数据库都对应数据目录下的一个子目录，或者说对应一个文件夹</span>，我们每当我们新建一个数据库时，<code>MySQL</code>会帮我们做这两件事儿：</p><ol><li><p>在<code>数据目录</code>下创建一个和数据库名同名的子目录（或者说是文件夹）。</p></li><li><p>在该与数据库名同名的子目录下创建一个名为<code>db.opt</code>的文件，这个文件中包含了该数据库的各种属性，比方说该数据库的字符集和比较规则是什么。</p></li></ol><p>&amp;emsp;&amp;emsp;比方说我们查看一下<span style="color:red">在我的计算机上</span>当前有哪些数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| charset_demo_db    |</span><br><span class="line">| dahaizi            |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| xiaohaizi          |</span><br><span class="line">+--------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到在我的计算机上当前有7个数据库，其中<code>charset_demo_db</code>、<code>dahaizi</code>和<code>xiaohaizi</code>数据库是我们自定义的，其余4个数据库是属于MySQL自带的系统数据库。我们再看一下<span style="color:red">我的计算机上</span>的<code>数据目录</code>下的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── auto.cnf</span><br><span class="line">├── ca-key.pem</span><br><span class="line">├── ca.pem</span><br><span class="line">├── charset_demo_db</span><br><span class="line">├── client-cert.pem</span><br><span class="line">├── client-key.pem</span><br><span class="line">├── dahaizi</span><br><span class="line">├── ib_buffer_pool</span><br><span class="line">├── ib_logfile0</span><br><span class="line">├── ib_logfile1</span><br><span class="line">├── ibdata1</span><br><span class="line">├── ibtmp1</span><br><span class="line">├── mysql</span><br><span class="line">├── performance_schema</span><br><span class="line">├── private_key.pem</span><br><span class="line">├── public_key.pem</span><br><span class="line">├── server-cert.pem</span><br><span class="line">├── server-key.pem</span><br><span class="line">├── sys</span><br><span class="line">├── xiaohaizideMacBook-Pro.local.err</span><br><span class="line">├── xiaohaizideMacBook-Pro.local.pid</span><br><span class="line">└── xiaohaizi</span><br><span class="line"></span><br><span class="line">6 directories, 16 files</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;当然这个数据目录下的文件和子目录比较多，但是如果仔细看的话，除了<code>information_schema</code>这个系统数据库外，其他的数据库在<code>数据目录</code>下都有对应的子目录。这个<code>information_schema</code>比较特殊，设计MySQL的大佬们对它的实现进行了特殊对待，没有使用相应的数据库目录，我们忽略它的存在就好了。</p><h3 id="表在文件系统中的表示"><a href="#表在文件系统中的表示" class="headerlink" title="表在文件系统中的表示"></a>表在文件系统中的表示</h3><p>&amp;emsp;&amp;emsp;我们的数据其实都是以记录的形式插入到表中的，每个表的信息其实可以分为两种：</p><ol><li><p>表结构的定义</p></li><li><p>表中的数据</p></li></ol><p>&amp;emsp;&amp;emsp;<code>表结构</code>就是该表的名称是什么，表里边有多少列，每个列的数据类型是什么，有什么约束条件和索引，用的是什么字符集和比较规则等等的各种信息，这些信息都体现在我们的建表语句中了。为了保存这些信息，<code>InnoDB</code>和<code>MyISAM</code>这两种存储引擎都在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于描述表结构的文件，文件名是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.frm</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;比方说我们在<code>dahaizi</code>数据库下创建一个名为<code>test</code>的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE dahaizi;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE test (</span><br><span class="line">    -&gt;     c1 INT</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;那在数据库<code>dahaizi</code>对应的子目录下就会创建一个名为<code>test.frm</code>的用于描述表结构的文件。值得注意的是，<span style="color:red">这个后缀名为.frm是以二进制格式存储的，我们直接打开会是乱码的～</span> 你还不赶紧在你的计算机上创建个表试试～</p><p>&amp;emsp;&amp;emsp;描述表结构的文件我们知道怎么存储了，那表中的数据存到什么文件中了呢？在这个问题上，不同的存储引擎就产生了分歧了，下面我们分别看一下<code>InnoDB</code>和<code>MyISAM</code>是用什么文件来保存表中数据的。</p><h4 id="InnoDB是如何存储表数据的"><a href="#InnoDB是如何存储表数据的" class="headerlink" title="InnoDB是如何存储表数据的"></a>InnoDB是如何存储表数据的</h4><p>&amp;emsp;&amp;emsp;我们前面重点介绍过<code>InnoDB</code>的一些实现原理，到现在为止我们应该熟悉下面这些东东：</p><ul><li><p><code>InnoDB</code>其实是使用<code>页</code>为基本单位来管理存储空间的，默认的<code>页</code>大小为<code>16KB</code>。</p></li><li><p>对于<code>InnoDB</code>存储引擎来说，每个索引都对应着一棵<code>B+</code>树，该<code>B+</code>树的每个节点都是一个数据页，数据页之间不必要是物理连续的，因为数据页之间有<code>双向链表</code>来维护着这些页的顺序。</p></li><li><p><code>InnoDB</code>的聚簇索引的叶子节点存储了完整的用户记录，也就是所谓的<span style="color:red">索引即数据，数据即索引</span>。</p></li></ul><p>&amp;emsp;&amp;emsp;为了更好的管理这些页，设计<code>InnoDB</code>的大佬们提出了一个<code>表空间</code>或者<code>文件空间</code>（英文名：<code>table space</code>或者<code>file space</code>）的概念，这个表空间是一个抽象的概念，它可以对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）。每一个<code>表空间</code>可以被划分为很多很多很多个<code>页</code>，我们的表数据就存放在某个<code>表空间</code>下的某些页里。设计<code>InnoDB</code>的大佬将表空间划分为几种不同的类型，我们一个一个看一下。</p><h5 id="系统表空间（system-tablespace）"><a href="#系统表空间（system-tablespace）" class="headerlink" title="系统表空间（system tablespace）"></a>系统表空间（system tablespace）</h5><p>&amp;emsp;&amp;emsp;这个所谓的<code>系统表空间</code>可以对应文件系统上一个或多个实际的文件，默认情况下，<code>InnoDB</code>会在<code>数据目录</code>下创建一个名为<code>ibdata1</code>（在你的数据目录下找找看有木有）、大小为<code>12M</code>的文件，这个文件就是对应的<code>系统表空间</code>在文件系统上的表示。怎么才<code>12M</code>？这么点儿还没插多少数据就用完了，那是因为这个文件是所谓的<code>自扩展文件</code>，也就是当不够用的时候它会自己增加文件大小～</p><p>&amp;emsp;&amp;emsp;当然，如果你想让系统表空间对应文件系统上多个实际文件，或者仅仅觉得原来的<code>ibdata1</code>这个文件名难听，那可以在<code>MySQL</code>启动时配置对应的文件路径以及它们的大小，比如我们这样修改一下配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_data_file_path=data1:512M;data2:512M:autoextend</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这样在<code>MySQL</code>启动之后就会创建这两个512M大小的文件作为<code>系统表空间</code>，其中的<code>autoextend</code>表明这两个文件如果不够用会自动扩展<code>data2</code>文件的大小。</p><p>&amp;emsp;&amp;emsp;我们也可以把<code>系统表空间</code>对应的文件路径不配置到<code>数据目录</code>下，甚至可以配置到单独的磁盘分区上，涉及到的启动参数就是<code>innodb_data_file_path</code>和<code>innodb_data_home_dir</code>，具体的配置逻辑挺绕的，我们这就不多介绍了，知道改哪个参数可以修改<code>系统表空间</code>对应的文件，有需要的时候到官方文档里一查就好了。</p><p>&amp;emsp;&amp;emsp;需要注意的一点是，在一个MySQL服务器中，系统表空间只有一份。从MySQL5.5.7到MySQL5.6.6之间的各个版本中，我们表中的数据都会被默认存储到这个 <em><strong>系统表空间</strong></em>。</p><h5 id="独立表空间-file-per-table-tablespace"><a href="#独立表空间-file-per-table-tablespace" class="headerlink" title="独立表空间(file-per-table tablespace)"></a>独立表空间(file-per-table tablespace)</h5><p>&amp;emsp;&amp;emsp;在MySQL5.6.6以及之后的版本中，<code>InnoDB</code>并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。使用<code>独立表空间</code>来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该<code>独立表空间</code>的文件，文件名和表名相同，只不过添加了一个<code>.ibd</code>的扩展名而已，所以完整的文件名称长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.ibd</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;比方说假如我们使用了<code>独立表空间</code>去存储<code>xiaohaizi</code>数据库下的<code>test</code>表的话，那么在该表所在数据库对应的<code>xiaohaizi</code>目录下会为<code>test</code>表创建这两个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.frm</span><br><span class="line">test.ibd</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;其中<code>test.ibd</code>文件就用来存储<code>test</code>表中的数据和索引。当然我们也可以自己指定使用<code>系统表空间</code>还是<code>独立表空间</code>来存储数据，这个功能由启动参数<code>innodb_file_per_table</code>控制，比如说我们想刻意将表数据都存储到<code>系统表空间</code>时，可以在启动<code>MySQL</code>服务器的时候这样配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_file_per_table=0</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;当<code>innodb_file_per_table</code>的值为<code>0</code>时，代表使用系统表空间；当<code>innodb_file_per_table</code>的值为<code>1</code>时，代表使用独立表空间。不过<code>innodb_file_per_table</code>参数只对新建的表起作用，对于已经分配了表空间的表并不起作用。如果我们想把已经存在系统表空间中的表转移到独立表空间，可以使用下面的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 TABLESPACE [=] innodb_file_per_table;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;或者把已经存在独立表空间的表转移到系统表空间，可以使用下面的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 TABLESPACE [=] innodb_system;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;其中中括号扩起来的<code>=</code>可有可无，比方说我们想把<code>test</code>表从独立表空间移动到系统表空间，可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE test TABLESPACE innodb_system;</span><br></pre></td></tr></table></figure><h5 id="其他类型的表空间"><a href="#其他类型的表空间" class="headerlink" title="其他类型的表空间"></a>其他类型的表空间</h5><p>&amp;emsp;&amp;emsp;随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、undo表空间（undo tablespace）、临时表空间（temporary tablespace）等等的，具体情况我们就不细介绍了，等用到的时候再提。</p><h4 id="MyISAM是如何存储表数据的"><a href="#MyISAM是如何存储表数据的" class="headerlink" title="MyISAM是如何存储表数据的"></a>MyISAM是如何存储表数据的</h4><p>&amp;emsp;&amp;emsp;好了，介绍完了<code>InnoDB</code>的系统表空间和独立表空间，现在轮到<code>MyISAM</code>了。我们知道不像<code>InnoDB</code>的索引和数据是一个东东，在<code>MyISAM</code>中的索引全部都是<code>二级索引</code>，该存储引擎的数据和索引是分开存放的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件。而且和<code>InnoDB</code>不同的是，<code>MyISAM</code>并没有什么所谓的<code>表空间</code>一说，<span style="color:red">表数据都存放到对应的数据库子目录下</span>。假如<code>test</code>表使用<code>MyISAM</code>存储引擎的话，那么在它所在数据库对应的<code>xiaohaizi</code>目录下会为<code>test</code>表创建这三个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.frm</span><br><span class="line">test.MYD</span><br><span class="line">test.MYI</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;其中<code>test.MYD</code>代表表的数据文件，也就是我们插入的用户记录；<code>test.MYI</code>代表表的索引文件，我们为该表创建的索引都会放到这个文件中。</p><h3 id="视图在文件系统中的表示"><a href="#视图在文件系统中的表示" class="headerlink" title="视图在文件系统中的表示"></a>视图在文件系统中的表示</h3><p>&amp;emsp;&amp;emsp;我们知道<code>MySQL</code>中的视图其实是虚拟的表，也就是某个查询语句的一个别名而已，所以在存储<code>视图</code>的时候是不需要存储真实的数据的，<span style="color:red">只需要把它的结构存储起来就行了</span>。和<code>表</code>一样，描述视图结构的文件也会被存储到所属数据库对应的子目录下面，只会存储一个<code>视图名.frm</code>的文件。</p><h3 id="其他的文件"><a href="#其他的文件" class="headerlink" title="其他的文件"></a>其他的文件</h3><p>&amp;emsp;&amp;emsp;除了我们上面说的这些用户自己存储的数据以外，<code>数据目录</code>下还包括为了更好运行程序的一些额外文件，主要包括这几种类型的文件：</p><ul><li><p>服务器进程文件。</p><p>  &amp;emsp;&amp;emsp;我们知道每运行一个<code>MySQL</code>服务器程序，都意味着启动一个进程。<code>MySQL</code>服务器会把自己的进程ID写入到一个文件中。</p></li><li><p>服务器日志文件。</p><p>  &amp;emsp;&amp;emsp;在服务器运行过程中，会产生各种各样的日志，比如常规的查询日志、错误日志、二进制日志、redo日志等等各种日志，这些日志各有各的用途，我们之后会重点介绍各种日志的用途，现在先了解一下就可以了。</p></li><li><p>默认&#x2F;自动生成的SSL和RSA证书和密钥文件。</p><p>  &amp;emsp;&amp;emsp;主要是为了客户端和服务器安全通信而创建的一些文件， 大家看不懂可以忽略～</p></li></ul><h2 id="文件系统对数据库的影响"><a href="#文件系统对数据库的影响" class="headerlink" title="文件系统对数据库的影响"></a>文件系统对数据库的影响</h2><p>&amp;emsp;&amp;emsp;因为<code>MySQL</code>的数据都是存在文件系统中的，就不得不受到文件系统的一些制约，这在数据库和表的命名、表的大小和性能方面体现的比较明显，比如下面这些方面：</p><ul><li><p>数据库名称和表名称不得超过文件系统所允许的最大长度。</p><p>  &amp;emsp;&amp;emsp;每个数据库都对应<code>数据目录</code>的一个子目录，数据库名称就是这个子目录的名称；每个表都会在数据库子目录下产生一个和表名同名的<code>.frm</code>文件，如果是<code>InnoDB</code>的独立表空间或者使用<code>MyISAM</code>引擎还会有别的文件的名称与表名一致。这些目录或文件名的长度都受限于文件系统所允许的长度～</p></li><li><p>特殊字符的问题</p><p>  &amp;emsp;&amp;emsp;为了避免因为数据库名和表名出现某些特殊字符而造成文件系统不支持的情况，<code>MySQL</code>会<span style="color:red">把数据库名和表名中所有除数字和拉丁字母以外的所有字符在文件名里都映射成 <code>@+编码值</code>的形式作为文件名</span>。比方说我们创建的表的名称为<code>&#39;test?&#39;</code>，由于<code>?</code>不属于数字或者拉丁字母，所以会被映射成编码值，所以这个表对应的<code>.frm</code>文件的名称就变成了<code>test@003f.frm</code>。</p></li><li><p>文件长度受文件系统最大长度限制</p><p>  &amp;emsp;&amp;emsp;对于<code>InnoDB</code>的独立表空间来说，每个表的数据都会被存储到一个与表名同名的<code>.ibd</code>文件中；对于<code>MyISAM</code>存储引擎来说，数据和索引会分别存放到与表同名的<code>.MYD</code>和<code>.MYI</code>文件中。这些文件会随着表中记录的增加而增大，它们的大小受限于文件系统支持的最大文件大小。</p></li></ul><h2 id="MySQL系统数据库简介"><a href="#MySQL系统数据库简介" class="headerlink" title="MySQL系统数据库简介"></a>MySQL系统数据库简介</h2><p>&amp;emsp;&amp;emsp;我们前面提到了MySQL的几个系统数据库，这几个数据库包含了MySQL服务器运行过程中所需的一些信息以及一些运行状态信息，我们现在稍微了解一下。</p><ul><li><p><code>mysql</code></p><p>  &amp;emsp;&amp;emsp;这个数据库贼核心，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</p></li><li><p><code>information_schema</code></p><p>  &amp;emsp;&amp;emsp;这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引等等。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数据。</p></li><li><p><code>performance_schema</code></p><p>  这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。</p></li><li><p><code>sys</code></p><p>  &amp;emsp;&amp;emsp;这个数据库主要是通过视图的形式把<code>information_schema </code>和<code>performance_schema</code>结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。</p></li></ul><p>&amp;emsp;&amp;emsp;什么？这四个系统数据库这就介绍完了？是的，我们的标题写的就是<code>简介</code>嘛！如果真的要介绍一下这几个系统库的使用，那怕是又要写一本书了… 这里只是因为介绍数据目录里遇到了，为了内容的完整性跟大家提一下，具体如何使用还是要参照文档～</p><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/11-%E4%B8%A4%E4%B8%AA%E8%A1%A8%E7%9A%84%E4%BA%B2%E5%AF%86%E6%8E%A5%E8%A7%A6-%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2022/10/31/model-mysql/mysql/11-%E4%B8%A4%E4%B8%AA%E8%A1%A8%E7%9A%84%E4%BA%B2%E5%AF%86%E6%8E%A5%E8%A7%A6-%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第11章-两个表的亲密接触-连接的原理"><a href="#第11章-两个表的亲密接触-连接的原理" class="headerlink" title="第11章 两个表的亲密接触-连接的原理"></a>第11章 两个表的亲密接触-连接的原理</h1><p>&amp;emsp;&amp;emsp;搞数据库一个避不开的概念就是<code>Join</code>，翻译成中文就是<code>连接</code>。相信很多小伙伴在初学连接的时候有些一脸懵逼，理解了连接的语义之后又可能不明白各个表中的记录到底是怎么连起来的，以至于在使用的时候常常陷入下面两种误区：</p><ul><li>误区一：业务至上，管他三七二十一，再复杂的查询也用在一个连接语句中搞定。</li><li>误区二：敬而远之，上次 DBA 那给报过来的慢查询就是因为使用了连接导致的，以后再也不敢用了。</li></ul><p>&amp;emsp;&amp;emsp;所以本章就来扒一扒连接的原理。考虑到一部分小伙伴可能忘了连接是什么或者压根儿就不知道，为了节省他们百度或者看其他书的宝贵时间以及为了我的书凑字数，我们先来介绍一下 MySQL 中支持的一些连接语法。</p><h2 id="连接简介"><a href="#连接简介" class="headerlink" title="连接简介"></a>连接简介</h2><h3 id="连接的本质"><a href="#连接的本质" class="headerlink" title="连接的本质"></a>连接的本质</h3><p>&amp;emsp;&amp;emsp;为了故事的顺利发展，我们先建立两个简单的表并给它们填充一点数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t1 (m1 int, n1 char(1));</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE t2 (m2 int, n2 char(1));</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO t1 VALUES(1, &#x27;a&#x27;), (2, &#x27;b&#x27;), (3, &#x27;c&#x27;);</span><br><span class="line">Query OK, 3 rows affected (0.00 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO t2 VALUES(2, &#x27;b&#x27;), (3, &#x27;c&#x27;), (4, &#x27;d&#x27;);</span><br><span class="line">Query OK, 3 rows affected (0.00 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们成功建立了<code>t1</code>、<code>t2</code>两个表，这两个表都有两个列，一个是<code>INT</code>类型的，一个是<code>CHAR(1)</code>类型的，填充好数据的两个表长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1;</span><br><span class="line">+------+------+</span><br><span class="line">| m1   | n1   |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | a    |</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    3 | c    |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM t2;</span><br><span class="line">+------+------+</span><br><span class="line">| m2   | n2   |</span><br><span class="line">+------+------+</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    3 | c    |</span><br><span class="line">|    4 | d    |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;<code>连接</code>的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。所以我们把<code>t1</code>和<code>t2</code>两个表连接起来的过程如下图所示：</p><p><img src="/../images/11-01.png"></p><p>&amp;emsp;&amp;emsp;这个过程看起来就是把<code>t1</code>表的记录和<code>t2</code>的记录连起来组成新的更大的记录，所以这个查询过程称之为连接查询。连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果集就可以称之为<code>笛卡尔积</code>。因为表<code>t1</code>中有3条记录，表<code>t2</code>中也有3条记录，所以这两个表连接之后的笛卡尔积就有<code>3×3=9</code>行记录。在<code>MySQL</code>中，连接查询的语法也很随意，只要在<code>FROM</code>语句后边跟多个表名就好了，比如我们把<code>t1</code>表和<code>t2</code>表连接起来的查询语句可以写成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1, t2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    1 | a    |    2 | b    |</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    2 | b    |</span><br><span class="line">|    1 | a    |    3 | c    |</span><br><span class="line">|    2 | b    |    3 | c    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">|    1 | a    |    4 | d    |</span><br><span class="line">|    2 | b    |    4 | d    |</span><br><span class="line">|    3 | c    |    4 | d    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="连接过程简介"><a href="#连接过程简介" class="headerlink" title="连接过程简介"></a>连接过程简介</h3><p>&amp;emsp;&amp;emsp;如果我们乐意，我们可以连接任意数量张表，但是如果没有任何限制条件的话，这些表连接起来产生的<code>笛卡尔积</code>可能是非常巨大的。比方说3个100行记录的表连接起来产生的<code>笛卡尔积</code>就有<code>100×100×100=1000000</code>行数据！所以在连接的时候过滤掉特定记录组合是有必要的，在连接查询中的过滤条件可以分成两种：</p><ul><li><p>涉及单表的条件</p><p>  &amp;emsp;&amp;emsp;这种只设计单表的过滤条件我们之前都提到过一万遍了，我们之前也一直称为<code>搜索条件</code>，比如<code>t1.m1 &gt; 1</code>是只针对<code>t1</code>表的过滤条件，<code>t2.n2 &lt; &#39;d&#39;</code>是只针对<code>t2</code>表的过滤条件。</p></li><li><p>涉及两表的条件</p><p>  &amp;emsp;&amp;emsp;这种过滤条件我们之前没见过，比如<code>t1.m1 = t2.m2</code>、<code>t1.n1 &gt; t2.n2</code>等，这些条件中涉及到了两个表，我们稍后会仔细分析这种过滤条件是如何使用的。</p></li></ul><p>&amp;emsp;&amp;emsp;下面我们就要看一下携带过滤条件的连接查询的大致执行过程了，比方说下面这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 = t2.m2 AND t2.n2 &lt; &#x27;d&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;在这个查询中我们指明了这三个过滤条件：</p><ul><li><p><code>t1.m1 &gt; 1</code></p></li><li><p><code>t1.m1 = t2.m2</code></p></li><li><p><code>t2.n2 &lt; &#39;d&#39;</code></p></li></ul><p>&amp;emsp;&amp;emsp;那么这个连接查询的大致执行过程如下：</p><ol><li><p>首先确定第一个需要查询的表，这个表称之为<code>驱动表</code>。怎样在单表中执行查询语句我们在前一章都介绍过了，只需要选取代价最小的那种访问方法去执行单表查询语句就好了（就是说从const、ref、ref_or_null、range、index、all这些执行方法中选取代价最小的去执行查询）。此处假设使用<code>t1</code>作为驱动表，那么就需要到<code>t1</code>表中找满足<code>t1.m1  &gt; 1</code>的记录，因为表中的数据太少，我们也没在表上建立二级索引，所以此处查询<code>t1</code>表的访问方法就设定为<code>all</code>吧，也就是采用全表扫描的方式执行单表查询。关于如何提升连接查询的性能我们之后再说，现在先把基本概念捋清楚。所以查询过程就如下图所示：</p><p> <img src="/../images/11-02.png"></p><p> &amp;emsp;&amp;emsp;我们可以看到，<code>t1</code>表中符合<code>t1.m1 &gt; 1</code>的记录有两条。</p></li><li><p>针对上一步骤中从驱动表产生的结果集中的每一条记录，分别需要到<code>t2</code>表中查找匹配的记录，所谓<code>匹配的记录</code>，指的是符合过滤条件的记录。因为是根据<code>t1</code>表中的记录去找<code>t2</code>表中的记录，所以<code>t2</code>表也可以被称之为<code>被驱动表</code>。上一步骤从驱动表中得到了2条记录，所以需要查询2次<code>t2</code>表。此时涉及两个表的列的过滤条件<code>t1.m1 = t2.m2</code>就派上用场了：</p><ul><li>当<code>t1.m1 = 2</code>时，过滤条件<code>t1.m1 = t2.m2</code>就相当于<code>t2.m2 = 2</code>，所以此时<code>t2</code>表相当于有了<code>t2.m2 = 2</code>、<code>t2.n2 &lt; &#39;d&#39;</code>这两个过滤条件，然后到<code>t2</code>表中执行单表查询。</li><li>当<code>t1.m1 = 3</code>时，过滤条件<code>t1.m1 = t2.m2</code>就相当于<code>t2.m2 = 3</code>，所以此时<code>t2</code>表相当于有了<code>t2.m2 = 3</code>、<code>t2.n2 &lt; &#39;d&#39;</code>这两个过滤条件，然后到<code>t2</code>表中执行单表查询。</li></ul><p> &amp;emsp;&amp;emsp;所以整个连接查询的执行过程就如下图所示：</p><p> <img src="/../images/11-03.png"></p><p> &amp;emsp;&amp;emsp;也就是说整个连接查询最后的结果只有两条符合过滤条件的记录：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">+------+------+------+------+</span><br></pre></td></tr></table></figure></p></li></ol><p>&amp;emsp;&amp;emsp;从上面两个步骤可以看出来，我们上面介绍的这个两表连接查询共需要查询1次<code>t1</code>表，2次<code>t2</code>表。当然这是在特定的过滤条件下的结果，如果我们把<code>t1.m1 &gt; 1</code>这个条件去掉，那么从<code>t1</code>表中查出的记录就有3条，就需要查询3次<code>t2</code>表了。也就是说在两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。</p><h3 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h3><p>&amp;emsp;&amp;emsp;为了大家更好理解后边内容，我们先创建两个有现实意义的表，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">    number INT NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,</span><br><span class="line">    name VARCHAR(5) COMMENT &#x27;姓名&#x27;,</span><br><span class="line">    major VARCHAR(30) COMMENT &#x27;专业&#x27;,</span><br><span class="line">    PRIMARY KEY (number)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8 COMMENT &#x27;学生信息表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE score (</span><br><span class="line">    number INT COMMENT &#x27;学号&#x27;,</span><br><span class="line">    subject VARCHAR(30) COMMENT &#x27;科目&#x27;,</span><br><span class="line">    score TINYINT COMMENT &#x27;成绩&#x27;,</span><br><span class="line">    PRIMARY KEY (number, score)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8 COMMENT &#x27;学生成绩表&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们新建了一个学生信息表，一个学生成绩表，然后我们向上述两个表中插入一些数据，为节省篇幅，具体插入过程就不介绍了，插入后两表中的数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM student;</span><br><span class="line">+----------+-----------+--------------------------+</span><br><span class="line">| number   | name      | major                    |</span><br><span class="line">+----------+-----------+--------------------------+</span><br><span class="line">| 20180101 | 杜子腾    | 软件学院                 |</span><br><span class="line">| 20180102 | 范统      | 计算机科学与工程         |</span><br><span class="line">| 20180103 | 史珍香    | 计算机科学与工程         |</span><br><span class="line">+----------+-----------+--------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM score;</span><br><span class="line">+----------+-----------------------------+-------+</span><br><span class="line">| number   | subject                     | score |</span><br><span class="line">+----------+-----------------------------+-------+</span><br><span class="line">| 20180101 | 母猪的产后护理              |    78 |</span><br><span class="line">| 20180101 | 论萨达姆的战争准备          |    88 |</span><br><span class="line">| 20180102 | 论萨达姆的战争准备          |    98 |</span><br><span class="line">| 20180102 | 母猪的产后护理              |   100 |</span><br><span class="line">+----------+-----------------------------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;现在我们想把每个学生的考试成绩都查询出来就需要进行两表连接了（因为<code>score</code>中没有姓名信息，所以不能单纯只查询<code>score</code>表）。连接过程就是从<code>student</code>表中取出记录，在<code>score</code>表中查找<code>number</code>相同的成绩记录，所以过滤条件就是<code>student.number = socre.number</code>，整个查询语句就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM student, score WHERE student.number = score.number;</span><br><span class="line">+----------+-----------+--------------------------+----------+-----------------------------+-------+</span><br><span class="line">| number   | name      | major                    | number   | subject                     | score |</span><br><span class="line">+----------+-----------+--------------------------+----------+-----------------------------+-------+</span><br><span class="line">| 20180101 | 杜子腾    | 软件学院                 | 20180101 | 母猪的产后护理              |    78 |</span><br><span class="line">| 20180101 | 杜子腾    | 软件学院                 | 20180101 | 论萨达姆的战争准备          |    88 |</span><br><span class="line">| 20180102 | 范统      | 计算机科学与工程         | 20180102 | 论萨达姆的战争准备          |    98 |</span><br><span class="line">| 20180102 | 范统      | 计算机科学与工程         | 20180102 | 母猪的产后护理              |   100 |</span><br><span class="line">+----------+-----------+--------------------------+----------+-----------------------------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;字段有点多哦，我们少查询几个字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1, score AS s2 WHERE s1.number = s2.number;</span><br><span class="line">+----------+-----------+-----------------------------+-------+</span><br><span class="line">| number   | name      | subject                     | score |</span><br><span class="line">+----------+-----------+-----------------------------+-------+</span><br><span class="line">| 20180101 | 杜子腾    | 母猪的产后护理              |    78 |</span><br><span class="line">| 20180101 | 杜子腾    | 论萨达姆的战争准备          |    88 |</span><br><span class="line">| 20180102 | 范统      | 论萨达姆的战争准备          |    98 |</span><br><span class="line">| 20180102 | 范统      | 母猪的产后护理              |   100 |</span><br><span class="line">+----------+-----------+-----------------------------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;从上述查询结果中我们可以看到，各个同学对应的各科成绩就都被查出来了，可是有个问题，<code>史珍香</code>同学，也就是学号为<code>20180103</code>的同学因为某些原因没有参加考试，所以在<code>score</code>表中没有对应的成绩记录。那如果老师想查看所有同学的考试成绩，即使是缺考的同学也应该展示出来，但是到目前为止我们介绍的<code>连接查询</code>是无法完成这样的需求的。我们稍微思考一下这个需求，其本质是想：<span style="color:red">驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集</span>。为了解决这个问题，就有了<code>内连接</code>和<code>外连接</code>的概念：</p><ul><li><p>对于<code>内连接</code>的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上面提到的连接都是所谓的<code>内连接</code>。</p></li><li><p>对于<code>外连接</code>的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。</p><p>  &amp;emsp;&amp;emsp;在<code>MySQL</code>中，根据选取驱动表的不同，外连接仍然可以细分为2种：</p><ul><li><p>左外连接</p><p>  选取左侧的表为驱动表。</p></li><li><p>右外连接</p><p>  选取右侧的表为驱动表。</p></li></ul></li></ul><p>&amp;emsp;&amp;emsp;可是这样仍然存在问题，即使对于外连接来说，有时候我们也并不想把驱动表的全部记录都加入到最后的结果集。这就犯难了，有时候匹配失败要加入结果集，有时候又不要加入结果集，这咋办，有点儿愁啊。。。噫，把过滤条件分为两种不就解决了这个问题了么，所以放在不同地方的过滤条件是有不同语义的：</p><ul><li><p><code>WHERE</code>子句中的过滤条件</p><p>  &amp;emsp;&amp;emsp;<code>WHERE</code>子句中的过滤条件就是我们平时见的那种，不论是内连接还是外连接，凡是不符合<code>WHERE</code>子句中的过滤条件的记录都不会被加入最后的结果集。</p></li><li><p><code>ON</code>子句中的过滤条件</p><p>  &amp;emsp;&amp;emsp;对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配<code>ON</code>子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用<code>NULL</code>值填充。</p><p>  &amp;emsp;&amp;emsp;需要注意的是，这个<code>ON</code>子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的，所以如果把<code>ON</code>子句放到内连接中，<code>MySQL</code>会把它和<code>WHERE</code>子句一样对待，也就是说：<span style="color:red">内连接中的WHERE子句和ON子句是等价的</span>。</p></li></ul><p>&amp;emsp;&amp;emsp;一般情况下，我们都把只涉及单表的过滤条件放到<code>WHERE</code>子句中，把涉及两表的过滤条件都放到<code>ON</code>子句中，我们也一般把放到<code>ON</code>子句中的过滤条件也称之为<code>连接条件</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：左外连接和右外连接简称左连接和右连接，所以下面提到的左外连接和右外连接中的`外`字都用括号扩起来，以表示这个字儿可有可无。</span><br></pre></td></tr></table></figure><h4 id="左（外）连接的语法"><a href="#左（外）连接的语法" class="headerlink" title="左（外）连接的语法"></a>左（外）连接的语法</h4><p>&amp;emsp;&amp;emsp;左（外）连接的语法还是挺简单的，比如我们要把<code>t1</code>表和<code>t2</code>表进行左外连接查询可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;其中，中括号里的<code>OUTER</code>单词是可以省略的。对于<code>LEFT JOIN</code>类型的连接来说，我们把放在左边的表称之为外表或者驱动表，右边的表称之为内表或者被驱动表。所以上述例子中<code>t1</code>就是外表或者驱动表，<code>t2</code>就是内表或者被驱动表。需要注意的是，<span style="color:red">对于左（外）连接和右（外）连接来说，必须使用<code>ON</code>子句来指出连接条件</span>。了解了左（外）连接的基本语法之后，再次回到我们上面那个现实问题中来，看看怎样写查询语句才能把所有的学生的成绩信息都查询出来，即使是缺考的考生也应该被放到结果集中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1 LEFT JOIN score AS s2 ON s1.number = s2.number;</span><br><span class="line">+----------+-----------+-----------------------------+-------+</span><br><span class="line">| number   | name      | subject                     | score |</span><br><span class="line">+----------+-----------+-----------------------------+-------+</span><br><span class="line">| 20180101 | 杜子腾    | 母猪的产后护理              |    78 |</span><br><span class="line">| 20180101 | 杜子腾    | 论萨达姆的战争准备          |    88 |</span><br><span class="line">| 20180102 | 范统      | 论萨达姆的战争准备          |    98 |</span><br><span class="line">| 20180102 | 范统      | 母猪的产后护理              |   100 |</span><br><span class="line">| 20180103 | 史珍香    | NULL                        |  NULL |</span><br><span class="line">+----------+-----------+-----------------------------+-------+</span><br><span class="line">5 rows in set (0.04 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;从结果集中可以看出来，虽然<code>史珍香</code>并没有对应的成绩记录，但是由于采用的是连接类型为左（外）连接，所以仍然把她放到了结果集中，只不过在对应的成绩记录的各列使用<code>NULL</code>值填充而已。</p><h4 id="右（外）连接的语法"><a href="#右（外）连接的语法" class="headerlink" title="右（外）连接的语法"></a>右（外）连接的语法</h4><p>&amp;emsp;&amp;emsp;右（外）连接和左（外）连接的原理是一样一样的，语法也只是把<code>LEFT</code>换成<code>RIGHT</code>而已：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;只不过驱动表是右边的表，被驱动表是左边的表，具体就不介绍了。</p><h4 id="内连接的语法"><a href="#内连接的语法" class="headerlink" title="内连接的语法"></a>内连接的语法</h4><p>&amp;emsp;&amp;emsp;内连接和外连接的根本区别就是<span style="color:red">在驱动表中的记录不符合<code>ON</code>子句中的连接条件时不会把该记录加入到最后的结果集</span>，我们最开始介绍的那些连接查询的类型都是内连接。不过之前仅仅提到了一种最简单的内连接语法，就是直接把需要连接的多个表都放到<code>FROM</code>子句后边。其实针对内连接，MySQL提供了好多不同的语法，我们以<code>t1</code>和<code>t2</code>表为例看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 连接条件] [WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;也就是说在<code>MySQL</code>中，下面这几种内连接的写法都是等价的：</p><ul><li>SELECT * FROM t1 JOIN t2;</li><li>SELECT * FROM t1 INNER JOIN t2;</li><li>SELECT * FROM t1 CROSS JOIN t2;</li></ul><p>&amp;emsp;&amp;emsp;上面的这些写法和直接把需要连接的表名放到<code>FROM</code>语句之后，用逗号<code>,</code>分隔开的写法是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1, t2;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;现在我们虽然介绍了很多种<code>内连接</code>的书写方式，不过熟悉一种就好了，这里我们推荐<code>INNER JOIN</code>的形式书写内连接（因为<code>INNER JOIN</code>语义很明确嘛，可以和<code>LEFT JOIN </code>和<code>RIGHT JOIN</code>很轻松的区分开）。这里需要注意的是，<span style="color:red">由于在内连接中ON子句和WHERE子句是等价的，所以内连接中不要求强制写明ON子句</span>。</p><p>&amp;emsp;&amp;emsp;我们前面说过，连接的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。不论哪个表作为驱动表，两表连接产生的笛卡尔积肯定是一样的。而对于内连接来说，由于凡是不符合<code>ON</code>子句或<code>WHERE</code>子句中的条件的记录都会被过滤掉，其实也就相当于从两表连接的笛卡尔积中把不符合过滤条件的记录给踢出去，所以<span style="color:red">对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果</span>。但是对于外连接来说，由于驱动表中的记录即使在被驱动表中找不到符合<code>ON</code>子句连接条件的记录，所以此时驱动表和被驱动表的关系就很重要了，也就是说<span style="color:red">左外连接和右外连接的驱动表和被驱动表不能轻易互换</span>。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>&amp;emsp;&amp;emsp;上面说了很多，给大家的感觉不是很直观，我们直接把表<code>t1</code>和<code>t2</code>的三种连接方式写在一起，这样大家理解起来就很easy了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">|    1 | a    | NULL | NULL |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM t1 RIGHT JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">| NULL | NULL |    4 | d    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="连接的原理"><a href="#连接的原理" class="headerlink" title="连接的原理"></a>连接的原理</h2><p>&amp;emsp;&amp;emsp;上面的介绍都只是为了唤醒大家对<code>连接</code>、<code>内连接</code>、<code>外连接</code>这些概念的记忆，这些基本概念是为了真正进入本章主题做的铺垫。真正的重点是MySQL采用了什么样的算法来进行表与表之间的连接，了解了这个之后，大家才能明白为什么有的连接查询运行的快如闪电，有的却慢如蜗牛。</p><h3 id="嵌套循环连接（Nested-Loop-Join）"><a href="#嵌套循环连接（Nested-Loop-Join）" class="headerlink" title="嵌套循环连接（Nested-Loop Join）"></a>嵌套循环连接（Nested-Loop Join）</h3><p>&amp;emsp;&amp;emsp;我们前面说过，对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍，具体访问几遍取决于对驱动表执行单表查询后的结果集中的记录条数。对于内连接来说，选取哪个表为驱动表都没关系，而外连接的驱动表是固定的，也就是说左（外）连接的驱动表就是左边的那个表，右（外）连接的驱动表就是右边的那个表。我们上面已经大致介绍过<code>t1</code>表和<code>t2</code>表执行内连接查询的大致过程，我们温习一下：</p><ul><li>步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。</li><li>步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。</li></ul><p>&amp;emsp;&amp;emsp;通用的两表连接过程如下图所示：</p><p><img src="/../images/11-04.png"></p><p>&amp;emsp;&amp;emsp;如果有3个表进行连接的话，那么<code>步骤2</code>中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表，重复上面过程，也就是<code>步骤2</code>中得到的结果集中的每一条记录都需要到<code>t3</code>表中找一找有没有匹配的记录，用伪代码表示一下这个过程就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for each row in t1 &#123;   #此处表示遍历满足对t1单表查询结果集中的每一条记录</span><br><span class="line">    </span><br><span class="line">    for each row in t2 &#123;   #此处表示对于某条t1表的记录来说，遍历满足对t2单表查询结果集中的每一条记录</span><br><span class="line">    </span><br><span class="line">        for each row in t3 &#123;   #此处表示对于某条t1和t2表的记录组合来说，对t3表进行单表查询</span><br><span class="line">            if row satisfies join conditions, send to client</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个过程就像是一个嵌套的循环，所以这种<span style="color:red">驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数</span>的连接执行方式称之为<code>嵌套循环连接</code>（<code>Nested-Loop Join</code>），这是最简单，也是最笨拙的一种连接查询算法。</p><h3 id="使用索引加快连接速度"><a href="#使用索引加快连接速度" class="headerlink" title="使用索引加快连接速度"></a>使用索引加快连接速度</h3><p>&amp;emsp;&amp;emsp;我们知道在<code>嵌套循环连接</code>的<code>步骤2</code>中可能需要访问多次被驱动表，如果访问被驱动表的方式都是全表扫描的话，妈呀，那得要扫描好多次呀～～～ 但是别忘了，查询<code>t2</code>表其实就相当于一次单表扫描，我们可以利用索引来加快查询速度哦。回顾一下最开始介绍的<code>t1</code>表和<code>t2</code>表进行内连接的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 = t2.m2 AND t2.n2 &lt; &#x27;d&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们使用的其实是<code>嵌套循环连接</code>算法执行的连接查询，再把上面那个查询执行过程表拉下来给大家看一下：</p><p><img src="/../images/11-05.png"></p><p>&amp;emsp;&amp;emsp;查询驱动表<code>t1</code>后的结果集中有两条记录，<code>嵌套循环连接</code>算法需要对被驱动表查询2次：</p><ul><li><p>当<code>t1.m1 = 2</code>时，去查询一遍<code>t2</code>表，对<code>t2</code>表的查询语句相当于：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t2 WHERE t2.m2 = 2 AND t2.n2 &lt; &#x27;d&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>当<code>t1.m1 = 3</code>时，再去查询一遍<code>t2</code>表，此时对<code>t2</code>表的查询语句相当于：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t2 WHERE t2.m2 = 3 AND t2.n2 &lt; &#x27;d&#x27;;</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;可以看到，原来的<code>t1.m1 = t2.m2</code>这个涉及两个表的过滤条件在针对<code>t2</code>表做查询时关于<code>t1</code>表的条件就已经确定了，所以我们只需要单单优化对<code>t2</code>表的查询了，上述两个对<code>t2</code>表的查询语句中利用到的列是<code>m2</code>和<code>n2</code>列，我们可以：</p><ul><li><p>在<code>m2</code>列上建立索引，因为对<code>m2</code>列的条件是等值查找，比如<code>t2.m2 = 2</code>、<code>t2.m2 = 3</code>等，所以可能使用到<code>ref</code>的访问方法，假设使用<code>ref</code>的访问方法去执行对<code>t2</code>表的查询的话，需要回表之后再判断<code>t2.n2 &lt; d</code>这个条件是否成立。</p><p>  &amp;emsp;&amp;emsp;这里有一个比较特殊的情况，就是假设<code>m2</code>列是<code>t2</code>表的主键或者唯一二级索引列，那么使用<code>t2.m2 = 常数值</code>这样的条件从<code>t2</code>表中查找记录的过程的代价就是常数级别的。我们知道在单表中使用主键值或者唯一二级索引列的值进行等值查找的方式称之为<code>const</code>，而设计<code>MySQL</code>的大佬把在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为：<code>eq_ref</code>。</p></li><li><p>在<code>n2</code>列上建立索引，涉及到的条件是<code>t2.n2 &lt; &#39;d&#39;</code>，可能用到<code>range</code>的访问方法，假设使用<code>range</code>的访问方法对<code>t2</code>表的查询的话，需要回表之后再判断在<code>m2</code>列上的条件是否成立。</p></li></ul><p>&amp;emsp;&amp;emsp;假设<code>m2</code>和<code>n2</code>列上都存在索引的话，那么就需要从这两个里边儿挑一个代价更低的去执行对<code>t2</code>表的查询。当然，建立了索引不一定使用索引，只有在<code>二级索引 + 回表</code>的代价比全表扫描的代价更低时才会使用索引。</p><p>&amp;emsp;&amp;emsp;另外，有时候连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，而这些列都是某个索引的一部分，这种情况下即使不能使用<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>或者<code>range</code>这些访问方法执行对被驱动表的查询的话，也可以使用索引扫描，也就是<code>index</code>的访问方法来查询被驱动表。所以我们建议在真实工作中最好不要使用<code>*</code>作为查询列表，最好把真实用到的列作为查询列表。</p><h3 id="基于块的嵌套循环连接（Block-Nested-Loop-Join）"><a href="#基于块的嵌套循环连接（Block-Nested-Loop-Join）" class="headerlink" title="基于块的嵌套循环连接（Block Nested-Loop Join）"></a>基于块的嵌套循环连接（Block Nested-Loop Join）</h3><p>&amp;emsp;&amp;emsp;扫描一个表的过程其实是先把这个表从磁盘上加载到内存中，然后从内存中比较匹配条件是否满足。现实生活中的表可不像<code>t1</code>、<code>t2</code>这种只有3条记录，成千上万条记录都是少的，几百万、几千万甚至几亿条记录的表到处都是。内存里可能并不能完全存放的下表中所有的记录，所以在扫描表前面记录的时候后边的记录可能还在磁盘上，等扫描到后边记录的时候可能内存不足，所以需要把前面的记录从内存中释放掉。我们前面又说过，采用<code>嵌套循环连接</code>算法的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个<code>I/O</code>代价就非常大了，所以我们得想办法：<span style="color:red">尽量减少访问被驱动表的次数</span>。</p><p>&amp;emsp;&amp;emsp;当被驱动表中的数据非常多时，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。所以我们可不可以在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了。所以设计<code>MySQL</code>的大佬提出了一个<code>join buffer</code>的概念，<code>join buffer</code>就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个<code>join buffer</code>中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和<code>join buffer</code>中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的<code>I/O</code>代价。使用<code>join buffer</code>的过程如下图所示：</p><p><img src="/../images/11-06.png"></p><p>&amp;emsp;&amp;emsp;最好的情况是<code>join buffer</code>足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。设计<code>MySQL</code>的大佬把这种加入了<code>join buffer</code>的嵌套循环连接算法称之为<code>基于块的嵌套连接</code>（Block Nested-Loop Join）算法。</p><p>&amp;emsp;&amp;emsp;这个<code>join buffer</code>的大小是可以通过启动参数或者系统变量<code>join_buffer_size</code>进行配置，默认大小为<code>262144字节</code>（也就是<code>256KB</code>），最小可以设置为<code>128字节</code>。当然，对于优化被驱动表的查询来说，最好是为被驱动表加上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大<code>join_buffer_size</code>的值来对连接查询进行优化。</p><p>&amp;emsp;&amp;emsp;另外需要注意的是，驱动表的记录并不是所有列都会被放到<code>join buffer</code>中，只有查询列表中的列和过滤条件中的列才会被放到<code>join buffer</code>中，所以再次提醒我们，最好不要把<code>*</code>作为查询列表，只需要把我们关心的列放到查询列表就好了，这样还可以在<code>join buffer</code>中放置更多的记录呢。</p><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/13-%E5%85%B5%E9%A9%AC%E6%9C%AA%E5%8A%A8%EF%BC%8C%E7%B2%AE%E8%8D%89%E5%85%88%E8%A1%8C-InnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E7%9A%84/"/>
      <url>/2022/10/31/model-mysql/mysql/13-%E5%85%B5%E9%A9%AC%E6%9C%AA%E5%8A%A8%EF%BC%8C%E7%B2%AE%E8%8D%89%E5%85%88%E8%A1%8C-InnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="第13章-兵马未动，粮草先行-InnoDB统计数据是如何收集的"><a href="#第13章-兵马未动，粮草先行-InnoDB统计数据是如何收集的" class="headerlink" title="第13章 兵马未动，粮草先行-InnoDB统计数据是如何收集的"></a>第13章 兵马未动，粮草先行-InnoDB统计数据是如何收集的</h1><p>&amp;emsp;&amp;emsp;我们前面介绍查询成本的时候经常用到一些统计数据，比如通过<code>SHOW TABLE STATUS</code>可以看到关于表的统计数据，通过<code>SHOW INDEX</code>可以看到关于索引的统计数据，那么这些统计数据是怎么来的呢？它们是以什么方式收集的呢？本章将聚焦于<code>InnoDB</code>存储引擎的统计数据收集策略，看完本章大家就会明白为什么前面老说<code>InnoDB</code>的统计信息是不精确的估计值了（言下之意就是我们不打算介绍<code>MyISAM</code>存储引擎统计数据的收集和存储方式，有想了解的同学自己个儿看看文档）。</p><h2 id="两种不同的统计数据存储方式"><a href="#两种不同的统计数据存储方式" class="headerlink" title="两种不同的统计数据存储方式"></a>两种不同的统计数据存储方式</h2><p>&amp;emsp;&amp;emsp;<code>InnoDB</code>提供了两种存储统计数据的方式：</p><ul><li><p>永久性的统计数据</p><p>  &amp;emsp;&amp;emsp;这种统计数据存储在磁盘上，也就是服务器重启之后这些统计数据还在。</p></li><li><p>非永久性的统计数据</p><p>  &amp;emsp;&amp;emsp;这种统计数据存储在内存中，当服务器关闭时这些这些统计数据就都被清除掉了，等到服务器重启之后，在某些适当的场景下才会重新收集这些统计数据。</p></li></ul><p>&amp;emsp;&amp;emsp;设计<code>MySQL</code>的大佬们给我们提供了系统变量<code>innodb_stats_persistent</code>来控制到底采用哪种方式去存储统计数据。在<code>MySQL 5.6.6</code>之前，<code>innodb_stats_persistent</code>的值默认是<code>OFF</code>，也就是说<code>InnoDB</code>的统计数据默认是存储到内存的，之后的版本中<code>innodb_stats_persistent</code>的值默认是<code>ON</code>，也就是统计数据默认被存储到磁盘中。</p><p>&amp;emsp;&amp;emsp;不过<code>InnoDB</code>默认是<span style="color:red">以表为单位来收集和存储统计数据的</span>，也就是说我们可以把某些表的统计数据（以及该表的索引统计数据）存储在磁盘上，把另一些表的统计数据存储在内存中。怎么做到的呢？我们可以在创建和修改表的时候通过指定<code>STATS_PERSISTENT</code>属性来指明该表的统计数据存储方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_PERSISTENT = (1|0);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 Engine=InnoDB, STATS_PERSISTENT = (1|0);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;当<code>STATS_PERSISTENT=1</code>时，表明我们想把该表的统计数据永久的存储到磁盘上，当<code>STATS_PERSISTENT=0</code>时，表明我们想把该表的统计数据临时的存储到内存中。如果我们在创建表时未指定<code>STATS_PERSISTENT</code>属性，那默认采用系统变量<code>innodb_stats_persistent</code>的值作为该属性的值。</p><h2 id="基于磁盘的永久性统计数据"><a href="#基于磁盘的永久性统计数据" class="headerlink" title="基于磁盘的永久性统计数据"></a>基于磁盘的永久性统计数据</h2><p>&amp;emsp;&amp;emsp;当我们选择把某个表以及该表索引的统计数据存放到磁盘上时，实际上是把这些统计数据存储到了两个表里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES FROM mysql LIKE &#x27;innodb%&#x27;;</span><br><span class="line">+---------------------------+</span><br><span class="line">| Tables_in_mysql (innodb%) |</span><br><span class="line">+---------------------------+</span><br><span class="line">| innodb_index_stats        |</span><br><span class="line">| innodb_table_stats        |</span><br><span class="line">+---------------------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到，这两个表都位于<code>mysql</code>系统数据库下面，其中：</p><ul><li><code>innodb_table_stats</code>存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</li><li><code>innodb_index_stats</code>存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</li></ul><p>&amp;emsp;&amp;emsp;我们下面的任务就是看一下这两个表里边都有什么以及表里的数据是如何生成的。</p><h3 id="innodb-table-stats"><a href="#innodb-table-stats" class="headerlink" title="innodb_table_stats"></a>innodb_table_stats</h3><p>&amp;emsp;&amp;emsp;直接看一下这个<code>innodb_table_stats</code>表中的各个列都是干嘛的：</p><table><thead><tr><th align="center">字段名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>database_name</code></td><td align="left">数据库名</td></tr><tr><td align="center"><code>table_name</code></td><td align="left">表名</td></tr><tr><td align="center"><code>last_update</code></td><td align="left">本条记录最后更新时间</td></tr><tr><td align="center"><code>n_rows</code></td><td align="left">表中记录的条数</td></tr><tr><td align="center"><code>clustered_index_size</code></td><td align="left">表的聚簇索引占用的页面数量</td></tr><tr><td align="center"><code>sum_of_other_index_sizes</code></td><td align="left">表的其他索引占用的页面数量</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;注意这个表的主键是<code>(database_name,table_name)</code>，也就是<span style="color:red">innodb_table_stats表的每条记录代表着一个表的统计信息</span>。我们直接看一下这个表里的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.innodb_table_stats;</span><br><span class="line">+---------------+---------------+---------------------+--------+----------------------+--------------------------+</span><br><span class="line">| database_name | table_name    | last_update         | n_rows | clustered_index_size | sum_of_other_index_sizes |</span><br><span class="line">+---------------+---------------+---------------------+--------+----------------------+--------------------------+</span><br><span class="line">| mysql         | gtid_executed | 2018-07-10 23:51:36 |      0 |                    1 |                        0 |</span><br><span class="line">| sys           | sys_config    | 2018-07-10 23:51:38 |      5 |                    1 |                        0 |</span><br><span class="line">| xiaohaizi     | single_table  | 2018-12-10 17:03:13 |   9693 |                   97 |                      175 |</span><br><span class="line">+---------------+---------------+---------------------+--------+----------------------+--------------------------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到我们熟悉的<code>single_table</code>表的统计信息就对应着<code>mysql.innodb_table_stats</code>的第三条记录。几个重要统计信息项的值如下：</p><ul><li><code>n_rows</code>的值是<code>9693</code>，表明<code>single_table</code>表中大约有<code>9693</code>条记录，注意这个数据是估计值。</li><li><code>clustered_index_size</code>的值是<code>97</code>，表明<code>single_table</code>表的聚簇索引占用97个页面，这个值是也是一个估计值。</li><li><code>sum_of_other_index_sizes</code>的值是<code>175</code>，表明<code>single_table</code>表的其他索引一共占用175个页面，这个值是也是一个估计值。</li></ul><h4 id="n-rows统计项的收集"><a href="#n-rows统计项的收集" class="headerlink" title="n_rows统计项的收集"></a>n_rows统计项的收集</h4><p>&amp;emsp;&amp;emsp;为什么老强调<code>n_rows</code>这个统计项的值是估计值呢？现在就来揭晓答案。<code>InnoDB</code>统计一个表中有多少行记录的套路是这样的：</p><ul><li>按照一定算法（并不是纯粹随机的）选取几个叶子节点页面，计算每个页面中主键值记录数量，然后计算平均一个页面中主键值的记录数量乘以全部叶子节点的数量就算是该表的<code>n_rows</code>值。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：真实的计算过程比这个稍微复杂一些，不过大致上就是这样的啦～</span><br></pre></td></tr></table></figure>  &amp;emsp;&amp;emsp;可以看出来这个<code>n_rows</code>值精确与否取决于统计时采样的页面数量，设计<code>MySQL</code>的大佬很贴心的为我们准备了一个名为<code>innodb_stats_persistent_sample_pages</code>的系统变量来控制<span style="color:red">使用永久性的统计数据时，计算统计数据时采样的页面数量</span>。该值设置的越大，统计出的<code>n_rows</code>值越精确，但是统计耗时也就最久；该值设置的越小，统计出的<code>n_rows</code>值越不精确，但是统计耗时特别少。所以在实际使用是需要我们去权衡利弊，该系统变量的默认值是<code>20</code>。  &amp;emsp;&amp;emsp;我们前面说过，不过<code>InnoDB</code>默认是<span style="color:red">以表为单位来收集和存储统计数据的</span>，我们也可以单独设置某个表的采样页面的数量，设置方式就是在创建或修改表的时候通过指定<code>STATS_SAMPLE_PAGES</code>属性来指明该表的统计数据存储方式：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量;</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量;</span><br></pre></td></tr></table></figure>  &amp;emsp;&amp;emsp;如果我们在创建表的语句中并没有指定<code>STATS_SAMPLE_PAGES</code>属性的话，将默认使用系统变量<code>innodb_stats_persistent_sample_pages</code>的值作为该属性的值。</li></ul><h4 id="clustered-index-size和sum-of-other-index-sizes统计项的收集"><a href="#clustered-index-size和sum-of-other-index-sizes统计项的收集" class="headerlink" title="clustered_index_size和sum_of_other_index_sizes统计项的收集"></a>clustered_index_size和sum_of_other_index_sizes统计项的收集</h4><p>&amp;emsp;&amp;emsp;统计这两个数据需要大量用到我们之前介绍的<code>InnoDB</code>表空间的知识，<span style="color:red">如果大家压根儿没有看那一章，那下面的计算过程大家还是不要看了（看也看不懂）</span>；如果看过了，那大家就会发现<code>InnoDB</code>表空间的知识真是有用啊啊啊！！！</p><p>&amp;emsp;&amp;emsp;这两个统计项的收集过程如下：</p><ul><li><p>从数据字典里找到表的各个索引对应的根页面位置。</p><p>  &amp;emsp;&amp;emsp;系统表<code>SYS_INDEXES</code>里存储了各个索引对应的根页面信息。</p></li><li><p>从根页面的<code>Page Header</code>里找到叶子节点段和非叶子节点段对应的<code>Segment Header</code>。</p><p>  &amp;emsp;&amp;emsp;在每个索引的根页面的<code>Page Header</code>部分都有两个字段：</p><ul><li><code>PAGE_BTR_SEG_LEAF</code>：表示B+树叶子段的<code>Segment Header</code>信息。</li><li><code>PAGE_BTR_SEG_TOP</code>：表示B+树非叶子段的<code>Segment Header</code>信息。</li></ul></li><li><p>从叶子节点段和非叶子节点段的<code>Segment Header</code>中找到这两个段对应的<code>INODE Entry</code>结构。</p><p>  这个是<code>Segment Header</code>结构：</p><p>  <img src="/../images/13-01.png"></p></li><li><p>从对应的<code>INODE Entry</code>结构中可以找到该段对应所有零散的页面地址以及<code>FREE</code>、<code>NOT_FULL</code>、<code>FULL</code>链表的基节点。</p><p>  这个是<code>INODE Entry</code>结构：</p><p>  <img src="/../images/13-02.png"></p></li><li><p>直接统计零散的页面有多少个，然后从那三个链表的<code>List Length</code>字段中读出该段占用的区的大小，每个区占用<code>64</code>个页，所以就可以统计出整个段占用的页面。    </p><p>  这个是链表基节点的示意图：</p><p>  <img src="/../images/13-03.png"></p></li><li><p>分别计算聚簇索引的叶子结点段和非叶子节点段占用的页面数，它们的和就是<code>clustered_index_size</code>的值，按照同样的套路把其余索引占用的页面数都算出来，加起来之后就是<code>sum_of_other_index_sizes</code>的值。</p></li></ul><p>&amp;emsp;&amp;emsp;这里需要大家注意一个问题，我们说一个段的数据在非常多时（超过32个页面），会以<code>区</code>为单位来申请空间，这里头的问题是<span style="color:red">以区为单位申请空间中有一些页可能并没有使用</span>，但是在统计<code>clustered_index_size</code>和<code>sum_of_other_index_sizes</code>时都把它们算进去了，所以说聚簇索引和其他的索引占用的页面数可能比这两个值要小一些。</p><h3 id="innodb-index-stats"><a href="#innodb-index-stats" class="headerlink" title="innodb_index_stats"></a>innodb_index_stats</h3><p>&amp;emsp;&amp;emsp;直接看一下这个<code>innodb_index_stats</code>表中的各个列都是干嘛的：</p><table><thead><tr><th align="center">字段名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>database_name</code></td><td align="left">数据库名</td></tr><tr><td align="center"><code>table_name</code></td><td align="left">表名</td></tr><tr><td align="center"><code>index_name</code></td><td align="left">索引名</td></tr><tr><td align="center"><code>last_update</code></td><td align="left">本条记录最后更新时间</td></tr><tr><td align="center"><code>stat_name</code></td><td align="left">统计项的名称</td></tr><tr><td align="center"><code>stat_value</code></td><td align="left">对应的统计项的值</td></tr><tr><td align="center"><code>sample_size</code></td><td align="left">为生成统计数据而采样的页面数量</td></tr><tr><td align="center"><code>stat_description</code></td><td align="left">对应的统计项的描述</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;注意这个表的主键是<code>(database_name,table_name,index_name,stat_name)</code>，其中的<code>stat_name</code>是指统计项的名称，也就是说<span style="color:red">innodb_index_stats表的每条记录代表着一个索引的一个统计项</span>。可能这会大家有些懵逼这个统计项到底指什么，别着急，我们直接看一下关于<code>single_table</code>表的索引统计数据都有些什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.innodb_index_stats WHERE table_name = &#x27;single_table&#x27;;</span><br><span class="line">+---------------+--------------+--------------+---------------------+--------------+------------+-------------+-----------------------------------+</span><br><span class="line">| database_name | table_name   | index_name   | last_update         | stat_name    | stat_value | sample_size | stat_description                  |</span><br><span class="line">+---------------+--------------+--------------+---------------------+--------------+------------+-------------+-----------------------------------+</span><br><span class="line">| xiaohaizi     | single_table | PRIMARY      | 2018-12-14 14:24:46 | n_diff_pfx01 |       9693 |          20 | id                                |</span><br><span class="line">| xiaohaizi     | single_table | PRIMARY      | 2018-12-14 14:24:46 | n_leaf_pages |         91 |        NULL | Number of leaf pages in the index |</span><br><span class="line">| xiaohaizi     | single_table | PRIMARY      | 2018-12-14 14:24:46 | size         |         97 |        NULL | Number of pages in the index      |</span><br><span class="line">| xiaohaizi     | single_table | idx_key1     | 2018-12-14 14:24:46 | n_diff_pfx01 |        968 |          28 | key1                              |</span><br><span class="line">| xiaohaizi     | single_table | idx_key1     | 2018-12-14 14:24:46 | n_diff_pfx02 |      10000 |          28 | key1,id                           |</span><br><span class="line">| xiaohaizi     | single_table | idx_key1     | 2018-12-14 14:24:46 | n_leaf_pages |         28 |        NULL | Number of leaf pages in the index |</span><br><span class="line">| xiaohaizi     | single_table | idx_key1     | 2018-12-14 14:24:46 | size         |         29 |        NULL | Number of pages in the index      |</span><br><span class="line">| xiaohaizi     | single_table | idx_key2     | 2018-12-14 14:24:46 | n_diff_pfx01 |      10000 |          16 | key2                              |</span><br><span class="line">| xiaohaizi     | single_table | idx_key2     | 2018-12-14 14:24:46 | n_leaf_pages |         16 |        NULL | Number of leaf pages in the index |</span><br><span class="line">| xiaohaizi     | single_table | idx_key2     | 2018-12-14 14:24:46 | size         |         17 |        NULL | Number of pages in the index      |</span><br><span class="line">| xiaohaizi     | single_table | idx_key3     | 2018-12-14 14:24:46 | n_diff_pfx01 |        799 |          31 | key3                              |</span><br><span class="line">| xiaohaizi     | single_table | idx_key3     | 2018-12-14 14:24:46 | n_diff_pfx02 |      10000 |          31 | key3,id                           |</span><br><span class="line">| xiaohaizi     | single_table | idx_key3     | 2018-12-14 14:24:46 | n_leaf_pages |         31 |        NULL | Number of leaf pages in the index |</span><br><span class="line">| xiaohaizi     | single_table | idx_key3     | 2018-12-14 14:24:46 | size         |         32 |        NULL | Number of pages in the index      |</span><br><span class="line">| xiaohaizi     | single_table | idx_key_part | 2018-12-14 14:24:46 | n_diff_pfx01 |       9673 |          64 | key_part1                         |</span><br><span class="line">| xiaohaizi     | single_table | idx_key_part | 2018-12-14 14:24:46 | n_diff_pfx02 |       9999 |          64 | key_part1,key_part2               |</span><br><span class="line">| xiaohaizi     | single_table | idx_key_part | 2018-12-14 14:24:46 | n_diff_pfx03 |      10000 |          64 | key_part1,key_part2,key_part3     |</span><br><span class="line">| xiaohaizi     | single_table | idx_key_part | 2018-12-14 14:24:46 | n_diff_pfx04 |      10000 |          64 | key_part1,key_part2,key_part3,id  |</span><br><span class="line">| xiaohaizi     | single_table | idx_key_part | 2018-12-14 14:24:46 | n_leaf_pages |         64 |        NULL | Number of leaf pages in the index |</span><br><span class="line">| xiaohaizi     | single_table | idx_key_part | 2018-12-14 14:24:46 | size         |         97 |        NULL | Number of pages in the index      |</span><br><span class="line">+---------------+--------------+--------------+---------------------+--------------+------------+-------------+-----------------------------------+</span><br><span class="line">20 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个结果有点儿多，正确查看这个结果的方式是这样的：</p><ul><li><p>先查看<code>index_name</code>列，这个列说明该记录是哪个索引的统计信息，从结果中我们可以看出来，<code>PRIMARY</code>索引（也就是主键）占了3条记录，<code>idx_key_part</code>索引占了6条记录。</p></li><li><p>针对<code>index_name</code>列相同的记录，<code>stat_name</code>表示针对该索引的统计项名称，<code>stat_value</code>展示的是该索引在该统计项上的值，<code>stat_description</code>指的是来描述该统计项的含义的。我们来具体看一下一个索引都有哪些统计项：</p><ul><li><p><code>n_leaf_pages</code>：表示该索引的叶子节点占用多少页面。</p></li><li><p><code>size</code>：表示该索引共占用多少页面。</p></li><li><p><code>n_diff_pfx<b>NN</b></code>：表示对应的索引列不重复的值有多少。其中的<code>NN</code>长得有点儿怪呀，什么意思呢？</p><p>  &amp;emsp;&amp;emsp;其实<code>NN</code>可以被替换为<code>01</code>、<code>02</code>、<code>03</code>… 这样的数字。比如对于<code>idx_key_part</code>来说：</p><ul><li><code>n_diff_pfx01</code>表示的是统计<code>key_part1</code>这单单一个列不重复的值有多少。</li><li><code>n_diff_pfx02</code>表示的是统计<code>key_part1、key_part2</code>这两个列组合起来不重复的值有多少。</li><li><code>n_diff_pfx03</code>表示的是统计<code>key_part1、key_part2、key_part3</code>这三个列组合起来不重复的值有多少。</li><li><code>n_diff_pfx04</code>表示的是统计<code>key_part1、key_part2、key_part3、id</code>这四个列组合起来不重复的值有多少。</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：这里需要注意的是，对于普通的二级索引，并不能保证它的索引列值是唯一的，比如对于idx_key1来说，key1列就可能有很多值重复的记录。此时只有在索引列上加上主键值才可以区分两条索引列值都一样的二级索引记录。对于主键和唯一二级索引则没有这个问题，它们本身就可以保证索引列值的不重复，所以也不需要再统计一遍在索引列后加上主键值的不重复值有多少。比如上面的idx_key1有n_diff_pfx01、n_diff_pfx02两个统计项，而idx_key2却只有n_diff_pfx01一个统计项。</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在计算某些索引列中包含多少不重复值时，需要对一些叶子节点页面进行采样，<code>size</code>列就表明了采样的页面数量是多少。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：对于有多个列的联合索引来说，采样的页面数量是：innodb_stats_persistent_sample_pages × 索引列的个数。当需要采样的页面数量大于该索引的叶子节点数量的话，就直接采用全表扫描来统计索引列的不重复值数量了。所以大家可以在查询结果中看到不同索引对应的size列的值可能是不同的。</span><br></pre></td></tr></table></figure></li></ul><h3 id="定期更新统计数据"><a href="#定期更新统计数据" class="headerlink" title="定期更新统计数据"></a>定期更新统计数据</h3><p>&amp;emsp;&amp;emsp;随着我们不断的对表进行增删改操作，表中的数据也一直在变化，<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表里的统计数据是不是也应该跟着变一变了？当然要变了，不变的话<code>MySQL</code>查询优化器计算的成本可就差老鼻子远了。设计<code>MySQL</code>的大佬提供了如下两种更新统计数据的方式：</p><ul><li><p>开启<code>innodb_stats_auto_recalc</code>。</p><p>  &amp;emsp;&amp;emsp;系统变量<code>innodb_stats_auto_recalc</code>决定着服务器是否自动重新计算统计数据，它的默认值是<code>ON</code>，也就是该功能默认是开启的。每个表都维护了一个变量，该变量记录着对该表进行增删改的记录条数，如果发生变动的记录数量超过了表大小的<code>10%</code>，并且自动重新计算统计数据的功能是打开的，那么服务器会重新进行一次统计数据的计算，并且更新<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表。不过<span style="color:red">自动重新计算统计数据的过程是异步发生的</span>，也就是即使表中变动的记录数超过了<code>10%</code>，自动重新计算统计数据也不会立即发生，可能会延迟几秒才会进行计算。</p><p>  &amp;emsp;&amp;emsp;再一次强调，<code>InnoDB</code>默认是<span style="color:red">以表为单位来收集和存储统计数据的</span>，我们也可以单独为某个表设置是否自动重新计算统计数的属性，设置方式就是在创建或修改表的时候通过指定<code>STATS_AUTO_RECALC</code>属性来指明该表的统计数据存储方式：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_AUTO_RECALC = (1|0);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 Engine=InnoDB, STATS_AUTO_RECALC = (1|0);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;当<code>STATS_AUTO_RECALC=1</code>时，表明我们想让该表自动重新计算统计数据，当<code>STATS_PERSISTENT=0</code>时，表明不想让该表自动重新计算统计数据。如果我们在创建表时未指定<code>STATS_AUTO_RECALC</code>属性，那默认采用系统变量<code>innodb_stats_auto_recalc</code>的值作为该属性的值。</p></li><li><p>手动调用<code>ANALYZE TABLE</code>语句来更新统计信息</p><p>  &amp;emsp;&amp;emsp;如果<code>innodb_stats_auto_recalc</code>系统变量的值为<code>OFF</code>的话，我们也可以手动调用<code>ANALYZE TABLE</code>语句来重新计算统计数据，比如我们可以这样更新关于<code>single_table</code>表的统计数据：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ANALYZE TABLE single_table;</span><br><span class="line">+------------------------+---------+----------+----------+</span><br><span class="line">| Table                  | Op      | Msg_type | Msg_text |</span><br><span class="line">+------------------------+---------+----------+----------+</span><br><span class="line">| xiaohaizi.single_table | analyze | status   | OK       |</span><br><span class="line">+------------------------+---------+----------+----------+</span><br><span class="line">1 row in set (0.08 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;需要注意的是，<span style="color:red">ANALYZE TABLE语句会立即重新计算统计数据，也就是这个过程是同步的</span>，在表中索引多或者采样页面特别多时这个过程可能会特别慢，请不要没事儿就运行一下<code>ANALYZE TABLE</code>语句，最好在业务不是很繁忙的时候再运行。</p></li></ul><h3 id="手动更新innodb-table-stats和innodb-index-stats表"><a href="#手动更新innodb-table-stats和innodb-index-stats表" class="headerlink" title="手动更新innodb_table_stats和innodb_index_stats表"></a>手动更新<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表</h3><p>&amp;emsp;&amp;emsp;其实<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表就相当于一个普通的表一样，我们能对它们做增删改查操作。这也就意味着我们可以<span style="color:red">手动更新某个表或者索引的统计数据</span>。比如说我们想把<code>single_table</code>表关于行数的统计数据更改一下可以这么做：</p><ul><li><p>步骤一：更新<code>innodb_table_stats</code>表。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE innodb_table_stats </span><br><span class="line">    SET n_rows = 1</span><br><span class="line">    WHERE table_name = &#x27;single_table&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>步骤二：让<code>MySQL</code>查询优化器重新加载我们更改过的数据。</p><p>  &amp;emsp;&amp;emsp;更新完<code>innodb_table_stats</code>只是单纯的修改了一个表的数据，需要让<code>MySQL</code>查询优化器重新加载我们更改过的数据，运行下面的命令就可以了：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH TABLE single_table;</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;之后我们使用<code>SHOW TABLE STATUS</code>语句查看表的统计数据时就看到<code>Rows</code>行变为了<code>1</code>。</p><h2 id="基于内存的非永久性统计数据"><a href="#基于内存的非永久性统计数据" class="headerlink" title="基于内存的非永久性统计数据"></a>基于内存的非永久性统计数据</h2><p>&amp;emsp;&amp;emsp;当我们把系统变量<code>innodb_stats_persistent</code>的值设置为<code>OFF</code>时，之后创建的表的统计数据默认就都是非永久性的了，或者我们直接在创建表或修改表时设置<code>STATS_PERSISTENT</code>属性的值为<code>0</code>，那么该表的统计数据就是非永久性的了。</p><p>&amp;emsp;&amp;emsp;与永久性的统计数据不同，非永久性的统计数据采样的页面数量是由<code>innodb_stats_transient_sample_pages</code>控制的，这个系统变量的默认值是<code>8</code>。</p><p>&amp;emsp;&amp;emsp;另外，由于非永久性的统计数据经常更新，所以导致<code>MySQL</code>查询优化器计算查询成本的时候依赖的是经常变化的统计数据，也就会<span style="color:red">生成经常变化的执行计划</span>，这个可能让大家有些懵逼。不过最近的<code>MySQL</code>版本都不咋用这种基于内存的非永久性统计数据了，所以我们也就不深入介绍它了。</p><h2 id="innodb-stats-method的使用"><a href="#innodb-stats-method的使用" class="headerlink" title="innodb_stats_method的使用"></a>innodb_stats_method的使用</h2><p>&amp;emsp;&amp;emsp;我们知道<code>索引列不重复的值的数量</code>这个统计数据对于<code>MySQL</code>查询优化器十分重要，因为通过它可以计算出在索引列中平均一个值重复多少行，它的应用场景主要有两个：</p><ul><li><p>单表查询中单点区间太多，比方说这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE key IN (&#x27;xx1&#x27;, &#x27;xx2&#x27;, ..., &#x27;xxn&#x27;);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;当<code>IN</code>里的参数数量过多时，采用<code>index dive</code>的方式直接访问<code>B+</code>树索引去统计每个单点区间对应的记录的数量就太耗费性能了，所以直接依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量。</p></li><li><p>连接查询时，如果有涉及两个表的等值匹配连接条件，该连接条件对应的被驱动表中的列又拥有索引时，则可以使用<code>ref</code>访问方法来对被驱动表进行查询，比方说这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 JOIN t2 ON t1.column = t2.key WHERE ...;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;在真正执行对<code>t2</code>表的查询前，<code>t1.comumn</code>的值是不确定的，所以我们也不能通过<code>index dive</code>的方式直接访问<code>B+</code>树索引去统计每个单点区间对应的记录的数量，所以也只能依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量。</p></li></ul><p>&amp;emsp;&amp;emsp;在统计索引列不重复的值的数量时，有一个比较烦的问题就是索引列中出现<code>NULL</code>值怎么办，比方说某个索引列的内容是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------+</span><br><span class="line">| col  |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">| NULL |</span><br><span class="line">| NULL |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;此时计算这个<code>col</code>列中不重复的值的数量就有下面的分歧：</p><ul><li><p>有的人认为<code>NULL</code>值代表一个未确定的值，所以设计<code>MySQL</code>的大佬才认为任何和<code>NULL</code>值做比较的表达式的值都为<code>NULL</code>，就是这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 1 = NULL;</span><br><span class="line">+----------+</span><br><span class="line">| 1 = NULL |</span><br><span class="line">+----------+</span><br><span class="line">|     NULL |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT 1 != NULL;</span><br><span class="line">+-----------+</span><br><span class="line">| 1 != NULL |</span><br><span class="line">+-----------+</span><br><span class="line">|      NULL |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT NULL = NULL;</span><br><span class="line">+-------------+</span><br><span class="line">| NULL = NULL |</span><br><span class="line">+-------------+</span><br><span class="line">|        NULL |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT NULL != NULL;</span><br><span class="line">+--------------+</span><br><span class="line">| NULL != NULL |</span><br><span class="line">+--------------+</span><br><span class="line">|         NULL |</span><br><span class="line">+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;所以每一个<code>NULL</code>值都是独一无二的，也就是说统计索引列不重复的值的数量时，应该把<code>NULL</code>值当作一个独立的值，所以<code>col</code>列的不重复的值的数量就是：<code>4</code>（分别是1、2、NULL、NULL这四个值）。</p></li><li><p>有的人认为其实<code>NULL</code>值在业务上就是代表没有，所有的<code>NULL</code>值代表的意义是一样的，所以<code>col</code>列不重复的值的数量就是：<code>3</code>（分别是1、2、NULL这三个值）。</p></li><li><p>有的人认为这<code>NULL</code>完全没有意义嘛，所以在统计索引列不重复的值的数量时压根儿不能把它们算进来，所以<code>col</code>列不重复的值的数量就是：<code>2</code>（分别是1、2这两个值）。</p></li></ul><p>&amp;emsp;&amp;emsp;设计<code>MySQL</code>的大佬蛮贴心的，他们提供了一个名为<code>innodb_stats_method</code>的系统变量，相当于在计算某个索引列不重复值的数量时如何对待<code>NULL</code>值这个锅甩给了用户，这个系统变量有三个候选值：</p><ul><li><p><code>nulls_equal</code>：认为所有<code>NULL</code>值都是相等的。这个值也是<code>innodb_stats_method</code>的默认值。</p><p>  &amp;emsp;&amp;emsp;如果某个索引列中<code>NULL</code>值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别多，所以倾向于不使用索引进行访问。</p></li><li><p><code>nulls_unequal</code>：认为所有<code>NULL</code>值都是不相等的。</p><p>  &amp;emsp;&amp;emsp;如果某个索引列中<code>NULL</code>值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别少，所以倾向于使用索引进行访问。</p></li><li><p><code>nulls_ignored</code>：直接把<code>NULL</code>值忽略掉。</p></li></ul><p>&amp;emsp;&amp;emsp;反正这个锅是甩给用户了，当你选定了<code>innodb_stats_method</code>值之后，优化器即使选择了不是最优的执行计划，那也跟设计<code>MySQL</code>的大佬们没关系了～ 当然对于用户的我们来说，<span style="color:red">最好不在索引列中存放NULL值才是正解</span>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><code>InnoDB</code>以表为单位来收集统计数据，这些统计数据可以是基于磁盘的永久性统计数据，也可以是基于内存的非永久性统计数据。</p></li><li><p><code>innodb_stats_persistent</code>控制着使用永久性统计数据还是非永久性统计数据；<code>innodb_stats_persistent_sample_pages</code>控制着永久性统计数据的采样页面数量；<code>innodb_stats_transient_sample_pages</code>控制着非永久性统计数据的采样页面数量；<code>innodb_stats_auto_recalc</code>控制着是否自动重新计算统计数据。</p></li><li><p>我们可以针对某个具体的表，在创建和修改表时通过指定<code>STATS_PERSISTENT</code>、<code>STATS_AUTO_RECALC</code>、<code>STATS_SAMPLE_PAGES</code>的值来控制相关统计数据属性。</p></li><li><p><code>innodb_stats_method</code>决定着在统计某个索引列不重复值的数量时如何对待<code>NULL</code>值。</p></li></ul><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/17-%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-optimizer%20trace%E7%9A%84%E7%A5%9E%E5%99%A8%E5%8A%9F%E6%95%88/"/>
      <url>/2022/10/31/model-mysql/mysql/17-%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-optimizer%20trace%E7%9A%84%E7%A5%9E%E5%99%A8%E5%8A%9F%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h1 id="第17章-神兵利器-optimizer-trace表的神器功效"><a href="#第17章-神兵利器-optimizer-trace表的神器功效" class="headerlink" title="第17章 神兵利器-optimizer trace表的神器功效"></a>第17章 神兵利器-optimizer trace表的神器功效</h1><p>&amp;emsp;&amp;emsp;对于<code>MySQL 5.6</code>以及之前的版本来说，查询优化器就像是一个黑盒子一样，你只能通过<code>EXPLAIN</code>语句查看到最后优化器决定使用的执行计划，却无法知道它为什么做这个决策。这对于一部分喜欢刨根问底的小伙伴来说简直是灾难：“我就觉得使用其他的执行方案比<code>EXPLAIN</code>输出的这种方案强，凭什么优化器做的决定和我想的不一样呢？”</p><p>&amp;emsp;&amp;emsp;在<code>MySQL 5.6</code>以及之后的版本中，设计<code>MySQL</code>的大佬贴心的为这部分小伙伴提出了一个<code>optimizer trace</code>的功能，这个功能可以让我们方便的查看优化器生成执行计划的整个过程，这个功能的开启与关闭由系统变量<code>optimizer_trace</code>决定，我们看一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;optimizer_trace&#x27;;</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">| Variable_name   | Value                    |</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">| optimizer_trace | enabled=off,one_line=off |</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到<code>enabled</code>值为<code>off</code>，表明这个功能默认是关闭的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：one_line的值是控制输出格式的，如果为on那么所有输出都将在一行中展示，不适合人阅读，所以我们就保持其默认值为off吧。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;如果想打开这个功能，必须首先把<code>enabled</code>的值改为<code>on</code>，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET optimizer_trace=&quot;enabled=on&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;然后我们就可以输入我们想要查看优化过程的查询语句，当该查询语句执行完成后，就可以到<code>information_schema</code>数据库下的<code>OPTIMIZER_TRACE</code>表中查看完整的优化过程。这个<code>OPTIMIZER_TRACE</code>表有4个列，分别是：</p><ul><li><code>QUERY</code>：表示我们的查询语句。</li><li><code>TRACE</code>：表示优化过程的JSON格式文本。</li><li><code>MISSING_BYTES_BEYOND_MAX_MEM_SIZE</code>：由于优化过程可能会输出很多，如果超过某个限制时，多余的文本将不会被显示，这个字段展示了被忽略的文本字节数。</li><li><code>INSUFFICIENT_PRIVILEGES</code>：表示是否没有权限查看优化过程，默认值是0，只有某些特殊情况下才会是<code>1</code>，我们暂时不关心这个字段的值。</li></ul><p>&amp;emsp;&amp;emsp;完整的使用<code>optimizer trace</code>功能的步骤总结如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 1. 打开optimizer trace功能 (默认情况下它是关闭的):</span><br><span class="line">SET optimizer_trace=&quot;enabled=on&quot;;</span><br><span class="line"></span><br><span class="line"># 2. 这里输入你自己的查询语句</span><br><span class="line">SELECT ...; </span><br><span class="line"></span><br><span class="line"># 3. 从OPTIMIZER_TRACE表中查看上一个查询的优化过程</span><br><span class="line">SELECT * FROM information_schema.OPTIMIZER_TRACE;</span><br><span class="line"></span><br><span class="line"># 4. 可能你还要观察其他语句执行的优化过程，重复上面的第2、3步</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 5. 当你停止查看语句的优化过程时，把optimizer trace功能关闭</span><br><span class="line">SET optimizer_trace=&quot;enabled=off&quot;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;现在我们有一个搜索条件比较多的查询语句，它的执行计划如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE</span><br><span class="line">    -&gt;     key1 &gt; &#x27;z&#x27; AND</span><br><span class="line">    -&gt;     key2 &lt; 1000000 AND</span><br><span class="line">    -&gt;     key3 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND</span><br><span class="line">    -&gt;     common_field = &#x27;abc&#x27;;</span><br><span class="line">+----+-------------+-------+------------+-------+----------------------------+----------+---------+------+------+----------+------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys              | key      | key_len | ref  | rows | filtered | Extra                              |</span><br><span class="line">+----+-------------+-------+------------+-------+----------------------------+----------+---------+------+------+----------+------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | range | idx_key2,idx_key1,idx_key3 | idx_key2 | 5       | NULL |   12 |     0.42 | Using index condition; Using where |</span><br><span class="line">+----+-------------+-------+------------+-------+----------------------------+----------+---------+------+------+----------+------------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到该查询可能使用到的索引有3个，那么为什么优化器最终选择了<code>idx_key2</code>而不选择其他的索引或者直接全表扫描呢？这时候就可以通过<code>otpimzer trace</code>功能来查看优化器的具体工作过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM s1 WHERE </span><br><span class="line">    key1 &gt; &#x27;z&#x27; AND </span><br><span class="line">    key2 &lt; 1000000 AND </span><br><span class="line">    key3 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND </span><br><span class="line">    common_field = &#x27;abc&#x27;;</span><br><span class="line">    </span><br><span class="line">SELECT * FROM information_schema.OPTIMIZER_TRACE\G    </span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们直接看一下通过查询<code>OPTIMIZER_TRACE</code>表得到的输出（我使用<code>#</code>后跟随注释的形式为大家解释了优化过程中的一些比较重要的点，大家重点关注一下）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line"># 分析的查询语句是什么</span><br><span class="line">QUERY: SELECT * FROM s1 WHERE</span><br><span class="line">    key1 &gt; &#x27;z&#x27; AND</span><br><span class="line">    key2 &lt; 1000000 AND</span><br><span class="line">    key3 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND</span><br><span class="line">    common_field = &#x27;abc&#x27;</span><br><span class="line"></span><br><span class="line"># 优化的具体过程</span><br><span class="line">TRACE: &#123;</span><br><span class="line">  &quot;steps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_preparation&quot;: &#123;     # prepare阶段</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;IN_uses_bisection&quot;: true</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;expanded_query&quot;: &quot;/* select#1 */ select `s1`.`id` AS `id`,`s1`.`key1` AS `key1`,`s1`.`key2` AS `key2`,`s1`.`key3` AS `key3`,`s1`.`key_part1` AS `key_part1`,`s1`.`key_part2` AS `key_part2`,`s1`.`key_part3` AS `key_part3`,`s1`.`common_field` AS `common_field` from `s1` where ((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ] /* steps */</span><br><span class="line">      &#125; /* join_preparation */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_optimization&quot;: &#123;    # optimize阶段</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;condition_processing&quot;: &#123;   # 处理搜索条件</span><br><span class="line">              &quot;condition&quot;: &quot;WHERE&quot;,</span><br><span class="line">              # 原始搜索条件</span><br><span class="line">              &quot;original_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;,</span><br><span class="line">              &quot;steps&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  # 等值传递转换</span><br><span class="line">                  &quot;transformation&quot;: &quot;equality_propagation&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  # 常量传递转换    </span><br><span class="line">                  &quot;transformation&quot;: &quot;constant_propagation&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  # 去除没用的条件</span><br><span class="line">                  &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ] /* steps */</span><br><span class="line">            &#125; /* condition_processing */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 替换虚拟生成列</span><br><span class="line">            &quot;substitute_generated_columns&quot;: &#123;</span><br><span class="line">            &#125; /* substitute_generated_columns */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 表的依赖信息</span><br><span class="line">            &quot;table_dependencies&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;row_may_be_null&quot;: false,</span><br><span class="line">                &quot;map_bit&quot;: 0,</span><br><span class="line">                &quot;depends_on_map_bits&quot;: [</span><br><span class="line">                ] /* depends_on_map_bits */</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* table_dependencies */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;ref_optimizer_key_uses&quot;: [</span><br><span class="line">            ] /* ref_optimizer_key_uses */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">          </span><br><span class="line">            # 预估不同单表访问方法的访问成本</span><br><span class="line">            &quot;rows_estimation&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;range_analysis&quot;: &#123;</span><br><span class="line">                  &quot;table_scan&quot;: &#123;   # 全表扫描的行数以及成本</span><br><span class="line">                    &quot;rows&quot;: 9688,</span><br><span class="line">                    &quot;cost&quot;: 2036.7</span><br><span class="line">                  &#125; /* table_scan */,</span><br><span class="line">                  </span><br><span class="line">                  # 分析可能使用的索引</span><br><span class="line">                  &quot;potential_range_indexes&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;PRIMARY&quot;,   # 主键不可用</span><br><span class="line">                      &quot;usable&quot;: false,</span><br><span class="line">                      &quot;cause&quot;: &quot;not_applicable&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key2&quot;,  # idx_key2可能被使用</span><br><span class="line">                      &quot;usable&quot;: true,</span><br><span class="line">                      &quot;key_parts&quot;: [</span><br><span class="line">                        &quot;key2&quot;</span><br><span class="line">                      ] /* key_parts */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key1&quot;,  # idx_key1可能被使用</span><br><span class="line">                      &quot;usable&quot;: true,</span><br><span class="line">                      &quot;key_parts&quot;: [</span><br><span class="line">                        &quot;key1&quot;,</span><br><span class="line">                        &quot;id&quot;</span><br><span class="line">                      ] /* key_parts */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key3&quot;,  # idx_key3可能被使用</span><br><span class="line">                      &quot;usable&quot;: true,</span><br><span class="line">                      &quot;key_parts&quot;: [</span><br><span class="line">                        &quot;key3&quot;,</span><br><span class="line">                        &quot;id&quot;</span><br><span class="line">                      ] /* key_parts */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key_part&quot;,  # idx_keypart不可用</span><br><span class="line">                      &quot;usable&quot;: false,</span><br><span class="line">                      &quot;cause&quot;: &quot;not_applicable&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                  ] /* potential_range_indexes */,</span><br><span class="line">                  &quot;setup_range_conditions&quot;: [</span><br><span class="line">                  ] /* setup_range_conditions */,</span><br><span class="line">                  &quot;group_index_range&quot;: &#123;</span><br><span class="line">                    &quot;chosen&quot;: false,</span><br><span class="line">                    &quot;cause&quot;: &quot;not_group_by_or_distinct&quot;</span><br><span class="line">                  &#125; /* group_index_range */,</span><br><span class="line">                  </span><br><span class="line">                  # 分析各种可能使用的索引的成本</span><br><span class="line">                  &quot;analyzing_range_alternatives&quot;: &#123;</span><br><span class="line">                    &quot;range_scan_alternatives&quot;: [</span><br><span class="line">                      &#123;</span><br><span class="line">                        # 使用idx_key2的成本分析</span><br><span class="line">                        &quot;index&quot;: &quot;idx_key2&quot;,</span><br><span class="line">                        # 使用idx_key2的范围区间</span><br><span class="line">                        &quot;ranges&quot;: [</span><br><span class="line">                          &quot;NULL &lt; key2 &lt; 1000000&quot;</span><br><span class="line">                        ] /* ranges */,</span><br><span class="line">                        &quot;index_dives_for_eq_ranges&quot;: true,   # 是否使用index dive</span><br><span class="line">                        &quot;rowid_ordered&quot;: false,     # 使用该索引获取的记录是否按照主键排序</span><br><span class="line">                        &quot;using_mrr&quot;: false,     # 是否使用mrr</span><br><span class="line">                        &quot;index_only&quot;: false,    # 是否是索引覆盖访问</span><br><span class="line">                        &quot;rows&quot;: 12,     # 使用该索引获取的记录条数</span><br><span class="line">                        &quot;cost&quot;: 15.41,  # 使用该索引的成本</span><br><span class="line">                        &quot;chosen&quot;: true  # 是否选择该索引</span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                        # 使用idx_key1的成本分析</span><br><span class="line">                        &quot;index&quot;: &quot;idx_key1&quot;,</span><br><span class="line">                        # 使用idx_key1的范围区间</span><br><span class="line">                        &quot;ranges&quot;: [</span><br><span class="line">                          &quot;z &lt; key1&quot;</span><br><span class="line">                        ] /* ranges */,</span><br><span class="line">                        &quot;index_dives_for_eq_ranges&quot;: true,   # 同上</span><br><span class="line">                        &quot;rowid_ordered&quot;: false,   # 同上</span><br><span class="line">                        &quot;using_mrr&quot;: false,   # 同上</span><br><span class="line">                        &quot;index_only&quot;: false,   # 同上</span><br><span class="line">                        &quot;rows&quot;: 266,   # 同上</span><br><span class="line">                        &quot;cost&quot;: 320.21,   # 同上</span><br><span class="line">                        &quot;chosen&quot;: false,   # 同上</span><br><span class="line">                        &quot;cause&quot;: &quot;cost&quot;   # 因为成本太大所以不选择该索引</span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                        # 使用idx_key3的成本分析</span><br><span class="line">                        &quot;index&quot;: &quot;idx_key3&quot;,</span><br><span class="line">                        # 使用idx_key3的范围区间</span><br><span class="line">                        &quot;ranges&quot;: [</span><br><span class="line">                          &quot;a &lt;= key3 &lt;= a&quot;,</span><br><span class="line">                          &quot;b &lt;= key3 &lt;= b&quot;,</span><br><span class="line">                          &quot;c &lt;= key3 &lt;= c&quot;</span><br><span class="line">                        ] /* ranges */,</span><br><span class="line">                        &quot;index_dives_for_eq_ranges&quot;: true,   # 同上</span><br><span class="line">                        &quot;rowid_ordered&quot;: false,   # 同上</span><br><span class="line">                        &quot;using_mrr&quot;: false,   # 同上</span><br><span class="line">                        &quot;index_only&quot;: false,   # 同上</span><br><span class="line">                        &quot;rows&quot;: 21,   # 同上</span><br><span class="line">                        &quot;cost&quot;: 28.21,   # 同上</span><br><span class="line">                        &quot;chosen&quot;: false,   # 同上</span><br><span class="line">                        &quot;cause&quot;: &quot;cost&quot;   # 同上</span><br><span class="line">                      &#125;</span><br><span class="line">                    ] /* range_scan_alternatives */,</span><br><span class="line">                    </span><br><span class="line">                    # 分析使用索引合并的成本</span><br><span class="line">                    &quot;analyzing_roworder_intersect&quot;: &#123;</span><br><span class="line">                      &quot;usable&quot;: false,</span><br><span class="line">                      &quot;cause&quot;: &quot;too_few_roworder_scans&quot;</span><br><span class="line">                    &#125; /* analyzing_roworder_intersect */</span><br><span class="line">                  &#125; /* analyzing_range_alternatives */,</span><br><span class="line">                  </span><br><span class="line">                  # 对于上述单表查询s1最优的访问方法</span><br><span class="line">                  &quot;chosen_range_access_summary&quot;: &#123;</span><br><span class="line">                    &quot;range_access_plan&quot;: &#123;</span><br><span class="line">                      &quot;type&quot;: &quot;range_scan&quot;,</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key2&quot;,</span><br><span class="line">                      &quot;rows&quot;: 12,</span><br><span class="line">                      &quot;ranges&quot;: [</span><br><span class="line">                        &quot;NULL &lt; key2 &lt; 1000000&quot;</span><br><span class="line">                      ] /* ranges */</span><br><span class="line">                    &#125; /* range_access_plan */,</span><br><span class="line">                    &quot;rows_for_plan&quot;: 12,</span><br><span class="line">                    &quot;cost_for_plan&quot;: 15.41,</span><br><span class="line">                    &quot;chosen&quot;: true</span><br><span class="line">                  &#125; /* chosen_range_access_summary */</span><br><span class="line">                &#125; /* range_analysis */</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* rows_estimation */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            </span><br><span class="line">            # 分析各种可能的执行计划</span><br><span class="line">            #（对多表查询这可能有很多种不同的方案，单表查询的方案上面已经分析过了，直接选取idx_key2就好）</span><br><span class="line">            &quot;considered_execution_plans&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;plan_prefix&quot;: [</span><br><span class="line">                ] /* plan_prefix */,</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;best_access_path&quot;: &#123;</span><br><span class="line">                  &quot;considered_access_paths&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;rows_to_scan&quot;: 12,</span><br><span class="line">                      &quot;access_type&quot;: &quot;range&quot;,</span><br><span class="line">                      &quot;range_details&quot;: &#123;</span><br><span class="line">                        &quot;used_index&quot;: &quot;idx_key2&quot;</span><br><span class="line">                      &#125; /* range_details */,</span><br><span class="line">                      &quot;resulting_rows&quot;: 12,</span><br><span class="line">                      &quot;cost&quot;: 17.81,</span><br><span class="line">                      &quot;chosen&quot;: true</span><br><span class="line">                    &#125;</span><br><span class="line">                  ] /* considered_access_paths */</span><br><span class="line">                &#125; /* best_access_path */,</span><br><span class="line">                &quot;condition_filtering_pct&quot;: 100,</span><br><span class="line">                &quot;rows_for_plan&quot;: 12,</span><br><span class="line">                &quot;cost_for_plan&quot;: 17.81,</span><br><span class="line">                &quot;chosen&quot;: true</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* considered_execution_plans */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 尝试给查询添加一些其他的查询条件</span><br><span class="line">            &quot;attaching_conditions_to_tables&quot;: &#123;</span><br><span class="line">              &quot;original_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;,</span><br><span class="line">              &quot;attached_conditions_computation&quot;: [</span><br><span class="line">              ] /* attached_conditions_computation */,</span><br><span class="line">              &quot;attached_conditions_summary&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                  &quot;attached&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ] /* attached_conditions_summary */</span><br><span class="line">            &#125; /* attaching_conditions_to_tables */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 再稍稍的改进一下执行计划</span><br><span class="line">            &quot;refine_plan&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;pushed_index_condition&quot;: &quot;(`s1`.`key2` &lt; 1000000)&quot;,</span><br><span class="line">                &quot;table_condition_attached&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* refine_plan */</span><br><span class="line">          &#125;</span><br><span class="line">        ] /* steps */</span><br><span class="line">      &#125; /* join_optimization */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_execution&quot;: &#123;    # execute阶段</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">        ] /* steps */</span><br><span class="line">      &#125; /* join_execution */</span><br><span class="line">    &#125;</span><br><span class="line">  ] /* steps */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 因优化过程文本太多而丢弃的文本字节大小，值为0时表示并没有丢弃</span><br><span class="line">MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0</span><br><span class="line"></span><br><span class="line"># 权限字段</span><br><span class="line">INSUFFICIENT_PRIVILEGES: 0</span><br><span class="line"></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;大家看到这个输出的第一感觉就是这文本也太多了点儿吧，其实这只是优化器执行过程中的一小部分，设计<code>MySQL</code>的大佬可能会在之后的版本中添加更多的优化过程信息。不过杂乱之中其实还是蛮有规律的，优化过程大致分为了三个阶段：</p><ul><li><code>prepare</code>阶段</li><li><code>optimize</code>阶段</li><li><code>execute</code>阶段</li></ul><p>&amp;emsp;&amp;emsp;我们所说的基于成本的优化主要集中在<code>optimize</code>阶段，对于单表查询来说，我们主要关注<code>optimize</code>阶段的<code>&quot;rows_estimation&quot;</code>这个过程，这个过程深入分析了对单表查询的各种执行方案的成本；对于多表连接查询来说，我们更多需要关注<code>&quot;considered_execution_plans&quot;</code>这个过程，这个过程里会写明各种不同的连接方式所对应的成本。反正优化器最终会选择成本最低的那种方案来作为最终的执行计划，也就是我们使用<code>EXPLAIN</code>语句所展现出的那种方案。</p><p>&amp;emsp;&amp;emsp;如果有小伙伴对使用<code>EXPLAIN</code>语句展示出的对某个查询的执行计划很不理解，大家可以尝试使用<code>optimizer trace</code>功能来详细了解每一种执行方案对应的成本，相信这个功能能让大家更深入的了解<code>MySQL</code>查询优化器。</p><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/19-%E4%BB%8E%E7%8C%AB%E7%88%B7%E8%A2%AB%E6%9D%80%E8%AF%B4%E8%B5%B7-%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/10/31/model-mysql/mysql/19-%E4%BB%8E%E7%8C%AB%E7%88%B7%E8%A2%AB%E6%9D%80%E8%AF%B4%E8%B5%B7-%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="第19章-从猫爷被杀说起-事务简介"><a href="#第19章-从猫爷被杀说起-事务简介" class="headerlink" title="第19章 从猫爷被杀说起-事务简介"></a>第19章 从猫爷被杀说起-事务简介</h1><h2 id="事务的起源"><a href="#事务的起源" class="headerlink" title="事务的起源"></a>事务的起源</h2><p>&amp;emsp;&amp;emsp;对于大部分程序员来说，他们的任务就是把现实世界的业务场景映射到数据库世界。比如银行为了存储人们的账户信息会建立一个<code>account</code>表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE account (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT COMMENT &#x27;自增id&#x27;,</span><br><span class="line">    name VARCHAR(100) COMMENT &#x27;客户名称&#x27;,</span><br><span class="line">    balance INT COMMENT &#x27;余额&#x27;,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;狗哥和猫爷是一对好基友，他们都到银行开一个账户，他们在现实世界中拥有的资产就会体现在数据库世界的<code>account</code>表中。比如现在狗哥有<code>11</code>元，猫爷只有<code>2</code>元，那么现实中的这个情况映射到数据库的<code>account</code>表就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |      11 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+--------+---------+</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;在某个特定的时刻，狗哥猫爷这些家伙在银行所拥有的资产是一个特定的值，这些特定的值也可以被描述为账户在这个特定的时刻现实世界的一个状态。随着时间的流逝，狗哥和猫爷可能陆续进行向账户中存钱、取钱或者向别人转账等操作，这样他们账户中的余额就可能发生变动，<span style="color:red">每一个操作都相当于现实世界中账户的一次状态转换</span>。数据库世界作为现实世界的一个映射，自然也要进行相应的变动。不变不知道，一变吓一跳，现实世界中一些看似很简单的状态转换，映射到数据库世界却不是那么容易的。比方说有一次猫爷在赌场赌博输了钱，急忙打电话给狗哥要借10块钱，不然那些看场子的就会把自己剁了。现实世界中的狗哥走向了ATM机，输入了猫爷的账号以及10元的转账金额，然后按下确认，狗哥就拔卡走人了。对于数据库世界来说，相当于执行了下面这两条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">UPDATE account SET balance = balance + 10 WHERE id = 2;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;但是这里头有个问题，上述两条语句只执行了一条时忽然服务器断电了咋办？把狗哥的钱扣了，但是没给猫爷转过去，那猫爷还是逃脱不了被砍死的噩运～  即使对于单独的一条语句，我们前面介绍<code>Buffer Pool</code>时也说过，在对某个页面进行读写访问时，都会先把这个页面加载到<code>Buffer Pool</code>中，之后如果修改了某个页面，也不会立即把修改同步到磁盘，而只是把这个修改了的页面加到<code>Buffer Pool</code>的<code>flush链表</code>中，在之后的某个时间点才会刷新到磁盘。如果在将修改过的页刷新到磁盘之前系统崩溃了那岂不是猫爷还是要被砍死？或者在刷新磁盘的过程中（只刷新部分数据到磁盘上）系统奔溃了猫爷也会被砍死？</p><p>&amp;emsp;&amp;emsp;怎么才能保证让可怜的猫爷不被砍死呢？其实再仔细想想，我们只是想<span style="color:red">让某些数据库操作符合现实世界中状态转换的规则</span>而已，设计数据库的大佬们仔细盘算了盘算，现实世界中状态转换的规则有好几条，待我们慢慢道来。</p><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>&amp;emsp;&amp;emsp;现实世界中转账操作是一个不可分割的操作，也就是说要么压根儿就没转，要么转账成功，不能存在中间的状态，也就是转了一半的这种情况。设计数据库的大佬们把这种要么全做，要么全不做的规则称之为<code>原子性</code>。但是在现实世界中的一个不可分割的操作却可能对应着数据库世界若干条不同的操作，数据库中的一条操作也可能被分解成若干个步骤（比如先修改缓存页，之后再刷新到磁盘等），最要命的是在任何一个可能的时间都可能发生意想不到的错误（可能是数据库本身的错误，或者是操作系统错误，甚至是直接断电之类的）而使操作执行不下去，所以猫爷可能会被砍死。为了保证在数据库世界中某些操作的原子性，设计数据库的大佬需要费一些心机来保证如果在执行操作的过程中发生了错误，把已经做了的操作恢复成没执行之前的样子，这也是我们后边章节要仔细介绍的内容。</p><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>&amp;emsp;&amp;emsp;现实世界中的两次状态转换应该是互不影响的，比如说狗哥向猫爷同时进行的两次金额为5元的转账（假设可以在两个ATM机上同时操作）。那么最后狗哥的账户里肯定会少10元，猫爷的账户里肯定多了10元。但是到对应的数据库世界中，事情又变的复杂了一些。为了简化问题，我们粗略的假设狗哥向猫爷转账5元的过程是由下面几个步骤组成的：</p><ul><li>步骤一：读取狗哥账户的余额到变量A中，这一步骤简写为<code>read(A)</code>。</li><li>步骤二：将狗哥账户的余额减去转账金额，这一步骤简写为<code>A = A - 5</code>。</li><li>步骤三：将狗哥账户修改过的余额写到磁盘里，这一步骤简写为<code>write(A)</code>。</li><li>步骤四：读取猫爷账户的余额到变量B，这一步骤简写为<code>read(B)</code>。</li><li>步骤五：将猫爷账户的余额加上转账金额，这一步骤简写为<code>B = B + 5</code>。</li><li>步骤六：将猫爷账户修改过的余额写到磁盘里，这一步骤简写为<code>write(B)</code>。</li></ul><p>&amp;emsp;&amp;emsp;我们将狗哥向猫爷同时进行的两次转账操作分别称为<code>T1</code>和<code>T2</code>，在现实世界中<code>T1</code>和<code>T2</code>是应该没有关系的，可以先执行完<code>T1</code>，再执行<code>T2</code>，或者先执行完<code>T2</code>，再执行<code>T1</code>，对应的数据库操作就像这样：</p><p><img src="/../images/19-01.png"><br>&amp;emsp;&amp;emsp;但是很不幸，真实的数据库中<code>T1</code>和<code>T2</code>的操作可能交替执行，比如这样：</p><p><img src="/../images/19-02.png"></p><p>&amp;emsp;&amp;emsp;如果按照上图中的执行顺序来进行两次转账的话，最终狗哥的账户里还剩<code>6</code>元钱，相当于只扣了5元钱，但是猫爷的账户里却成了<code>12</code>元钱，相当于多了10元钱，这银行岂不是要亏死了？</p><p>&amp;emsp;&amp;emsp;所以对于现实世界中状态转换对应的某些数据库操作来说，不仅要保证这些操作以<code>原子性</code>的方式执行完成，而且要保证其它的状态转换不会影响到本次状态转换，这个规则被称之为<code>隔离性</code>。这时设计数据库的大佬们就需要采取一些措施来让访问相同数据（上例中的A账户和B账户）的不同状态转换（上例中的<code>T1</code>和<code>T2</code>）对应的数据库操作的执行顺序有一定规律，这也是我们后边章节要仔细介绍的内容。</p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>&amp;emsp;&amp;emsp;我们生活的这个世界存在着形形色色的约束，比如身份证号不能重复，性别只能是男或者女，高考的分数只能在0～750之间，人民币面值最大只能是100（现在是2019年），红绿灯只有3种颜色，房价不能为负的，学生要听老师话，等等有点儿扯远了～ 只有符合这些约束的数据才是有效的，比如有个小孩儿跟你说他高考考了1000分，你一听就知道他胡扯呢。数据库世界只是现实世界的一个映射，现实世界中存在的约束当然也要在数据库世界中有所体现。如果数据库中的数据全部符合现实世界中的约束（all defined rules），我们说这些数据就是一致的，或者说符合<code>一致性</code>的。</p><p>&amp;emsp;&amp;emsp;如何保证数据库中数据的一致性（就是符合所有现实世界的约束）呢？这其实靠两方面的努力：</p><ul><li><p>数据库本身能为我们保证一部分一致性需求（就是数据库自身可以保证一部分现实世界的约束永远有效）。</p><p>  &amp;emsp;&amp;emsp;我们知道<code>MySQL</code>数据库可以为表建立主键、唯一索引、外键、声明某个列为<code>NOT NULL</code>来拒绝<code>NULL</code>值的插入。比如说当我们对某个列建立唯一索引时，如果插入某条记录时该列的值重复了，那么<code>MySQL</code>就会报错并且拒绝插入。除了这些我们已经非常熟悉的保证一致性的功能，<code>MySQL</code>还支持<code>CHECK</code>语法来自定义约束，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE account (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT COMMENT &#x27;自增id&#x27;,</span><br><span class="line">    name VARCHAR(100) COMMENT &#x27;客户名称&#x27;,</span><br><span class="line">    balance INT COMMENT &#x27;余额&#x27;,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    CHECK (balance &gt;= 0) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;上述例子中的<code>CHECK</code>语句本意是想规定<code>balance</code>列不能存储小于0的数字，对应的现实世界的意思就是银行账户余额不能小于0。但是很遗憾，<span style="color:red">MySQL仅仅支持CHECK语法，但实际上并没有一点卵用</span>，也就是说即使我们使用上述带有<code>CHECK</code>子句的建表语句来创建<code>account</code>表，那么在后续插入或更新记录时，<code>MySQL</code>并不会去检查<code>CHECK</code>子句中的约束是否成立。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：其它的一些数据库，比如SQL Server或者Oracle支持的CHECK语法是有实实在在的作用的，每次进行插入或更新记录之前都会检查一下数据是否符合CHECK子句中指定的约束条件是否成立，如果不成立的话就会拒绝插入或更新。</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;虽然<code>CHECK</code>子句对一致性检查没什么卵用，但是我们还是可以通过定义触发器的方式来自定义一些约束条件以保证数据库中数据的一致性。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：触发器是MySQL基础内容中的知识，本书是一本MySQL进阶的书籍，如果你不了解触发器，那恐怕要找本基础内容的书籍来看看了。</span><br></pre></td></tr></table></figure></li><li><p>更多的一致性需求需要靠写业务代码的程序员自己保证。</p><p>  &amp;emsp;&amp;emsp;为建立现实世界和数据库世界的对应关系，理论上应该把现实世界中的所有约束都反应到数据库世界中，但是很不幸，在更改数据库数据时进行一致性检查是一个耗费性能的工作，比方说我们为<code>account</code>表建立了一个触发器，每当插入或者更新记录时都会校验一下<code>balance</code>列的值是不是大于0，这就会影响到插入或更新的速度。仅仅是校验一行记录符不符合一致性需求倒也不是什么大问题，有的一致性需求简直变态，比方说银行会建立一张代表账单的表，里边儿记录了每个账户的每笔交易，<span style="color:red">每一笔交易完成后，都需要保证整个系统的余额等于所有账户的收入减去所有账户的支出</span>。如果在数据库层面实现这个一致性需求的话，每次发生交易时，都需要将所有的收入加起来减去所有的支出，再将所有的账户余额加起来，看看两个值相不相等。这不是搞笑呢么，如果账单表里有几亿条记录，光是这个校验的过程可能就要跑好几个小时，也就是说你在煎饼摊买个煎饼，使用银行卡付款之后要等好几个小时才能提示付款成功，这样的性能代价是完全承受不起的。</p><p>  &amp;emsp;&amp;emsp;现实生活中复杂的一致性需求比比皆是，而由于性能问题把一致性需求交给数据库去解决这是不现实的，所以这个锅就甩给了业务端程序员。比方说我们的<code>account</code>表，我们也可以不建立触发器，只要编写业务的程序员在自己的业务代码里判断一下，当某个操作会将<code>balance</code>列的值更新为小于0的值时，就不执行该操作就好了嘛！</p></li></ul><p>&amp;emsp;&amp;emsp;我们前面介绍的<code>原子性</code>和<code>隔离性</code>都会对<code>一致性</code>产生影响，比如我们现实世界中转账操作完成后，有一个<code>一致性</code>需求就是参与转账的账户的总的余额是不变的。如果数据库不遵循<code>原子性</code>要求，也就是转了一半就不转了，也就是说给狗哥扣了钱而没给猫爷转过去，那最后就是不符合一致性需求的；类似的，如果数据库不遵循<code>隔离性</code>要求，就像我们前面介绍<code>隔离性</code>时举的例子中所说的，最终狗哥账户中扣的钱和猫爷账户中涨的钱可能就不一样了，也就是说不符合<code>一致性</code>需求了。所以说，<span style="color:red">数据库某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后保证符合所有既定的约束则是一种结果</span>。那满足<code>原子性</code>和<code>隔离性</code>的操作一定就满足<code>一致性</code>么？那倒也不一定，比如说狗哥要转账20元给猫爷，虽然在满足<code>原子性</code>和<code>隔离性</code>，但转账完成了之后狗哥的账户的余额就成负的了，这显然是不满足<code>一致性</code>的。那不满足<code>原子性</code>和<code>隔离性</code>的操作就一定不满足<code>一致性</code>么？这也不一定，只要最后的结果符合所有现实世界中的约束，那么就是符合<code>一致性</code>的。</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>&amp;emsp;&amp;emsp;当现实世界的一个状态转换完成后，这个转换的结果将永久的保留，这个规则被设计数据库的大佬们称为<code>持久性</code>。比方说狗哥向猫爷转账，当ATM机提示转账成功了，就意味着这次账户的状态转换完成了，狗哥就可以拔卡走人了。如果当狗哥走掉之后，银行又把这次转账操作给撤销掉，恢复到没转账之前的样子，那猫爷不就惨了，又得被砍死了，所以这个<code>持久性</code>是非常重要的。</p><p>&amp;emsp;&amp;emsp;当把现实世界的状态转换映射到数据库世界时，<code>持久性</code>意味着该转换对应的数据库操作所修改的数据都应该在磁盘上保留下来，不论之后发生了什么事故，本次转换造成的影响都不应该被丢失掉（要不然猫爷还是会被砍死）。</p><h2 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h2><p>&amp;emsp;&amp;emsp;为了方便大家记住我们上面介绍的现实世界状态转换过程中需要遵守的4个特性，我们把<code>原子性</code>（<code>Atomicity</code>）、<code>隔离性</code>（<code>Isolation</code>）、<code>一致性</code>（<code>Consistency</code>）和<code>持久性</code>（<code>Durability</code>）这四个词对应的英文单词首字母提取出来就是<code>A</code>、<code>I</code>、<code>C</code>、<code>D</code>，稍微变换一下顺序可以组成一个完整的英文单词：<code>ACID</code>。想必大家都是学过初高中英语的，<code>ACID</code>是英文<code>酸</code>的意思，以后我们提到<code>ACID</code>这个词儿，大家就应该想到原子性、一致性、隔离性、持久性这几个规则。另外，设计数据库的大佬为了方便起见，把需要保证<code>原子性</code>、<code>隔离性</code>、<code>一致性</code>和<code>持久性</code>的一个或多个数据库操作称之为一个<code>事务</code>（英文名是：<code>transaction</code>）。</p><p>&amp;emsp;&amp;emsp;我们现在知道<code>事务</code>是一个抽象的概念，它其实对应着一个或多个数据库操作，设计数据库的大佬根据这些操作所执行的不同阶段把<code>事务</code>大致上划分成了这么几个状态：</p><ul><li><p>活动的（active）</p><p>  &amp;emsp;&amp;emsp;事务对应的数据库操作正在执行过程中时，我们就说该事务处在<code>活动的</code>状态。</p></li><li><p>部分提交的（partially committed）</p><p>  &amp;emsp;&amp;emsp;当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在<code>部分提交的</code>状态。</p></li><li><p>失败的（failed）</p><p>  &amp;emsp;&amp;emsp;当事务处在<code>活动的</code>或者<code>部分提交的</code>状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在<code>失败的</code>状态。</p></li><li><p>中止的（aborted）</p><p>  &amp;emsp;&amp;emsp;如果事务执行了半截而变为<code>失败的</code>状态，比如我们前面介绍的狗哥向猫爷转账的事务，当狗哥账户的钱被扣除，但是猫爷账户的钱没有增加时遇到了错误，从而当前事务处在了<code>失败的</code>状态，那么就需要把已经修改的狗哥账户余额调整为未转账之前的金额，换句话说，就是要撤销失败事务对当前数据库造成的影响。书面一点的话，我们把这个撤销的过程称之为<code>回滚</code>。当<code>回滚</code>操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了<code>中止的</code>状态。</p></li><li><p>提交的（committed）</p><p>  &amp;emsp;&amp;emsp;当一个处在<code>部分提交的</code>状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了<code>提交的</code>状态。</p></li></ul><p>&amp;emsp;&amp;emsp;随着事务对应的数据库操作执行到不同阶段，事务的状态也在不断变化，一个基本的状态转换图如下所示：</p><p><img src="/../images/19-03.png"><br>&amp;emsp;&amp;emsp;从图中大家也可以看出了，<span style="color:red">只有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了</span>。对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，对于处于中止状态的事务，该事务对数据库所做的所有修改都会被回滚到没执行该事务之前的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：贴士处纯属扯犊子，与正文没什么关系，纯属吐槽。大家知道我们的计算机术语基本上全是从英文翻译成中文的，事务的英文是transaction，英文直译就是交易，买卖的意思，交易就是买的人付钱，卖的人交货，不能付了钱不交货，交了货不付钱把，所以交易本身就是一种不可分割的操作。不知道是哪位大神把transaction翻译成了事务（我想估计是他们也想不出什么更好的词儿，只能随便找一个了），事务这个词儿完全没有交易、买卖的意思，所以大家理解起来也会比较困难，外国人理解transaction可能更好理解一点吧～ </span><br></pre></td></tr></table></figure><h2 id="MySQL中事务的语法"><a href="#MySQL中事务的语法" class="headerlink" title="MySQL中事务的语法"></a>MySQL中事务的语法</h2><p>&amp;emsp;&amp;emsp;我们说<code>事务</code>的本质其实只是一系列数据库操作，只不过这些数据库操作符合<code>ACID</code>特性而已，那么<code>MySQL</code>中如何将某些操作放到一个事务里去执行的呢？我们下面就来重点介绍介绍。</p><h3 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h3><p>&amp;emsp;&amp;emsp;我们可以使用下面两种语句之一来开启一个事务：</p><ul><li><p><code>BEGIN [WORK];</code></p><p>  &amp;emsp;&amp;emsp;<code>BEGIN</code>语句代表开启一个事务，后边的单词<code>WORK</code>可有可无。开启事务后，就可以继续写若干条语句，这些语句都属于刚刚开启的这个事务。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; 加入事务的语句...</span><br></pre></td></tr></table></figure></li><li><p><code>START TRANSACTION;</code></p><p>  &amp;emsp;&amp;emsp;<code>START TRANSACTION</code>语句和<code>BEGIN</code>语句有着相同的功效，都标志着开启一个事务，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; 加入事务的语句...</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;不过比<code>BEGIN</code>语句牛逼一点儿的是，可以在<code>START TRANSACTION</code>语句后边跟随几个<code>修饰符</code>，就是它们几个：</p><ul><li><p><code>READ ONLY</code>：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：其实只读事务中只是不允许修改那些其他事务也能访问到的表中的数据，对于临时表来说（我们使用CREATE TMEPORARY TABLE创建的表），由于它们只能在当前会话中可见，所以只读事务其实也是可以对临时表进行增、删、改操作的。</span><br></pre></td></tr></table></figure></li><li><p><code>READ WRITE</code>：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p></li><li><p><code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读（先不用关心什么是个一致性读，后边的章节才会介绍）。</p></li></ul><p>  &amp;emsp;&amp;emsp;比如我们想开启一个只读事务的话，直接把<code>READ ONLY</code>这个修饰符加在<code>START TRANSACTION</code>语句后边就好，比如这样：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ ONLY;</span><br></pre></td></tr></table></figure><br>  &amp;emsp;&amp;emsp;如果我们想在<code>START TRANSACTION</code>后边跟随多个<code>修饰符</code>的话，可以使用逗号将<code>修饰符</code>分开，比如开启一个只读事务和一致性读，就可以这样写：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ ONLY, WITH CONSISTENT SNAPSHOT;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;或者开启一个读写事务和一致性读，就可以这样写：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ WRITE, WITH CONSISTENT SNAPSHOT</span><br></pre></td></tr></table></figure><br>  &amp;emsp;&amp;emsp;不过这里需要大家注意的一点是，<code>READ ONLY</code>和<code>READ WRITE</code>是用来设置所谓的事务<code>访问模式</code>的，就是以只读还是读写的方式来访问数据库中的数据，一个事务的访问模式不能同时既设置为<code>只读</code>的也设置为<code>读写</code>的，所以我们不能同时把<code>READ ONLY</code>和<code>READ WRITE</code>放到<code>START TRANSACTION</code>语句后边。另外，如果我们不显式指定事务的访问模式，那么该事务的访问模式就是<code>读写</code>模式。</p></li></ul><h3 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h3><p>&amp;emsp;&amp;emsp;开启事务之后就可以继续写需要放到该事务中的语句了，当最后一条语句写完了之后，我们就可以提交该事务了，提交的语句也很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT [WORK]</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;<code>COMMIT</code>语句就代表提交一个事务，后边的<code>WORK</code>可有可无。比如我们上面说狗哥给猫爷转10元钱其实对应<code>MySQL</code>中的两条语句，我们就可以把这两条语句放到一个事务中，完整的过程就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance + 10 WHERE id = 2;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; COMMIT;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="手动中止事务"><a href="#手动中止事务" class="headerlink" title="手动中止事务"></a>手动中止事务</h3><p>&amp;emsp;&amp;emsp;如果我们写了几条语句之后发现上面的某条语句写错了，我们可以手动的使用下面这个语句来将数据库恢复到事务执行之前的样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK [WORK]</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;<code>ROLLBACK</code>语句就代表中止并回滚一个事务，后边的<code>WORK</code>可有可无类似的。比如我们在写狗哥给猫爷转账10元钱对应的<code>MySQL</code>语句时，先给狗哥扣了10元，然后一时大意只给猫爷账户上增加了1元，此时就可以使用<code>ROLLBACK</code>语句进行回滚，完整的过程就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance + 1 WHERE id = 2;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这里需要强调一下，<code>ROLLBACK</code>语句是我们程序员手动的去回滚事务时才去使用的，如果事务在执行过程中遇到了某些错误而无法继续执行的话，事务自身会自动的回滚。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：我们这里所说的开启、提交、中止事务的语法只是针对使用黑框框时通过mysql客户端程序与服务器进行交互时控制事务的语法，如果大家使用的是别的客户端程序，比如JDBC之类的，那需要参考相应的文档来看看如何控制事务。</span><br></pre></td></tr></table></figure><h3 id="支持事务的存储引擎"><a href="#支持事务的存储引擎" class="headerlink" title="支持事务的存储引擎"></a>支持事务的存储引擎</h3><p>&amp;emsp;&amp;emsp;<code>MySQL</code>中并不是所有存储引擎都支持事务的功能，目前只有<code>InnoDB</code>和<code>NDB</code>存储引擎支持（NDB存储引擎不是我们的重点），如果某个事务中包含了修改使用不支持事务的存储引擎的表，那么对该使用不支持事务的存储引擎的表所做的修改将无法进行回滚。比方说我们有两个表，<code>tbl1</code>使用支持事务的存储引擎<code>InnoDB</code>，<code>tbl2</code>使用不支持事务的存储引擎<code>MyISAM</code>，它们的建表语句如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tbl1 (</span><br><span class="line">    i int</span><br><span class="line">) engine=InnoDB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tbl2 (</span><br><span class="line">    i int</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们看看先开启一个事务，写一条插入语句后再回滚该事务，<code>tbl1</code>和<code>tbl2</code>的表现有什么不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM tbl1;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO tbl1 VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM tbl1;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到，对于使用支持事务的存储引擎的<code>tbl1</code>表来说，我们在插入一条记录再回滚后，<code>tbl1</code>就恢复到没有插入记录时的状态了。再看看<code>tbl2</code>表的表现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM tbl2;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO tbl2 VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM tbl2;</span><br><span class="line">+------+</span><br><span class="line">| i    |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到，虽然我们使用了<code>ROLLBACK</code>语句来回滚事务，但是插入的那条记录还是留在了<code>tbl2</code>表中。</p><h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>&amp;emsp;&amp;emsp;<code>MySQL</code>中有一个系统变量<code>autocommit</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到它的默认值为<code>ON</code>，也就是说默认情况下，如果我们不显式的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的<code>自动提交</code>。假如我们在狗哥向猫爷转账10元时不以<code>START TRANSACTION</code>或者<code>BEGIN</code>语句显式的开启一个事务，那么下面这两条语句就相当于放到两个独立的事务中去执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">UPDATE account SET balance = balance + 10 WHERE id = 2;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;当然，如果我们想关闭这种<code>自动提交</code>的功能，可以使用下面两种方法之一：</p><ul><li><p>显式的的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务。</p><p>  &amp;emsp;&amp;emsp;这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</p></li><li><p>把系统变量<code>autocommit</code>的值设置为<code>OFF</code>，就像这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit = OFF;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这样的话，我们写入的多条语句就算是属于同一个事务了，直到我们显式的写出<code>COMMIT</code>语句来把这个事务提交掉，或者显式的写出<code>ROLLBACK</code>语句来把这个事务回滚掉。</p></li></ul><h3 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h3><p>&amp;emsp;&amp;emsp;当我们使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了一个事务，或者把系统变量<code>autocommit</code>的值设置为<code>OFF</code>时，事务就不会进行<code>自动提交</code>，但是如果我们输入了某些语句之后就会<code>悄悄的</code>提交掉，就像我们输入了<code>COMMIT</code>语句了一样，这种因为某些特殊的语句而导致事务提交的情况称为<code>隐式提交</code>，这些会导致事务隐式提交的语句包括：</p><ul><li><p>定义或修改数据库对象的数据定义语言（Data definition language，缩写为：<code>DDL</code>）。</p><p>  &amp;emsp;&amp;emsp;所谓的数据库对象，指的就是<code>数据库</code>、<code>表</code>、<code>视图</code>、<code>存储过程</code>等等这些东西。当我们使用<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>等语句去修改这些所谓的数据库对象时，就会隐式的提交前面语句所属于的事务，就像这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT ... # 事务中的一条语句</span><br><span class="line">UPDATE ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其它语句</span><br><span class="line"></span><br><span class="line">CREATE TABLE ... # 此语句会隐式的提交前面语句所属于的事务</span><br></pre></td></tr></table></figure></li><li><p>隐式使用或修改<code>mysql</code>数据库中的表</p><p>   &amp;emsp;&amp;emsp;当我们使用<code>ALTER USER</code>、<code>CREATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code>等语句时也会隐式的提交前面语句所属于的事务。</p></li><li><p>事务控制或关于锁定的语句</p><p>  &amp;emsp;&amp;emsp;当我们在一个事务还没提交或者回滚时就又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了另一个事务时，会隐式的提交上一个事务，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT ... # 事务中的一条语句</span><br><span class="line">UPDATE ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其它语句</span><br><span class="line"></span><br><span class="line">BEGIN; # 此语句会隐式的提交前面语句所属于的事务</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;或者当前的<code>autocommit</code>系统变量的值为<code>OFF</code>，我们手动把它调为<code>ON</code>时，也会隐式的提交前面语句所属的事务。</p><p>  &amp;emsp;&amp;emsp;或者使用<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会隐式的提交前面语句所属的事务。</p></li><li><p>加载数据的语句</p><p>  &amp;emsp;&amp;emsp;比如我们使用<code>LOAD DATA</code>语句来批量往数据库中导入数据时，也会隐式的提交前面语句所属的事务。</p></li><li><p>关于<code>MySQL</code>复制的一些语句</p><p>  &amp;emsp;&amp;emsp;使用<code>START SLAVE</code>、<code>STOP SLAVE</code>、<code>RESET SLAVE</code>、<code>CHANGE MASTER TO</code>等语句时也会隐式的提交前面语句所属的事务。</p></li><li><p>其它的一些语句</p><p>  &amp;emsp;&amp;emsp;使用<code>ANALYZE TABLE</code>、<code>CACHE INDEX</code>、<code>CHECK TABLE</code>、<code>FLUSH</code>、 <code>LOAD INDEX INTO CACHE</code>、<code>OPTIMIZE TABLE</code>、<code>REPAIR TABLE</code>、<code>RESET</code>等语句也会隐式的提交前面语句所属的事务。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：上面提到的一些语句，如果你都认识并且知道是干嘛用的那再好不过了，不认识也不要气馁，这里写出来只是为了内容的完整性，把可能会导致事务隐式提交的情况都列举一下，具体每个语句都是干嘛用的等我们遇到了再说。</span><br></pre></td></tr></table></figure><h3 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h3><p>&amp;emsp;&amp;emsp;如果你开启了一个事务，并且已经敲了很多语句，忽然发现上一条语句有点问题，你只好使用<code>ROLLBACK</code>语句来让数据库状态恢复到事务执行之前的样子，然后一切从头再来，总有一种一夜回到解放前的感觉。所以设计数据库的大佬们提出了一个<code>保存点</code>（英文：<code>savepoint</code>）的概念，就是在事务对应的数据库语句中打几个点，我们在调用<code>ROLLBACK</code>语句时可以指定会滚到哪个点，而不是回到最初的原点。定义保存点的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;当我们想回滚到某个保存点时，可以使用下面这个语句（下面语句中的单词<code>WORK</code>和<code>SAVEPOINT</code>是可有可无的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;不过如果<code>ROLLBACK</code>语句后边不跟随保存点名称的话，会直接回滚到事务执行之前的状态。</p><p>&amp;emsp;&amp;emsp;如果我们想删除某个保存点，可以使用这个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RELEASE SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;下面还是以狗哥向猫爷转账10元的例子展示一下<code>保存点</code>的用法，在执行完扣除狗哥账户的钱<code>10</code>元的语句之后打一个<code>保存点</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |      11 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SAVEPOINT s1;    # 一个保存点</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |       1 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance + 1 WHERE id = 2; # 更新错了</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK TO s1;  # 回滚到保存点s1处</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |       1 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/01-%E8%A3%85%E4%BD%9C%E8%87%AA%E5%B7%B1%E6%98%AF%E4%B8%AA%E5%B0%8F%E7%99%BD-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86MySQL/"/>
      <url>/2022/10/31/model-mysql/mysql/01-%E8%A3%85%E4%BD%9C%E8%87%AA%E5%B7%B1%E6%98%AF%E4%B8%AA%E5%B0%8F%E7%99%BD-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-装作自己是个小白-重新认识MySQL"><a href="#第1章-装作自己是个小白-重新认识MySQL" class="headerlink" title="第1章 装作自己是个小白-重新认识MySQL"></a>第1章 装作自己是个小白-重新认识MySQL</h1><h2 id="MySQL的客户端／服务器架构"><a href="#MySQL的客户端／服务器架构" class="headerlink" title="MySQL的客户端／服务器架构"></a>MySQL的客户端／服务器架构</h2><p>&amp;emsp;&amp;emsp;以我们平时使用的微信为例，它其实是由两部分组成的，一部分是客户端程序，一部分是服务器程序。客户端可能有很多种形式，比如手机APP，电脑软件或者是网页版微信，每个客户端都有一个唯一的用户名，就是你的微信号，另一方面，腾讯公司在他们的机房里运行着一个服务器软件，我们平时操作微信其实都是用客户端来和这个服务器来打交道。比如狗哥用微信给猫爷发了一条消息的过程其实是这样的：</p><ol><li>消息被客户端包装了一下，添加了发送者和接收者信息，然后从狗哥的微信客户端传送给微信服务器；</li><li>微信服务器从消息里获取到它的发送者和接收者，根据消息的接收者信息把这条消息送达到猫爷的微信客户端，猫爷的微信客户端里就显示出狗哥给他发了一条消息。</li></ol><p>&amp;emsp;&amp;emsp;<code>MySQL</code>的使用过程跟这个是一样的，它的服务器程序<span style="color:red">直接和我们存储的数据打交道</span>，然后可以有好多客户端程序连接到这个服务器程序，发送增删改查的请求，然后服务器就响应这些请求，从而操作它维护的数据。和微信一样，<code>MySQL</code>的每个客户端都需要提供用户名密码才能登录，登录之后才能给服务器发请求来操作某些数据。我们日常使用<code>MySQL</code>的情景一般是这样的：</p><ol><li>启动<code>MySQL</code>服务器程序。</li><li>启动<code>MySQL</code>客户端程序并连接到服务器程序。</li><li>在客户端程序中输入一些命令语句作为请求发送到服务器程序，服务器程序收到这些请求后，会根据请求的内容来操作具体的数据并向客户端返回操作结果。</li></ol><p>&amp;emsp;&amp;emsp;我们知道计算机很牛逼，在一台计算机上可以同时运行多个程序，比如微信、QQ、音乐播放器、文本编辑器等，每一个运行着的程序也被称为一个<code>进程</code>。我们的<code>MySQL</code>服务器程序和客户端程序本质上都算是计算机上的一个<code>进程</code>，这个代表着<code>MySQL</code>服务器程序的进程也被称为<code>MySQL数据库实例</code>，简称<code>数据库实例</code>。</p><p>&amp;emsp;&amp;emsp;每个进程都有一个唯一的编号，称为<code>进程ID</code>，英文名叫<code>PID</code>，这个编号是在我们启动程序的时候由操作系统随机分配的，操作系统会保证在某一时刻同一台机器上的进程号不重复。比如你打开了计算机中的QQ程序，那么操作系统会为它分配一个唯一的进程号，如果你把这个程序关掉了，那操作系统就会把这个进程号回收，之后可能会重新分配给别的进程。当我们下一次再启动 QQ程序的时候分配的就可能是另一个编号。每个进程都有一个名称，这个名称是编写程序的人自己定义的，比如我们启动的<code>MySQL</code>服务器进程的默认名称为<code>mysqld</code>， 而我们常用的<code>MySQL</code>客户端进程的默认名称为<code>mysql</code>。</p><h2 id="MySQL的安装"><a href="#MySQL的安装" class="headerlink" title="MySQL的安装"></a>MySQL的安装</h2><p>&amp;emsp;&amp;emsp;不论我们通过下载源代码自行编译安装的方式，还是直接使用官方提供的安装包进行安装之后，<code>MySQL</code>的服务器程序和客户端程序都会被安装到我们的机器上。不论使用上述两者的哪种安装方式，一定一定一定（重要的话说三遍）要记住你把<code>MySQL</code>安装到哪了，换句话说，一定要记住<code>MySQL</code>的安装目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：`MySQL`的大部分安装包都包含了服务器程序和客户端程序，不过在Linux下使用RPM包时会有单独的服务器RPM包和客户端RPM包，需要分别安装。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;另外，<code>MySQL</code>可以运行在各种各样的操作系统上，我们后边会讨论在类<code>UNIX</code>操作系统和<code>Windows</code>操作系统上使用的一些差别。为了方便大家理解，我在<code>macOS</code> 操作系统（苹果电脑使用的操作系统）和<code>Windows</code>操作系统上都安装了<code>MySQL</code>，它们的安装目录分别是：</p><ul><li><p><code>macOS</code>操作系统上的安装目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/mysql/</span><br></pre></td></tr></table></figure></li><li><p><code>Windows</code>操作系统上的安装目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\MySQL\MySQL Server 5.7</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;下面我会以这两个安装目录为例来进一步扯出更多的概念，不过一定要注意，<span style="color:red">这两个安装目录是我的运行不同操作系统的机器上的安装目录，一定要记着把下面示例中用到安装目录的地方替换为你自己机器上的安装目录</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：类UNIX操作系统非常多，比如FreeBSD、Linux、macOS、Solaris等都属于UNIX操作系统的范畴，我们这里使用macOS操作系统代表类UNIX操作系统来运行MySQL。</span><br></pre></td></tr></table></figure><h3 id="bin目录下的可执行文件"><a href="#bin目录下的可执行文件" class="headerlink" title="bin目录下的可执行文件"></a>bin目录下的可执行文件</h3><p>&amp;emsp;&amp;emsp;在<code>MySQL</code>的安装目录下有一个特别特别重要的<code>bin</code>目录，这个目录下存放着许多可执行文件，以<code>macOS</code>系统为例，这个<code>bin</code>目录的绝对路径就是（在我的机器上）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/mysql/bin</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们列出一些在<code>macOS</code>中这个<code>bin</code>目录下的一部分可执行文件来看一下（文件太多，全列出来会刷屏的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── mysql</span><br><span class="line">├── mysql.server -&gt; ../support-files/mysql.server</span><br><span class="line">├── mysqladmin</span><br><span class="line">├── mysqlbinlog</span><br><span class="line">├── mysqlcheck</span><br><span class="line">├── mysqld</span><br><span class="line">├── mysqld_multi</span><br><span class="line">├── mysqld_safe</span><br><span class="line">├── mysqldump</span><br><span class="line">├── mysqlimport</span><br><span class="line">├── mysqlpump</span><br><span class="line">... (省略其他文件)</span><br><span class="line">0 directories, 40 files</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;<code>Windows</code>中的可执行文件与<code>macOS</code>中的类似，不过都是以<code>.exe</code>为扩展名的。这些可执行文件都是与服务器程序和客户端程序相关的，后边我们会详细介绍一些比较重要的可执行文件，现在先看看执行这些文件的方式。</p><p>&amp;emsp;&amp;emsp;对于有可视化界面的操作系统来说，我们拿着鼠标点点点就可以执行某个可执行文件，不过现在我们更关注在命令行环境下如何执行这些可执行文件，命令行通俗的说就是那些黑框框，这里的指的是类<code>UNIX</code>系统中的<code>Shell</code>或者<code>Windows</code>系统中的<code>cmd.exe</code>，如果你现在还不知道怎么启动这些命令行工具，网上搜搜吧～ 下面我们以<code>macOS</code>系统为例来看看如何启动这些可执行文件（<code>Windows</code>中的操作是类似的，依葫芦画瓢就好了）</p><ul><li><p>使用可执行文件的相对／绝对路径<br>  &amp;emsp;&amp;emsp;假设我们现在所处的工作目录是<code>MySQL</code>的安装目录，也就是<code>/usr/local/mysql</code>，我们想启动<code>bin</code>目录下的<code>mysqld</code>这个可执行文件，可以使用相对路径来启动：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/mysqld</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;或者直接输入<code>mysqld</code>的绝对路径也可以：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/mysql/bin/mysqld</span><br></pre></td></tr></table></figure></li><li><p>将该<code>bin</code>目录的路径加入到环境变量<code>PATH</code>中<br>  &amp;emsp;&amp;emsp;如果我们觉得每次执行一个文件都要输入一串长长的路径名贼麻烦的话，可以把该<code>bin</code>目录所在的路径添加到环境变量<code>PATH</code>中。环境变量<code>PATH</code>是一系列路径的集合，各个路径之间使用冒号<code>:</code>隔离开，比方说我的机器上的环境变量<code>PATH</code>的值就是：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;我的系统中这个环境变量<code>PATH</code>的值表明：当我在输入一个命令时，系统便会在<code>/usr/local/bin</code>、<code>/usr/bin:</code>、<code>/bin:</code>、<code>/usr/sbin</code>、<code>/sbin</code>这些目录下依次寻找是否存在我们输入的那个命令，如果寻找成功，则执行该目录下对应的可执行文件。所以我们现在可以修改一下这个环境变量<code>PATH</code>，把<code>MySQL</code>安装目录下的<code>bin</code>目录的路径也加入到<code>PATH</code>中，在我的机器上修改后的环境变量<code>PATH</code>的值为：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/mysql/bin</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这样现在不论我们所处的工作目录是什么，我们都可以直接输入可执行文件的名字就可以启动它，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;方便多了～</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：关于什么是环境变量以及如何在当前系统中添加或修改系统变量不是我们介绍的范围，大家找本相关的书或者上网查一查～</span><br></pre></td></tr></table></figure><h2 id="启动MySQL服务器程序"><a href="#启动MySQL服务器程序" class="headerlink" title="启动MySQL服务器程序"></a>启动MySQL服务器程序</h2><h3 id="UNIX里启动服务器程序"><a href="#UNIX里启动服务器程序" class="headerlink" title="UNIX里启动服务器程序"></a>UNIX里启动服务器程序</h3><p>&amp;emsp;&amp;emsp;在类<code>UNIX</code>系统中用来启动<code>MySQL</code>服务器程序的可执行文件有很多，大多在<code>MySQL</code>安装目录的<code>bin</code>目录下，我们一起来看看。</p><h4 id="mysqld"><a href="#mysqld" class="headerlink" title="mysqld"></a>mysqld</h4><p>&amp;emsp;&amp;emsp;<code>mysqld</code>这个可执行文件就代表着<code>MySQL</code>服务器程序，运行这个可执行文件就可以直接启动一个服务器进程。但这个命令不常用，我们继续往下看更牛逼的启动命令。</p><h4 id="mysqld-safe"><a href="#mysqld-safe" class="headerlink" title="mysqld_safe"></a>mysqld_safe</h4><p>&amp;emsp;&amp;emsp;<code>mysqld_safe</code>是一个启动脚本，它会间接的调用<code>mysqld</code>，而且还顺便启动了另外一个监控进程，这个监控进程在服务器进程挂了的时候，可以帮助重启它。另外，使用<code>mysqld_safe</code>启动服务器程序时，它会将服务器程序的出错信息和其他诊断信息重定向到某个文件中，产生出错日志，这样可以方便我们找出发生错误的原因。</p><h4 id="mysql-server"><a href="#mysql-server" class="headerlink" title="mysql.server"></a>mysql.server</h4><p>&amp;emsp;&amp;emsp;<code>mysql.server</code>也是一个启动脚本，它会间接的调用<code>mysqld_safe</code>，在调用<code>mysql.server</code>时在后边指定<code>start</code>参数就可以启动服务器程序了，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql.server start</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;需要注意的是，<span style="color:red">这个 <em><strong>mysql.server</strong></em> 文件其实是一个链接文件，它的实际文件是 <em><strong>..&#x2F;support-files&#x2F;mysql.server</strong></em></span>。我使用的<code>macOS</code>操作系统会在<code>bin</code>目录下自动创建一个指向实际文件的链接文件，如果你的操作系统没有帮你自动创建这个链接文件，那就自己创建一个呗～ 别告诉我你不会创建链接文件，上网搜搜呗～</p><p>&amp;emsp;&amp;emsp;另外，我们还可以使用<code>mysql.server</code>命令来关闭正在运行的服务器程序，只要把<code>start</code>参数换成<code>stop</code>就好了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql.server stop</span><br></pre></td></tr></table></figure><h4 id="mysqld-multi"><a href="#mysqld-multi" class="headerlink" title="mysqld_multi"></a>mysqld_multi</h4><p>&amp;emsp;&amp;emsp;其实我们一台计算机上也可以运行多个服务器实例，也就是运行多个<code>MySQL</code>服务器进程。<code>mysql_multi</code>可执行文件可以对每一个服务器进程的启动或停止进行监控。这个命令的使用比较复杂，本书主要是为了讲清楚<code>MySQL</code>服务器和客户端运行的过程，不会对启动多个服务器程序进行过多介绍。</p><h3 id="Windows里启动服务器程序"><a href="#Windows里启动服务器程序" class="headerlink" title="Windows里启动服务器程序"></a>Windows里启动服务器程序</h3><p>&amp;emsp;&amp;emsp;<code>Windows</code>里没有像类<code>UNIX</code>系统中那么多的启动脚本，但是也提供了手动启动和以服务的形式启动这两种方式，下面我们详细看。</p><h4 id="mysqld-1"><a href="#mysqld-1" class="headerlink" title="mysqld"></a>mysqld</h4><p>&amp;emsp;&amp;emsp;同样的，在<code>MySQL</code>安装目录下的<code>bin</code>目录下有一个<code>mysqld</code>可执行文件，在命令行里输入<code>mysqld</code>，或者直接双击运行它就算启动了<code>MySQL</code>服务器程序了。</p><h4 id="以服务的方式运行服务器程序"><a href="#以服务的方式运行服务器程序" class="headerlink" title="以服务的方式运行服务器程序"></a>以服务的方式运行服务器程序</h4><p>&amp;emsp;&amp;emsp;首先看看什么是个<code>Windows</code> 服务？如果无论是谁正在使用这台计算机，我们都需要长时间的运行某个程序，而且需要在计算机启动的时候便启动它，一般我们都会把它注册为一个<code>Windows 服务</code>，操作系统会帮我们管理它。把某个程序注册为<code>Windows</code>服务的方式挺简单，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;完整的可执行文件路径&quot; --install [-manual] [服务名]</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;其中的<code>-manual</code>可以省略，加上它的话，表示在<code>Windows</code>系统启动的时候<span style="color:red">不</span>自动启动该服务，否则会自动启动。<code>服务名</code>也可以省略，默认的服务名就是<code>MySQL</code>。比如我的<code>Windows</code>计算机上<code>mysqld</code>的完整路径是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;所以如果我们想把它注册为服务的话可以在命令行里这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld&quot; --install</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;在把<code>mysqld</code>注册为<code>Windows</code>服务之后，我们就可以通过下面这个命令来启动<code>MySQL</code>服务器程序了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start MySQL</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;当然，如果你喜欢图形界面的话，你可以通过<code>Windows</code>的服务管理器通过用鼠标点点点的方式来启动和停止服务（作为一个程序猿，还是用黑框框吧～）。</p><p>&amp;emsp;&amp;emsp;关闭这个服务也非常简单，只要把上面的<code>start</code>换成<code>stop</code>就行了，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop MySQL</span><br></pre></td></tr></table></figure><h2 id="启动MySQL客户端程序"><a href="#启动MySQL客户端程序" class="headerlink" title="启动MySQL客户端程序"></a>启动MySQL客户端程序</h2><p>&amp;emsp;&amp;emsp;在我们成功启动<code>MySQL</code>服务器程序后，就可以接着启动客户端程序来连接到这个服务器喽，<code>bin</code>目录下有许多客户端程序，比方说<code>mysqladmin</code>、<code>mysqldump</code>、<code>mysqlcheck</code>等等（好多呢，就不一一列举了）。这里我们重点要关注的是可执行文件<code>mysql</code>，通过这个可执行文件可以让我们和服务器程序进程交互，也就是发送请求，接收服务器的处理结果。启动这个可执行文件时一般需要一些参数，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h主机名  -u用户名 -p密码</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;各个参数的意义如下：</p><table><thead><tr><th align="center"><div style="width:45px">参数名</div></th><th align="left">含义</th></tr></thead><tbody><tr><td align="center"><code>-h</code></td><td align="left"><div style="width:450px">表示服务器进程所在计算机的域名或者IP地址，如果服务器进程就运行在本机的话，可以省略这个参数，或者填<code>localhost</code>或者<code>127.0.0.1</code>。也可以写作 <code>--host=主机名</code>的形式。</div></td></tr><tr><td align="center"><code>-u</code></td><td align="left">表示用户名。也可以写作 <code>--user=用户名</code>的形式。</td></tr><tr><td align="center"><code>-p</code></td><td align="left">表示密码。也可以写作 <code>--password=密码</code>的形式。</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：像 h、u、p 这样名称只有一个英文字母的参数称为短形式的参数，使用时前面需要加单短划线，像 host、user、password 这样大于一个英文字母的参数称为长形式的参数，使用时前面需要加双短划线。后边会详细讨论这些参数的使用方式的，稍安勿躁～</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;比如我这样执行下面这个可执行文件（用户名密码按你的实际情况填写），就可以启动<code>MySQL</code>客户端，并且连接到服务器了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -hlocalhost -uroot -p123456</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们看一下连接成功后的界面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.7.21 Homebrew</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;最后一行的<code>mysql&gt;</code>是一个客户端的提示符，之后客户端发送给服务器的命令都需要写在这个提示符后边。</p><p>&amp;emsp;&amp;emsp;如果我们想断开客户端与服务器的连接并且关闭客户端的话，可以在<code>mysql&gt;</code>提示符后输入下面任意一个命令：</p><pre><code>1. `quit`2. `exit`3. `\q`</code></pre><p>&amp;emsp;&amp;emsp;比如我们输入<code>quit</code>试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; quit</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;输出了<code>Bye</code>说明客户端程序已经关掉了。值得注意的是，这是关闭客户端程序的方式，不是关闭服务器程序的方式，怎么关闭服务器程序上一节里介绍过了。</p><p>&amp;emsp;&amp;emsp;如果你愿意，你可以多打开几个黑框框，每个黑框框都使用<code>mysql -hlocahhost -uroot -p123456</code>来运行多个客户端程序，每个客户端程序都是互不影响的。如果你有多个电脑，也可以试试把它们用局域网连起来，在一个电脑上启动<code>MySQL</code>服务器程序，在另一个电脑上执行<code>mysql</code>命令时使用<code>IP</code>地址作为主机名来连接到服务器。</p><h3 id="连接注意事项"><a href="#连接注意事项" class="headerlink" title="连接注意事项"></a>连接注意事项</h3><ul><li><p>最好不要在一行命令中输入密码。</p><p>  &amp;emsp;&amp;emsp;我们直接在黑框框里输入密码很可能被别人看到，这和你当着别人的面输入银行卡密码没什么区别，所以我们在执行<code>mysql</code>连接服务器的时候可以不显式的写出密码，就像这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -hlocahhost -uroot -p</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;点击回车之后才会提示你输入密码：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter password:</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;不过这回你输入的密码不会被显示出来，心怀不轨的人也就看不到了，输入完成点击回车就成功连接到了服务器。</p></li><li><p>如果你非要在一行命令中显式的把密码输出来，那<code>-p</code>和密码值之间不能有空白字符（其他参数名之间可以有空白字符），就像这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h localhost -u root -p123456</span><br></pre></td></tr></table></figure><p>  如果加上了空白字符就是<span style="color:red">错误的</span>，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h localhost -u root -p 123456</span><br></pre></td></tr></table></figure></li><li><p><code>mysql</code>的各个参数的摆放顺序没有硬性规定，也就是说你也可以这么写：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -p  -u root -h localhost</span><br></pre></td></tr></table></figure></li><li><p>如果你的服务器和客户端安装在同一台机器上，<code>-h</code>参数可以省略，就像这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p  </span><br></pre></td></tr></table></figure></li><li><p>如果你使用的是类<code>UNIX</code>系统，并且省略<code>-u</code>参数后，会把你登陆操作系统的用户名当作<code>MySQL</code>的用户名去处理。</p><p>  &amp;emsp;&amp;emsp;比方说我用登录操作系统的用户名是<code>xiaohaizi</code>，那么在我的机器上下面这两条命令是等价的：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -u xiaohaizi -p</span><br><span class="line">mysql -p</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;对于<code>Windows</code>系统来说，默认的用户名是<code>ODBC</code>，你可以通过设置环境变量<code>USER</code>来添加一个默认用户名。</p></li></ul><h2 id="客户端与服务器连接的过程"><a href="#客户端与服务器连接的过程" class="headerlink" title="客户端与服务器连接的过程"></a>客户端与服务器连接的过程</h2><p>&amp;emsp;&amp;emsp;我们现在已经知道如何启动<code>MySQL</code>的服务器程序，以及如何启动客户端程序来连接到这个服务器程序。运行着的服务器程序和客户端程序本质上都是计算机上的一个进程，所以客户端进程向服务器进程发送请求并得到回复的过程<span style="color:red">本质上是一个进程间通信的过程</span>！<code>MySQL</code>支持下面三种客户端进程和服务器进程的通信方式。</p><h3 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h3><p>&amp;emsp;&amp;emsp;真实环境中，数据库服务器进程和客户端进程可能运行在不同的主机中，它们之间必须通过网络来进行通讯。<code>MySQL</code>采用<code>TCP</code>作为服务器和客户端之间的网络通信协议。在网络环境下，每台计算机都有一个唯一的<code>IP地址</code>，如果某个进程有需要采用<code>TCP</code>协议进行网络通信方面的需求，可以向操作系统申请一个<code>端口号</code>，这是一个整数值，它的取值范围是<code>0~65535</code>。这样在网络中的其他进程就可以通过<code>IP地址 + 端口号</code>的方式来与这个进程连接，这样进程之间就可以通过网络进行通信了。</p><p>&amp;emsp;&amp;emsp;<code>MySQL</code>服务器启动的时候会默认申请<code>3306</code>端口号，之后就在这个端口号上等待客户端进程进行连接，用书面一点的话来说，<code>MySQL</code>服务器会默认监听<code>3306</code>端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：TCP/IP 网络体系结构是现在通用的一种网络体系结构，其中的 TCP 和 IP 是体系结构中两个非常重要的网络协议，如果你并不知道协议是什么，或者并不知道网络是什么，那恐怕兄弟你来错地方了，找本计算机网络的书去看看吧！</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;如果<code>3306</code>端口号已经被别的进程占用了或者我们单纯的想自定义该数据库实例监听的端口号，那可以在启动服务器程序的命令行里添加<code>-P</code>参数来明确指定一下端口号，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld -P3307</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这样<code>MySQL</code>服务器在启动时就会去监听我们指定的端口号<code>3307</code>。</p><p>&amp;emsp;&amp;emsp;如果客户端进程想要使用<code>TCP/IP</code>网络来连接到服务器进程，比如我们在使用<code>mysql</code>来启动客户端程序时，在<code>-h</code>参数后必须跟随<code>IP地址</code>来作为需要连接的服务器进程所在主机的主机名，如果客户端进程和服务器进程在一台计算机中的话，我们可以使用<code>127.0.0.1</code>来代表本机的<code>IP地址</code>。另外，如果服务器进程监听的端口号不是默认的<code>3306</code>，我们也可以在使用<code>mysql</code>启动客户端程序时使用<code>-P</code>参数（大写的<code>P</code>，小写的<code>p</code>是用来指定密码的）来指定需要连接到的端口号。比如我们现在已经在本机启动了服务器进程，监听的端口号为<code>3307</code>，那我们启动客户端程序时可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h127.0.0.1 -uroot -P3307 -p</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;不知大家发现了没有，我们在启动服务器程序的命令<code>mysqld</code>和启动客户端程序的命令<code>mysql</code>后边都可以使用<code>-P</code>参数，关于如何在命令后边指定参数，指定哪些参数我们稍后会详细介绍的，稍微等等～</p><h3 id="命名管道和共享内存"><a href="#命名管道和共享内存" class="headerlink" title="命名管道和共享内存"></a>命名管道和共享内存</h3><p>&amp;emsp;&amp;emsp;如果你是一个<code>Windows</code>用户，那么客户端进程和服务器进程之间可以考虑使用<code>命名管道</code>或<code>共享内存</code>进行通信。不过启用这些通信方式的时候需要在启动服务器程序和客户端程序时添加一些参数：</p><ul><li><p>使用<code>命名管道</code>来进行进程间通信<br>&amp;emsp;&amp;emsp;需要在启动服务器程序的命令中加上<code>--enable-named-pipe</code>参数，然后在启动客户端程序的命令中加入<code>--pipe</code>或者<code>--protocol=pipe</code>参数。</p></li><li><p>使用<code>共享内存</code>来进行进程间通信<br>&amp;emsp;&amp;emsp;需要在启动服务器程序的命令中加上<code>--shared-memory</code>参数，在成功启动服务器后，<code>共享内存</code>便成为本地客户端程序的默认连接方式，不过我们也可以在启动客户端程序的命令中加入<code>--protocol=memory</code>参数来显式的指定使用共享内存进行通信。</p><p>&amp;emsp;&amp;emsp;不过需要注意的是，使用<code>共享内存</code>的方式进行通信的服务器进程和客户端进程必须在同一台<code>Windows</code>主机中。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：命名管道和共享内存是Windows操作系统中的两种进程间通信方式，如果你没听过的话也不用纠结，并不妨碍我们介绍MySQL的知识～</span><br></pre></td></tr></table></figure><h3 id="Unix域套接字文件"><a href="#Unix域套接字文件" class="headerlink" title="Unix域套接字文件"></a>Unix域套接字文件</h3><p>&amp;emsp;&amp;emsp;如果我们的服务器进程和客户端进程都运行在同一台操作系统为类<code>Unix</code>的机器上的话，我们可以使用<code>Unix域套接字文件</code>来进行进程间通信。如果我们在启动客户端程序的时候指定的主机名为<code>localhost</code>，或者指定了<code>--protocol=socket</code>的启动参数，那服务器程序和客户端程序之间就可以通过<code>Unix</code>域套接字文件来进行通信了。<code>MySQL</code>服务器程序默认监听的<code>Unix</code>域套接字文件路径为<code>/tmp/mysql.sock</code>，客户端程序也默认连接到这个<code>Unix</code>域套接字文件。如果我们想改变这个默认路径，可以在启动服务器程序时指定<code>socket</code>参数，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --socket=/tmp/a.txt</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这样服务器启动后便会监听<code>/tmp/a.txt</code>。在服务器改变了默认的<code>UNIX</code>域套接字文件后，如果客户端程序想通过<code>UNIX</code>域套接字文件进行通信的话，也需要显式的指定连接到的<code>UNIX</code>域套接字文件路径，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -hlocalhost -uroot --socket=/tmp/a.txt -p</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这样该客户端进程和服务器进程就可以通过路径为<code>/tmp/a.txt</code>的<code>Unix</code>域套接字文件进行通信了。</p><h2 id="服务器处理客户端请求"><a href="#服务器处理客户端请求" class="headerlink" title="服务器处理客户端请求"></a>服务器处理客户端请求</h2><p>&amp;emsp;&amp;emsp;其实不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：<span style="color:red">客户端进程向服务器进程发送一段文本（MySQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）</span>。那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？客户端可以向服务器发送增删改查各类请求，我们这里以比较复杂的查询请求为例来画个图展示一下大致的过程：</p><p><img src="/../images/01-01.png"></p><p>&amp;emsp;&amp;emsp;从图中我们可以看出，服务器程序处理来自客户端的查询请求大致需要经过三个部分，分别是<code>连接管理</code>、<code>解析与优化</code>、<code>存储引擎</code>。下面我们来详细看一下这三个部分都干了什么。</p><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>&amp;emsp;&amp;emsp;客户端进程可以采用我们上面介绍的<code>TCP/IP</code>、<code>命名管道或共享内存</code>、<code>Unix域套接字</code>这几种方式之一来与服务器进程建立连接，每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频繁创建和销毁线程的效果，从而节省开销。从这一点大家也能看出，<code>MySQL</code>服务器会为每一个连接进来的客户端分配一个线程，但是线程分配的太多了会严重影响系统性能，所以我们也需要限制一下可以同时连接到服务器的客户端数量，至于怎么限制我们后边再说～</p><p>&amp;emsp;&amp;emsp;在客户端程序发起连接的时候，需要携带主机信息、用户名、密码，服务器程序会对客户端程序提供的这些信息进行认证，如果认证失败，服务器程序会拒绝连接。另外，如果客户端程序和服务器程序不运行在一台计算机上，我们还可以采用使用了<code>SSL</code>（安全套接字）的网络连接进行通信，来保证数据传输的安全性。</p><p>&amp;emsp;&amp;emsp;当连接建立后，与该客户端关联的服务器线程会一直等待客户端发送过来的请求，<code>MySQL</code>服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理，预知后事如何，继续往下看～</p><h3 id="解析与优化"><a href="#解析与优化" class="headerlink" title="解析与优化"></a>解析与优化</h3><p>&amp;emsp;&amp;emsp;到现在为止，<code>MySQL</code>服务器已经获得了文本形式的请求，接着还要经过九九八十一难的处理，其中的几个比较重要的部分分别是<code>查询缓存</code>、<code>语法解析</code>和<code>查询优化</code>，下面我们详细来看。</p><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>&amp;emsp;&amp;emsp;如果我问你<code>9+8×16-3×2×17</code>的值是多少，你可能会用计算器去算一下，或者牛逼一点用心算，最终得到了结果<code>35</code>，如果我再问你一遍<code>9+8×16-3×2×17</code>的值是多少，你还会再傻呵呵的算一遍么？我们刚刚已经算过了，直接说答案就好了。<code>MySQL</code>服务器程序处理查询请求的过程也是这样，会把刚刚处理过的查询请求和结果<code>缓存</code>起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了，就不用再傻呵呵的去底层的表中查找了。这个查询缓存可以在不同客户端之间共享，也就是说如果客户端A刚刚查询了一个语句，而客户端B之后发送了同样的查询请求，那么客户端B的这次查询就可以直接使用查询缓存中的数据。</p><p>&amp;emsp;&amp;emsp;当然，<code>MySQL</code>服务器并没有人聪明，<span style="color:red">如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中</span>。另外，<span style="color:red">如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存</span>。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数<code>NOW</code>，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！</p><p>&amp;emsp;&amp;emsp;不过既然是缓存，那就有它缓存失效的时候。<span style="color:red">MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、 <code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或 <code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除</span>！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。</span><br></pre></td></tr></table></figure><h4 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h4><p>&amp;emsp;&amp;emsp;如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本而已，所以<code>MySQL</code>服务器程序首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到<code>MySQL</code>服务器内部使用的一些数据结构上来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：这个从指定的文本中提取出我们需要的信息本质上算是一个编译过程，涉及词法解析、语法分析、语义分析等阶段，这些问题不属于我们讨论的范畴，大家只要了解在处理请求的过程中需要这个步骤就好了。</span><br></pre></td></tr></table></figure><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>&amp;emsp;&amp;emsp;语法解析之后，服务器程序获得到了需要的信息，比如要查询的列是哪些，表是哪个，搜索条件是什么等等，但光有这些是不够的，因为我们写的<code>MySQL</code>语句执行起来效率可能并不是很高，<code>MySQL</code>的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接等等的一堆东西。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是什么样的。我们可以使用<code>EXPLAIN</code>语句来查看某个语句的执行计划，关于查询优化这部分的详细内容我们后边会仔细介绍，现在你只需要知道在<code>MySQL</code>服务器程序处理请求的过程中有这么一个步骤就好了。</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>&amp;emsp;&amp;emsp;截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表，<code>MySQL</code>服务器把数据的存储和提取操作都封装到了一个叫<code>存储引擎</code>的模块里。我们知道<code>表</code>是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是<code>存储引擎</code>负责的事情。为了实现不同的功能，<code>MySQL</code>提供了各式各样的<code>存储引擎</code>，不同<code>存储引擎</code>管理的表具体的存储结构可能不同，采用的存取算法也可能不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：为什么叫`引擎`呢？因为这个名字更拉风～ 其实这个存储引擎以前叫做`表处理器`，后来可能人们觉得太土，就改成了`存储引擎`的叫法，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;为了管理方便，人们把<code>连接管理</code>、<code>查询缓存</code>、<code>语法解析</code>、<code>查询优化</code>这些并不涉及真实数据存储的功能划分为<code>MySQL server</code>的功能，把真实存取数据的功能划分为<code>存储引擎</code>的功能。各种不同的存储引擎向上面的<code>MySQL server</code>层提供统一的调用接口（也就是存储引擎API），包含了几十个底层函数，像”读取索引第一条内容”、”读取索引下一条内容”、”插入记录”等等。</p><p>&amp;emsp;&amp;emsp;所以在<code>MySQL server</code>完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p><h2 id="常用存储引擎"><a href="#常用存储引擎" class="headerlink" title="常用存储引擎"></a>常用存储引擎</h2><p>&amp;emsp;&amp;emsp;<code>MySQL</code>支持非常多种存储引擎，我这先列举一些：</p><table><thead><tr><th align="center">存储引擎</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>ARCHIVE</code></td><td align="center">用于数据存档（行被插入后不能再修改）</td></tr><tr><td align="center"><code>BLACKHOLE</code></td><td align="center">丢弃写操作，读操作会返回空内容</td></tr><tr><td align="center"><code>CSV</code></td><td align="center">在存储数据时，以逗号分隔各个数据项</td></tr><tr><td align="center"><code>FEDERATED</code></td><td align="center">用来访问远程表</td></tr><tr><td align="center"><code>InnoDB</code></td><td align="center">具备外键支持功能的事务存储引擎</td></tr><tr><td align="center"><code>MEMORY</code></td><td align="center">置于内存的表</td></tr><tr><td align="center"><code>MERGE</code></td><td align="center">用来管理多个MyISAM表构成的表集合</td></tr><tr><td align="center"><code>MyISAM</code></td><td align="center">主要的非事务处理存储引擎</td></tr><tr><td align="center"><code>NDB</code></td><td align="center">MySQL集群专用存储引擎</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;这么多我们怎么挑啊，你多虑了，其实我们最常用的就是<code>InnoDB</code>和<code>MyISAM</code>，有时会提一下<code>Memory</code>。其中<code>InnoDB</code>是<code>MySQL</code>默认的存储引擎，我们之后会详细介绍这个存储引擎的各种功能，现在先看一下一些存储引擎对于某些功能的支持情况：</p><table><thead><tr><th align="center">Feature</th><th align="center">MyISAM</th><th align="center">Memory</th><th align="center">InnoDB</th><th align="center">Archive</th><th align="center">NDB</th></tr></thead><tbody><tr><td align="center">B-tree indexes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td></tr><tr><td align="center">Backup&#x2F;point-in-time recovery</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr><tr><td align="center">Cluster database support</td><td align="center">no</td><td align="center">no</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td></tr><tr><td align="center">Clustered indexes</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td></tr><tr><td align="center">Compressed data</td><td align="center">yes</td><td align="center">no</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td></tr><tr><td align="center">Data caches</td><td align="center">no</td><td align="center">N&#x2F;A</td><td align="center">yes</td><td align="center">no</td><td align="center">yes</td></tr><tr><td align="center">Encrypted data</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr><tr><td align="center">Foreign key support</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td><td align="center">yes</td></tr><tr><td align="center">Full-text search indexes</td><td align="center">yes</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td></tr><tr><td align="center">Geospatial data type support</td><td align="center">yes</td><td align="center">no</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr><tr><td align="center">Geospatial indexing support</td><td align="center">yes</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td></tr><tr><td align="center">Hash indexes</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td></tr><tr><td align="center">Index caches</td><td align="center">yes</td><td align="center">N&#x2F;A</td><td align="center">yes</td><td align="center">no</td><td align="center">yes</td></tr><tr><td align="center">Locking granularity</td><td align="center">Table</td><td align="center">Table</td><td align="center">Row</td><td align="center">Row</td><td align="center">Row</td></tr><tr><td align="center">MVCC</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td></tr><tr><td align="center">Query cache support</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr><tr><td align="center">Replication support</td><td align="center">yes</td><td align="center">Limited</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr><tr><td align="center">Storage limits</td><td align="center">256TB</td><td align="center">RAM</td><td align="center">64TB</td><td align="center">None</td><td align="center">384EB</td></tr><tr><td align="center">T-tree indexes</td><td align="center">no</td><td align="center">no</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td></tr><tr><td align="center">Transactions</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td><td align="center">yes</td></tr><tr><td align="center">Update statistics for data dictionary</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;密密麻麻列了这么多，看的头皮都发麻了，达到的效果就是告诉你：这玩意儿很复杂。其实这些东西大家没必要立即就给记住，我列出来的目的就是想让大家明白不同的存储引擎支持不同的功能，有些重要的功能我们会在后边的介绍中慢慢让大家理解的～</p><h2 id="关于存储引擎的一些操作"><a href="#关于存储引擎的一些操作" class="headerlink" title="关于存储引擎的一些操作"></a>关于存储引擎的一些操作</h2><h3 id="查看当前服务器程序支持的存储引擎"><a href="#查看当前服务器程序支持的存储引擎" class="headerlink" title="查看当前服务器程序支持的存储引擎"></a>查看当前服务器程序支持的存储引擎</h3><p>&amp;emsp;&amp;emsp;我们可以用下面这个命令来查看当前服务器程序支持的存储引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINES;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;来看一下调用效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINES;</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |</span><br><span class="line">| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |</span><br><span class="line">| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |</span><br><span class="line">| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |</span><br><span class="line">| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |</span><br><span class="line">| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |</span><br><span class="line">| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |</span><br><span class="line">| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |</span><br><span class="line">| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;其中的<code>Support</code>列表示该存储引擎是否可用，<code>DEFAULT</code>值代表是当前服务器程序的默认存储引擎。<code>Comment</code>列是对存储引擎的一个描述，英文的，将就着看吧。<code>Transactions</code>列代表该存储引擎是否支持事务处理。<code>XA</code>列代表该存储引擎是否支持分布式事务。<code>Savepoints</code>代表该列是否支持部分事务回滚。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：好吧，也许你并不知道什么是个事务、更别提分布式事务了，这些内容我们在后边的章节会详细介绍，现在瞅一眼看个新鲜就行。</span><br></pre></td></tr></table></figure><h3 id="设置表的存储引擎"><a href="#设置表的存储引擎" class="headerlink" title="设置表的存储引擎"></a>设置表的存储引擎</h3><p>&amp;emsp;&amp;emsp;我们前面说过，存储引擎是负责对表中的数据进行提取和写入的，<span style="color:red">我们可以为不同的表设置不同的存储引擎</span>，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p><h4 id="创建表时指定存储引擎"><a href="#创建表时指定存储引擎" class="headerlink" title="创建表时指定存储引擎"></a>创建表时指定存储引擎</h4><p>&amp;emsp;&amp;emsp;我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎<code>InnoDB</code>（当然这个默认的存储引擎也是可以修改的，我们在后边的章节中再说怎么改）。如果我们想显式的指定一下表的存储引擎，那可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    建表语句;</span><br><span class="line">) ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;比如我们想创建一个存储引擎为<code>MyISAM</code>的表可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE engine_demo_table(</span><br><span class="line">    -&gt;     i int</span><br><span class="line">    -&gt; ) ENGINE = MyISAM;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><h4 id="修改表的存储引擎"><a href="#修改表的存储引擎" class="headerlink" title="修改表的存储引擎"></a>修改表的存储引擎</h4><p>&amp;emsp;&amp;emsp;如果表已经建好了，我们也可以使用下面这个语句来修改表的存储引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;比如我们修改一下<code>engine_demo_table</code>表的存储引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE engine_demo_table ENGINE = InnoDB;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这时我们再查看一下<code>engine_demo_table</code>的表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE TABLE engine_demo_table\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: engine_demo_table</span><br><span class="line">Create Table: CREATE TABLE `engine_demo_table` (</span><br><span class="line">  `i` int(11) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到该表的存储引擎已经改为<code>InnoDB</code>了。</p><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/02-MySQL%E7%9A%84%E8%B0%83%E6%8E%A7%E6%8C%89%E9%92%AE-%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/"/>
      <url>/2022/10/31/model-mysql/mysql/02-MySQL%E7%9A%84%E8%B0%83%E6%8E%A7%E6%8C%89%E9%92%AE-%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="第2章-MySQL的调控按钮-启动选项和系统变量"><a href="#第2章-MySQL的调控按钮-启动选项和系统变量" class="headerlink" title="第2章 MySQL的调控按钮-启动选项和系统变量"></a>第2章 MySQL的调控按钮-启动选项和系统变量</h1><p>&amp;emsp;&amp;emsp;如果你用过手机，你的手机上一定有一个设置的功能，你可以选择设置手机的来电铃声、设置音量大小、设置解锁密码等等。假如没有这些设置功能，我们的生活将置于尴尬的境地，比如在图书馆里无法把手机设置为静音，无法把流量开关关掉以节省流量，在别人得知解锁密码后无法更改密码～ <code>MySQL</code>的服务器程序和客户端程序也有很多设置项，比如对于<code>MySQL</code>服务器程序，我们可以指定诸如允许同时连入的客户端数量、客户端和服务器通信方式、表的默认存储引擎、查询缓存的大小等设置项。对于<code>MySQL</code>客户端程序，我们之前已经见识过了，可以指定需要连接的服务器程序所在主机的主机名或IP地址、用户名及密码等信息。</p><p>&amp;emsp;&amp;emsp;这些设置项一般都有各自的默认值，比方说服务器允许同时连入的客户端的默认数量是<code>151</code>，表的默认存储引擎是<code>InnoDB</code>，我们可以在程序启动的时候去修改这些默认值，对于这种在程序启动时指定的设置项也称之为启动选项（startup options），这些选项控制着程序启动后的行为。在<code>MySQL</code>安装目录下的<code>bin</code>目录中的各种可执行文件，不论是服务器相关的程序（比如<code>mysqld</code>、<code>mysqld_safe</code>）还是客户端相关的程序（比如<code>mysql</code>、<code>mysqladmin</code>），在启动的时候基本都可以指定启动参数。这些启动参数可以放在命令行中指定，也可以把它们放在配置文件中指定。下面我们以<code>mysqld</code>为例，来详细介绍指定启动选项的格式。需要注意的一点是，我们现在要介绍的是设置启动选项的方式，下面出现的启动选项不论大家认不认识，先不用去纠结每个选项具体的作用是什么，之后我们会对一些重要的启动选项详细介绍。</p><h2 id="在命令行上使用选项"><a href="#在命令行上使用选项" class="headerlink" title="在命令行上使用选项"></a>在命令行上使用选项</h2><p>&amp;emsp;&amp;emsp;如果我们在启动客户端程序时在<code>-h</code>参数后边紧跟服务器的IP地址，这就意味着客户端和服务器之间需要通过<code>TCP/IP</code>网络进行通信。因为我的客户端程序和服务器程序都装在一台计算机上，所以在使用客户端程序连接服务器程序时指定的主机名是<code>127.0.0.1</code>的情况下，客户端进程和服务器进程之间会使用<code>TCP/IP</code>网络进行通信。如果我们在启动服务器程序的时候就禁止各客户端使用<code>TCP/IP</code>网络进行通信，可以在启动服务器程序的命令行里添加<code>skip-networking</code>启动选项，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --skip-networking</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到，我们在命令行中指定启动选项时需要在选项名前加上<code>--</code>前缀。另外，如果选项名是由多个单词构成的，它们之间可以由短划线<code>-</code>连接起来，也可以使用下划线<code>_</code>连接起来，也就是说<code>skip-networking</code>和<code>skip_networking</code>表示的含义是相同的。所以上面的写法与下面的写法是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --skip_networking</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;在按照上述命令启动服务器程序后，如果我们再使用<code>mysql</code>来启动客户端程序时，再把服务器主机名指定为<code>127.0.0.1</code>（IP地址的形式）的话会显示连接失败：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> mysql -h127.0.0.1 -uroot -p</span><br><span class="line">Enter password:</span><br><span class="line"></span><br><span class="line">ERROR 2003 (HY000): Can&#x27;t connect to MySQL server on &#x27;127.0.0.1&#x27; (61)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这就意味着我们指定的启动选项<code>skip-networking</code>生效了！</p><p>&amp;emsp;&amp;emsp;再举一个例子，我们前面说过如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用<code>InnoDB</code>作为表的存储引擎。如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --default-storage-engine=MyISAM</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们现在就已经把表的默认存储引擎改为<code>MyISAM</code>了，在客户端程序连接到服务器程序后试着创建一个表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE sys_var_demo(</span><br><span class="line">    -&gt;     i INT</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个定义语句中我们并没有明确指定表的存储引擎，创建成功后再看一下这个表的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE TABLE sys_var_demo\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: sys_var_demo</span><br><span class="line">Create Table: CREATE TABLE `sys_var_demo` (</span><br><span class="line">  `i` int(11) DEFAULT NULL</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到该表的存储引擎已经是<code>MyISAM</code>了，说明启动选项<code>default-storage-engine</code>生效了。</p><p>&amp;emsp;&amp;emsp;所以在启动服务器程序的命令行后边指定启动选项的通用格式就是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--启动选项1[=值1] --启动选项2[=值2] ... --启动选项n[=值n]</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;也就是说我们可以将各个启动选项写到一行中，各个启动选项之间使用空白字符隔开，在每一个启动选项名称前面添加<code>--</code>。对于不需要值的启动选项，比方说<code>skip-networking</code>，它们就不需要指定对应的值。对于需要指定值的启动选项，比如<code>default-storage-engine</code>我们在指定这个设置项的时候需要显式的指定它的值：<code>InnoDB</code>、<code>MyISAM</code>等。在命令行上指定有值的启动选项时需要注意，<span style="color:red">选项名、&#x3D;、选项值之间不可以有空白字符</span>，比如写成下面这样就是不正确的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqld --default-storage-engine = MyISAM</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;<span style="color:red">每个MySQL程序都有许多不同的选项。大多数程序提供了一个<code>--help</code>选项，你可以查看该程序支持的全部启动选项以及它们的默认值</span>。例如，使用<code>mysql --help</code>可以看到<code>mysql</code>程序支持的启动选项，<code>mysqld_safe --help</code>可以看到<code>mysqld_safe</code>程序支持的启动选项。查看<code>mysqld</code>支持的启动选项有些特别，需要使用<code>mysqld --verbose --help</code>。</p><h3 id="选项的长形式和短形式"><a href="#选项的长形式和短形式" class="headerlink" title="选项的长形式和短形式"></a>选项的长形式和短形式</h3><p>&amp;emsp;&amp;emsp;我们前面提到的<code>skip-networking</code>、<code>default-storage-engine</code>称之为长形式的选项（因为它们很长），设计<code>MySQL</code>的大佬为了我们使用的方便，对于一些常用的选项提供了短形式，我们列举一些具有短形式的启动选项来看看（<code>MySQL</code>支持的短形式选项太多了，全列出来会刷屏的）：</p><table><thead><tr><th align="center">长形式</th><th align="center">短形式</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center"><code>--host</code></td><td align="center"><code>-h</code></td><td align="left">主机名</td></tr><tr><td align="center"><code>--user</code></td><td align="center"><code>-u</code></td><td align="left">用户名</td></tr><tr><td align="center"><code>--password</code></td><td align="center"><code>-p</code></td><td align="left">密码</td></tr><tr><td align="center"><code>--port</code></td><td align="center"><code>-P</code></td><td align="left">端口</td></tr><tr><td align="center"><code>--version</code></td><td align="center"><code>-V</code></td><td align="left">版本信息</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;短形式的选项名只有一个字母，与使用长形式选项时需要在选项名前加两个短划线<code>--</code>不同的是，使用短形式选项时在选项名前只加一个短划线<code>-</code>前缀。有一些短形式的选项我们之前已经接触过了，比方说我们在启动服务器程序时指定监听的端口号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld -P3307</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;使用短形式指定启动选项时，选项名和选项值之间可以没有间隙，或者用空白字符隔开（<code>-p</code>选项有些特殊，<code>-p</code>和密码值之间不能有空白字符），也就是说上面的命令形式和下面的是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld -P 3307</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;另外，选项名是区分大小写的，比如<code>-p</code>和<code>-P</code>选项拥有完全不同的含义，大家需要注意一下。</p><h2 id="配置文件中使用选项"><a href="#配置文件中使用选项" class="headerlink" title="配置文件中使用选项"></a>配置文件中使用选项</h2><p>&amp;emsp;&amp;emsp;在命令行中设置启动选项只对当次启动生效，也就是说如果下一次重启程序的时候我们还想保留这些启动选项的话，还得重复把这些选项写到启动命令行中，这样真的很烦呀！于是设计<code>MySQL</code>的大佬们提出一种<code>配置文件</code>（也称为<code>选项文件</code>）的概念，我们把需要设置的启动选项都写在这个配置文件中，每次启动服务器的时候都从这个文件里加载相应的启动选项。由于这个配置文件可以长久的保存在计算机的硬盘里，所以只需我们配置一次，以后就都不用显式的把启动选项都写在启动命令行中了，<span style="color:red">所以我们推荐使用配置文件的方式来设置启动选项</span>。</p><h3 id="配置文件的路径"><a href="#配置文件的路径" class="headerlink" title="配置文件的路径"></a>配置文件的路径</h3><p>&amp;emsp;&amp;emsp;<code>MySQL</code>程序在启动时会寻找多个路径下的配置文件，这些路径有的是固定的，有的是可以在命令行指定的。根据操作系统的不同，配置文件的路径也有所不同，我们分开看一下。</p><h4 id="Windows操作系统的配置文件"><a href="#Windows操作系统的配置文件" class="headerlink" title="Windows操作系统的配置文件"></a>Windows操作系统的配置文件</h4><p>&amp;emsp;&amp;emsp;在<code>Windows</code>操作系统中，<code>MySQL</code>会按照下列路径来寻找配置文件：</p><table><thead><tr><th>路径名</th><th>备注</th></tr></thead><tbody><tr><td><code>%WINDIR%\my.ini</code>， <code>%WINDIR%\my.cnf</code></td><td></td></tr><tr><td><code>C:\my.ini</code>， <code>C:\my.cnf</code></td><td></td></tr><tr><td><code>BASEDIR\my.ini</code>， <code>BASEDIR\my.cnf</code></td><td></td></tr><tr><td><code>defaults-extra-file</code></td><td>命令行指定的额外配置文件路径</td></tr><tr><td><code>%APPDATA%\MySQL\.mylogin.cnf</code></td><td>登录路径选项（仅限客户端）</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;在阅读这些<code>Windows</code>操作系统下配置文件路径的时候需要注意一些事情：</p><ul><li><p>在给定的前三个路径中，配置文件可以使用<code>.ini</code>的扩展名，也可以使用<code>.cnf</code>的扩展名。</p></li><li><p><code>%WINDIR%</code>指的是你机器上<code>Windows</code>目录的位置，通常是<code>C:\WINDOWS</code>，如果你不确定，可以使用这个命令来查看：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %WINDIR%</span><br></pre></td></tr></table></figure></li><li><p><code>BASEDIR</code>指的是<code>MySQL</code>安装目录的路径，在我的<code>Windows</code>机器上的<code>BASEDIR</code>的值是：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\MySQL\MySQL Server 5.7</span><br></pre></td></tr></table></figure></li><li><p>第四个路径指的是我们在启动程序时可以通过指定<code>defaults-extra-file</code>参数的值来添加额外的配置文件路径，比方说我们在命令行上可以这么写：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --defaults-extra-file=C:\Users\xiaohaizi\my_extra_file.txt</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这样<code>MySQL</code>服务器启动时就可以额外在<code>C:\Users\xiaohaizi\my_extra_file.txt</code>这个路径下查找配置文件。  </p></li><li><p><code>%APPDATA%</code>表示<code>Windows</code>应用程序数据目录的值，可以使用下列命令查看：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %APPDATA%</span><br></pre></td></tr></table></figure></li><li><p>列表中最后一个名为<code>.mylogin.cnf</code>配置文件有点儿特殊，它不是一个纯文本文件（其他的配置文件都是纯文本文件），而是使用<code>mysql_config_editor</code>实用程序创建的加密文件。文件中只能包含一些用于启动客户端软件时连接服务器的一些选项，包括 <code>host</code>、<code>user</code>、<code>password</code>、<code>port</code>和 <code>socket</code>。而且它只能被客户端程序所使用。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：mysql_config_editor实用程序其实是MySQL安装目录下的bin目录下的一个可执行文件，这个实用程序有专用的语法来生成或修改 .mylogin.cnf 文件中的内容，如何使用这个程序不是我们讨论的主题，可以到MySQL的官方文档中查看。</span><br></pre></td></tr></table></figure><h4 id="类Unix操作系统中的配置文件"><a href="#类Unix操作系统中的配置文件" class="headerlink" title="类Unix操作系统中的配置文件"></a>类Unix操作系统中的配置文件</h4><p>&amp;emsp;&amp;emsp;在类<code>UNIX</code>操作系统中，<code>MySQL</code>会按照下列路径来寻找配置文件：</p><table><thead><tr><th>路径名</th><th>备注</th></tr></thead><tbody><tr><td><code>/etc/my.cnf</code></td><td></td></tr><tr><td><code>/etc/mysql/my.cnf</code></td><td></td></tr><tr><td><code>SYSCONFDIR/my.cnf</code></td><td></td></tr><tr><td><code>$MYSQL_HOME/my.cnf</code></td><td>特定于服务器的选项（仅限服务器）</td></tr><tr><td><code>defaults-extra-file</code></td><td>命令行指定的额外配置文件路径</td></tr><tr><td><code>~/.my.cnf</code></td><td>用户特定选项</td></tr><tr><td><code>~/.mylogin.cnf</code></td><td>用户特定的登录路径选项（仅限客户端）</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;在阅读这些<code>UNIX</code>操作系统下配置文件路径的时候需要注意一些事情：</p><ul><li><p><code>SYSCONFDIR</code>表示在使用<code>CMake</code>构建<code>MySQL</code>时使用<code>SYSCONFDIR</code>选项指定的目录。默认情况下，这是位于编译安装目录下的<code>etc</code>目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：如果你不懂什么是个CMAKE，什么是个编译，那就跳过吧，对我们后续的文章没什么影响。</span><br></pre></td></tr></table></figure></li><li><p><code>MYSQL_HOME</code>是一个环境变量，该变量的值是我们自己设置的，我们想设置就设置，不想设置就不设置。该变量的值代表一个路径，我们可以在该路径下创建一个<code>my.cnf</code>配置文件，那么这个配置文件中只能放置关于启动服务器程序相关的选项（言外之意就是其他的配置文件既能存放服务器相关的选项也能存放客户端相关的选项，<code>.mylogin.cnf</code>除外，它只能存放客户端相关的一些选项）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：如果大家使用mysqld_safe启动服务器程序，而且我们也没有主动设置这个MySQL_HOME环境变量的值，那这个环境变量的值将自动被设置为MySQL的安装目录，也就是MySQL服务器将会在安装目录下查找名为my.cnf配置文件（别忘了mysql.server会调用mysqld_safe，所以使用mysql.server启动服务器时也会在安装目录下查找配置文件）。</span><br></pre></td></tr></table></figure></li><li><p>列表中的最后两个以<code>~</code>开头的路径是用户相关的，类<code>UNIX</code>系统中都有一个当前登陆用户的概念，每个用户都可以有一个用户目录，<code>~</code>就代表这个用户目录，大家可以查看<code>HOME</code>环境变量的值来确定一下当前用户的用户目录，比方说我的<code>macOS</code>机器上的用户目录就是<code>/Users/xiaohaizi</code>。之所以说列表中最后两个配置文件是用户相关的，是因为不同的类<code>UNIX</code>系统的用户都可以在自己的用户目录下创建<code>.my.cnf</code>或者<code>.mylogin.cnf</code>，换句话说，不同登录用户使用的<code>.my.cnf</code>或者<code>.mylogin.cnf</code>配置文件是不同的。</p></li><li><p><code>defaults-extra-file</code>的含义与Windows中的一样。</p></li><li><p><code>.mylogin.cnf</code>的含义也同<code>Windows</code>中的一样，再次强调一遍，它不是纯文本文件，只能使用<code>mysql_config_editor</code>实用程序去创建或修改，用于存放客户端登陆服务器时的相关选项。</p></li></ul><p>&amp;emsp;&amp;emsp;这也就是说，在我的计算机中这几个路径中的<span style="color:red">任意一个</span>都可以当作配置文件来使用，如果它们不存在，你可以手动创建一个，比方说我手动在<code>~/.my.cnf</code>这个路径下创建一个配置文件。</p><p>&amp;emsp;&amp;emsp;另外，我们在介绍如何启动<code>MySQL</code>服务器程序的时候说过，使用<code>mysqld_safe</code>程序启动服务器时，会间接调用<code>mysqld</code>，所以对于传递给<code>mysqld_safe</code>的启动选项来说，如果<code>mysqld_safe</code>程序不处理，会接着传递给<code>mysqld</code>程序处理。比方说<code>skip-networking</code>选项是由<code>mysqld</code>处理的，<code>mysqld_safe</code>并不处理，但是如果我们我们在命令行上这样执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld_safe --skip-networking</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;则在<code>mysqld_safe</code>调用<code>mysqld</code>时，会把它处理不了的这个<code>skip-networking</code>选项交给<code>mysqld</code>处理。</p><h3 id="配置文件的内容"><a href="#配置文件的内容" class="headerlink" title="配置文件的内容"></a>配置文件的内容</h3><p>&amp;emsp;&amp;emsp;与在命令行中指定启动选项不同的是，配置文件中的启动选项被划分为若干个组，每个组有一个组名，用中括号<code>[]</code>扩起来，像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysqladmin]</span><br><span class="line">(具体的启动选项...)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;像这个配置文件里就定义了许多个组，组名分别是<code>server</code>、<code>mysqld</code>、<code>mysqld_safe</code>、<code>client</code>、<code>mysql</code>、<code>mysqladmin</code>。每个组下面可以定义若干个启动选项，我们以<code>[server]</code>组为例来看一下填写启动选项的形式（其他组中启动选项的形式是一样的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">option1            #这是option1，该选项不需要选项值</span><br><span class="line">option2 = value2      #这是option2，该选项需要选项值</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;在配置文件中指定启动选项的语法类似于命令行语法，但是配置文件中只能使用长形式的选项。在配置文件中指定的启动选项不允许加<code>--</code>前缀，并且每行只指定一个选项，而且<code>=</code>周围可以有空白字符（命令行中选项名、<code>=</code>、选项值之间不允许有空白字符）。另外，在配置文件中，我们可以使用<code>#</code>来添加注释，从<code>#</code>出现直到行尾的内容都属于注释内容，读取配置文件时会忽略这些注释内容。为了大家更容易对比启动选项在命令行和配置文件中指定的区别，我们再把命令行中指定<code>option1</code>和<code>option2</code>两个选项的格式写一遍看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--option1 --option2=value2</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;配置文件中不同的选项组是给不同的启动命令使用的，如果选项组名称与程序名称相同，则组中的选项将专门应用于该程序。例如，<code>[mysqld]</code>和<code>[mysql]</code>组分别应用于<code>mysqld</code>服务器程序和<code>mysql</code>客户端程序。不过有两个选项组比较特别：</p><ul><li><p><code>[server]</code>组下面的启动选项将作用于所有的服务器程序。</p></li><li><p><code>[client]</code>组下面的启动选项将作用于所有的客户端程序。</p></li></ul><p>&amp;emsp;&amp;emsp;需要注意的一点是，<code>mysqld_safe</code>和<code>mysql.server</code>这两个程序在启动时都会读取<code>[mysqld]</code>选项组中的内容。为了直观感受一下，我们挑一些启动命令来看一下它们能读取的选项组都有哪些：</p><table><thead><tr><th align="center">启动命令</th><th align="center">类别</th><th align="center">能读取的组</th></tr></thead><tbody><tr><td align="center"><code>mysqld</code></td><td align="center">启动服务器</td><td align="center"><code>[mysqld]</code>、<code>[server]</code></td></tr><tr><td align="center"><code>mysqld_safe</code></td><td align="center">启动服务器</td><td align="center"><code>[mysqld]</code>、<code>[server]</code>、<code>[mysqld_safe]</code></td></tr><tr><td align="center"><code>mysql.server</code></td><td align="center">启动服务器</td><td align="center"><code>[mysqld]</code>、<code>[server]</code>、<code>[mysql.server]</code></td></tr><tr><td align="center"><code>mysql</code></td><td align="center">启动客户端</td><td align="center"><code>[mysql]</code>、<code>[client]</code></td></tr><tr><td align="center"><code>mysqladmin</code></td><td align="center">启动客户端</td><td align="center"><code>[mysqladmin]</code>、<code>[client]</code></td></tr><tr><td align="center"><code>mysqldump</code></td><td align="center">启动客户端</td><td align="center"><code>[mysqldump]</code>、<code>[client]</code></td></tr></tbody></table><p>&amp;emsp;&amp;emsp;现在我们以<code>macOS</code>操作系统为例，在<code>/etc/mysql/my.cnf</code>这个配置文件中添加一些内容（<code>Windows</code>系统参考上面提到的配置文件路径）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">skip-networking</span><br><span class="line">default-storage-engine=MyISAM</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;然后直接用<code>mysqld</code>启动服务器程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;虽然在命令行没有添加启动选项，但是在程序启动的时候，就会默认的到我们上面提到的配置文件路径下查找配置文件，其中就包括<code>/etc/mysql/my.cnf</code>。又由于<code>mysqld</code>命令可以读取<code>[server]</code>选项组的内容，所以<code>skip-networking</code>和<code>default-storage-engine=MyISAM</code>这两个选项是生效的。你可以把这些启动选项放在<code>[client]</code>组里再试试用<code>mysqld</code>启动服务器程序，看一下里边的启动选项生效不（剧透一下，不生效）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：如果我们想指定mysql.server程序的启动参数，则必须将它们放在配置文件中，而不是放在命令行中。mysql.server仅支持start和stop作为命令行参数。</span><br></pre></td></tr></table></figure><h3 id="特定MySQL版本的专用选项组"><a href="#特定MySQL版本的专用选项组" class="headerlink" title="特定MySQL版本的专用选项组"></a>特定MySQL版本的专用选项组</h3><p>&amp;emsp;&amp;emsp;我们可以在选项组的名称后加上特定的<code>MySQL</code>版本号，比如对于<code>[mysqld]</code>选项组来说，我们可以定义一个<code>[mysqld-5.7]</code>的选项组，它的含义和<code>[mysqld]</code>一样，只不过只有版本号为<code>5.7</code>的<code>mysqld</code>程序才能使用这个选项组中的选项。</p><h3 id="配置文件的优先级"><a href="#配置文件的优先级" class="headerlink" title="配置文件的优先级"></a>配置文件的优先级</h3><p>&amp;emsp;&amp;emsp;我们前面介绍过<code>MySQL</code>将在某些固定的路径下搜索配置文件，我们也可以通过在命令行上指定<code>defaults-extra-file</code>启动选项来指定额外的配置文件路径。<code>MySQL</code>将按照我们在上表中给定的顺序依次读取各个配置文件，如果该文件不存在则忽略。值得注意的是，<span style="color:red">如果我们在多个配置文件中设置了相同的启动选项，那以最后一个配置文件中的为准</span>。比方说<code>/etc/my.cnf</code>文件的内容是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">default-storage-engine=InnoDB</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;而<code>~/.my.cnf</code>文件中的内容是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">default-storage-engine=MyISAM</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;又因为<code>~/.my.cnf</code>比<code>/etc/my.cnf</code>顺序靠后，所以如果两个配置文件中出现相同的启动选项，以<code>~/.my.cnf</code>中的为准，所以<code>MySQL</code>服务器程序启动之后，<code>default-storage-engine</code>的值就是<code>MyISAM</code>。</p><h3 id="同一个配置文件中多个组的优先级"><a href="#同一个配置文件中多个组的优先级" class="headerlink" title="同一个配置文件中多个组的优先级"></a>同一个配置文件中多个组的优先级</h3><p>&amp;emsp;&amp;emsp;我们说同一个命令可以访问配置文件中的多个组，比如<code>mysqld</code>可以访问<code>[mysqld]</code>、<code>[server]</code>组，如果在同一个配置文件中，比如<code>~/.my.cnf</code>，在这些组里出现了同样的配置项，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">default-storage-engine=InnoDB</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">default-storage-engine=MyISAM</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;那么，<span style="color:red">将以最后一个出现的组中的启动选项为准</span>，比方说例子中<code>default-storage-engine</code>既出现在<code>[mysqld]</code>组也出现在<code>[server]</code>组，因为<code>[mysqld]</code>组在<code>[server]</code>组后边，就以<code>[mysqld]</code>组中的配置项为准。</p><h3 id="defaults-file的使用"><a href="#defaults-file的使用" class="headerlink" title="defaults-file的使用"></a>defaults-file的使用</h3><p>&amp;emsp;&amp;emsp;如果我们不想让<code>MySQL</code>到默认的路径下搜索配置文件（就是上表中列出的那些），可以在命令行指定<code>defaults-file</code>选项，比如这样（以<code>UNIX</code>系统为例）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --defaults-file=/tmp/myconfig.txt</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这样，在程序启动的时候将只在<code>/tmp/myconfig.txt</code>路径下搜索配置文件。如果文件不存在或无法访问，则会发生错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：注意defaults-extra-file和defaults-file的区别，使用defaults-extra-file可以指定额外的配置文件搜索路径（也就是说那些固定的配置文件路径也会被搜索）。</span><br></pre></td></tr></table></figure><h2 id="命令行和配置文件中启动选项的区别"><a href="#命令行和配置文件中启动选项的区别" class="headerlink" title="命令行和配置文件中启动选项的区别"></a>命令行和配置文件中启动选项的区别</h2><p>&amp;emsp;&amp;emsp;在命令行上指定的绝大部分启动选项都可以放到配置文件中，但是有一些选项是专门为命令行设计的，比方说<code>defaults-extra-file</code>、<code>defaults-file</code>这样的选项本身就是为了指定配置文件路径的，再放在配置文件中使用就没什么意义了。剩下的一些只能用在命令行上而不能用到配置文件中的启动选项就不一一列举了，用到的时候再提（本书中基本用不到，有兴趣的到官方文档看）。</p><p>&amp;emsp;&amp;emsp;另外有一点需要特别注意，<span style="color:red">如果同一个启动选项既出现在命令行中，又出现在配置文件中，那么以命令行中的启动选项为准</span>！比如我们在配置文件中写了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">default-storage-engine=InnoDB</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;而我们的启动命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql.server start --default-storage-engine=MyISAM</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;那最后<code>default-storage-engine</code>的值就是<code>MyISAM</code>！</p><h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><h3 id="系统变量简介"><a href="#系统变量简介" class="headerlink" title="系统变量简介"></a>系统变量简介</h3><p>&amp;emsp;&amp;emsp;<code>MySQL</code>服务器程序运行过程中会用到许多影响程序行为的变量，它们被称为<code>MySQL</code>系统变量，比如允许同时连入的客户端数量用系统变量<code>max_connections</code>表示，表的默认存储引擎用系统变量<code>default_storage_engine</code>表示，查询缓存的大小用系统变量<code>query_cache_size</code>表示，<code>MySQL</code>服务器程序的系统变量有好几百条，我们就不一一列举了。每个系统变量都有一个默认值，我们可以使用命令行或者配置文件中的选项在启动服务器时改变一些系统变量的值。大多数的系统变量的值也可以在程序运行过程中修改，而无需停止并重新启动它。</p><h3 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h3><p>&amp;emsp;&amp;emsp;我们可以使用下列命令查看<code>MySQL</code>服务器程序支持的系统变量以及它们的当前值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;由于<code>系统变量</code>实在太多了，如果我们直接使用<code>SHOW VARIABLES</code>查看的话就直接刷屏了，所以通常都会带一个<code>LIKE</code>过滤条件来查看我们需要的系统变量的值，比方说这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| default_storage_engine | InnoDB |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES like &#x27;max_connections&#x27;;</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| max_connections | 151   |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到，现在服务器程序使用的默认存储引擎就是<code>InnoDB</code>，允许同时连接的客户端数量最多为<code>151</code>。别忘了<code>LIKE</code>表达式后边可以跟通配符来进行模糊查询，也就是说我们可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;default%&#x27;;</span><br><span class="line">+-------------------------------+-----------------------+</span><br><span class="line">| Variable_name                 | Value                 |</span><br><span class="line">+-------------------------------+-----------------------+</span><br><span class="line">| default_authentication_plugin | mysql_native_password |</span><br><span class="line">| default_password_lifetime     | 0                     |</span><br><span class="line">| default_storage_engine        | InnoDB                |</span><br><span class="line">| default_tmp_storage_engine    | InnoDB                |</span><br><span class="line">| default_week_format           | 0                     |</span><br><span class="line">+-------------------------------+-----------------------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这样就查出了所有以<code>default</code>开头的系统变量的值。</p><h3 id="设置系统变量"><a href="#设置系统变量" class="headerlink" title="设置系统变量"></a>设置系统变量</h3><h4 id="通过启动选项设置"><a href="#通过启动选项设置" class="headerlink" title="通过启动选项设置"></a>通过启动选项设置</h4><p>&amp;emsp;&amp;emsp;大部分的<code>系统变量</code>都可以通过启动服务器时传送启动选项的方式来进行设置。如何填写启动选项我们上面已经花了大篇幅来介绍了，就是下面两种方式：</p><ul><li><p>通过命令行添加启动选项。</p><p>  比方说我们在启动服务器程序时用这个命令：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --default-storage-engine=MyISAM --max-connections=10</span><br></pre></td></tr></table></figure></li><li><p>通过配置文件添加启动选项。</p><p>  我们可以这样填写配置文件：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">default-storage-engine=MyISAM</span><br><span class="line">max-connections=10</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;当使用上面两种方式中的任意一种启动服务器程序后，我们再来查看一下系统变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| default_storage_engine | MyISAM |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;max_connections&#x27;;</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| max_connections | 10    |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到<code>default_storage_engine</code>和<code>max_connections</code>这两个系统变量的值已经被修改了。有一点需要注意的是，<span style="color:red">对于启动选项来说，如果启动选项名由多个单词组成，各个单词之间用短划线<code>-</code>或者下划线<code>_</code>连接起来都可以，但是对应的系统变量之间必须使用下划线<code>_</code>连接起来</span>。</p><h4 id="服务器程序运行过程中设置"><a href="#服务器程序运行过程中设置" class="headerlink" title="服务器程序运行过程中设置"></a>服务器程序运行过程中设置</h4><p>&amp;emsp;&amp;emsp;<code>系统变量</code>比较牛逼的一点就是，<span style="color:red">对于大部分系统变量来说，它们的值可以在服务器程序运行过程中，进行动态修改而无需停止并重启服务器</span>。不过系统变量有作用范围之分，下面详细介绍下。</p><h5 id="设置不同作用范围的系统变量"><a href="#设置不同作用范围的系统变量" class="headerlink" title="设置不同作用范围的系统变量"></a>设置不同作用范围的系统变量</h5><p>&amp;emsp;&amp;emsp;我们前面说过，多个客户端程序可以同时连接到一个服务器程序。对于同一个系统变量，我们有时想让不同的客户端有不同的值。比方说狗哥使用客户端A，他想让当前客户端对应的默认存储引擎为<code>InnoDB</code>，所以他可以把系统变量<code>default_storage_engine</code>的值设置为<code>InnoDB</code>；猫爷使用客户端B，他想让当前客户端对应的默认存储引擎为<code>MyISAM</code>，所以他可以把系统变量<code>default_storage_engine</code>的值设置为<code>MyISAM</code>。这样可以使狗哥和猫爷的的客户端拥有不同的默认存储引擎，使用时互不影响，十分方便。但是这样各个客户端都私有一份系统变量会产生这么两个问题：</p><ul><li><p>有一些系统变量并不是针对单个客户端的，比如允许同时连接到服务器的客户端数量<code>max_connections</code>，查询缓存的大小<code>query_cache_size</code>，这些公有的系统变量让某个客户端私有显然不合适。</p></li><li><p>一个新连接到服务器的客户端对应的系统变量的值该怎么设置？</p></li></ul><p>&amp;emsp;&amp;emsp;为了解决这两个问题，设计<code>MySQL</code>的大佬提出了系统变量的<code>作用范围</code>的概念，具体来说<code>作用范围</code>分为这两种：</p><ul><li><p><code>GLOBAL</code>：全局变量，影响服务器的整体操作。</p></li><li><p><code>SESSION</code>：会话变量，影响某个客户端连接的操作。（注：<code>SESSION</code>有个别名叫<code>LOCAL</code>）</p></li></ul><p>&amp;emsp;&amp;emsp;在服务器启动时，会将每个全局变量初始化为其默认值（可以通过命令行或选项文件中指定的选项更改这些默认值）。然后服务器还为每个连接的客户端维护一组会话变量，客户端的会话变量在连接时使用相应全局变量的当前值初始化。</p><p>这话有点儿绕，还是以<code>default_storage_engine</code>举例，在服务器启动时会初始化一个名为<code>default_storage_engine</code>，作用范围为<code>GLOBAL</code>的系统变量。之后每当有一个客户端连接到该服务器时，服务器都会单独为该客户端分配一个名为<code>default_storage_engine</code>，作用范围为<code>SESSION</code>的系统变量，该作用范围为<code>SESSION</code>的系统变量值按照当前作用范围为<code>GLOBAL</code>的同名系统变量值进行初始化。</p><p>&amp;emsp;&amp;emsp;很显然，<span style="color:red">通过启动选项设置的系统变量的作用范围都是<code>GLOBAL</code>的，也就是对所有客户端都有效的</span>，因为在系统启动的时候还没有客户端程序连接进来呢。了解了系统变量的<code>GLOBAL</code>和<code>SESSION</code>作用范围之后，我们再看一下在服务器程序运行期间通过客户端程序设置系统变量的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] 系统变量名 = 值;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;或者写成这样也行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET [@@(GLOBAL|SESSION).]var_name = XXX;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;比如我们想在服务器运行过程中把作用范围为<code>GLOBAL</code>的系统变量<code>default_storage_engine</code>的值修改为<code>MyISAM</code>，也就是想让后面新连接到服务器的客户端都用<code>MyISAM</code>作为默认的存储引擎，那我们可以选择下面两条语句中的任意一条来进行设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语句一：SET GLOBAL default_storage_engine = MyISAM;</span><br><span class="line">语句二：SET @@GLOBAL.default_storage_engine = MyISAM;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;如果只想对本客户端生效，也可以选择下面三条语句中的任意一条来进行设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语句一：SET SESSION default_storage_engine = MyISAM;</span><br><span class="line">语句二：SET @@SESSION.default_storage_engine = MyISAM;</span><br><span class="line">语句三：SET default_storage_engine = MyISAM;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;从上面的<code>语句三</code>也可以看出，<span style="color:red">如果在设置系统变量的语句中省略了作用范围，默认的作用范围就是<code>SESSION</code></span>。也就是说<code>SET 系统变量名 = 值</code>和<code>SET SESSION 系统变量名 = 值</code>是等价的。</p><h5 id="查看不同作用范围的系统变量"><a href="#查看不同作用范围的系统变量" class="headerlink" title="查看不同作用范围的系统变量"></a>查看不同作用范围的系统变量</h5><p>&amp;emsp;&amp;emsp;既然<code>系统变量</code>有<code>作用范围</code>之分，那我们的<code>SHOW VARIABLES</code>语句查看的是什么<code>作用范围</code>的<code>系统变量</code>呢？</p><p>&amp;emsp;&amp;emsp;答：默认查看的是<code>SESSION</code>作用范围的系统变量。</p><p>&amp;emsp;&amp;emsp;当然我们也可以在查看系统变量的语句上加上要查看哪个<code>作用范围</code>的系统变量，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;下面我们演示一下完整的设置并查看系统变量的过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW SESSION VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| default_storage_engine | InnoDB |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW GLOBAL VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| default_storage_engine | InnoDB |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SET SESSION default_storage_engine = MyISAM;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW SESSION VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| default_storage_engine | MyISAM |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW GLOBAL VARIABLES LIKE &#x27;default_storage_engine&#x27;;</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| default_storage_engine | InnoDB |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到，最初<code>default_storage_engine</code>的系统变量无论是在<code>GLOBAL</code>作用范围上还是在<code>SESSION</code>作用范围上的值都是<code>InnoDB</code>，我们在<code>SESSION</code>作用范围把它的值设置为<code>MyISAM</code>之后，可以看到<code>GLOBAL</code>作用范围的值并没有改变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：如果某个客户端改变了某个系统变量在`GLOBAL`作用范围的值，并不会影响该系统变量在当前已经连接的客户端作用范围为`SESSION`的值，只会影响后续连入的客户端在作用范围为`SESSION`的值。</span><br></pre></td></tr></table></figure><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li><p><span style="color:red">并不是所有系统变量都具有<code>GLOBAL</code>和<code>SESSION</code>的作用范围</span>。</p><ul><li><p>有一些系统变量只具有<code>GLOBAL</code>作用范围，比方说<code>max_connections</code>，表示服务器程序支持同时最多有多少个客户端程序进行连接。</p></li><li><p>有一些系统变量只具有<code>SESSION</code>作用范围，比如<code>insert_id</code>，表示在对某个包含<code>AUTO_INCREMENT</code>列的表进行插入时，该列初始的值。</p></li><li><p>有一些系统变量的值既具有<code>GLOBAL</code>作用范围，也具有<code>SESSION</code>作用范围，比如我们前面用到的<code>default_storage_engine</code>，而且其实大部分的系统变量都是这样的，</p></li></ul></li><li><p><span style="color:red">有些系统变量是只读的，并不能设置值</span>。</p><p>  &amp;emsp;&amp;emsp;比方说<code>version</code>，表示当前<code>MySQL</code>的版本，我们客户端是不能设置它的值的，只能在<code>SHOW VARIABLES</code>语句里查看。</p></li></ul><h3 id="启动选项和系统变量的区别"><a href="#启动选项和系统变量的区别" class="headerlink" title="启动选项和系统变量的区别"></a>启动选项和系统变量的区别</h3><p>&amp;emsp;&amp;emsp;<code>启动选项</code>是在程序启动时我们程序员传递的一些参数，而<code>系统变量</code>是影响服务器程序运行行为的变量，它们之间的关系如下：</p><ul><li><p>大部分的系统变量都可以被当作启动选项传入。</p></li><li><p>有些系统变量是在程序运行过程中自动生成的，是不可以当作启动选项来设置，比如<code>auto_increment_offset</code>、<code>character_set_client</code>等。</p></li><li><p>有些启动选项也不是系统变量，比如<code>defaults-file</code>。</p></li></ul><h2 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h2><p>&amp;emsp;&amp;emsp;为了让我们更好的了解服务器程序的运行情况，<code>MySQL</code>服务器程序中维护了很多关于程序运行状态的变量，它们被称为<code>状态变量</code>。比方说<code>Threads_connected</code>表示当前有多少客户端与服务器建立了连接，<code>Handler_update</code>表示已经更新了多少行记录等，像这样显示服务器程序状态信息的<code>状态变量</code>还有好几百个，我们就不一一介绍了，等遇到了会详细说它们的作用的。</p><p>&amp;emsp;&amp;emsp;由于<code>状态变量</code>是用来显示服务器程序运行状况的，所以<span style="color:red">它们的值只能由服务器程序自己来设置，我们程序员是不能设置的</span>。与<code>系统变量</code>类似，<code>状态变量</code>也有<code>GLOBAL</code>和<code>SESSION</code>两个作用范围的，所以查看<code>状态变量</code>的语句可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;类似的，如果我们不写明作用范围，默认的作用范围是<code>SESSION</code>，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE &#x27;thread%&#x27;;</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Threads_cached    | 0     |</span><br><span class="line">| Threads_connected | 1     |</span><br><span class="line">| Threads_created   | 1     |</span><br><span class="line">| Threads_running   | 1     |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;所有以<code>Thread</code>开头的<code>SESSION</code>作用范围的状态变量就都被展示出来了。</p><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/03-%E4%B9%B1%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/"/>
      <url>/2022/10/31/model-mysql/mysql/03-%E4%B9%B1%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="第3章-乱码的前世今生-字符集和比较规则"><a href="#第3章-乱码的前世今生-字符集和比较规则" class="headerlink" title="第3章 乱码的前世今生-字符集和比较规则"></a>第3章 乱码的前世今生-字符集和比较规则</h1><h2 id="字符集和比较规则简介"><a href="#字符集和比较规则简介" class="headerlink" title="字符集和比较规则简介"></a>字符集和比较规则简介</h2><h3 id="字符集简介"><a href="#字符集简介" class="headerlink" title="字符集简介"></a>字符集简介</h3><p>&amp;emsp;&amp;emsp;我们知道在计算机中只能存储二进制数据，那该怎么存储字符串呢？当然是建立字符与二进制数据的映射关系了，建立这个关系最起码要搞清楚两件事儿：</p><ol><li>你要把哪些字符映射成二进制数据？<br> &amp;emsp;&amp;emsp;也就是界定清楚字符范围。</li><li>怎么映射？<br> &amp;emsp;&amp;emsp;将一个字符映射成一个二进制数据的过程也叫做<code>编码</code>，将一个二进制数据映射到一个字符的过程叫做<code>解码</code>。</li></ol><p>&amp;emsp;&amp;emsp;人们抽象出一个<code>字符集</code>的概念来描述某个字符范围的编码规则。比方说我们来自定义一个名称为<code>xiaohaizi</code>的字符集，它包含的字符范围和编码规则如下：</p><ul><li><p>包含字符<code>&#39;a&#39;</code>、<code>&#39;b&#39;</code>、<code>&#39;A&#39;</code>、<code>&#39;B&#39;</code>。</p></li><li><p>编码规则如下：</p><p>  采用1个字节编码一个字符的形式，字符和字节的映射关系如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;a&#x27; -&gt; 00000001 (十六进制：0x01)</span><br><span class="line">&#x27;b&#x27; -&gt; 00000010 (十六进制：0x02)</span><br><span class="line">&#x27;A&#x27; -&gt; 00000011 (十六进制：0x03)</span><br><span class="line">&#x27;B&#x27; -&gt; 00000100 (十六进制：0x04)</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;有了<code>xiaohaizi</code>字符集，我们就可以用二进制形式表示一些字符串了，下面是一些字符串用<code>xiaohaizi</code>字符集编码后的二进制表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;bA&#x27; -&gt; 0000001000000011  (十六进制：0x0203)</span><br><span class="line">&#x27;baB&#x27; -&gt; 000000100000000100000100  (十六进制：0x020104)</span><br><span class="line">&#x27;cd&#x27; -&gt; 无法表示，字符集xiaohaizi不包含字符&#x27;c&#x27;和&#x27;d&#x27;</span><br></pre></td></tr></table></figure><h3 id="比较规则简介"><a href="#比较规则简介" class="headerlink" title="比较规则简介"></a>比较规则简介</h3><p>&amp;emsp;&amp;emsp;在我们确定了<code>xiaohaizi</code>字符集表示字符的范围以及编码规则后，怎么比较两个字符的大小呢？最容易想到的就是直接比较这两个字符对应的二进制编码的大小，比方说字符<code>&#39;a&#39;</code>的编码为<code>0x01</code>，字符<code>&#39;b&#39;</code>的编码为<code>0x02</code>，所以<code>&#39;a&#39;</code>小于<code>&#39;b&#39;</code>，这种简单的比较规则也可以被称为二进制比较规则，英文名为<code>binary collation</code>。</p><p>&amp;emsp;&amp;emsp;二进制比较规则是简单，但有时候并不符合现实需求，比如在很多场合对于英文字符我们都是不区分大小写的，也就是说<code>&#39;a&#39;</code>和<code>&#39;A&#39;</code>是相等的，在这种场合下就不能简单粗暴的使用二进制比较规则了，这时候我们可以这样指定比较规则：</p><ol><li>将两个大小写不同的字符全都转为大写或者小写。</li><li>再比较这两个字符对应的二进制数据。</li></ol><p>&amp;emsp;&amp;emsp;这是一种稍微复杂一点点的比较规则，但是实际生活中的字符不止英文字符一种，比如我们的汉字有几万之多，对于某一种字符集来说，比较两个字符大小的规则可以制定出很多种，也就是说<span style="color:red">同一种字符集可以有多种比较规则</span>，我们稍后就要介绍各种现实生活中用的字符集以及它们的一些比较规则。</p><h3 id="一些重要的字符集"><a href="#一些重要的字符集" class="headerlink" title="一些重要的字符集"></a>一些重要的字符集</h3><p>&amp;emsp;&amp;emsp;不幸的是，这个世界太大了，不同的人制定出了好多种<code>字符集</code>，它们表示的字符范围和用到的编码规则可能都不一样。我们看一下一些常用字符集的情况：</p><ul><li><p><code>ASCII</code>字符集</p><p>  &amp;emsp;&amp;emsp;共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于总共才128个字符，所以可以使用1个字节来进行编码，我们看一些字符的编码方式：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;L&#x27; -&gt;  01001100（十六进制：0x4C，十进制：76）</span><br><span class="line">&#x27;M&#x27; -&gt;  01001101（十六进制：0x4D，十进制：77）</span><br></pre></td></tr></table></figure></li><li><p><code>ISO 8859-1</code>字符集</p><p>  &amp;emsp;&amp;emsp;共收录256个字符，是在<code>ASCII</code>字符集的基础上又扩充了128个西欧常用字符(包括德法两国的字母)，也可以使用1个字节来进行编码。这个字符集也有一个别名<code>latin1</code>。</p></li><li><p><code>GB2312</code>字符集</p><p>  &amp;emsp;&amp;emsp;收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。其中收录汉字6763个，其他文字符号682个。同时这种字符集又兼容<code>ASCII</code>字符集，所以在编码方式上显得有些奇怪：</p><ul><li>如果该字符在<code>ASCII</code>字符集中，则采用1字节编码。</li><li>否则采用2字节编码。</li></ul><p>&amp;emsp;&amp;emsp;这种表示一个字符需要的字节数可能不同的编码方式称为<code>变长编码方式</code>。比方说字符串<code>&#39;爱u&#39;</code>，其中<code>&#39;爱&#39;</code>需要用2个字节进行编码，编码后的十六进制表示为<code>0xB0AE</code>，<code>&#39;u&#39;</code>需要用1个字节进行编码，编码后的十六进制表示为<code>0x75</code>，所以拼合起来就是<code>0xB0AE75</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：我们怎么区分某个字节代表一个单独的字符还是代表某个字符的一部分呢？别忘了`ASCII`字符集只收录128个字符，使用0～127就可以表示全部字符，所以如果某个字节是在0～127之内的，就意味着一个字节代表一个单独的字符，否则就是两个字节代表一个单独的字符。</span><br></pre></td></tr></table></figure></li><li><p><code>GBK</code>字符集</p><p>&amp;emsp;&amp;emsp;<code>GBK</code>字符集只是在收录字符范围上对<code>GB2312</code>字符集作了扩充，编码方式上兼容<code>GB2312</code>。</p></li><li><p><code>utf8</code>字符集</p><p>&amp;emsp;&amp;emsp;收录地球上能想到的所有字符，而且还在不断扩充。这种字符集兼容<code>ASCII</code>字符集，采用变长编码方式，编码一个字符需要使用1～4个字节，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;L&#x27; -&gt;  01001100（十六进制：0x4C）</span><br><span class="line">&#x27;啊&#x27; -&gt;  111001011001010110001010（十六进制：0xE5958A）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：其实准确的说，utf8只是Unicode字符集的一种编码方案，Unicode字符集可以采用utf8、utf16、utf32这几种编码方案，utf8使用1～4个字节编码一个字符，utf16使用2个或4个字节编码一个字符，utf32使用4个字节编码一个字符。更详细的Unicode和其编码方案的知识不是本书的重点，大家上网查查。MySQL中并不区分字符集和编码方案的概念，所以后边介绍的时候把utf8、utf16、utf32都当作一种字符集对待。</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;对于同一个字符，不同字符集也可能有不同的编码方式。比如对于汉字<code>&#39;我&#39;</code>来说，<code>ASCII</code>字符集中根本没有收录这个字符，<code>utf8</code>和<code>gb2312</code>字符集对汉字<code>我</code>的编码方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utf8编码：111001101000100010010001 (3个字节，十六进制表示是：0xE68891)</span><br><span class="line">gb2312编码：1100111011010010 (2个字节，十六进制表示是：0xCED2)</span><br></pre></td></tr></table></figure><h2 id="MySQL中支持的字符集和排序规则"><a href="#MySQL中支持的字符集和排序规则" class="headerlink" title="MySQL中支持的字符集和排序规则"></a>MySQL中支持的字符集和排序规则</h2><h3 id="MySQL中的utf8和utf8mb4"><a href="#MySQL中的utf8和utf8mb4" class="headerlink" title="MySQL中的utf8和utf8mb4"></a>MySQL中的utf8和utf8mb4</h3><p>&amp;emsp;&amp;emsp;我们上面说<code>utf8</code>字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而在<code>MySQL</code>中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计<code>MySQL</code>的大佬偷偷的定义了两个概念：</p><ul><li><p><code>utf8mb3</code>：阉割过的<code>utf8</code>字符集，只使用1～3个字节表示字符。</p></li><li><p><code>utf8mb4</code>：正宗的<code>utf8</code>字符集，使用1～4个字节表示字符。</p></li></ul><p>&amp;emsp;&amp;emsp;有一点需要大家十分的注意，在<code>MySQL</code>中<code>utf8</code>是<code>utf8mb3</code>的别名，所以之后在<code>MySQL</code>中提到<code>utf8</code>就意味着使用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如存储一些emoji表情什么的，那请使用<code>utf8mb4</code>。</p><h3 id="字符集的查看"><a href="#字符集的查看" class="headerlink" title="字符集的查看"></a>字符集的查看</h3><p>&amp;emsp;&amp;emsp;<code>MySQL</code>支持好多好多种字符集，查看当前<code>MySQL</code>中支持的字符集可以用下面这个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;其中<code>CHARACTER SET</code>和<code>CHARSET</code>是同义词，用任意一个都可以。我们查询一下（支持的字符集太多了，我们省略了一些）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CHARSET;</span><br><span class="line">+----------+---------------------------------+---------------------+--------+</span><br><span class="line">| Charset  | Description                     | Default collation   | Maxlen |</span><br><span class="line">+----------+---------------------------------+---------------------+--------+</span><br><span class="line">| big5     | Big5 Traditional Chinese        | big5_chinese_ci     |      2 |</span><br><span class="line">...</span><br><span class="line">| latin1   | cp1252 West European            | latin1_swedish_ci   |      1 |</span><br><span class="line">| latin2   | ISO 8859-2 Central European     | latin2_general_ci   |      1 |</span><br><span class="line">...</span><br><span class="line">| ascii    | US ASCII                        | ascii_general_ci    |      1 |</span><br><span class="line">...</span><br><span class="line">| gb2312   | GB2312 Simplified Chinese       | gb2312_chinese_ci   |      2 |</span><br><span class="line">...</span><br><span class="line">| gbk      | GBK Simplified Chinese          | gbk_chinese_ci      |      2 |</span><br><span class="line">| latin5   | ISO 8859-9 Turkish              | latin5_turkish_ci   |      1 |</span><br><span class="line">...</span><br><span class="line">| utf8     | UTF-8 Unicode                   | utf8_general_ci     |      3 |</span><br><span class="line">| ucs2     | UCS-2 Unicode                   | ucs2_general_ci     |      2 |</span><br><span class="line">...</span><br><span class="line">| latin7   | ISO 8859-13 Baltic              | latin7_general_ci   |      1 |</span><br><span class="line">| utf8mb4  | UTF-8 Unicode                   | utf8mb4_general_ci  |      4 |</span><br><span class="line">| utf16    | UTF-16 Unicode                  | utf16_general_ci    |      4 |</span><br><span class="line">| utf16le  | UTF-16LE Unicode                | utf16le_general_ci  |      4 |</span><br><span class="line">...</span><br><span class="line">| utf32    | UTF-32 Unicode                  | utf32_general_ci    |      4 |</span><br><span class="line">| binary   | Binary pseudo charset           | binary              |      1 |</span><br><span class="line">...</span><br><span class="line">| gb18030  | China National Standard GB18030 | gb18030_chinese_ci  |      4 |</span><br><span class="line">+----------+---------------------------------+---------------------+--------+</span><br><span class="line">41 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到，我使用的这个<code>MySQL</code>版本一共支持<code>41</code>种字符集，其中的<code>Default collation</code>列表示这种字符集中一种默认的<code>比较规则</code>。大家注意返回结果中的最后一列<code>Maxlen</code>，它代表该种字符集表示一个字符最多需要几个字节。为了让大家的印象更深刻，我把几个常用到的字符集的<code>Maxlen</code>列摘抄下来，大家务必记住：</p><table><thead><tr><th align="center">字符集名称</th><th align="center">Maxlen</th></tr></thead><tbody><tr><td align="center"><code>ascii</code></td><td align="center"><code>1</code></td></tr><tr><td align="center"><code>latin1</code></td><td align="center"><code>1</code></td></tr><tr><td align="center"><code>gb2312</code></td><td align="center"><code>2</code></td></tr><tr><td align="center"><code>gbk</code></td><td align="center"><code>2</code></td></tr><tr><td align="center"><code>utf8</code></td><td align="center"><code>3</code></td></tr><tr><td align="center"><code>utf8mb4</code></td><td align="center"><code>4</code></td></tr></tbody></table><h3 id="比较规则的查看"><a href="#比较规则的查看" class="headerlink" title="比较规则的查看"></a>比较规则的查看</h3><p>&amp;emsp;&amp;emsp;查看<code>MySQL</code>中支持的比较规则的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW COLLATION [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们前面说过一种字符集可能对应着若干种比较规则，<code>MySQL</code>支持的字符集就已经非常多了，所以支持的比较规则更多，我们先只查看一下<code>utf8</code>字符集下的比较规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW COLLATION LIKE &#x27;utf8\_%&#x27;;</span><br><span class="line">+--------------------------+---------+-----+---------+----------+---------+</span><br><span class="line">| Collation                | Charset | Id  | Default | Compiled | Sortlen |</span><br><span class="line">+--------------------------+---------+-----+---------+----------+---------+</span><br><span class="line">| utf8_general_ci          | utf8    |  33 | Yes     | Yes      |       1 |</span><br><span class="line">| utf8_bin                 | utf8    |  83 |         | Yes      |       1 |</span><br><span class="line">| utf8_unicode_ci          | utf8    | 192 |         | Yes      |       8 |</span><br><span class="line">| utf8_icelandic_ci        | utf8    | 193 |         | Yes      |       8 |</span><br><span class="line">| utf8_latvian_ci          | utf8    | 194 |         | Yes      |       8 |</span><br><span class="line">| utf8_romanian_ci         | utf8    | 195 |         | Yes      |       8 |</span><br><span class="line">| utf8_slovenian_ci        | utf8    | 196 |         | Yes      |       8 |</span><br><span class="line">| utf8_polish_ci           | utf8    | 197 |         | Yes      |       8 |</span><br><span class="line">| utf8_estonian_ci         | utf8    | 198 |         | Yes      |       8 |</span><br><span class="line">| utf8_spanish_ci          | utf8    | 199 |         | Yes      |       8 |</span><br><span class="line">| utf8_swedish_ci          | utf8    | 200 |         | Yes      |       8 |</span><br><span class="line">| utf8_turkish_ci          | utf8    | 201 |         | Yes      |       8 |</span><br><span class="line">| utf8_czech_ci            | utf8    | 202 |         | Yes      |       8 |</span><br><span class="line">| utf8_danish_ci           | utf8    | 203 |         | Yes      |       8 |</span><br><span class="line">| utf8_lithuanian_ci       | utf8    | 204 |         | Yes      |       8 |</span><br><span class="line">| utf8_slovak_ci           | utf8    | 205 |         | Yes      |       8 |</span><br><span class="line">| utf8_spanish2_ci         | utf8    | 206 |         | Yes      |       8 |</span><br><span class="line">| utf8_roman_ci            | utf8    | 207 |         | Yes      |       8 |</span><br><span class="line">| utf8_persian_ci          | utf8    | 208 |         | Yes      |       8 |</span><br><span class="line">| utf8_esperanto_ci        | utf8    | 209 |         | Yes      |       8 |</span><br><span class="line">| utf8_hungarian_ci        | utf8    | 210 |         | Yes      |       8 |</span><br><span class="line">| utf8_sinhala_ci          | utf8    | 211 |         | Yes      |       8 |</span><br><span class="line">| utf8_german2_ci          | utf8    | 212 |         | Yes      |       8 |</span><br><span class="line">| utf8_croatian_ci         | utf8    | 213 |         | Yes      |       8 |</span><br><span class="line">| utf8_unicode_520_ci      | utf8    | 214 |         | Yes      |       8 |</span><br><span class="line">| utf8_vietnamese_ci       | utf8    | 215 |         | Yes      |       8 |</span><br><span class="line">| utf8_general_mysql500_ci | utf8    | 223 |         | Yes      |       1 |</span><br><span class="line">+--------------------------+---------+-----+---------+----------+---------+</span><br><span class="line">27 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这些比较规则的命名还挺有规律的，具体规律如下：</p><ul><li><p>比较规则名称以与其关联的字符集的名称开头。如上图的查询结果的比较规则名称都是以<code>utf8</code>开头的。</p></li><li><p>后边紧跟着该比较规则主要作用于哪种语言，比如<code>utf8_polish_ci</code>表示以波兰语的规则比较，<code>utf8_spanish_ci</code>是以西班牙语的规则比较，<code>utf8_general_ci</code>是一种通用的比较规则。</p></li><li><p>名称后缀意味着该比较规则是否区分语言中的重音、大小写什么的，具体可以用的值如下：</p></li></ul><table><thead><tr><th align="center">后缀</th><th align="center">英文释义</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>_ai</code></td><td align="center"><code>accent insensitive</code></td><td align="center">不区分重音</td></tr><tr><td align="center"><code>_as</code></td><td align="center"><code>accent sensitive</code></td><td align="center">区分重音</td></tr><tr><td align="center"><code>_ci</code></td><td align="center"><code>case insensitive</code></td><td align="center">不区分大小写</td></tr><tr><td align="center"><code>_cs</code></td><td align="center"><code>case sensitive</code></td><td align="center">区分大小写</td></tr><tr><td align="center"><code>_bin</code></td><td align="center"><code>binary</code></td><td align="center">以二进制方式比较</td></tr></tbody></table><pre><code>比如`utf8_general_ci`这个比较规则是以`ci`结尾的，说明不区分大小写。</code></pre><p>&amp;emsp;&amp;emsp;<span style="color:red">每种字符集对应若干种比较规则，每种字符集都有一种默认的比较规则</span>，<code>SHOW COLLATION</code>的返回结果中的<code>Default</code>列的值为<code>YES</code>的就是该字符集的默认比较规则，比方说<code>utf8</code>字符集默认的比较规则就是<code>utf8_general_ci</code>。</p><h2 id="字符集和比较规则的应用"><a href="#字符集和比较规则的应用" class="headerlink" title="字符集和比较规则的应用"></a>字符集和比较规则的应用</h2><h3 id="各级别的字符集和比较规则"><a href="#各级别的字符集和比较规则" class="headerlink" title="各级别的字符集和比较规则"></a>各级别的字符集和比较规则</h3><p>&amp;emsp;&amp;emsp;<code>MySQL</code>有4个级别的字符集和比较规则，分别是：</p><ul><li>服务器级别</li><li>数据库级别</li><li>表级别</li><li>列级别</li></ul><p>&amp;emsp;&amp;emsp;我们接下来仔细看一下怎么设置和查看这几个级别的字符集和比较规则。</p><h4 id="服务器级别"><a href="#服务器级别" class="headerlink" title="服务器级别"></a>服务器级别</h4><p>&amp;emsp;&amp;emsp;<code>MySQL</code>提供了两个系统变量来表示服务器级别的字符集和比较规则：</p><table><thead><tr><th align="center">系统变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>character_set_server</code></td><td align="center">服务器级别的字符集</td></tr><tr><td align="center"><code>collation_server</code></td><td align="center">服务器级别的比较规则</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;我们看一下这两个系统变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_server&#x27;;</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| character_set_server | utf8  |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_server&#x27;;</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| Variable_name    | Value           |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| collation_server | utf8_general_ci |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到在我的计算机中服务器级别默认的字符集是<code>utf8</code>，默认的比较规则是<code>utf8_general_ci</code>。</p><p>&amp;emsp;&amp;emsp;我们可以在启动服务器程序时通过启动选项或者在服务器程序运行过程中使用<code>SET</code>语句修改这两个变量的值。比如我们可以在配置文件中这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">character_set_server=gbk</span><br><span class="line">collation_server=gbk_chinese_ci</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;当服务器启动的时候读取这个配置文件后这两个系统变量的值便修改了。</p><h4 id="数据库级别"><a href="#数据库级别" class="headerlink" title="数据库级别"></a>数据库级别</h4><p>&amp;emsp;&amp;emsp;我们在创建和修改数据库的时候可以指定该数据库的字符集和比较规则，具体语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br><span class="line"></span><br><span class="line">ALTER DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;其中的<code>DEFAULT</code>可以省略，并不影响语句的语义。比方说我们新创建一个名叫<code>charset_demo_db</code>的数据库，在创建的时候指定它使用的字符集为<code>gb2312</code>，比较规则为<code>gb2312_chinese_ci</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE charset_demo_db</span><br><span class="line">    -&gt; CHARACTER SET gb2312</span><br><span class="line">    -&gt; COLLATE gb2312_chinese_ci;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;如果想查看当前数据库使用的字符集和比较规则，可以查看下面两个系统变量的值（前提是使用<code>USE</code>语句选择当前默认数据库，如果没有默认数据库，则变量与相应的服务器级系统变量具有相同的值）：</p><table><thead><tr><th align="center">系统变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>character_set_database</code></td><td align="center">当前数据库的字符集</td></tr><tr><td align="center"><code>collation_database</code></td><td align="center">当前数据库的比较规则</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;我们来查看一下刚刚创建的<code>charset_demo_db</code>数据库的字符集和比较规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE charset_demo_db;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_database&#x27;;</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| character_set_database | gb2312 |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_database&#x27;;</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">| Variable_name      | Value             |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">| collation_database | gb2312_chinese_ci |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到这个<code>charset_demo_db</code>数据库的字符集和比较规则就是我们在创建语句中指定的。需要注意的一点是：<span style="color:red"> <em><strong>character_set_database</strong></em> 和 <em><strong>collation_database</strong></em> 这两个系统变量是只读的，我们不能通过修改这两个变量的值而改变当前数据库的字符集和比较规则</span>。</p><p>&amp;emsp;&amp;emsp;数据库的创建语句中也可以不指定字符集和比较规则，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;<span style="color:red">这样的话，将使用服务器级别的字符集和比较规则作为数据库的字符集和比较规则</span>。</p><h4 id="表级别"><a href="#表级别" class="headerlink" title="表级别"></a>表级别</h4><p>&amp;emsp;&amp;emsp;我们也可以在创建和修改表的时候指定表的字符集和比较规则，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息)</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]]</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;比方说我们在刚刚创建的<code>charset_demo_db</code>数据库中创建一个名为<code>t</code>的表，并指定这个表的字符集和比较规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t(</span><br><span class="line">    -&gt;     col VARCHAR(10)</span><br><span class="line">    -&gt; ) CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;如果创建和修改表的语句中没有指明字符集和比较规则，<span style="color:red">将使用该表所在数据库的字符集和比较规则作为该表的字符集和比较规则</span>。假设我们的创建表<code>t</code>的语句是这么写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t(</span><br><span class="line">    col VARCHAR(10)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;因为表<code>t</code>的建表语句中并没有明确指定字符集和比较规则，则表<code>t</code>的字符集和比较规则将继承所在数据库<code>charset_demo_db</code>的字符集和比较规则，也就是<code>gb2312</code>和<code>gb2312_chinese_ci</code>。</p><h4 id="列级别"><a href="#列级别" class="headerlink" title="列级别"></a>列级别</h4><p>&amp;emsp;&amp;emsp;需要注意的是，对于存储字符串的列，<span style="color:red">同一个表中的不同的列也可以有不同的字符集和比较规则</span>。我们在创建和修改列定义的时候可以指定该列的字符集和比较规则，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],</span><br><span class="line">    其他列...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;比如我们修改一下表<code>t</code>中列<code>col</code>的字符集和比较规则可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE t MODIFY col VARCHAR(10) CHARACTER SET gbk COLLATE gbk_chinese_ci;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;对于某个列来说，如果在创建和修改的语句中没有指明字符集和比较规则，<span style="color:red">将使用该列所在表的字符集和比较规则作为该列的字符集和比较规则</span>。比方说表<code>t</code>的字符集是<code>utf8</code>，比较规则是<code>utf8_general_ci</code>，修改列<code>col</code>的语句是这么写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE t MODIFY col VARCHAR(10);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;那列<code>col</code>的字符集和编码将使用表<code>t</code>的字符集和比较规则，也就是<code>utf8</code>和<code>utf8_general_ci</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：在转换列的字符集时需要注意，如果转换前列中存储的数据不能用转换后的字符集进行表示，就会发生错误。比方说原先列使用的字符集是utf8，列中存储了一些汉字，现在把列的字符集转换为ascii的话就会出错，因为ascii字符集并不能表示汉字字符。</span><br></pre></td></tr></table></figure><h4 id="仅修改字符集或仅修改比较规则"><a href="#仅修改字符集或仅修改比较规则" class="headerlink" title="仅修改字符集或仅修改比较规则"></a>仅修改字符集或仅修改比较规则</h4><p>&amp;emsp;&amp;emsp;由于字符集和比较规则是互相有联系的，如果我们只修改了字符集，比较规则也会跟着变化，如果只修改了比较规则，字符集也会跟着变化，具体规则如下：</p><ul><li>只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。</li><li>只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。</li></ul><p>&amp;emsp;&amp;emsp;<span style="color:red">不论哪个级别的字符集和比较规则，这两条规则都适用</span>，我们以服务器级别的字符集和比较规则为例来看一下详细过程：</p><ul><li><p>只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET character_set_server = gb2312;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_server&#x27;;</span><br><span class="line">+----------------------+--------+</span><br><span class="line">| Variable_name        | Value  |</span><br><span class="line">+----------------------+--------+</span><br><span class="line">| character_set_server | gb2312 |</span><br><span class="line">+----------------------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  SHOW VARIABLES LIKE &#x27;collation_server&#x27;;</span><br><span class="line">+------------------+-------------------+</span><br><span class="line">| Variable_name    | Value             |</span><br><span class="line">+------------------+-------------------+</span><br><span class="line">| collation_server | gb2312_chinese_ci |</span><br><span class="line">+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;我们只修改了<code>character_set_server</code>的值为<code>gb2312</code>，<code>collation_server</code>的值自动变为了<code>gb2312_chinese_ci</code>。</p></li><li><p>只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET collation_server = utf8_general_ci;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_server&#x27;;</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| character_set_server | utf8  |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_server&#x27;;</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| Variable_name    | Value           |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| collation_server | utf8_general_ci |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;我们只修改了<code>collation_server</code>的值为<code>utf8_general_ci</code>，<code>character_set_server</code>的值自动变为了<code>utf8</code>。</p></li></ul><h4 id="各级别字符集和比较规则小结"><a href="#各级别字符集和比较规则小结" class="headerlink" title="各级别字符集和比较规则小结"></a>各级别字符集和比较规则小结</h4><p>&amp;emsp;&amp;emsp;我们介绍的这4个级别字符集和比较规则的联系如下：</p><ul><li>如果创建或修改列时，没有显式的指定字符集和比较规则，则该列默认用表的字符集和比较规则</li><li>如果创建或修改表时，没有显式的指定字符集和比较规则，则该表默认用数据库的字符集和比较规则</li><li>如果创建或修改数据库时，没有显式的指定字符集和比较规则，则该数据库默认用服务器的字符集和比较规则</li></ul><p>&amp;emsp;&amp;emsp;知道了这些规则之后，对于给定的表，我们应该知道它的各个列的字符集和比较规则是什么，从而根据这个列的类型来确定存储数据时每个列的实际数据占用的存储空间大小了。比方说我们向表<code>t</code>中插入一条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO t(col) VALUES(&#x27;我我&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM t;</span><br><span class="line">+--------+</span><br><span class="line">| s      |</span><br><span class="line">+--------+</span><br><span class="line">| 我我   |</span><br><span class="line">+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;首先列<code>col</code>使用的字符集是<code>gbk</code>，一个字符<code>&#39;我&#39;</code>在<code>gbk</code>中的编码为<code>0xCED2</code>，占用两个字节，两个字符的实际数据就占用4个字节。如果把该列的字符集修改为<code>utf8</code>的话，这两个字符就实际占用6个字节。</p><h3 id="客户端和服务器通信中的字符集"><a href="#客户端和服务器通信中的字符集" class="headerlink" title="客户端和服务器通信中的字符集"></a>客户端和服务器通信中的字符集</h3><h4 id="编码和解码使用的字符集不一致的后果"><a href="#编码和解码使用的字符集不一致的后果" class="headerlink" title="编码和解码使用的字符集不一致的后果"></a>编码和解码使用的字符集不一致的后果</h4><p>&amp;emsp;&amp;emsp;说到底，字符串在计算机上的体现就是一个字节串，如果你使用不同字符集去解码这个字节串，最后得到的结果可能让你挠头。</p><p>&amp;emsp;&amp;emsp;我们知道字符<code>&#39;我&#39;</code>在<code>utf8</code>字符集编码下的字节串长这样：<code>0xE68891</code>，如果一个程序把这个字节串发送到另一个程序里，另一个程序用不同的字符集去解码这个字节串，假设使用的是<code>gbk</code>字符集来解释这串字节，解码过程就是这样的：</p><ol><li><p>首先看第一个字节<code>0xE6</code>，它的值大于<code>0x7F</code>（十进制：127），说明是两字节编码，继续读一字节后是<code>0xE688</code>，然后从<code>gbk</code>编码表中查找字节为<code>0xE688</code>对应的字符，发现是字符<code>&#39;鎴&#39;</code></p></li><li><p>继续读一个字节<code>0x91</code>，它的值也大于<code>0x7F</code>，再往后读一个字节发现木有了，所以这是半个字符。</p></li><li><p>所以<code>0xE68891</code>被<code>gbk</code>字符集解释成一个字符<code>&#39;鎴&#39;</code>和半个字符。</p></li></ol><p>&amp;emsp;&amp;emsp;假设用<code>iso-8859-1</code>，也就是<code>latin1</code>字符集去解释这串字节，解码过程如下：</p><ol><li><p>先读第一个字节<code>0xE6</code>，它对应的<code>latin1</code>字符为<code>æ</code>。</p></li><li><p>再读第二个字节<code>0x88</code>，它对应的<code>latin1</code>字符为<code>ˆ</code>。</p></li><li><p>再读第二个字节<code>0x91</code>，它对应的<code>latin1</code>字符为<code>‘</code>。</p></li><li><p>所以整串字节<code>0xE68891</code>被<code>latin1</code>字符集解释后的字符串就是<code>&#39;æˆ‘&#39;</code></p></li></ol><p>&amp;emsp;&amp;emsp;可见，<span style="color:red">如果对于同一个字符串编码和解码使用的字符集不一样，会产生意想不到的结果</span>，作为人类的我们看上去就像是产生了乱码一样。</p><h4 id="字符集转换的概念"><a href="#字符集转换的概念" class="headerlink" title="字符集转换的概念"></a>字符集转换的概念</h4><p>&amp;emsp;&amp;emsp;如果接收<code>0xE68891</code>这个字节串的程序按照<code>utf8</code>字符集进行解码，然后又把它按照<code>gbk</code>字符集进行编码，最后编码后的字节串就是<code>0xCED2</code>，我们把这个过程称为<code>字符集的转换</code>，也就是字符串<code>&#39;我&#39;</code>从<code>utf8</code>字符集转换为<code>gbk</code>字符集。</p><h4 id="MySQL中字符集的转换"><a href="#MySQL中字符集的转换" class="headerlink" title="MySQL中字符集的转换"></a>MySQL中字符集的转换</h4><p>&amp;emsp;&amp;emsp;我们知道从客户端发往服务器的请求本质上就是一个字符串，服务器向客户端返回的结果本质上也是一个字符串，而字符串其实是使用某种字符集编码的二进制数据。这个字符串可不是使用一种字符集的编码方式一条道走到黑的，从发送请求到返回结果这个过程中伴随着多次字符集的转换，在这个过程中会用到3个系统变量，我们先把它们写出来看一下：</p><table><thead><tr><th align="center">系统变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>character_set_client</code></td><td align="center">服务器解码请求时使用的字符集</td></tr><tr><td align="center"><code>character_set_connection</code></td><td align="center">服务器处理请求时会把请求字符串从<code>character_set_client</code>转为<code>character_set_connection</code></td></tr><tr><td align="center"><code>character_set_results</code></td><td align="center">服务器向客户端返回数据时使用的字符集</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;这几个系统变量在我的计算机上的默认值如下（不同操作系统的默认值可能不同）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_client&#x27;;</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| character_set_client | utf8  |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_connection&#x27;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| character_set_connection | utf8  |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_results&#x27;;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| character_set_results | utf8  |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;大家可以看到这几个系统变量的值都是<code>utf8</code>，为了体现出字符集在请求处理过程中的变化，我们这里特意修改一个系统变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set character_set_connection = gbk;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;所以现在系统变量<code>character_set_client</code>和<code>character_set_results</code>的值还是<code>utf8</code>，而<code>character_set_connection</code>的值为<code>gbk</code>。现在假设我们客户端发送的请求是下面这个字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE s = &#x27;我&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;为了方便大家理解这个过程，我们只分析字符<code>&#39;我&#39;</code>在这个过程中字符集的转换。</p><p>&amp;emsp;&amp;emsp;现在看一下在请求从发送到结果返回过程中字符集的变化：</p><ol><li><p>客户端发送请求所使用的字符集</p><p> &amp;emsp;&amp;emsp;一般情况下客户端所使用的字符集和当前操作系统一致，不同操作系统使用的字符集可能不一样，如下：</p><ul><li>类<code>Unix</code>系统使用的是<code>utf8</code></li><li><code>Windows</code>使用的是<code>gbk</code></li></ul></li></ol><p>&amp;emsp;&amp;emsp;例如我在使用的<code>macOS</code>操作系统时，客户端使用的就是<code>utf8</code>字符集。所以字符<code>&#39;我&#39;</code>在发送给服务器的请求中的字节形式就是：<code>0xE68891</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：如果你使用的是可视化工具，比如navicat之类的，这些工具可能会使用自定义的字符集来编码发送到服务器的字符串，而不采用操作系统默认的字符集（所以在学习的时候还是尽量用黑框框）。</span><br></pre></td></tr></table></figure><ol start="2"><li><p>服务器接收到客户端发送来的请求其实是一串二进制的字节，它会认为这串字节采用的字符集是<code>character_set_client</code>，然后把这串字节转换为<code>character_set_connection</code>字符集编码的字符。</p><p> &amp;emsp;&amp;emsp;由于我的计算机上<code>character_set_client</code>的值是<code>utf8</code>，首先会按照<code>utf8</code>字符集对字节串<code>0xE68891</code>进行解码，得到的字符串就是<code>&#39;我&#39;</code>，然后按照<code>character_set_connection</code>代表的字符集，也就是<code>gbk</code>进行编码，得到的结果就是字节串<code>0xCED2</code>。</p></li><li><p>因为表<code>t</code>的列<code>col</code>采用的是<code>gbk</code>字符集，与<code>character_set_connection</code>一致，所以直接到列中找字节值为<code>0xCED2</code>的记录，最后找到了一条记录。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：如果某个列使用的字符集和character_set_connection代表的字符集不一致的话，还需要进行一次字符集转换。</span><br></pre></td></tr></table></figure><ol start="4"><li><p>上一步骤找到的记录中的<code>col</code>列其实是一个字节串<code>0xCED2</code>，<code>col</code>列是采用<code>gbk</code>进行编码的，所以首先会将这个字节串使用<code>gbk</code>进行解码，得到字符串<code>&#39;我&#39;</code>，然后再把这个字符串使用<code>character_set_results</code>代表的字符集，也就是<code>utf8</code>进行编码，得到了新的字节串：<code>0xE68891</code>，然后发送给客户端。</p></li><li><p>由于客户端是用的字符集是<code>utf8</code>，所以可以顺利的将<code>0xE68891</code>解释成字符<code>我</code>，从而显示到我们的显示器上，所以我们人类也读懂了返回的结果。</p></li></ol><p>&amp;emsp;&amp;emsp;如果你读上面的文字有点晕，可以参照这个图来仔细分析一下这几个步骤：</p><p><img src="/../images/03-01.png"></p><p>&amp;emsp;&amp;emsp;从这个分析中我们可以得出这么几点需要注意的地方：</p><ul><li><p>服务器认为客户端发送过来的请求是用<code>character_set_client</code>编码的。</p><p>  &amp;emsp;&amp;emsp;<span style="color:red">假设你的客户端采用的字符集和 <em><strong>character_set_client</strong></em> 不一样的话，这就会出现意想不到的情况</span>。比如我的客户端使用的是<code>utf8</code>字符集，如果把系统变量<code>character_set_client</code>的值设置为<code>ascii</code>的话，服务器可能无法理解我们发送的请求，更别谈处理这个请求了。</p></li><li><p>服务器将把得到的结果集使用<code>character_set_results</code>编码后发送给客户端。</p><p>  &amp;emsp;&amp;emsp;<span style="color:red">假设你的客户端采用的字符集和 <em><strong>character_set_results</strong></em> 不一样的话，这就可能会出现客户端无法解码结果集的情况</span>，结果就是在你的屏幕上出现乱码。比如我的客户端使用的是<code>utf8</code>字符集，如果把系统变量<code>character_set_results</code>的值设置为<code>ascii</code>的话，可能会产生乱码。</p></li><li><p><code>character_set_connection</code>只是服务器在将请求的字节串从<code>character_set_client</code>转换为<code>character_set_connection</code>时使用，它是什么其实没多重要，但是一定要注意，<span style="color:red">该字符集包含的字符范围一定涵盖请求中的字符</span>，要不然会导致有的字符无法使用<code>character_set_connection</code>代表的字符集进行编码。比如你把<code>character_set_client</code>设置为<code>utf8</code>，把<code>character_set_connection</code>设置成<code>ascii</code>，那么此时你如果从客户端发送一个汉字到服务器，那么服务器无法使用<code>ascii</code>字符集来编码这个汉字，就会向用户发出一个警告。</p></li></ul><p>&amp;emsp;&amp;emsp;知道了在<code>MySQL</code>中从发送请求到返回结果过程里发生的各种字符集转换，但是为什么要转来转去的呢？不晕么？</p><p>&amp;emsp;&amp;emsp;答：是的，很头晕，所以<span style="color:red">我们通常都把 <em><strong>character_set_client</strong></em> 、<em><strong>character_set_connection</strong></em>、<em><strong>character_set_results</strong></em> 这三个系统变量设置成和客户端使用的字符集一致的情况，这样减少了很多无谓的字符集转换</span>。为了方便我们设置，<code>MySQL</code>提供了一条非常简便的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET NAMES 字符集名;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这一条语句产生的效果和我们执行这3条的效果是一样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET character_set_client = 字符集名;</span><br><span class="line">SET character_set_connection = 字符集名;</span><br><span class="line">SET character_set_results = 字符集名;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;比方说我的客户端使用的是<code>utf8</code>字符集，所以需要把这几个系统变量的值都设置为<code>utf8</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET NAMES utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_client&#x27;;</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| character_set_client | utf8  |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  SHOW VARIABLES LIKE &#x27;character_set_connection&#x27;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| character_set_connection | utf8  |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;character_set_results&#x27;;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| character_set_results | utf8  |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：如果你使用的是Windows系统，那应该设置成gbk。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;另外，如果你想在启动客户端的时候就把<code>character_set_client</code>、<code>character_set_connection</code>、<code>character_set_results</code>这三个系统变量的值设置成一样的，那我们可以在启动客户端的时候指定一个叫<code>default-character-set</code>的启动选项，比如在配置文件里可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;它起到的效果和执行一遍<code>SET NAMES utf8</code>是一样一样的，都会将那三个系统变量的值设置成<code>utf8</code>。</p><h3 id="比较规则的应用"><a href="#比较规则的应用" class="headerlink" title="比较规则的应用"></a>比较规则的应用</h3><p>&amp;emsp;&amp;emsp;结束了字符集的漫游，我们把视角再次聚焦到<code>比较规则</code>，<code>比较规则</code>的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中，所以有时候也称为<code>排序规则</code>。比方说表<code>t</code>的列<code>col</code>使用的字符集是<code>gbk</code>，使用的比较规则是<code>gbk_chinese_ci</code>，我们向里边插入几条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO t(col) VALUES(&#x27;a&#x27;), (&#x27;b&#x27;), (&#x27;A&#x27;), (&#x27;B&#x27;);</span><br><span class="line">Query OK, 4 rows affected (0.00 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们查询的时候按照<code>t</code>列排序一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t ORDER BY col;</span><br><span class="line">+------+</span><br><span class="line">| col  |</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">| A    |</span><br><span class="line">| b    |</span><br><span class="line">| B    |</span><br><span class="line">| 我   |</span><br><span class="line">+------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到在默认的比较规则<code>gbk_chinese_ci</code>中是不区分大小写的，我们现在把列<code>col</code>的比较规则修改为<code>gbk_bin</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE t MODIFY col VARCHAR(10) COLLATE gbk_bin;</span><br><span class="line">Query OK, 5 rows affected (0.02 sec)</span><br><span class="line">Records: 5  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;由于<code>gbk_bin</code>是直接比较字符的编码，所以是区分大小写的，我们再看一下排序后的查询结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t ORDER BY s;</span><br><span class="line">+------+</span><br><span class="line">| s    |</span><br><span class="line">+------+</span><br><span class="line">| A    |</span><br><span class="line">| B    |</span><br><span class="line">| a    |</span><br><span class="line">| b    |</span><br><span class="line">| 我   |</span><br><span class="line">+------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;所以，如果以后大家在对字符串做比较或者对某个字符串列做排序操作时，没有得到想象中的结果，需要思考一下是不是<code>比较规则</code>的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">小贴士：</span><br><span class="line">列col中各个字符在使用gbk字符集编码后对应的数字如下：</span><br><span class="line">&#x27;A&#x27; -&gt; 65 （十进制）</span><br><span class="line">&#x27;B&#x27; -&gt; 66 （十进制）</span><br><span class="line">&#x27;a&#x27; -&gt; 97 （十进制）</span><br><span class="line">&#x27;b&#x27; -&gt; 98 （十进制）</span><br><span class="line">&#x27;我&#x27; -&gt; 25105 （十进制）</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p><code>字符集</code>指的是某个字符范围的编码规则。</p></li><li><p><code>比较规则</code>是针对某个字符集中的字符比较大小的一种规则。</p></li><li><p>在<code>MySQL</code>中，一个字符集可以有若干种比较规则，其中有一个默认的比较规则，一个比较规则必须对应一个字符集。</p></li><li><p>查看<code>MySQL</code>中查看支持的字符集和比较规则的语句如下：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];</span><br><span class="line">SHOW COLLATION [LIKE 匹配的模式];</span><br></pre></td></tr></table></figure></li><li><p>MySQL有四个级别的字符集和比较规则</p></li></ol><ul><li><p>服务器级别</p><p>&amp;emsp;&amp;emsp;<code>character_set_server</code>表示服务器级别的字符集，<code>collation_server</code>表示服务器级别的比较规则。</p></li><li><p>数据库级别</p><p>&amp;emsp;&amp;emsp;创建和修改数据库时可以指定字符集和比较规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br><span class="line"></span><br><span class="line">ALTER DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;<code>character_set_database</code>表示当前数据库的字符集，<code>collation_database</code>表示当前默认数据库的比较规则，这两个系统变量是只读的，不能修改。如果没有指定当前默认数据库，则变量与相应的服务器级系统变量具有相同的值。</p></li><li><p>表级别</p><p>&amp;emsp;&amp;emsp;创建和修改表的时候指定表的字符集和比较规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息)</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]];</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure></li><li><p>列级别</p><p>&amp;emsp;&amp;emsp;创建和修改列定义的时候可以指定该列的字符集和比较规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],</span><br><span class="line">    其他列...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure></li></ul><ol start="6"><li><p>从发送请求到接收结果过程中发生的字符集转换：</p><ul><li><p>客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。</p></li><li><p>服务器将客户端发送来的字节串采用<code>character_set_client</code>代表的字符集进行解码，将解码后的字符串再按照<code>character_set_connection</code>代表的字符集进行编码。</p></li><li><p>如果<code>character_set_connection</code>代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从<code>character_set_connection</code>代表的字符集转换为具体操作的列使用的字符集之后再进行操作。</p></li><li><p>将从某个列获取到的字节串从该列使用的字符集转换为<code>character_set_results</code>代表的字符集后发送到客户端。</p></li><li><p>客户端使用操作系统的字符集解析收到的结果集字节串。</p></li></ul></li></ol><p>&amp;emsp;&amp;emsp;在这个过程中各个系统变量的含义如下：</p><table><thead><tr><th align="center">系统变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>character_set_client</code></td><td align="center">服务器解码请求时使用的字符集</td></tr><tr><td align="center"><code>character_set_connection</code></td><td align="center">服务器处理请求时会把请求字符串从<code>character_set_client</code>转为<code>character_set_connection</code></td></tr><tr><td align="center"><code>character_set_results</code></td><td align="center">服务器向客户端返回数据时使用的字符集</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;一般情况下要使用保持这三个变量的值和客户端使用的字符集相同。</p><ol start="7"><li>比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中。</li></ol><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/04-%E4%BB%8E%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E8%AF%B4%E8%B5%B7-InnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2022/10/31/model-mysql/mysql/04-%E4%BB%8E%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E8%AF%B4%E8%B5%B7-InnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="第4章-从一条记录说起-InnoDB记录结构"><a href="#第4章-从一条记录说起-InnoDB记录结构" class="headerlink" title="第4章 从一条记录说起-InnoDB记录结构"></a>第4章 从一条记录说起-InnoDB记录结构</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>&amp;emsp;&amp;emsp;到现在为止，<code>MySQL</code>对于我们来说还是一个黑盒，我们只负责使用客户端发送请求并等待服务器返回结果，表中的数据到底存到了哪里？以什么格式存放的？<code>MySQL</code>是以什么方式来访问的这些数据？这些问题我们统统不知道，对于未知领域的探索向来就是社会主义核心价值观中的一部分，作为新一代社会主义接班人，不把它们搞懂怎么支援祖国建设呢？</p><p>&amp;emsp;&amp;emsp;我们前面介绍请求处理过程的时候提到过，<code>MySQL</code>服务器上负责对表中数据的读取和写入工作的部分是<code>存储引擎</code>，而服务器又支持不同类型的存储引擎，比如<code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>什么的，不同的存储引擎一般是由不同的人为实现不同的特性而开发的，<span style="color:red">真实数据在不同存储引擎中存放的格式一般是不同的</span>，甚至有的存储引擎比如<code>Memory</code>都不用磁盘来存储数据，也就是说关闭服务器后表中的数据就消失了。由于<code>InnoDB</code>是<code>MySQL</code>默认的存储引擎，也是我们最常用到的存储引擎，我们也没有那么多时间去把各个存储引擎的内部实现都看一遍，所以本集要介绍的是使用<code>InnoDB</code>作为存储引擎的数据存储结构，了解了一个存储引擎的数据存储结构之后，其他的存储引擎都是依葫芦画瓢，等我们用到了再说。</p><h2 id="InnoDB页简介"><a href="#InnoDB页简介" class="headerlink" title="InnoDB页简介"></a>InnoDB页简介</h2><p>&amp;emsp;&amp;emsp;<code>InnoDB</code>是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，<code>InnoDB</code>存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，<code>InnoDB</code>采取的方式是：<span style="color:red">将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 <em><strong>16</strong></em> KB</span>。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</p><h2 id="InnoDB行格式"><a href="#InnoDB行格式" class="headerlink" title="InnoDB行格式"></a>InnoDB行格式</h2><p>&amp;emsp;&amp;emsp;我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为<code>行格式</code>或者<code>记录格式</code>。设计<code>InnoDB</code>存储引擎的大佬们到现在为止设计了4种不同类型的<code>行格式</code>，分别是<code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code>和<code>Compressed</code>行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理上大体都是相同的。</p><h3 id="指定行格式的语法"><a href="#指定行格式的语法" class="headerlink" title="指定行格式的语法"></a>指定行格式的语法</h3><p>&amp;emsp;&amp;emsp;我们可以在创建或修改表的语句中指定<code>行格式</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</span><br><span class="line">    </span><br><span class="line">ALTER TABLE 表名 ROW_FORMAT=行格式名称</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;比如我们在<code>xiaohaizi</code>数据库里创建一个演示用的表<code>record_format_demo</code>，可以这样指定它的<code>行格式</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE xiaohaizi;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE record_format_demo (</span><br><span class="line">    -&gt;     c1 VARCHAR(10),</span><br><span class="line">    -&gt;     c2 VARCHAR(10) NOT NULL,</span><br><span class="line">    -&gt;     c3 CHAR(10),</span><br><span class="line">    -&gt;     c4 VARCHAR(10)</span><br><span class="line">    -&gt; ) CHARSET=ascii ROW_FORMAT=COMPACT;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到我们刚刚创建的这个表的<code>行格式</code>就是<code>Compact</code>，另外，我们还显式指定了这个表的字符集为<code>ascii</code>，因为<code>ascii</code>字符集只包括空格、标点符号、数字、大小写字母和一些不可见字符，所以我们的汉字是不能存到这个表里的。我们现在向这个表中插入两条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES(&#x27;aaaa&#x27;, &#x27;bbb&#x27;, &#x27;cc&#x27;, &#x27;d&#x27;), (&#x27;eeee&#x27;, &#x27;fff&#x27;, NULL, NULL);</span><br><span class="line">Query OK, 2 rows affected (0.02 sec)</span><br><span class="line">Records: 2  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;现在表中的记录就是这个样子的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM record_format_demo;</span><br><span class="line">+------+-----+------+------+</span><br><span class="line">| c1   | c2  | c3   | c4   |</span><br><span class="line">+------+-----+------+------+</span><br><span class="line">| aaaa | bbb | cc   | d    |</span><br><span class="line">| eeee | fff | NULL | NULL |</span><br><span class="line">+------+-----+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;演示表的内容也填充好了，现在我们就来看看各个行格式下的存储方式到底有什么不同吧～</p><h3 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式"></a>COMPACT行格式</h3><p>&amp;emsp;&amp;emsp;废话不多说，直接看图：</p><p><img src="/../images/04-01.png" alt="COMPACT行格式"></p><p>&amp;emsp;&amp;emsp;大家从图中可以看出来，一条完整的记录其实可以被分为<code>记录的额外信息</code>和<code>记录的真实数据</code>两大部分，下面我们详细看一下这两部分的组成。</p><h4 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h4><p>&amp;emsp;&amp;emsp;这部分信息是<span style="color:red">服务器为了描述这条记录而不得不额外添加的一些信息</span>，这些额外信息分为3类，分别是<code>变长字段长度列表</code>、<code>NULL值列表</code>和<code>记录头信息</code>，我们分别看一下。</p><h5 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h5><p>&amp;emsp;&amp;emsp;我们知道<code>MySQL</code>支持一些变长的数据类型，比如<code>VARCHAR(M)</code>、<code>VARBINARY(M)</code>、各种<code>TEXT</code>类型，各种<code>BLOB</code>类型，我们也可以把拥有这些数据类型的列称为<code>变长字段</code>，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把<code>MySQL</code>服务器搞懵，所以这些变长字段占用的存储空间分为两部分：</p><ol><li>真正的数据内容</li><li>占用的字节数</li></ol><p>&amp;emsp;&amp;emsp;在<code>Compact</code>行格式中，<span style="color:red">把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放</span>，我们再次强调一遍，是<span style="color:red">逆序</span>存放！</p><p>&amp;emsp;&amp;emsp;我们拿<code>record_format_demo</code>表中的第一条记录来举个例子。因为<code>record_format_demo</code>表的<code>c1</code>、<code>c2</code>、<code>c4</code>列都是<code>VARCHAR(10)</code>类型的，也就是变长的数据类型，所以这三个列的值的长度都需要保存在记录开头处，因为<code>record_format_demo</code>表中的各个列都使用的是<code>ascii</code>字符集，所以每个字符只需要1个字节来进行编码，来看一下第一条记录各变长字段内容的长度：</p><table><thead><tr><th align="center">列名</th><th align="center">存储内容</th><th align="center">内容长度（十进制表示）</th><th align="center">内容长度（十六进制表示）</th></tr></thead><tbody><tr><td align="center"><code>c1</code></td><td align="center"><code>&#39;aaaa&#39;</code></td><td align="center"><code>4</code></td><td align="center"><code>0x04</code></td></tr><tr><td align="center"><code>c2</code></td><td align="center"><code>&#39;bbb&#39;</code></td><td align="center"><code>3</code></td><td align="center"><code>0x03</code></td></tr><tr><td align="center"><code>c4</code></td><td align="center"><code>&#39;d&#39;</code></td><td align="center"><code>1</code></td><td align="center"><code>0x01</code></td></tr></tbody></table><p>&amp;emsp;&amp;emsp;又因为这些长度值需要按照列的<span style="color:red">逆序</span>存放，所以最后<code>变长字段长度列表</code>的字节串用十六进制表示的效果就是（各个字节之间实际上没有空格，用空格隔开只是方便理解）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01 03 04 </span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;把这个字节串组成的<code>变长字段长度列表</code>填入上面的示意图中的效果就是：</p><p><img src="/../images/04-02.png" alt="填入变长字段长度列表"></p><p>&amp;emsp;&amp;emsp;由于第一行记录中<code>c1</code>、<code>c2</code>、<code>c4</code>列中的字符串都比较短，也就是说内容占用的字节数比较小，用1个字节就可以表示，但是如果变长列的内容占用的字节数比较多，可能就需要用2个字节来表示。具体用1个还是2个字节来表示真实数据占用的字节数，<code>InnoDB</code>有它的一套规则，我们首先声明一下<code>W</code>、<code>M</code>和<code>L</code>的意思：</p><ol><li><p>假设某个字符集中表示一个字符最多需要使用的字节数为<code>W</code>，也就是使用<code>SHOW CHARSET</code>语句的结果中的<code>Maxlen</code>列，比方说<code>utf8</code>字符集中的<code>W</code>就是<code>3</code>，<code>gbk</code>字符集中的<code>W</code>就是<code>2</code>，<code>ascii</code>字符集中的<code>W</code>就是<code>1</code>。</p></li><li><p>对于变长类型<code>VARCHAR(M)</code>来说，这种类型表示能存储最多<code>M</code>个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是<code>M×W</code>。</p></li><li><p>假设它实际存储的字符串占用的字节数是<code>L</code>。</p></li></ol><p>&amp;emsp;&amp;emsp;所以确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是这样：</p><ul><li>如果<code>M×W &lt;= 255</code>，那么使用1个字节来表示真正字符串占用的字节数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是说InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数不大于255时，可以认为只使用1个字节来表示真正字符串占用的字节数。</span><br></pre></td></tr></table></figure><ul><li>如果<code>M×W &gt; 255</code>，则分为两种情况：<ul><li>如果<code>L &lt;= 127</code>，则用1个字节来表示真正字符串占用的字节数。</li><li>如果<code>L &gt; 127</code>，则用2个字节来表示真正字符串占用的字节数。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢？设计InnoDB的大佬使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，那该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0），如果该字节的第一个位为1，那该字节就是半个字段长度。</span><br><span class="line">对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中（我们后边会介绍），在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;总结一下就是说：如果该可变字段允许存储的最大字节数（<code>M×W</code>）超过255字节并且真实存储的字节数（<code>L</code>）超过127字节，则使用2个字节，否则使用1个字节。</p><p>&amp;emsp;&amp;emsp;另外需要注意的一点是，<span style="color:red">变长字段长度列表中只存储值为 <em><strong>非NULL</strong></em> 的列内容占用的长度，值为 <em><strong>NULL</strong></em> 的列的长度是不储存的 </span>。也就是说对于第二条记录来说，因为<code>c4</code>列的值为<code>NULL</code>，所以第二条记录的<code>变长字段长度列表</code>只需要存储<code>c1</code>和<code>c2</code>列的长度即可。其中<code>c1</code>列存储的值为<code>&#39;eeee&#39;</code>，占用的字节数为<code>4</code>，<code>c2</code>列存储的值为<code>&#39;fff&#39;</code>，占用的字节数为<code>3</code>。数字<code>4</code>可以用1个字节表示，<code>3</code>也可以用1个字节表示，所以整个<code>变长字段长度列表</code>共需2个字节。填充完<code>变长字段长度列表</code>的两条记录的对比图如下：</p><p><img src="/../images/04-03.png" alt="填充完`变长字段长度列表`的两条记录的对比图"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：并不是所有记录都有这个 变长字段长度列表 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。</span><br></pre></td></tr></table></figure><h5 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h5><p>&amp;emsp;&amp;emsp;我们知道表中的某些列可能存储<code>NULL</code>值，如果把这些<code>NULL</code>值都放到<code>记录的真实数据</code>中存储会很占地方，所以<code>Compact</code>行格式把这些值为<code>NULL</code>的列统一管理起来，存储到<code>NULL</code>值列表中，它的处理过程是这样的：</p><ol><li><p>首先统计表中允许存储<code>NULL</code>的列有哪些。</p><p> &amp;emsp;&amp;emsp;我们前面说过，主键列、被<code>NOT NULL</code>修饰的列都是不可以存储<code>NULL</code>值的，所以在统计的时候不会把这些列算进去。比方说表<code>record_format_demo</code>的3个列<code>c1</code>、<code>c3</code>、<code>c4</code>都是允许存储<code>NULL</code>值的，而<code>c2</code>列是被<code>NOT NULL</code>修饰，不允许存储<code>NULL</code>值。</p></li><li><p><span style="color:red">如果表中没有允许存储 <em><strong>NULL</strong></em> 的列，则 <em>NULL值列表</em> 也不存在了</span>，否则将每个允许存储<code>NULL</code>的列对应一个二进制位，二进制位按照列的顺序<span style="color:red">逆序</span>排列，二进制位表示的意义如下：</p><ul><li>二进制位的值为<code>1</code>时，代表该列的值为<code>NULL</code>。</li><li>二进制位的值为<code>0</code>时，代表该列的值不为<code>NULL</code>。</li></ul><p> &amp;emsp;&amp;emsp;因为表<code>record_format_demo</code>有3个值允许为<code>NULL</code>的列，所以这3个列和二进制位的对应关系就是这样：</p><p> <img src="/../images/04-04.png" alt="record_format_demo表3值对应关系">    </p><p> &amp;emsp;&amp;emsp;再一次强调，二进制位按照列的顺序<span style="color:red">逆序</span>排列，所以第一个列<code>c1</code>和最后一个二进制位对应。 </p></li><li><p><code>MySQL</code>规定<code>NULL值列表</code>必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补<code>0</code>。</p><p> &amp;emsp;&amp;emsp;表<code>record_format_demo</code>只有3个值允许为<code>NULL</code>的列，对应3个二进制位，不足一个字节，所以在字节的高位补<code>0</code>，效果就是这样：</p><p> <img src="/../images/04-05.png"></p><p> &amp;emsp;&amp;emsp;以此类推，如果一个表中有9个允许为<code>NULL</code>，那这个记录的<code>NULL</code>值列表部分就需要2个字节来表示了。</p></li></ol><p>&amp;emsp;&amp;emsp;知道了规则之后，我们再返回头看表<code>record_format_demo</code>中的两条记录中的<code>NULL值列表</code>应该怎么储存。因为只有<code>c1</code>、<code>c3</code>、<code>c4</code>这3个列允许存储<code>NULL</code>值，所以所有记录的<code>NULL值列表</code>只需要一个字节。</p><ul><li><p>对于第一条记录来说，<code>c1</code>、<code>c3</code>、<code>c4</code>这3个列的值都不为<code>NULL</code>，所以它们对应的二进制位都是<code>0</code>，画个图就是这样：</p><p>  <img src="/../images/04-06.png"><br>  &amp;emsp;&amp;emsp;所以第一条记录的<code>NULL值列表</code>用十六进制表示就是：<code>0x00</code>。</p></li><li><p>对于第二条记录来说，<code>c1</code>、<code>c3</code>、<code>c4</code>这3个列中<code>c3</code>和<code>c4</code>的值都为<code>NULL</code>，所以这3个列对应的二进制位的情况就是：</p><p>  <img src="/../images/04-07.png"></p><p>  &amp;emsp;&amp;emsp;所以第二条记录的<code>NULL值列表</code>用十六进制表示就是：<code>0x06</code>。</p></li></ul><p>&amp;emsp;&amp;emsp;所以这两条记录在填充了<code>NULL值列表</code>后的示意图就是这样：</p><p><img src="/../images/04-08.png"></p><h5 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h5><p>&amp;emsp;&amp;emsp;除了<code>变长字段长度列表</code>、<code>NULL值列表</code>之外，还有一个用于描述记录的<code>记录头信息</code>，它是由固定的<code>5</code>个字节组成。<code>5</code>个字节也就是<code>40</code>个二进制位，不同的位代表不同的意思，如图：</p><p><img src="/../images/04-09.png"></p><p>&amp;emsp;&amp;emsp;这些二进制位代表的详细信息如下表：</p><table><thead><tr><th align="center">名称</th><th align="center">大小（单位：bit）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>预留位1</code></td><td align="center"><code>1</code></td><td align="center">没有使用</td></tr><tr><td align="center"><code>预留位2</code></td><td align="center"><code>1</code></td><td align="center">没有使用</td></tr><tr><td align="center"><code>delete_mask</code></td><td align="center"><code>1</code></td><td align="center">标记该记录是否被删除</td></tr><tr><td align="center"><code>min_rec_mask</code></td><td align="center"><code>1</code></td><td align="center">B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td align="center"><code>n_owned</code></td><td align="center"><code>4</code></td><td align="center">表示当前记录拥有的记录数</td></tr><tr><td align="center"><code>heap_no</code></td><td align="center"><code>13</code></td><td align="center">表示当前记录在记录堆的位置信息</td></tr><tr><td align="center"><code>record_type</code></td><td align="center"><code>3</code></td><td align="center">表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶子节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录</td></tr><tr><td align="center"><code>next_record</code></td><td align="center"><code>16</code></td><td align="center">表示下一条记录的相对位置</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;大家不要被这么多的属性和陌生的概念给吓着，我这里只是为了内容的完整性把这些位代表的意思都写了出来，现在没必要把它们的意思都记住，记住也没什么用，现在只需要看一遍混个脸熟，等之后用到这些属性的时候我们再回过头来看。</p><p>&amp;emsp;&amp;emsp;因为我们并不清楚这些属性详细的用法，所以这里就不分析各个属性值是怎么产生的了，之后我们遇到会详细看的。所以我们现在直接看一下<code>record_format_demo</code>中的两条记录的<code>头信息</code>分别是什么：</p><p><img src="/../images/04-10.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：再一次强调，大家如果看不懂记录头信息里各个位代表的概念千万别纠结，我们后边会说的～</span><br></pre></td></tr></table></figure><h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p>&amp;emsp;&amp;emsp;对于<code>record_format_demo</code>表来说，<code>记录的真实数据</code>除了<code>c1</code>、<code>c2</code>、<code>c3</code>、<code>c4</code>这几个我们自己定义的列的数据以外，<code>MySQL</code>会为每个记录默认的添加一些列（也称为<code>隐藏列</code>），具体的列如下：</p><table><thead><tr><th align="center">列名</th><th align="center">是否必须</th><th align="center">占用空间</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>row_id</code></td><td align="center">否</td><td align="center"><code>6</code>字节</td><td align="center">行ID，唯一标识一条记录</td></tr><tr><td align="center"><code>transaction_id</code></td><td align="center">是</td><td align="center"><code>6</code>字节</td><td align="center">事务ID</td></tr><tr><td align="center"><code>roll_pointer</code></td><td align="center">是</td><td align="center"><code>7</code>字节</td><td align="center">回滚指针</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，我们为了美观才写成了row_id、transaction_id和roll_pointer。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这里需要提一下<code>InnoDB</code>表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个<code>Unique</code>键作为主键，如果表中连<code>Unique</code>键都没有定义的话，则<code>InnoDB</code>会为表默认添加一个名为<code>row_id</code>的隐藏列作为主键。所以我们从上表中可以看出：<span style="color:red">InnoDB存储引擎会为每条记录都添加 <em><strong>transaction_id</strong></em> 和 <em><strong>roll_pointer</strong></em> 这两个列，但是 <em><strong>row_id</strong></em> 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）</span>。这些隐藏列的值不用我们操心，<code>InnoDB</code>存储引擎会自己帮我们生成的。</p><p>&amp;emsp;&amp;emsp;因为表<code>record_format_demo</code>并没有定义主键，所以<code>MySQL</code>服务器会为每条记录增加上述的3个列。现在看一下加上<code>记录的真实数据</code>的两个记录长什么样吧：</p><p><img src="/../images/04-11.png"></p><p>&amp;emsp;&amp;emsp;看这个图的时候我们需要注意几点：</p><ol><li><p>表<code>record_format_demo</code>使用的是<code>ascii</code>字符集，所以<code>0x61616161</code>就表示字符串<code>&#39;aaaa&#39;</code>，<code>0x626262</code>就表示字符串<code>&#39;bbb&#39;</code>，以此类推。</p></li><li><p>注意第1条记录中<code>c3</code>列的值，它是<code>CHAR(10)</code>类型的，它实际存储的字符串是：<code>&#39;cc&#39;</code>，而<code>ascii</code>字符集中的字节表示是<code>&#39;0x6363&#39;</code>，虽然表示这个字符串只占用了2个字节，但整个<code>c3</code>列仍然占用了10个字节的空间，除真实数据以外的8个字节的统统都用<span style="color:red">空格字符</span>填充，空格字符在<code>ascii</code>字符集的表示就是<code>0x20</code>。</p></li><li><p>注意第2条记录中<code>c3</code>和<code>c4</code>列的值都为<code>NULL</code>，它们被存储在了前面的<code>NULL值列表</code>处，在记录的真实数据处就不再冗余存储，从而节省存储空间。</p></li></ol><h4 id="CHAR-M-列的存储格式"><a href="#CHAR-M-列的存储格式" class="headerlink" title="CHAR(M)列的存储格式"></a>CHAR(M)列的存储格式</h4><p>&amp;emsp;&amp;emsp;<code>record_format_demo</code>表的<code>c1</code>、<code>c2</code>、<code>c4</code>列的类型是<code>VARCHAR(10)</code>，而<code>c3</code>列的类型是<code>CHAR(10)</code>，我们说在<code>Compact</code>行格式下只会把变长类型的列的长度<span style="color:red">逆序</span>存到<code>变长字段长度列表</code>中，就像这样：</p><p><img src="/../images/04-12.png"></p><p>&amp;emsp;&amp;emsp;但是这只是因为我们的<code>record_format_demo</code>表采用的是<code>ascii</code>字符集，这个字符集是一个定长字符集，也就是说表示一个字符采用固定的一个字节，如果采用变长的字符集（也就是表示一个字符需要的字节数不确定，比如<code>gbk</code>表示一个字符要1~2个字节、<code>utf8</code>表示一个字符要1~3个字节等）的话，<code>c3</code>列的长度也会被存储到<code>变长字段长度列表</code>中，比如我们修改一下<code>record_format_demo</code>表的字符集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE record_format_demo MODIFY COLUMN c3 CHAR(10) CHARACTER SET utf8;</span><br><span class="line">Query OK, 2 rows affected (0.02 sec)</span><br><span class="line">Records: 2  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;修改该列字符集后记录的<code>变长字段长度列表</code>也发生了变化，如图：</p><p><img src="/../images/04-13.png"></p><p>&amp;emsp;&amp;emsp;这就意味着：<span style="color:red">对于 <em><strong>CHAR(M)</strong></em> 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表</span>。</p><p>&amp;emsp;&amp;emsp;另外有一点还需要注意，变长字符集的<code>CHAR(M)</code>类型的列要求至少占用<code>M</code>个字节，而<code>VARCHAR(M)</code>却没有这个要求。比方说对于使用<code>utf8</code>字符集的<code>CHAR(10)</code>的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用<code>10</code>个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。（这里你感受到设计<code>Compact</code>行格式的大佬既想节省存储空间，又不想更新<code>CHAR(M)</code>类型的列产生碎片时的纠结心情了吧。）</p><h3 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h3><p>&amp;emsp;&amp;emsp;其实知道了<code>Compact</code>行格式之后，其他的行格式就是依葫芦画瓢了。我们现在要介绍的<code>Redundant</code>行格式是<code>MySQL5.0</code>之前用的一种行格式，也就是说它已经非常老了，但是本着知识完整性的角度还是要提一下，大家乐呵乐呵的看就好。</p><p>&amp;emsp;&amp;emsp;画个图展示一下<code>Redundant</code>行格式的全貌：</p><p><img src="/../images/04-14.png"></p><p>&amp;emsp;&amp;emsp;现在我们把表<code>record_format_demo</code>的行格式修改为<code>Redundant</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE record_format_demo ROW_FORMAT=Redundant;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;为了方便大家理解和节省篇幅，我们直接把表<code>record_format_demo</code>在<code>Redundant</code>行格式下的两条记录的真实存储数据提供出来，之后我们着重分析两种行格式的不同即可。</p><p><img src="/../images/04-15.png"></p><p>&amp;emsp;&amp;emsp;下面我们从各个方面看一下<code>Redundant</code>行格式有什么不同的地方：</p><ul><li><p>字段长度偏移列表</p><p>  &amp;emsp;&amp;emsp;注意<code>Compact</code>行格式的开头是<code>变长字段长度列表</code>，而<code>Redundant</code>行格式的开头是<code>字段长度偏移列表</code>，与<code>变长字段长度列表</code>有两处不同：</p><ul><li><p>没有了<span style="color:red">变长</span>两个字，意味着<code>Redundant</code>行格式会把该条记录中<span style="color:red">所有列</span>（包括<code>隐藏列</code>）的长度信息都按照<span style="color:red">逆序</span>存储到<code>字段长度偏移列表</code>。</p></li><li><p>多了个<span style="color:red">偏移</span>两个字，这意味着计算列值长度的方式不像<code>Compact</code>行格式那么直观，它是采用两个相邻数值的<span style="color:red">差值</span>来计算各个列值的长度。</p><p>  比如第一条记录的<code>字段长度偏移列表</code>就是：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25 24 1A 17 13 0C 06</span><br></pre></td></tr></table></figure><p>  因为它是逆序排放的，所以按照列的顺序排列就是：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">06 0C 13 17 1A 24 25</span><br></pre></td></tr></table></figure><p>  按照两个相邻数值的<span style="color:red">差值</span>来计算各个列值的长度的意思就是：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一列(`row_id`)的长度就是 0x06个字节，也就是6个字节。</span><br><span class="line">第二列(`transaction_id`)的长度就是 (0x0C - 0x06)个字节，也就是6个字节。</span><br><span class="line">第三列(`roll_pointer`)的长度就是 (0x13 - 0x0C)个字节，也就是7个字节。</span><br><span class="line">第四列(`c1`)的长度就是 (0x17 - 0x13)个字节，也就是4个字节。</span><br><span class="line">第五列(`c2`)的长度就是 (0x1A - 0x17)个字节，也就是3个字节。</span><br><span class="line">第六列(`c3`)的长度就是 (0x24 - 0x1A)个字节，也就是10个字节。</span><br><span class="line">第七列(`c4`)的长度就是 (0x25 - 0x24)个字节，也就是1个字节。</span><br></pre></td></tr></table></figure></li></ul></li><li><p>记录头信息  </p><p>  &amp;emsp;&amp;emsp;<code>Redundant</code>行格式的记录头信息占用<code>6</code>字节，<code>48</code>个二进制位，这些二进制位代表的意思如下：</p></li></ul><table><thead><tr><th align="center">名称</th><th align="center">大小（单位：bit）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>预留位1</code></td><td align="center"><code>1</code></td><td align="center">没有使用</td></tr><tr><td align="center"><code>预留位2</code></td><td align="center"><code>1</code></td><td align="center">没有使用</td></tr><tr><td align="center"><code>delete_mask</code></td><td align="center"><code>1</code></td><td align="center">标记该记录是否被删除</td></tr><tr><td align="center"><code>min_rec_mask</code></td><td align="center"><code>1</code></td><td align="center">B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td align="center"><code>n_owned</code></td><td align="center"><code>4</code></td><td align="center">表示当前记录拥有的记录数</td></tr><tr><td align="center"><code>heap_no</code></td><td align="center"><code>13</code></td><td align="center">表示当前记录在页面堆的位置信息</td></tr><tr><td align="center"><code>n_field</code></td><td align="center"><code>10</code></td><td align="center">表示记录中列的数量</td></tr><tr><td align="center"><code>1byte_offs_flag</code></td><td align="center"><code>1</code></td><td align="center">标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示的</td></tr><tr><td align="center"><code>next_record</code></td><td align="center"><code>16</code></td><td align="center">表示下一条记录的相对位置</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;第一条记录中的头信息是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 00 10 0F 00 BC</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;根据这六个字节可以计算出各个属性的值，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">预留位1：0x00</span><br><span class="line">预留位2：0x00</span><br><span class="line">delete_mask: 0x00</span><br><span class="line">min_rec_mask: 0x00</span><br><span class="line">n_owned: 0x00</span><br><span class="line">heap_no: 0x02</span><br><span class="line">n_field: 0x07</span><br><span class="line">1byte_offs_flag: 0x01</span><br><span class="line">next_record:0xBC</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;与<code>Compact</code>行格式的记录头信息对比来看，有两处不同：<br>    1. Redundant 行格式多了 n_field 和 1byte_offs_flag 这两个属性。<br>    2. Redundant 行格式没有 record_type 这个属性。</p><ul><li><p><code>1byte_offs_flag</code>的值是怎么选择的</p><p>  &amp;emsp;&amp;emsp;<code>字段长度偏移列表</code>实质上是存储每个列中的值占用的空间在<code>记录的真实数据</code>处结束的位置，还是拿<code>record_format_demo</code>第一条记录为例，<code>0x06</code>代表第一个列在<code>记录的真实数据</code>第6个字节处结束，<code>0x0C</code>代表第二个列在<code>记录的真实数据</code>第12个字节处结束，<code>0x13</code>代表第三个列在<code>记录的真实数据</code>第19个字节处结束，等等等等，最后一个列对应的偏移量值为<code>0x25</code>，也就意味着最后一个列在<code>记录的真实数据</code>第37个字节处结束，也就意味着整条记录的<code>真实数据</code>实际上占用<code>37</code>个字节。</p><p>  &amp;emsp;&amp;emsp;我们前面说过每个列对应的偏移量可以占用1个字节或者2个字节来存储，那到底什么时候用1个字节，什么时候用2个字节呢？其实是根据该条<code>Redundant</code>行格式<code>记录的真实数据</code>占用的总大小来判断的：</p><ul><li>当记录的真实数据占用的字节数不大于127（十六进制<code>0x7F</code>，二进制<code>01111111</code>）时，每个列对应的偏移量占用1个字节。</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：如果整个记录的真实数据占用的存储空间都不大于127个字节，那么每个列对应的偏移量值肯定也就不大于127，也就可以使用1个字节来表示喽。</span><br></pre></td></tr></table></figure><ul><li><p>当记录的真实数据占用的字节数大于127，但不大于32767（十六进制<code>0x7FFF</code>，二进制<code>0111111111111111</code>）时，每个列对应的偏移量占用2个字节。</p></li><li><p>有没有记录的真实数据大于32767的情况呢？有，不过此时的记录已经存放到了溢出页中，在本页中只保留前<code>768</code>个字节和20个字节的溢出页面地址（当然这20个字节中还记录了一些别的信息）。因为<code>字段长度偏移列表</code>处只需要记录每个列在本页面中的偏移就好了，所以每个列使用2个字节来存储偏移量就够了。</p></li></ul><p>  &amp;emsp;&amp;emsp;大家可以看出来，设计<code>Redundant</code>行格式的大佬还是比较简单粗暴的，直接使用整个<code>记录的真实数据</code>长度来决定使用1个字节还是2个字节存储列对应的偏移量。只要整条记录的真实数据占用的存储空间大小大于127，即使第一个列的值占用存储空间小于127，那对不起，也需要使用2个字节来表示该列对应的偏移量。简单粗暴，就是这么简单粗暴（所以这种行格式有些过时了～）。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：大家有没有疑惑，一个字节能表示的范围是0～255，为什么在记录的真实数据占用的存储空间大于127时就采用2个字节表示各个列的偏移量呢？稍安勿躁，后边马上揭晓。</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;为了在解析记录时知道每个列的偏移量是使用1个字节还是2个字节表示的，设计<code>Redundant</code>行格式的大佬特意在<code>记录头信息</code>里放置了一个称之为<code>1byte_offs_flag</code>的属性：  </p><ul><li>当它的值为1时，表明使用1个字节存储。</li><li>当它的值为0时，表明使用2个字节存储。</li></ul></li><li><p><code>Redundant</code>行格式中<code>NULL</code>值的处理</p><p>  &amp;emsp;&amp;emsp;因为<code>Redundant</code>行格式并没有<code>NULL值列表</code>，所以设计<code>Redundant</code>行格式的大佬在<code>字段长度偏移列表</code>中的各个列对应的偏移量处做了一些特殊处理 —— 将列对应的偏移量值的第一个比特位作为是否为<code>NULL</code>的依据，该比特位也可以被称之为<code>NULL比特位</code>。也就是说在解析一条记录的某个列时，首先看一下该列对应的偏移量的<code>NULL比特位</code>是不是为<code>1</code>，如果为<code>1</code>，那么该列的值就是<code>NULL</code>，否则不是<code>NULL</code>。</p><p>  &amp;emsp;&amp;emsp;这也就解释了上面介绍为什么只要记录的真实数据大于127（十六进制<code>0x7F</code>，二进制<code>01111111</code>）时，就采用2个字节来表示一个列对应的偏移量，主要是第一个比特位是所谓的<code>NULL比特位</code>，用来标记该列的值是否为<code>NULL</code>。</p><p>  &amp;emsp;&amp;emsp;但是还有一点要注意，对于值为<code>NULL</code>的列来说，该列的类型是否为定长类型决定了<code>NULL</code>值的实际存储方式，我们接下来分析一下<code>record_format_demo</code>表的第二条记录，它对应的<code>字段长度偏移列表</code>如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A4 A4 1A 17 13 0C 06</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;按照列的顺序排放就是：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">06 0C 13 17 1A A4 A4</span><br></pre></td></tr></table></figure><p>  我们分情况看一下：    </p><ul><li><p>如果存储<code>NULL</code>值的字段是定长类型的，比方说<code>CHAR(M)</code>数据类型的，则<code>NULL</code>值也将占用记录的真实数据部分，并把该字段对应的数据使用<code>0x00</code>字节填充。</p><p>  &amp;emsp;&amp;emsp;如图第二条记录的<code>c3</code>列的值是<code>NULL</code>，而<code>c3</code>列的类型是<code>CHAR(10)</code>，占用记录的真实数据部分10字节，所以我们看到在<code>Redundant</code>行格式中使用<code>0x00000000000000000000</code>来表示<code>NULL</code>值。</p><p>  &amp;emsp;&amp;emsp;另外，<code>c3</code>列对应的偏移量为<code>0xA4</code>，它对应的二进制实际是：<code>10100100</code>，可以看到最高位为<code>1</code>，意味着该列的值是<code>NULL</code>。将最高位去掉后的值变成了<code>0100100</code>，对应的十进制值为<code>36</code>，而<code>c2</code>列对应的偏移量为<code>0x1A</code>，也就是十进制的<code>26</code>。<code>36 - 26 = 10</code>，也就是说最终<code>c3</code>列占用的存储空间为10个字节。</p></li><li><p>如果该存储<code>NULL</code>值的字段是变长数据类型的，则不在<code>记录的真实数据</code>处占用任何存储空间。</p><p>  &amp;emsp;&amp;emsp;比如<code>record_format_demo</code>表的<code>c4</code>列是<code>VARCHAR(10)</code>类型的，<code>VARCHAR(10)</code>是一个变长数据类型，<code>c4</code>列对应的偏移量为<code>0xA4</code>，与<code>c3</code>列对应的偏移量相同，这也就意味着它的值也为<code>NULL</code>，将<code>0xA4</code>的最高位去掉后对应的十进制值也是<code>36</code>，<code>36 - 36 = 0</code>，也就意味着<code>c4</code>列本身不占用任何<code>记录的实际数据</code>处的空间。</p></li></ul></li></ul><p>&amp;emsp;&amp;emsp;除了以上的几点之外，<code>Redundant</code>行格式和<code>Compact</code>行格式还是大致相同的。</p><h4 id="CHAR-M-列的存储格式-1"><a href="#CHAR-M-列的存储格式-1" class="headerlink" title="CHAR(M)列的存储格式"></a>CHAR(M)列的存储格式</h4><p>&amp;emsp;&amp;emsp;我们知道<code>Compact</code>行格式在<code>CHAR(M)</code>类型的列中存储数据的时候还挺麻烦，分变长字符集和定长字符集的情况，而在<code>Redundant</code>行格式中十分干脆，不管该列使用的字符集是什么，只要是使用<code>CHAR(M)</code>类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和<code>M</code>的乘积。比方说使用<code>utf8</code>字符集的<code>CHAR(10)</code>类型的列占用的真实数据空间始终为<code>30</code>个字节，使用<code>gbk</code>字符集的<code>CHAR(10)</code>类型的列占用的真实数据空间始终为<code>20</code>个字节。由此可以看出来，使用<code>Redundant</code>行格式的<code>CHAR(M)</code>类型的列是不会产生碎片的。</p><h3 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h3><h4 id="VARCHAR-M-最多能存储的数据"><a href="#VARCHAR-M-最多能存储的数据" class="headerlink" title="VARCHAR(M)最多能存储的数据"></a>VARCHAR(M)最多能存储的数据</h4><p>&amp;emsp;&amp;emsp;我们知道对于<code>VARCHAR(M)</code>类型的列最多可以占用<code>65535</code>个字节。其中的<code>M</code>代表该类型最多存储的字符数量，如果我们使用<code>ascii</code>字符集的话，一个字符就代表一个字节，我们看看<code>VARCHAR(65535)</code>是否可用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE varchar_size_demo(</span><br><span class="line">    -&gt;     c VARCHAR(65535)</span><br><span class="line">    -&gt; ) CHARSET=ascii ROW_FORMAT=Compact;</span><br><span class="line">ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;从报错信息里可以看出，<code>MySQL</code>对一条记录占用的最大存储空间是有限制的，除了<code>BLOB</code>或者<code>TEXT</code>类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过<code>65535</code>个字节。所以<code>MySQL</code>服务器建议我们把存储类型改为<code>TEXT</code>或者<code>BLOB</code>的类型。这个<code>65535</code>个字节除了列本身的数据之外，还包括一些其他的数据（<code>storage overhead</code>），比如说我们为了存储一个<code>VARCHAR(M)</code>类型的列，其实需要占用3部分存储空间：</p><ul><li>真实数据</li><li>真实数据占用字节的长度</li><li><code>NULL</code>值标识，如果该列有<code>NOT NULL</code>属性则可以没有这部分存储空间</li></ul><p>&amp;emsp;&amp;emsp;如果该<code>VARCHAR</code>类型的列没有<code>NOT NULL</code>属性，那最多只能存储<code>65532</code>个字节的数据，因为真实数据的长度可能占用2个字节，<code>NULL</code>值标识需要占用1个字节：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE varchar_size_demo(</span><br><span class="line">    -&gt;      c VARCHAR(65532)</span><br><span class="line">    -&gt; ) CHARSET=ascii ROW_FORMAT=Compact;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;如果<code>VARCHAR</code>类型的列有<code>NOT NULL</code>属性，那最多只能存储<code>65533</code>个字节的数据，因为真实数据的长度可能占用2个字节，不需要<code>NULL</code>值标识：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP TABLE varchar_size_demo;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE varchar_size_demo(</span><br><span class="line">    -&gt;      c VARCHAR(65533) NOT NULL</span><br><span class="line">    -&gt; ) CHARSET=ascii ROW_FORMAT=Compact;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;如果<code>VARCHAR(M)</code>类型的列使用的不是<code>ascii</code>字符集，那会怎么样呢？来看一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP TABLE varchar_size_demo;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE varchar_size_demo(</span><br><span class="line">    -&gt;       c VARCHAR(65532)</span><br><span class="line">    -&gt; ) CHARSET=gbk ROW_FORMAT=Compact;</span><br><span class="line">ERROR 1074 (42000): Column length too big for column &#x27;c&#x27; (max = 32767); use BLOB or TEXT instead</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE varchar_size_demo(</span><br><span class="line">    -&gt;       c VARCHAR(65532)</span><br><span class="line">    -&gt; ) CHARSET=utf8 ROW_FORMAT=Compact;</span><br><span class="line">ERROR 1074 (42000): Column length too big for column &#x27;c&#x27; (max = 21845); use BLOB or TEXT instead</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;从执行结果中可以看出，如果<code>VARCHAR(M)</code>类型的列使用的不是<code>ascii</code>字符集，那<code>M</code>的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为<code>NULL</code>的情况下，<code>gbk</code>字符集表示一个字符最多需要<code>2</code>个字节，那在该字符集下，<code>M</code>的最大取值就是<code>32766</code>（也就是：65532&#x2F;2），也就是说最多能存储<code>32766</code>个字符；<code>utf8</code>字符集表示一个字符最多需要<code>3</code>个字节，那在该字符集下，<code>M</code>的最大取值就是<code>21844</code>，就是说最多能存储<code>21844</code>（也就是：65532&#x2F;3）个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：上述所言在列的值允许为NULL的情况下，gbk字符集下M的最大取值就是32766，utf8字符集下M的最大取值就是21844，这都是在表中只有一个字段的情况下说的，一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！</span><br></pre></td></tr></table></figure><h4 id="记录中的数据太多产生的溢出"><a href="#记录中的数据太多产生的溢出" class="headerlink" title="记录中的数据太多产生的溢出"></a>记录中的数据太多产生的溢出</h4><p>&amp;emsp;&amp;emsp;我们以<code>ascii</code>字符集下的<code>varchar_size_demo</code>表为例，插入一条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE varchar_size_demo(</span><br><span class="line">    -&gt;       c VARCHAR(65532)</span><br><span class="line">    -&gt; ) CHARSET=ascii ROW_FORMAT=Compact;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO varchar_size_demo(c) VALUES(REPEAT(&#x27;a&#x27;, 65532));</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;其中的<code>REPEAT(&#39;a&#39;, 65532)</code>是一个函数调用，它表示生成一个把字符<code>&#39;a&#39;</code>重复<code>65532</code>次的字符串。前面说过，<code>MySQL</code>中磁盘和内存交互的基本单位是<code>页</code>，也就是说<code>MySQL</code>是以<code>页</code>为基本单位来管理存储空间的，我们的记录都会被分配到某个<code>页</code>中存储。而一个页的大小一般是<code>16KB</code>，也就是<code>16384</code>字节，而一个<code>VARCHAR(M)</code>类型的列就最多可以存储<code>65532</code>个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。</p><p>&amp;emsp;&amp;emsp;在<code>Compact</code>和<code>Reduntant</code>行格式中，对于占用存储空间非常大的列，在<code>记录的真实数据</code>处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后<code>记录的真实数据</code>处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，如图所示：</p><p><img src="/../images/04-16.png"></p><p>&amp;emsp;&amp;emsp;从图中可以看出来，对于<code>Compact</code>和<code>Reduntant</code>行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前<code>768</code>个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做<code>行溢出</code>，存储超出<code>768</code>字节的那些页面也被称为<code>溢出页</code>。画一个简图就是这样：</p><p><img src="/../images/04-17.png"></p><p>&amp;emsp;&amp;emsp;最后需要注意的是，<span style="color:red">不只是 <em><strong>VARCHAR(M)</strong></em> 类型的列，其他的 <em><strong>TEXT</strong></em>、<em><strong>BLOB</strong></em> 类型的列在存储数据非常多的时候也会发生<code>行溢出</code></span>。</p><h4 id="行溢出的临界点"><a href="#行溢出的临界点" class="headerlink" title="行溢出的临界点"></a>行溢出的临界点</h4><p>&amp;emsp;&amp;emsp;那发生<code>行溢出</code>的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生<code>行溢出</code>？</p><p>&amp;emsp;&amp;emsp;<code>MySQL</code>中规定<span style="color:red">一个页中至少存放两行记录</span>，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。以上面的<code>varchar_size_demo</code>表为例，它只有一个列<code>c</code>，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会<code>行溢出</code>的现象呢？这得分析一下页中的空间都是如何利用的。</p><ul><li><p>每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要<code>136</code>个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。</p></li><li><p>每个记录需要的额外信息是<code>27</code>字节。</p><p>  这27个字节包括下面这些部分：</p><ul><li>2个字节用于存储真实数据的长度</li><li>1个字节用于存储列是否是NULL值</li><li>5个字节大小的头信息</li><li>6个字节的<code>row_id</code>列</li><li>6个字节的<code>transaction_id</code>列</li><li>7个字节的<code>roll_pointer</code>列</li></ul></li></ul><p>&amp;emsp;&amp;emsp;假设一个列中存储的数据字节数为n，那么发生<code>行溢出</code>现象时需要满足这个式子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">136 + 2×(27 + n) &gt; 16384</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;求解这个式子得出的解是：<code>n &gt; 8098</code>。也就是说如果一个列中存储的数据不大于<code>8098</code>个字节，那就不会发生<code>行溢出</code>，否则就会发生<code>行溢出</code>。不过这个<code>8098</code>个字节的结论只是针对只有一个列的<code>varchar_size_demo</code>表来说的，如果表中有多个列，那上面的式子和结论都需要改一改了，所以重点就是：<span style="color:red">你不用关注这个临界点是什么，只要知道如果我们向一个行中存储了很大的数据时，可能发生<code>行溢出</code>的现象</span>。</p><h3 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a>Dynamic和Compressed行格式</h3><p>&amp;emsp;&amp;emsp;下面要介绍另外两个行格式，<code>Dynamic</code>和<code>Compressed</code>行格式，我现在使用的<code>MySQL</code>版本是<code>5.7</code>，它的默认行格式就是<code>Dynamic</code>，这俩行格式和<code>Compact</code>行格式挺像，只不过在处理<code>行溢出</code>数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前<code>768</code>个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：</p><p><img src="/../images/04-18.png"></p><p>&amp;emsp;&amp;emsp;<code>Compressed</code>行格式和<code>Dynamic</code>不同的一点是，<code>Compressed</code>行格式会采用压缩算法对页面进行压缩，以节省空间。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>页是<code>MySQL</code>中磁盘和内存交互的基本单位，也是<code>MySQL</code>是管理存储空间的基本单位。</p></li><li><p>指定和修改行格式的语法如下：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 ROW_FORMAT=行格式名称</span><br></pre></td></tr></table></figure></li><li><p><code>InnoDB</code>目前定义了4种行格式</p><ul><li><p>COMPACT行格式</p><p>  具体组成如图：<br>  <img src="/../images/04-19.png"></p></li><li><p>Redundant行格式</p><p>  具体组成如图：<br>  <img src="/../images/04-20.png"></p></li><li><p>Dynamic和Compressed行格式</p><p>  &amp;emsp;&amp;emsp;这两种行格式类似于<code>COMPACT行格式</code>，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。</p><p>  &amp;emsp;&amp;emsp;另外，<code>Compressed</code>行格式会采用压缩算法对页面进行压缩。</p></li></ul></li></ol><ul><li><p>一个页一般是<code>16KB</code>，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为<code>行溢出</code>。</p></li></ul><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/05-%E7%9B%9B%E6%94%BE%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%A7%E7%9B%92%E5%AD%90-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/"/>
      <url>/2022/10/31/model-mysql/mysql/05-%E7%9B%9B%E6%94%BE%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%A7%E7%9B%92%E5%AD%90-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="第5章-盛放记录的大盒子-InnoDB数据页结构"><a href="#第5章-盛放记录的大盒子-InnoDB数据页结构" class="headerlink" title="第5章 盛放记录的大盒子-InnoDB数据页结构"></a>第5章 盛放记录的大盒子-InnoDB数据页结构</h1><h2 id="不同类型的页简介"><a href="#不同类型的页简介" class="headerlink" title="不同类型的页简介"></a>不同类型的页简介</h2><p>&amp;emsp;&amp;emsp;前面我们简单提了一下<code>页</code>的概念，它是<code>InnoDB</code>管理存储空间的基本单位，一个页的大小一般是<code>16KB</code>。<code>InnoDB</code>为了不同的目的而设计了许多种不同类型的<code>页</code>，比如存放表空间头部信息的页，存放<code>Insert Buffer</code>信息的页，存放<code>INODE</code>信息的页，存放<code>undo</code>日志信息的页等等等等。当然了，如果我说的这些名词你一个都没有听过，就当我放了个屁吧～ 不过这没有一毛钱关系，我们今儿个也不准备说这些类型的页，我们聚焦的是那些存放我们表中记录的那种类型的页，官方称这种存放记录的页为索引（<code>INDEX</code>）页，鉴于我们还没有了解过索引是个什么东西，而这些表中的记录就是我们日常口中所称的<code>数据</code>，所以目前还是叫这种存放记录的页为<code>数据页</code>吧。</p><h2 id="数据页结构的快速浏览"><a href="#数据页结构的快速浏览" class="headerlink" title="数据页结构的快速浏览"></a>数据页结构的快速浏览</h2><p>&amp;emsp;&amp;emsp;数据页代表的这块<code>16KB</code>大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：</p><p><img src="/../images/05-01.png"></p><p>&amp;emsp;&amp;emsp;从图中可以看出，一个<code>InnoDB</code>数据页的存储空间大致被划分成了<code>7</code>个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。下面我们用表格的方式来大致描述一下这7个部分都存储一些什么内容（快速的瞅一眼就行了，后边会详细介绍的）：</p><table><thead><tr><th align="center">名称</th><th align="center">中文名</th><th align="center">占用空间大小</th><th align="center">简单描述</th></tr></thead><tbody><tr><td align="center"><code>File Header</code></td><td align="center">文件头部</td><td align="center"><code>38</code>字节</td><td align="center">页的一些通用信息</td></tr><tr><td align="center"><code>Page Header</code></td><td align="center">页面头部</td><td align="center"><code>56</code>字节</td><td align="center">数据页专有的一些信息</td></tr><tr><td align="center"><code>Infimum + Supremum</code></td><td align="center">最小记录和最大记录</td><td align="center"><code>26</code>字节</td><td align="center">两个虚拟的行记录</td></tr><tr><td align="center"><code>User Records</code></td><td align="center">用户记录</td><td align="center">不确定</td><td align="center">实际存储的行记录内容</td></tr><tr><td align="center"><code>Free Space</code></td><td align="center">空闲空间</td><td align="center">不确定</td><td align="center">页中尚未使用的空间</td></tr><tr><td align="center"><code>Page Directory</code></td><td align="center">页面目录</td><td align="center">不确定</td><td align="center">页中的某些记录的相对位置</td></tr><tr><td align="center"><code>File Trailer</code></td><td align="center">文件尾部</td><td align="center"><code>8</code>字节</td><td align="center">校验页是否完整</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：我们接下来并不打算按照页中各个部分的出现顺序来依次介绍它们，因为各个部分中会出现很多大家目前不理解的概念，这会打击各位读文章的信心与兴趣，希望各位能接受这种拍摄手法～</span><br></pre></td></tr></table></figure><h2 id="记录在页中的存储"><a href="#记录在页中的存储" class="headerlink" title="记录在页中的存储"></a>记录在页中的存储</h2><p>&amp;emsp;&amp;emsp;在页的7个组成部分中，我们自己存储的记录会按照我们指定的<code>行格式</code>存储到<code>User Records</code>部分。但是在一开始生成页的时候，其实并没有<code>User Records</code>这个部分，每当我们插入一条记录，都会从<code>Free Space</code>部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到<code>User Records</code>部分，当<code>Free Space</code>部分的空间全部被<code>User Records</code>部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：</p><p><img src="/../images/05-02.png"></p><p>&amp;emsp;&amp;emsp;为了更好的管理在<code>User Records</code>中的这些记录，<code>InnoDB</code>可费了一番力气呢，在哪费力气了呢？不就是把记录按照指定的行格式一条一条摆在<code>User Records</code>部分么？其实这话还得从记录行格式的<code>记录头信息</code>中说起。</p><h3 id="记录头信息的秘密"><a href="#记录头信息的秘密" class="headerlink" title="记录头信息的秘密"></a>记录头信息的秘密</h3><p>&amp;emsp;&amp;emsp;为了故事的顺利发展，我们先创建一个表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE page_demo(</span><br><span class="line">    -&gt;     c1 INT,</span><br><span class="line">    -&gt;     c2 INT,</span><br><span class="line">    -&gt;     c3 VARCHAR(10000),</span><br><span class="line">    -&gt;     PRIMARY KEY (c1)</span><br><span class="line">    -&gt; ) CHARSET=ascii ROW_FORMAT=Compact;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个新创建的<code>page_demo</code>表有3个列，其中<code>c1</code>和<code>c2</code>列是用来存储整数的，<code>c3</code>列是用来存储字符串的。需要注意的是，<span style="color:red">我们把 <em><strong>c1</strong></em> 列指定为主键，所以在具体的行格式中InnoDB就没必要为我们去创建那个所谓的 <em><strong>row_id</strong></em> 隐藏列了</span>。而且我们为这个表指定了<code>ascii</code>字符集以及<code>Compact</code>的行格式。所以这个表中记录的行格式示意图就是这样的：</p><p><img src="/../images/05-03.png"></p><p>&amp;emsp;&amp;emsp;从图中可以看到，我们特意把<code>记录头信息</code>的5个字节的数据给标出来了，说明它很重要，我们再次先把这些<code>记录头信息</code>中各个属性的大体意思浏览一下（我们目前使用<code>Compact</code>行格式进行演示）：</p><table><thead><tr><th align="center">名称</th><th align="center">大小（单位：bit）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>预留位1</code></td><td align="center"><code>1</code></td><td align="center">没有使用</td></tr><tr><td align="center"><code>预留位2</code></td><td align="center"><code>1</code></td><td align="center">没有使用</td></tr><tr><td align="center"><code>delete_mask</code></td><td align="center"><code>1</code></td><td align="center">标记该记录是否被删除</td></tr><tr><td align="center"><code>min_rec_mask</code></td><td align="center"><code>1</code></td><td align="center">B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td align="center"><code>n_owned</code></td><td align="center"><code>4</code></td><td align="center">表示当前记录拥有的记录数</td></tr><tr><td align="center"><code>heap_no</code></td><td align="center"><code>13</code></td><td align="center">表示当前记录在记录堆的位置信息</td></tr><tr><td align="center"><code>record_type</code></td><td align="center"><code>3</code></td><td align="center">表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录</td></tr><tr><td align="center"><code>next_record</code></td><td align="center"><code>16</code></td><td align="center">表示下一条记录的相对位置</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;由于我们现在主要在介绍<code>记录头信息</code>的作用，所以为了大家理解上的方便，我们只在<code>page_demo</code>表的行格式演示图中画出有关的头信息属性以及<code>c1</code>、<code>c2</code>、<code>c3</code>列的信息（其他信息没画不代表它们不存在啊，只是为了理解上的方便在图中省略了～），简化后的行格式示意图就是这样：</p><p><img src="/../images/05-04.png"></p><p>&amp;emsp;&amp;emsp;下面我们试着向<code>page_demo</code>表中插入几条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO page_demo VALUES(1, 100, &#x27;aaaa&#x27;), (2, 200, &#x27;bbbb&#x27;), (3, 300, &#x27;cccc&#x27;), (4, 400, &#x27;dddd&#x27;);</span><br><span class="line">Query OK, 4 rows affected (0.00 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;为了方便大家分析这些记录在<code>页</code>的<code>User Records</code>部分中是怎么表示的，我把记录中头信息和实际的列数据都用十进制表示出来了（其实是一堆二进制位），所以这些记录的示意图就是：</p><p><img src="/../images/05-05.png"></p><p>&amp;emsp;&amp;emsp;看这个图的时候需要注意一下，各条记录在<code>User Records</code>中存储的时候并没有空隙，这里只是为了大家观看方便才把每条记录单独画在一行中。我们对照着这个图来看看记录头信息中的各个属性是什么意思：</p><ul><li><p><code>delete_mask</code></p><p>  &amp;emsp;&amp;emsp;这个属性标记着当前记录是否被删除，占用1个二进制位，值为<code>0</code>的时候代表记录并没有被删除，为<code>1</code>的时候代表记录被删除掉了。</p><p>  &amp;emsp;&amp;emsp;什么？被删除的记录还在<code>页</code>中么？是的，摆在台面上的和背地里做的可能大相径庭，你以为它删除了，可它还在真实的磁盘上[摊手]（忽然想起冠希～）。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的<code>垃圾链表</code>，在这个链表中的记录占用的空间称之为所谓的<code>可重用空间</code>，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：将这个delete_mask位设置为1和将被删除的记录加入到垃圾链表中其实是两个阶段，我们后边在介绍事务的时候会详细介绍删除操作的详细过程，稍安勿躁。</span><br></pre></td></tr></table></figure></li><li><p><code>min_rec_mask</code></p><p>  &amp;emsp;&amp;emsp;B+树的每层非叶子节点中的最小记录都会添加该标记，什么是个<code>B+</code>树？什么是个非叶子节点？好吧，等会再聊这个问题。反正我们自己插入的四条记录的<code>min_rec_mask</code>值都是<code>0</code>，意味着它们都不是<code>B+</code>树的非叶子节点中的最小记录。</p></li><li><p><code>n_owned</code></p><p>  &amp;emsp;&amp;emsp;这个暂时保密，稍后它是主角～</p></li><li><p><code>heap_no</code></p><p>  &amp;emsp;&amp;emsp;这个属性表示当前记录在本<code>页</code>中的位置，从图中可以看出来，我们插入的4条记录在本<code>页</code>中的位置分别是：<code>2</code>、<code>3</code>、<code>4</code>、<code>5</code>。是不是少了点什么？是的，怎么不见<code>heap_no</code>值为<code>0</code>和<code>1</code>的记录呢？</p><p>  &amp;emsp;&amp;emsp;这其实是设计<code>InnoDB</code>的大佬们玩的一个小把戏，他们自动给每个页里边儿加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为<code>伪记录</code>或者<code>虚拟记录</code>。这两个伪记录一个代表<code>最小记录</code>，一个代表<code>最大记录</code>，等一下~，记录可以比大小么？</p><p>  &amp;emsp;&amp;emsp;是的，记录也可以比大小，对于<span style="color:red">一条完整的记录</span>来说，比较记录的大小就是比较<code>主键</code>的大小。比方说我们插入的4行记录的主键值分别是：<code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>，这也就意味着这4条记录的大小从小到大依次递增。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：请注意我强调了对于`一条完整的记录`来说，比较记录的大小就相当于比的是主键的大小。后边我们还会介绍只存储一条记录的部分列的情况，敬请期待～</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;但是不管我们向<code>页</code>中插入了多少自己的记录，设计<code>InnoDB</code>的大佬们都规定他们定义的两条伪记录分别为最小记录与最大记录。这两条记录的构造十分简单，都是由5字节大小的<code>记录头信息</code>和8字节大小的一个固定的部分组成的，如图所示</p><p>  <img src="/../images/05-06.png"></p><p>  &amp;emsp;&amp;emsp;由于这两条记录不是我们自己定义的记录，所以它们并不存放在<code>页</code>的<code>User Records</code>部分，他们被单独放在一个称为<code>Infimum + Supremum</code>的部分，如图所示：</p><p>  <img src="/../images/05-07.png"></p><p>  &amp;emsp;&amp;emsp;从图中我们可以看出来，最小记录和最大记录的<code>heap_no</code>值分别是<code>0</code>和<code>1</code>，也就是说它们的位置最靠前。</p></li><li><p><code>record_type</code></p><p>  &amp;emsp;&amp;emsp;这个属性表示当前记录的类型，一共有4种类型的记录，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的<code>record_type</code>值都是<code>0</code>，而最小记录和最大记录的<code>record_type</code>值分别为<code>2</code>和<code>3</code>。</p><p>  &amp;emsp;&amp;emsp;至于<code>record_type</code>为<code>1</code>的情况，我们之后在说索引的时候会重点强调的。</p></li><li><p><code>next_record</code></p><p>  &amp;emsp;&amp;emsp;这玩意儿非常重要，它表示<span style="color:red">从当前记录的真实数据到下一条记录的真实数据的地址偏移量</span>。比方说第一条记录的<code>next_record</code>值为<code>32</code>，意味着从第一条记录的真实数据的地址处向后找<code>32</code>个字节便是下一条记录的真实数据。如果你熟悉数据结构的话，就立即明白了，这其实是个<code>链表</code>，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是，<span style="color:red"><code>下一条记录</code>指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录</span>。而且规定<span style="color:red"> <em><strong>Infimum记录（也就是最小记录）</strong></em> 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 <em><strong>Supremum记录（也就是最大记录）</strong></em>  </span>，为了更形象的表示一下这个<code>next_record</code>起到的作用，我们用箭头来替代一下<code>next_record</code>中的地址偏移量：</p><p>  <img src="/../images/05-08.png"></p><p>  &amp;emsp;&amp;emsp;从图中可以看出来，<span style="color:red">我们的记录按照主键从小到大的顺序形成了一个单链表</span>。<code>最大记录</code>的<code>next_record</code>的值为<code>0</code>，这也就是说最大记录是没有<code>下一条记录</code>了，它是这个单链表中的最后一个节点。如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第2条记录删掉：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM page_demo WHERE c1 = 2;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;删掉第2条记录后的示意图就是：</p><p>  <img src="/../images/05-09.png"></p><p>  &amp;emsp;&amp;emsp;从图中可以看出来，删除第2条记录前后主要发生了这些变化：</p><ul><li>第2条记录并没有从存储空间中移除，而是把该条记录的<code>delete_mask</code>值设置为<code>1</code>。</li><li>第2条记录的<code>next_record</code>值变为了0，意味着该记录没有下一条记录了。</li><li>第1条记录的<code>next_record</code>指向了第3条记录。</li><li>还有一点你可能忽略了，就是<code>最大记录</code>的<code>n_owned</code>值从<code>5</code>变成了<code>4</code>，关于这一点的变化我们稍后会详细说明的。</li></ul></li></ul><p>&amp;emsp;&amp;emsp;所以，<span style="color:red">不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：你会不会觉得next_record这个指针有点儿怪，为什么要指向记录头信息和真实数据之间的位置呢？为什么不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。我们前面还说过变长字段长度列表、NULL值列表中的信息都是逆序存放，这样可以使记录中位置靠前的字段和它们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。当然如果你看不懂这句话的话就不要勉强了，果断跳过～</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;再来看一个有意思的事情，因为主键值为<code>2</code>的记录被我们删掉了，但是存储空间却没有回收，如果我们再次把这条记录插入到表中，会发生什么事呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO page_demo VALUES(2, 200, &#x27;bbbb&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们看一下记录的存储情况：</p><p><img src="/../images/05-10.png"></p><p>&amp;emsp;&amp;emsp;从图中可以看到，<code>InnoDB</code>并没有因为新记录的插入而为它申请新的存储空间，而是直接复用了原来被删除记录的存储空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。</span><br></pre></td></tr></table></figure><h2 id="Page-Directory（页目录）"><a href="#Page-Directory（页目录）" class="headerlink" title="Page Directory（页目录）"></a>Page Directory（页目录）</h2><p>&amp;emsp;&amp;emsp;现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？比如说这样的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM page_demo WHERE c1 = 3;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;最笨的办法：从<code>Infimum</code>记录（最小记录）开始，沿着链表一直往后找，总有一天会找到（或者找不到[摊手]），在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。</p><p>&amp;emsp;&amp;emsp;这个方法在页中存储的记录数量比较少的情况用起来也没什么问题，比方说现在我们的表里只有<code>4</code>条自己插入的记录，所以最多找<code>4</code>次就可以把所有记录都遍历一遍，但是如果一个页中存储了非常多的记录，这么查找对性能来说还是有损耗的，所以我们说这种遍历查找这是一个<code>笨</code>办法。但是设计<code>InnoDB</code>的大佬们是什么人，他们能用这么笨的办法么，当然是要设计一种更6的查找方式喽，他们从书的目录中找到了灵感。</p><p>&amp;emsp;&amp;emsp;我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。设计<code>InnoDB</code>的大佬们为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：</p><ol><li><p>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</p></li><li><p>每个组的<span style="color:red">最后</span>一条记录（也就是组内最大的那条记录）的头信息中的<code>n_owned</code>属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</p></li><li><p>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近<code>页</code>的尾部的地方，这个地方就是所谓的<code>Page Directory</code>，也就是<code>页目录</code>（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为<code>槽</code>（英文名：<code>Slot</code>），所以这个页面目录就是由<code>槽</code>组成的。</p></li></ol><p>&amp;emsp;&amp;emsp;比方说现在的<code>page_demo</code>表中正常的记录共有6条，<code>InnoDB</code>会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下面的示意图：</p><p><img src="/../images/05-11.png"></p><p>&amp;emsp;&amp;emsp;从这个图中我们需要注意这么几点：</p><ul><li><p>现在<code>页目录</code>部分中有两个槽，也就意味着我们的记录被分成了两个组，<code>槽1</code>中的值是<code>112</code>，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；<code>槽0</code>中的值是<code>99</code>，代表最小记录的地址偏移量。</p></li><li><p>注意最小和最大记录的头信息中的<code>n_owned</code>属性</p><ul><li>最小记录的<code>n_owned</code>值为<code>1</code>，这就代表着以最小记录结尾的这个分组中只有<code>1</code>条记录，也就是最小记录本身。</li><li>最大记录的<code>n_owned</code>值为<code>5</code>，这就代表着以最大记录结尾的这个分组中只有<code>5</code>条记录，包括最大记录本身还有我们自己插入的<code>4</code>条记录。</li></ul></li></ul><p>&amp;emsp;&amp;emsp;<code>99</code>和<code>112</code>这样的地址偏移量很不直观，我们用箭头指向的方式替代数字，这样更易于我们理解，所以修改后的示意图就是这样：</p><p><img src="/../images/05-12.png"></p><p>&amp;emsp;&amp;emsp;哎呀，咋看上去怪怪的，这么乱的图对于我这个强迫症真是不能忍，那我们就暂时不管各条记录在存储设备上的排列方式了，单纯从<span style="color:red">逻辑上</span>看一下这些记录和页目录的关系：</p><p><img src="/../images/05-13.png"></p><p>&amp;emsp;&amp;emsp;这样看就顺眼多了嘛！为什么最小记录的<code>n_owned</code>值为1，而最大记录的<code>n_owned</code>值为<code>5</code>呢，这里头有什么猫腻么？</p><p>&amp;emsp;&amp;emsp;是的，设计<code>InnoDB</code>的大佬们对每个分组中的记录条数是有规定的：<span style="color:red">对于最小记录所在的分组只能有 <em><strong>1</strong></em> 条记录，最大记录所在的分组拥有的记录条数只能在 <em><strong>1~8</strong></em> 条之间，剩下的分组中记录的条数范围只能在是 <em><strong>4~8</strong></em> 条之间</span>。所以分组是按照下面的步骤进行的：</p><ul><li><p>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</p></li><li><p>之后每插入一条记录，都会从<code>页目录</code>中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的<code>n_owned</code>值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</p></li><li><p>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在<code>页目录</code>中新增一个<code>槽</code>来记录这个新增分组中最大的那条记录的偏移量。</p></li></ul><p>&amp;emsp;&amp;emsp;由于现在<code>page_demo</code>表中的记录太少，无法演示添加了<code>页目录</code>之后加快查找速度的过程，所以再往<code>page_demo</code>表中添加一些记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO page_demo VALUES(5, 500, &#x27;eeee&#x27;), (6, 600, &#x27;ffff&#x27;), (7, 700, &#x27;gggg&#x27;), (8, 800, &#x27;hhhh&#x27;), (9, 900, &#x27;iiii&#x27;), (10, 1000, &#x27;jjjj&#x27;), (11, 1100, &#x27;kkkk&#x27;), (12, 1200, &#x27;llll&#x27;), (13, 1300, &#x27;mmmm&#x27;), (14, 1400, &#x27;nnnn&#x27;), (15, 1500, &#x27;oooo&#x27;), (16, 1600, &#x27;pppp&#x27;);</span><br><span class="line">Query OK, 12 rows affected (0.00 sec)</span><br><span class="line">Records: 12  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们一口气又往表中添加了12条记录，现在页里边就一共有18条记录了（包括最小和最大记录），这些记录被分成了5个组，如图所示：</p><p><img src="/../images/05-14.png"></p><p>&amp;emsp;&amp;emsp;因为把16条记录的全部信息都画在一张图里太占地方，让人眼花缭乱的，所以只保留了用户记录头信息中的<code>n_owned</code>和<code>next_record</code>属性，也省略了各个记录之间的箭头，我没画不等于没有啊！现在看怎么从这个<code>页目录</code>中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的<code>二分法</code>来进行快速查找。4个槽的编号分别是：<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>，所以初始情况下最低的槽就是<code>low=0</code>，最高的槽就是<code>high=4</code>。比方说我们想找主键值为<code>6</code>的记录，过程是这样的：</p><ol><li><p>计算中间槽的位置：<code>(0+4)/2=2</code>，所以查看<code>槽2</code>对应记录的主键值为<code>8</code>，又因为<code>8 &gt; 6</code>，所以设置<code>high=2</code>，<code>low</code>保持不变。</p></li><li><p>重新计算中间槽的位置：<code>(0+2)/2=1</code>，所以查看<code>槽1</code>对应的主键值为<code>4</code>，又因为<code>4 &lt; 6</code>，所以设置<code>low=1</code>，<code>high</code>保持不变。</p></li><li><p>因为<code>high - low</code>的值为1，所以确定主键值为<code>5</code>的记录在<code>槽2</code>对应的组中。此刻我们需要找到<code>槽2</code>中主键值最小的那条记录，然后沿着单向链表遍历<code>槽2</code>中的记录。但是我们前面又说过，每个槽对应的记录都是该组中主键值最大的记录，这里<code>槽2</code>对应的记录是主键值为<code>8</code>的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到<code>槽1</code>对应的记录（主键值为<code>4</code>），该条记录的下一条记录就是<code>槽2</code>中主键值最小的记录，该记录的主键值为<code>5</code>。所以我们可以从这条主键值为<code>5</code>的记录出发，遍历<code>槽2</code>中的各条记录，直到找到主键值为<code>6</code>的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</p></li></ol><p>&amp;emsp;&amp;emsp;所以在一个数据页中查找指定主键值的记录的过程分为两步：</p><ol><li><p><span style="color:red">通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录</span>。</p></li><li><p><span style="color:red">通过记录的<code>next_record</code>属性遍历该槽所在的组中的各个记录</span>。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：如果你不知道二分法是个什么东西，找个基础算法书看看吧。什么？算法书写的看不懂？等我～</span><br></pre></td></tr></table></figure><h2 id="Page-Header（页面头部）"><a href="#Page-Header（页面头部）" class="headerlink" title="Page Header（页面头部）"></a>Page Header（页面头部）</h2><p>&amp;emsp;&amp;emsp;设计<code>InnoDB</code>的大佬们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫<code>Page Header</code>的部分，它是<code>页</code>结构的第二部分，这个部分占用固定的<code>56</code>个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下表：</p><table><thead><tr><th align="center">名称</th><th align="center">占用空间大小</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>PAGE_N_DIR_SLOTS</code></td><td align="center"><code>2</code>字节</td><td align="center">在页目录中的槽数量</td></tr><tr><td align="center"><code>PAGE_HEAP_TOP</code></td><td align="center"><code>2</code>字节</td><td align="center">还未使用的空间最小地址，也就是说从该地址之后就是<code>Free Space</code></td></tr><tr><td align="center"><code>PAGE_N_HEAP</code></td><td align="center"><code>2</code>字节</td><td align="center">本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td align="center"><code>PAGE_FREE</code></td><td align="center"><code>2</code>字节</td><td align="center">第一个已经标记为删除的记录地址（各个已删除的记录通过<code>next_record</code>也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td align="center"><code>PAGE_GARBAGE</code></td><td align="center"><code>2</code>字节</td><td align="center">已删除记录占用的字节数</td></tr><tr><td align="center"><code>PAGE_LAST_INSERT</code></td><td align="center"><code>2</code>字节</td><td align="center">最后插入记录的位置</td></tr><tr><td align="center"><code>PAGE_DIRECTION</code></td><td align="center"><code>2</code>字节</td><td align="center">记录插入的方向</td></tr><tr><td align="center"><code>PAGE_N_DIRECTION</code></td><td align="center"><code>2</code>字节</td><td align="center">一个方向连续插入的记录数量</td></tr><tr><td align="center"><code>PAGE_N_RECS</code></td><td align="center"><code>2</code>字节</td><td align="center">该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td align="center"><code>PAGE_MAX_TRX_ID</code></td><td align="center"><code>8</code>字节</td><td align="center">修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td align="center"><code>PAGE_LEVEL</code></td><td align="center"><code>2</code>字节</td><td align="center">当前页在B+树中所处的层级</td></tr><tr><td align="center"><code>PAGE_INDEX_ID</code></td><td align="center"><code>8</code>字节</td><td align="center">索引ID，表示当前页属于哪个索引</td></tr><tr><td align="center"><code>PAGE_BTR_SEG_LEAF</code></td><td align="center"><code>10</code>字节</td><td align="center">B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td align="center"><code>PAGE_BTR_SEG_TOP</code></td><td align="center"><code>10</code>字节</td><td align="center">B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;如果大家认真看过前面的文章，从<code>PAGE_N_DIR_SLOTS</code>到<code>PAGE_LAST_INSERT</code>以及<code>PAGE_N_RECS</code>的意思大家一定是清楚的，如果不清楚，对不起，你应该回头再看一遍前面的文章。剩下的状态信息看不明白不要着急，饭要一口一口吃，东西要一点一点学（一定要稍安勿躁哦，不要被这些名词吓到）。在这里我们先介绍一下<code>PAGE_DIRECTION</code>和<code>PAGE_N_DIRECTION</code>的意思：</p><ul><li><p><code>PAGE_DIRECTION</code></p><p>  &amp;emsp;&amp;emsp;假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是<code>PAGE_DIRECTION</code>。</p></li><li><p><code>PAGE_N_DIRECTION</code></p><p>  &amp;emsp;&amp;emsp;假设连续几次插入新记录的方向都是一致的，<code>InnoDB</code>会把沿着同一个方向插入记录的条数记下来，这个条数就用<code>PAGE_N_DIRECTION</code>这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</p></li></ul><p>&amp;emsp;&amp;emsp;至于我们没提到的那些属性，我没说是因为现在不需要大家知道。不要着急，当我们学完了后边的内容，你再回头看，一切都是那么清晰。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小贴士：说到这个有些东西后边我们学过后回头看就很清晰的事儿不禁让我想到了乔布斯在斯坦福大学的演讲，摆一下原文：  </span><br><span class="line">    “You can&#x27;t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future.You have to trust in something - your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.”  </span><br><span class="line">    上面这段话纯属心血来潮写的，大意是坚持做自己喜欢的事儿，你在做的时候可能并不能搞清楚这些事儿对自己之后的人生有什么影响，但当你一路走来回头看时，一切都是那么清晰，就像是命中注定的一样。上述内容跟MySQL毫无干系，请忽略～  </span><br></pre></td></tr></table></figure><h2 id="File-Header（文件头部）"><a href="#File-Header（文件头部）" class="headerlink" title="File Header（文件头部）"></a>File Header（文件头部）</h2><p>&amp;emsp;&amp;emsp;上面介绍的<code>Page Header</code>是专门针对<code>数据页</code>记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀。我们现在描述的<code>File Header</code>针对各种类型的页都通用，也就是说不同类型的页都会以<code>File Header</code>作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁啦等等～ 这个部分占用固定的<code>38</code>个字节，是由下面这些内容组成的：</p><table><thead><tr><th align="center">名称</th><th align="center">占用空间大小</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td><td align="center"><code>4</code>字节</td><td align="center">页的校验和（checksum值）</td></tr><tr><td align="center"><code>FIL_PAGE_OFFSET</code></td><td align="center"><code>4</code>字节</td><td align="center">页号</td></tr><tr><td align="center"><code>FIL_PAGE_PREV</code></td><td align="center"><code>4</code>字节</td><td align="center">上一个页的页号</td></tr><tr><td align="center"><code>FIL_PAGE_NEXT</code></td><td align="center"><code>4</code>字节</td><td align="center">下一个页的页号</td></tr><tr><td align="center"><code>FIL_PAGE_LSN</code></td><td align="center"><code>8</code>字节</td><td align="center">页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr><td align="center"><code>FIL_PAGE_TYPE</code></td><td align="center"><code>2</code>字节</td><td align="center">该页的类型</td></tr><tr><td align="center"><code>FIL_PAGE_FILE_FLUSH_LSN</code></td><td align="center"><code>8</code>字节</td><td align="center">仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td align="center"><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td><td align="center"><code>4</code>字节</td><td align="center">页属于哪个表空间</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;对照着这个表格，我们看几个目前比较重要的部分：</p><ul><li><p><code>FIL_PAGE_SPACE_OR_CHKSUM</code></p><p>  &amp;emsp;&amp;emsp;这个代表当前页面的校验和（checksum）。什么是个校验和？就是对于一个很长很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为<code>校验和</code>。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。</p></li><li><p><code>FIL_PAGE_OFFSET</code></p><p>  &amp;emsp;&amp;emsp;每一个<code>页</code>都有一个单独的页号，就跟你的身份证号码一样，<code>InnoDB</code>通过页号来可以唯一定位一个<code>页</code>。</p></li><li><p><code>FIL_PAGE_TYPE</code></p><p>  &amp;emsp;&amp;emsp;这个代表当前<code>页</code>的类型，我们前面说过，<code>InnoDB</code>为了不同的目的而把页分为不同的类型，我们上面介绍的其实都是存储记录的<code>数据页</code>，其实还有很多别的类型的页，具体如下表：</p></li></ul><table><thead><tr><th align="center">类型名称</th><th align="center">十六进制</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>FIL_PAGE_TYPE_ALLOCATED</code></td><td align="center">0x0000</td><td align="center">最新分配，还没使用</td></tr><tr><td align="center"><code>FIL_PAGE_UNDO_LOG</code></td><td align="center">0x0002</td><td align="center">Undo日志页</td></tr><tr><td align="center"><code>FIL_PAGE_INODE</code></td><td align="center">0x0003</td><td align="center">段信息节点</td></tr><tr><td align="center"><code>FIL_PAGE_IBUF_FREE_LIST</code></td><td align="center">0x0004</td><td align="center">Insert Buffer空闲列表</td></tr><tr><td align="center"><code>FIL_PAGE_IBUF_BITMAP</code></td><td align="center">0x0005</td><td align="center">Insert Buffer位图</td></tr><tr><td align="center"><code>FIL_PAGE_TYPE_SYS</code></td><td align="center">0x0006</td><td align="center">系统页</td></tr><tr><td align="center"><code>FIL_PAGE_TYPE_TRX_SYS</code></td><td align="center">0x0007</td><td align="center">事务系统数据</td></tr><tr><td align="center"><code>FIL_PAGE_TYPE_FSP_HDR</code></td><td align="center">0x0008</td><td align="center">表空间头部信息</td></tr><tr><td align="center"><code>FIL_PAGE_TYPE_XDES</code></td><td align="center">0x0009</td><td align="center">扩展描述页</td></tr><tr><td align="center"><code>FIL_PAGE_TYPE_BLOB</code></td><td align="center">0x000A</td><td align="center">BLOB页</td></tr><tr><td align="center"><code>FIL_PAGE_INDEX</code></td><td align="center">0x45BF</td><td align="center">索引页，也就是我们所说的<code>数据页</code></td></tr></tbody></table><pre><code>&amp;emsp;&amp;emsp;我们存放记录的数据页的类型其实是`FIL_PAGE_INDEX`，也就是所谓的`索引页`。至于什么是个索引，且听下回分解～</code></pre><ul><li><p><code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code></p><p>  &amp;emsp;&amp;emsp;我们前面强调过，<code>InnoDB</code>都是以页为单位存放数据的，有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），<code>InnoDB</code>可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，<span style="color:red">并不是所有类型的页都有上一个和下一个页的属性</span>，不过我们本集中介绍的<code>数据页</code>（也就是类型为<code>FIL_PAGE_INDEX</code>的页）是有这两个属性的，所以所有的数据页其实是一个双链表，就像这样：</p><p>  <img src="/../images/05-15.png"></p></li></ul><p>&amp;emsp;&amp;emsp;关于<code>File Header</code>的其他属性我们暂时用不到，等用到的时候再提～</p><h2 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h2><p>&amp;emsp;&amp;emsp;我们知道<code>InnoDB</code>存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以<code>页</code>为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据<span style="color:red">同步</span>到磁盘中。但是在同步了一半的时候中断电了咋办，这不是莫名尴尬么？为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），设计<code>InnoDB</code>的大佬们在每个页的尾部都加了一个<code>File Trailer</code>部分，这个部分由<code>8</code>个字节组成，可以分成2个小部分：</p><ul><li><p>前4个字节代表页的校验和</p><p>  &amp;emsp;&amp;emsp;这个部分是和<code>File Header</code>中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为<code>File Header</code>在页面的前面，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在<code>File Header</code>中的校验和就代表着已经修改过的页，而在<code>File Trialer</code>中的校验和代表着原先的页，二者不同则意味着同步中间出了错。</p></li><li><p>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）</p><p>  &amp;emsp;&amp;emsp;这个部分也是为了校验页的完整性的，只不过我们目前还没说<code>LSN</code>是个什么意思，所以大家可以先不用管这个属性。</p></li></ul><p>&amp;emsp;&amp;emsp;这个<code>File Trailer</code>与<code>File Header</code>类似，都是所有类型的页通用的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做<code>数据页</code>。</p></li><li><p>一个数据页可以被大致划分为7个部分，分别是</p><ul><li><code>File Header</code>，表示页的一些通用信息，占固定的38字节。</li><li><code>Page Header</code>，表示数据页专有的一些信息，占固定的56个字节。</li><li><code>Infimum + Supremum</code>，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的<code>26</code>个字节。</li><li><code>User Records</code>：真实存储我们插入的记录的部分，大小不固定。</li><li><code>Free Space</code>：页中尚未使用的部分，大小不确定。</li><li><code>Page Directory</code>：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。</li><li><code>File Trailer</code>：用于检验页是否完整的部分，占用固定的8个字节。</li></ul></li><li><p>每个记录的头信息中都有一个<code>next_record</code>属性，从而使页中的所有记录串联成一个<code>单链表</code>。</p></li><li><p><code>InnoDB</code>会为把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个<code>槽</code>，存放在<code>Page Directory</code>中，所以在一个页中根据主键查找记录是非常快的，分为两步：</p><ul><li><p>通过二分法确定该记录所在的槽。</p></li><li><p>通过记录的next_record属性遍历该槽所在的组中的各个记录。</p></li></ul></li><li><p>每个数据页的<code>File Header</code>部分都有上一个和下一个页的编号，所以所有的数据页会组成一个<code>双链表</code>。</p></li><li><p>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的<code>LSN</code>值，如果首部和尾部的校验和和<code>LSN</code>值校验不成功的话，就说明同步过程出现了问题。</p></li></ol><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/06-%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%A7%98%E7%B1%8D-B+%E6%A0%91%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/10/31/model-mysql/mysql/06-%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%A7%98%E7%B1%8D-B+%E6%A0%91%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="第6章-快速查询的秘籍-B-树索引"><a href="#第6章-快速查询的秘籍-B-树索引" class="headerlink" title="第6章 快速查询的秘籍-B+树索引"></a>第6章 快速查询的秘籍-B+树索引</h1><p>&amp;emsp;&amp;emsp;前面我们详细介绍了<code>InnoDB</code>数据页的7个组成部分，知道了各个数据页可以组成一个<code>双向链表</code>，而每个数据页中的记录会按照主键值从小到大的顺序组成一个<code>单向链表</code>，每个数据页都会为存储在它里边儿的记录生成一个<code>页目录</code>，在通过主键查找某条记录的时候可以在<code>页目录</code>中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录（如果你对这段话有一丁点儿疑惑，那么接下来的部分不适合你，返回去看一下数据页结构吧）。页和记录的关系示意图如下：</p><p><img src="/../images/06-01.png">    </p><p>&amp;emsp;&amp;emsp;其中页a、页b、页c … 页n 这些页可以不在物理结构上相连，只要通过双向链表相关联即可。</p><h2 id="没有索引的查找"><a href="#没有索引的查找" class="headerlink" title="没有索引的查找"></a>没有索引的查找</h2><p>&amp;emsp;&amp;emsp;本集的主题是<code>索引</code>，在正式介绍<code>索引</code>之前，我们需要了解一下没有索引的时候是怎么查找记录的。为了方便大家理解，我们下面先只介绍搜索条件为对某个列精确匹配的情况，所谓精确匹配，就是搜索条件中用等于<code>=</code>连接起的表达式，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;</span><br></pre></td></tr></table></figure><h3 id="在一个页中的查找"><a href="#在一个页中的查找" class="headerlink" title="在一个页中的查找"></a>在一个页中的查找</h3><p>&amp;emsp;&amp;emsp;假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p><ul><li><p>以主键为搜索条件</p><p>  &amp;emsp;&amp;emsp;这个查找过程我们已经很熟悉了，可以在<code>页目录</code>中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p></li><li><p>以其他列作为搜索条件</p><p>  &amp;emsp;&amp;emsp;对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的<code>页目录</code>，所以我们无法通过二分法快速定位相应的<code>槽</code>。这种情况下只能从<code>最小记录</code>开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p></li></ul><h3 id="在很多页中查找"><a href="#在很多页中查找" class="headerlink" title="在很多页中查找"></a>在很多页中查找</h3><p>&amp;emsp;&amp;emsp;大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p><ol><li>定位到记录所在的页。</li><li>从所在的页内中查找相应的记录。</li></ol><p>&amp;emsp;&amp;emsp;在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，<span style="color:red">由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚介绍过的查找方式去查找指定的记录</span>。因为要遍历所有的数据页，所以这种方式显然是超级耗时的，如果一个表有一亿条记录，使用这种方式去查找记录那要等到猴年马月才能等到查找结果。所以祖国和人民都在期盼一种能高效完成搜索的方法，<code>索引</code>同志就要亮相登台了。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>&amp;emsp;&amp;emsp;为了故事的顺利发展，我们先建一个表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE index_demo(</span><br><span class="line">    -&gt;     c1 INT,</span><br><span class="line">    -&gt;     c2 INT,</span><br><span class="line">    -&gt;     c3 CHAR(1),</span><br><span class="line">    -&gt;     PRIMARY KEY(c1)</span><br><span class="line">    -&gt; ) ROW_FORMAT = Compact;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个新建的<code>index_demo</code>表中有2个<code>INT</code>类型的列，1个<code>CHAR(1)</code>类型的列，而且我们规定了<code>c1</code>列为主键，这个表使用<code>Compact</code>行格式来实际存储记录的。为了我们理解上的方便，我们简化了一下<code>index_demo</code>表的行格式示意图：</p><p><img src="/../images/06-02.png">    </p><p>&amp;emsp;&amp;emsp;我们只在示意图里展示记录的这几个部分：</p><ul><li><p><code>record_type</code>：记录头信息的一项属性，表示记录的类型，<code>0</code>表示普通记录、<code>2</code>表示最小记录、<code>3</code>表示最大记录、<code>1</code>我们还没用过，等会再说～</p></li><li><p><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。</p></li><li><p><code>各个列的值</code>：这里只记录在<code>index_demo</code>表中的三个列，分别是<code>c1</code>、<code>c2</code>和<code>c3</code>。</p></li><li><p><code>其他信息</code>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</p></li></ul><p>&amp;emsp;&amp;emsp;为了节省篇幅，我们之后的示意图中会把记录的<code>其他信息</code>这个部分省略掉，因为它占地方并且不会有什么观赏效果。另外，为了方便理解，我们觉得把记录竖着放看起来感觉更好，所以将记录格式示意图的<code>其他信息</code>去掉并把它竖起来的效果就是这样：</p><p><img src="/../images/06-03.png"></p><p>&amp;emsp;&amp;emsp;把一些记录放到页里边的示意图就是：</p><p><img src="/../images/06-04.png"></p><h3 id="一个简单的索引方案"><a href="#一个简单的索引方案" class="headerlink" title="一个简单的索引方案"></a>一个简单的索引方案</h3><p>&amp;emsp;&amp;emsp;回到正题，我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？<span style="color:red">因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以 <em><strong>不得不</strong></em> 依次遍历所有的数据页</span>。所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？还记得我们为根据主键值快速定位一条记录在页中的位置而设立的页目录么？我们也可以想办法为快速定位记录所在的数据页而建立一个别的目录，建这个目录必须完成下面这些事儿：</p><ul><li><p>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</p><p>  &amp;emsp;&amp;emsp;为了故事的顺利发展，我们这里需要做一个假设：假设我们的每个数据页最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。有了这个假设之后我们向<code>index_demo</code>表插入3条记录：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO index_demo VALUES(1, 4, &#x27;u&#x27;), (3, 9, &#x27;d&#x27;), (5, 3, &#x27;y&#x27;);</span><br><span class="line">Query OK, 3 rows affected (0.01 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：</p><p>  <img src="/../images/06-05.png"></p><p>  &amp;emsp;&amp;emsp;从图中可以看出来，<code>index_demo</code>表中的3条记录都被插入到了编号为<code>10</code>的数据页中了。此时我们再来插入一条记录：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO index_demo VALUES(4, 4, &#x27;a&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;因为<code>页10</code>最多只能放3条记录，所以我们<span style="color:red">不得不</span>再分配一个新页：</p><p>  <img src="/../images/06-06.png"></p><p>  &amp;emsp;&amp;emsp;咦？怎么分配的页号是<code>28</code>呀，不应该是<code>11</code>么？再次强调一遍，<span style="color:red">新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着</span>。它们只是通过维护着上一个页和下一个页的编号而建立了链表关系。另外，<code>页10</code>中用户记录最大的主键值是<code>5</code>，而<code>页28</code>中有一条记录的主键值是<code>4</code>，因为<code>5 &gt; 4</code>，所以这就不符合<span style="color:red">下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</span>的要求，所以在插入主键值为<code>4</code>的记录的时候需要伴随着一次记录移动，也就是把主键值为<code>5</code>的记录移动到<code>页28</code>中，然后再把主键值为<code>4</code>的记录插入到<code>页10</code>中，这个过程的示意图如下：</p><p>  <img src="/../images/06-07.png"></p><p>  &amp;emsp;&amp;emsp;这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：<span style="color:red">下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</span>。这个过程我们也可以称为<code>页分裂</code>。</p></li><li><p>给所有的页建立一个目录项。</p><p>  &amp;emsp;&amp;emsp;由于<span style="color:red">数据页的编号可能并不是连续的</span>，所以在向<code>index_demo</code>表中插入许多条记录后，可能是这样的效果：</p><p>  <img src="/../images/06-08.png"></p><p>  &amp;emsp;&amp;emsp;因为这些<code>16KB</code>的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，<span style="color:red">每个页对应一个目录项</span>，每个目录项包括下面两个部分：</p><ul><li>页的用户记录中最小的主键值，我们用<code>key</code>来表示。</li><li>页号，我们用<code>page_no</code>表示。</li></ul><p>  &amp;emsp;&amp;emsp;所以我们为上面几个页做好的目录就像这样子：</p><p>  <img src="/../images/06-09.png">    </p><p>  &amp;emsp;&amp;emsp;以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的最小主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现<span style="color:red">根据主键值</span>快速查找某条记录的功能了。比方说我们想找主键值为<code>20</code>的记录，具体查找过程分两步：</p><p>  1.先从目录项中根据二分法快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 <code>12 &lt; 20 &lt; 209</code>），它对应的页是<code>页9</code>。<br>  2.再根据前面说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</p></li></ul><p>&amp;emsp;&amp;emsp;至此，针对数据页做的简易目录就搞定了。不过忘了说了，这个<code>目录</code>有一个别名，称为<code>索引</code>。</p><h3 id="InnoDB中的索引方案"><a href="#InnoDB中的索引方案" class="headerlink" title="InnoDB中的索引方案"></a>InnoDB中的索引方案</h3><p>&amp;emsp;&amp;emsp;上面之所以称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存储，但是这样做有几个问题：</p><ul><li><p><code>InnoDB</code>是使用页来作为管理存储空间的基本单位，也就是最多能保证<code>16KB</code>的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</p></li><li><p>我们时常会对记录进行增删，假设我们把<code>页28</code>中的记录都删除了，<code>页28</code>也就没有存在的必要了，那意味着<code>目录项2</code>也就没有存在的必要了，这就需要把<code>目录项2</code>后的目录项都向前移动一下，这种牵一发而动全身的设计不是什么好主意～</p></li></ul><p>&amp;emsp;&amp;emsp;所以，设计<code>InnoDB</code>的大佬们需要一种可以灵活管理所有<code>目录项</code>的方式。他们灵光乍现，忽然发现这些<code>目录项</code>其实长得跟我们的用户记录差不多，只不过<code>目录项</code>中的两个列是<code>主键</code>和<code>页号</code>而已，所以他们<span style="color:red">复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<code>目录项记录</code></span>。那<code>InnoDB</code>怎么区分一条记录是普通的<code>用户记录</code>还是<code>目录项记录</code>呢？别忘了记录头信息里的<code>record_type</code>属性，它的各个取值代表的意思如下：</p><ul><li><code>0</code>：普通的用户记录</li><li><code>1</code>：目录项记录</li><li><code>2</code>：最小记录</li><li><code>3</code>：最大记录</li></ul><p>&amp;emsp;&amp;emsp;原来这个值为<code>1</code>的<code>record_type</code>是这个意思呀，我们把前面使用到的目录项放到数据页中的样子就是这样：</p><p><img src="/../images/06-10.png"></p><p>&amp;emsp;&amp;emsp;从图中可以看出来，我们新分配了一个编号为<code>30</code>的页来专门存储<code>目录项记录</code>。这里再次强调一遍<code>目录项记录</code>和普通的<code>用户记录</code>的不同点：</p><ul><li><p><code>目录项记录</code>的<code>record_type</code>值是1，而普通用户记录的<code>record_type</code>值是0。</p></li><li><p><code>目录项记录</code>只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有<code>InnoDB</code>自己添加的隐藏列。</p></li><li><p>还记得我们之前在介绍记录头信息的时候说过一个叫<code>min_rec_mask</code>的属性么，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code>。</p></li></ul><p>&amp;emsp;&amp;emsp;除了上述几点外，这两者就没什么差别了，它们用的是一样的数据页（页面类型都是<code>0x45BF</code>，这个属性在<code>File Header</code>中，忘了的话可以翻到前面的文章看），页的组成结构也是一样一样的（就是我们前面介绍过的7个部分），都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下面两步：</p><ol><li><p>先到存储<code>目录项记录</code>的页，也就是页<code>30</code>中通过二分法快速定位到对应目录项，因为<code>12 &lt; 20 &lt; 209</code>，所以定位到对应的记录所在的页就是<code>页9</code>。</p></li><li><p>再到存储用户记录的<code>页9</code>中根据二分法快速定位到主键值为<code>20</code>的用户记录。</p></li></ol><p>&amp;emsp;&amp;emsp;虽然说<code>目录项记录</code>中<span style="color:red">只存储主键值和对应的页号</span>，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有<code>16KB</code>大小，能存放的<code>目录项记录</code>也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的<code>目录项记录</code>，该咋办呢？</p><p>&amp;emsp;&amp;emsp;当然是再多整一个存储<code>目录项记录</code>的页喽～ 为了大家更好的理解新分配一个<code>目录项记录</code>页的过程，我们假设一个存储<code>目录项记录</code>的页最多只能存放4条<code>目录项记录</code>（请注意是假设哦，真实情况下可以存放好多条的），所以如果此时我们再向上图中插入一条主键值为<code>320</code>的用户记录的话，那就需要分配一个新的存储<code>目录项记录</code>的页喽：</p><p><img src="/../images/06-11.png"></p><p>&amp;emsp;&amp;emsp;从图中可以看出，我们插入了一条主键值为<code>320</code>的用户记录之后需要两个新的数据页：</p><ul><li><p>为存储该用户记录而新生成了<code>页31</code>。</p></li><li><p>因为原先存储<code>目录项记录</code>的<code>页30</code>的容量已满（我们前面假设只能存储4条<code>目录项记录</code>），所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</p></li></ul><p>&amp;emsp;&amp;emsp;现在因为存储<code>目录项记录</code>的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为<code>20</code>的记录为例：</p><ol><li><p>确定<code>目录项记录</code>页</p><p> &amp;emsp;&amp;emsp;我们现在的存储<code>目录项记录</code>的页有两个，即<code>页30</code>和<code>页32</code>，又因为<code>页30</code>表示的目录项的主键值的范围是<code>[1, 320)</code>，<code>页32</code>表示的目录项的主键值不小于<code>320</code>，所以主键值为<code>20</code>的记录对应的目录项记录在<code>页30</code>中。</p></li><li><p>通过<code>目录项记录</code>页确定用户记录真实所在的页。</p><p> &amp;emsp;&amp;emsp;在一个存储<code>目录项记录</code>的页中通过主键值定位一条目录项记录的方式说过了，不赘述了～</p></li><li><p>在真实存储用户记录的页中定位到具体的记录。</p><p> &amp;emsp;&amp;emsp;在一个存储用户记录的页中通过主键值定位一条用户记录的方式已经说过200遍了，你再不会我就，我就，我就求你到上一篇介绍数据页结构的文章中多看几遍，求你了～</p></li></ol><p>&amp;emsp;&amp;emsp;那么问题来了，在这个查询步骤的第1步中我们需要定位存储<code>目录项记录</code>的页，但是这些页在存储空间中也可能不挨着，如果我们表中的数据非常多则会产生很多存储<code>目录项记录</code>的页，那我们怎么根据主键值快速定位一个存储<code>目录项记录</code>的页呢？其实也简单，为这些存储<code>目录项记录</code>的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p><p><img src="/../images/06-12.png"></p><p>&amp;emsp;&amp;emsp;如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表<code>页30</code>和<code>页32</code>，如果用户记录的主键值在<code>[1, 320)</code>之间，则到<code>页30</code>中查找更详细的<code>目录项记录</code>，如果主键值不小于<code>320</code>的话，就到<code>页32</code>中查找更详细的<code>目录项记录</code>。不过这张图好漂亮喔，随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下面这个图来描述它：</p><p><img src="/../images/06-13.png"></p><p>&amp;emsp;&amp;emsp;这玩意儿像不像一个倒过来的<code>树</code>呀，上头是树根，下头是树叶！其实这是一种组织数据的形式，或者说是一种数据结构，它的名称是<code>B+</code>树。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：为什么叫`B+`呢，`B`树是什么？喔对不起，这不是我们讨论的范围，你可以去找一本数据结构或算法的书来看。什么？数据结构的书看不懂？等我～</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到<code>B+</code>树这个数据结构中了，所以我们也称这些数据页为<code>节点</code>。从图中可以看出来，我们的<span style="color:red">实际用户记录其实都存放在B+树的最底层的节点上</span>，这些节点也被称为<code>叶子节点</code>或<code>叶节点</code>，其余用来存放<code>目录项</code>的节点称为<code>非叶子节点</code>或者<code>内节点</code>，其中<code>B+</code>树最上面的那个节点也称为<code>根节点</code>。</p><p>&amp;emsp;&amp;emsp;从图中可以看出来，一个<code>B+</code>树的节点其实可以分成好多层，设计<code>InnoDB</code>的大佬们为了讨论方便，规定最下面的那层，也就是存放我们用户记录的那层为第<code>0</code>层，之后依次往上加。之前的讨论我们做了一个非常极端的假设：存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录数量是非常大的，假设，假设，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：</p><ul><li><p>如果<code>B+</code>树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放<code>100</code>条记录。</p></li><li><p>如果<code>B+</code>树有2层，最多能存放<code>1000×100=100000</code>条记录。</p></li><li><p>如果<code>B+</code>树有3层，最多能存放<code>1000×1000×100=100000000</code>条记录。</p></li><li><p>如果<code>B+</code>树有4层，最多能存放<code>1000×1000×1000×100=100000000000</code>条记录。哇咔咔～这么多的记录！！！</p></li></ul><p>&amp;emsp;&amp;emsp;你的表里能存放<code>100000000000</code>条记录么？所以一般情况下，我们用到的<code>B+</code>树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过二分法实现快速定位记录，这不是很牛么！</p><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>&amp;emsp;&amp;emsp;我们上面介绍的<code>B+</code>树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p><ol><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li><p>页内的记录是按照主键的大小顺序排成一个单向链表。</p></li><li><p>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</p></li><li><p>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</p></li></ul></li><li><p><code>B+</code>树的叶子节点存储的是完整的用户记录。</p><p> &amp;emsp;&amp;emsp;所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ol><p>&amp;emsp;&amp;emsp;我们把具有这两种特性的<code>B+</code>树称为<code>聚簇索引</code>，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种<code>聚簇索引</code>并不需要我们在<code>MySQL</code>语句中显式的使用<code>INDEX</code>语句去创建（后边会介绍索引相关的语句），<code>InnoDB</code>存储引擎会<span style="color:red">自动的为我们创建聚簇索引</span>。另外有趣的一点是，在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式（所有的用户记录都存储在了<code>叶子节点</code>），也就是所谓的<span style="color:red">索引即数据，数据即索引</span>。</p><h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>&amp;emsp;&amp;emsp;大家有木有发现，上面介绍的<code>聚簇索引</code>只能在搜索条件是主键值时才能发挥作用，因为<code>B+</code>树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该咋办呢？难道只能从头到尾沿着链表依次遍历记录么？</p><p>&amp;emsp;&amp;emsp;不，我们可以多建几棵<code>B+</code>树，不同的<code>B+</code>树中的数据采用不同的排序规则。比方说我们用<code>c2</code>列的大小作为数据页、页中记录的排序规则，再建一棵<code>B+</code>树，效果如下图所示：</p><p><img src="/../images/06-14.png"></p><p>&amp;emsp;&amp;emsp;这个<code>B+</code>树与上面介绍的聚簇索引有几处不同：</p><ul><li><p>使用记录<code>c2</code>列的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li><p>页内的记录是按照<code>c2</code>列的大小顺序排成一个单向链表。</p></li><li><p>各个存放用户记录的页也是根据页中记录的<code>c2</code>列大小顺序排成一个双向链表。</p></li><li><p>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的<code>c2</code>列大小顺序排成一个双向链表。</p></li></ul></li><li><p><code>B+</code>树的叶子节点存储的并不是完整的用户记录，而只是<code>c2列+主键</code>这两个列的值。</p></li><li><p>目录项记录中不再是<code>主键+页号</code>的搭配，而变成了<code>c2列+页号</code>的搭配。</p></li></ul><p>&amp;emsp;&amp;emsp;所以如果我们现在想通过<code>c2</code>列的值查找某些记录的话就可以使用我们刚刚建好的这个<code>B+</code>树了。以查找<code>c2</code>列的值为<code>4</code>的记录为例，查找过程如下：</p><ol><li><p>确定<code>目录项记录</code>页</p><p> &amp;emsp;&amp;emsp;根据<code>根页面</code>，也就是<code>页44</code>，可以快速定位到<code>目录项记录</code>所在的页为<code>页42</code>（因为<code>2 &lt; 4 &lt; 9</code>）。</p></li><li><p>通过<code>目录项记录</code>页确定用户记录真实所在的页。</p><p> &amp;emsp;&amp;emsp;在<code>页42</code>中可以快速定位到实际存储用户记录的页，但是由于<code>c2</code>列并没有唯一性约束，所以<code>c2</code>列值为<code>4</code>的记录可能分布在多个数据页中，又因为<code>2 &lt; 4 ≤ 4</code>，所以确定实际存储用户记录的页在<code>页34</code>和<code>页35</code>中。</p></li><li><p>在真实存储用户记录的页中定位到具体的记录。</p><p> &amp;emsp;&amp;emsp;到<code>页34</code>和<code>页35</code>中定位到具体的记录。</p></li><li><p>但是这个<code>B+</code>树的叶子节点中的记录只存储了<code>c2</code>和<code>c1</code>（也就是<code>主键</code>）两个列，所以<span style="color:red">我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录</span>。</p></li></ol><p>&amp;emsp;&amp;emsp;各位各位，看到步骤4的操作了么？我们根据这个以<code>c2</code>列大小排序的<code>B+</code>树只能确定我们要查找记录的主键值，所以如果我们想根据<code>c2</code>列的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一遍，这个过程也被称为<code>回表</code>。也就是根据<code>c2</code>列的值查询一条完整的用户记录需要使用到<code>2</code>棵<code>B+</code>树！！！</p><p>&amp;emsp;&amp;emsp;为什么我们还需要一次<code>回表</code>操作呢？直接把完整的用户记录放到<code>叶子节点</code>不就好了么？你说的对，如果把完整的用户记录放到<code>叶子节点</code>是可以不用<code>回表</code>，但是太占地方了呀～相当于每建立一棵<code>B+</code>树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。因为这种按照<code>非主键列</code>建立的<code>B+</code>树需要一次<code>回表</code>操作才可以定位到完整的用户记录，所以这种<code>B+</code>树也被称为<code>二级索引</code>（英文名<code>secondary index</code>），或者<code>辅助索引</code>。由于我们使用的是<code>c2</code>列的大小作为<code>B+</code>树的排序规则，所以我们也称这个<code>B+</code>树为<span style="color:red">为c2列建立的索引</span>。</p><h5 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h5><p>&amp;emsp;&amp;emsp;我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让<code>B+</code>树按照<code>c2</code>和<code>c3</code>列的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照<code>c2</code>列进行排序。</li><li>在记录的<code>c2</code>列相同的情况下，采用<code>c3</code>列进行排序</li></ul><p>&amp;emsp;&amp;emsp;为<code>c2</code>和<code>c3</code>列建立的索引的示意图如下：</p><p><img src="/../images/06-15.png"></p><p>&amp;emsp;&amp;emsp;如图所示，我们需要注意一下几点：</p><ul><li><p>每条<code>目录项记录</code>都由<code>c2</code>、<code>c3</code>、<code>页号</code>这三个部分组成，各条记录先按照<code>c2</code>列的值进行排序，如果记录的<code>c2</code>列相同，则按照<code>c3</code>列的值进行排序。</p></li><li><p><code>B+</code>树叶子节点处的用户记录由<code>c2</code>、<code>c3</code>和主键<code>c1</code>列组成。</p></li></ul><p>&amp;emsp;&amp;emsp;千万要注意一点，<span style="color:red">以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的</span>，不同点如下：</p><ul><li><p>建立<code>联合索引</code>只会建立如上图一样的1棵<code>B+</code>树。</p></li><li><p>为c2和c3列分别建立索引会分别以<code>c2</code>和<code>c3</code>列的大小为排序规则建立2棵<code>B+</code>树。</p></li></ul><h3 id="InnoDB的B-树索引的注意事项"><a href="#InnoDB的B-树索引的注意事项" class="headerlink" title="InnoDB的B+树索引的注意事项"></a>InnoDB的B+树索引的注意事项</h3><h4 id="根页面万年不动窝"><a href="#根页面万年不动窝" class="headerlink" title="根页面万年不动窝"></a>根页面万年不动窝</h4><p>&amp;emsp;&amp;emsp;我们前面介绍<code>B+</code>树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上<code>B+</code>树的形成过程是这样的：</p><ul><li><p>每当为某个表创建一个<code>B+</code>树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个<code>B+</code>树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</p></li><li><p>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</p></li><li><p>当<code>根节点</code>中的可用空间用完时继续插入记录，此时会将<code>根节点</code>中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</p></li></ul><p>&amp;emsp;&amp;emsp;这个过程需要大家特别注意的是：<span style="color:red">一个B+树索引的根节点自诞生之日起，便不会再移动</span>。这样只要我们对某个表建立一个索引，那么它的<code>根节点</code>的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出<code>根节点</code>的页号，从而来访问这个索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：跟大家剧透一下，这个存储某个索引的根节点在哪个页面中的信息就是传说中的数据字典中的一项信息，关于更多数据字典的内容，后边会详细介绍，别着急。</span><br></pre></td></tr></table></figure><h4 id="内节点中目录项记录的唯一性"><a href="#内节点中目录项记录的唯一性" class="headerlink" title="内节点中目录项记录的唯一性"></a>内节点中目录项记录的唯一性</h4><p>&amp;emsp;&amp;emsp;我们知道<code>B+</code>树索引的内节点中目录项记录的内容是<code>索引列 + 页号</code>的搭配，但是这个搭配对于二级索引来说有点儿不严谨。还拿<code>index_demo</code>表为例，假设这个表中的数据是这样的：</p><table><thead><tr><th align="center"><code>c1</code></th><th align="center"><code>c2</code></th><th align="center"><code>c3</code></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">‘u’</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">‘d’</td></tr><tr><td align="center">5</td><td align="center">1</td><td align="center">‘y’</td></tr><tr><td align="center">7</td><td align="center">1</td><td align="center">‘a’</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;如果二级索引中目录项记录的内容只是<code>索引列 + 页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的<code>B+</code>树应该长这样：</p><p><img src="/../images/06-16.png"></p><p>&amp;emsp;&amp;emsp;如果我们想新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是：<code>9</code>、<code>1</code>、<code>&#39;c&#39;</code>，那么在修改这个为<code>c2</code>列建立的二级索引对应的<code>B+</code>树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的<code>c2</code>列的值都是<code>1</code>，而我们新插入的这条记录的<code>c2</code>列的值也是<code>1</code>，那我们这条新插入的记录到底应该放到<code>页4</code>中，还是应该放到<code>页5</code>中啊？答案是：对不起，懵逼了。</p><p>&amp;emsp;&amp;emsp;为了让新插入记录能找到自己在那个页里，<span style="color:red">我们需要保证在B+树的同一层内节点的目录项记录除<code>页号</code>这个字段以外是唯一的</span>。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>&amp;emsp;&amp;emsp;也就是我们把<code>主键值</code>也添加到二级索引内节点中的目录项记录了，这样就能保证<code>B+</code>树每一层节点中各条目录项记录除<code>页号</code>这个字段外是唯一的，所以我们为<code>c2</code>列建立二级索引后的示意图实际上应该是这样子的：</p><p><img src="/../images/06-17.png"></p><p>&amp;emsp;&amp;emsp;这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 主键 + 页号</code>的值构成的，可以先把新记录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为<code>B+</code>树同一层中不同目录项记录的<code>c2列 + 主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到<code>页5</code>中。</p><h4 id="一个页面最少存储2条记录"><a href="#一个页面最少存储2条记录" class="headerlink" title="一个页面最少存储2条记录"></a>一个页面最少存储2条记录</h4><p>&amp;emsp;&amp;emsp;我们前面说过一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度杠杠的！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是什么效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录？逗我呢？所以<code>InnoDB</code>的一个数据页至少可以存放两条记录，这也是我们之前介绍记录行格式的时候说过一个结论（我们当时依据这个结论推导了表中只有一个列时该列在不发生行溢出的情况下最多能存储多少字节，忘了的话回去看看吧）。</p><h3 id="MyISAM中的索引方案简单介绍"><a href="#MyISAM中的索引方案简单介绍" class="headerlink" title="MyISAM中的索引方案简单介绍"></a>MyISAM中的索引方案简单介绍</h3><p>&amp;emsp;&amp;emsp;至此，我们介绍的都是<code>InnoDB</code>存储引擎中的索引方案，为了内容的完整性，以及各位可能在面试的时候遇到这类的问题，我们有必要再简单介绍一下<code>MyISAM</code>存储引擎中的索引方案。我们知道<code>InnoDB</code>中<span style="color:red">索引即数据，也就是聚簇索引的那棵<code>B+</code>树的叶子节点中已经把所有完整的用户记录都包含了</span>，而<code>MyISAM</code>的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：</p><ul><li><p>将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为<code>数据文件</code>。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。</p><p>  &amp;emsp;&amp;emsp;<code>MyISAM</code>记录也需要记录头信息来存储一些额外数据，我们以上面介绍过的<code>index_demo</code>表为例，看一下这个表中的记录使用<code>MyISAM</code>作为存储引擎在存储空间中的表示：</p><p>  <img src="/../images/06-18.png"></p><p>  &amp;emsp;&amp;emsp;由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。</p></li><li><p>使用<code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是<code>主键值 + 行号</code>的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！</p><p>  &amp;emsp;&amp;emsp;这一点和<code>InnoDB</code>是完全不相同的，在<code>InnoDB</code>存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次<code>回表</code>操作，意味着<span style="color:red"><code>MyISAM</code>中建立的索引相当于全部都是<code>二级索引</code></span>！</p></li><li><p>如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和<code>InnoDB</code>中的索引差不多，不过在叶子节点处存储的是<code>相应的列 + 行号</code>。这些索引也全部都是<code>二级索引</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小贴士：MyISAM的行格式有定长记录格式（Static）、变长记录格式（Dynamic）、压缩记录格式（Compressed）。上面用到的index_demo表采用定长记录格式，也就是一条记录占用存储空间的大小是固定的，这样就可以轻松算出某条记录在数据文件中的地址偏移量。但是变长记录格式就不行了，MyISAM会直接在索引叶子节点处存储该条记录在数据文件中的地址偏移量。通过这个可以看出，MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里边儿找记录，虽然说也不慢，但还是比不上直接用地址去访问。  </span><br><span class="line">    此处我们只是非常简要的介绍了一下MyISAM的索引，具体细节全拿出来又可以写一篇文章了。这里只是希望大家理解InnoDB中的索引即数据，数据即索引，而MyISAM中却是索引是索引、数据是数据。</span><br></pre></td></tr></table></figure></li></ul><h3 id="MySQL中创建和删除索引的语句"><a href="#MySQL中创建和删除索引的语句" class="headerlink" title="MySQL中创建和删除索引的语句"></a>MySQL中创建和删除索引的语句</h3><p>&amp;emsp;&amp;emsp;光顾着介绍索引的原理了，那我们如何使用<code>MySQL</code>语句去建立这种索引呢？<code>InnoDB</code>和<code>MyISAM</code>会<span style="color:red">自动</span>为主键或者声明为<code>UNIQUE</code>的列去自动建立<code>B+</code>树索引，但是如果我们想为其他的列建立索引就需要我们显式的去指明。为什么不自动为每个列都建立个索引呢？别忘了，每建立一个索引都会建立一棵<code>B+</code>树，每插入一条记录都要维护各个记录、数据页的排序关系，这是很费性能和存储空间的。</p><p>&amp;emsp;&amp;emsp;我们可以在创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TALBE 表名 (</span><br><span class="line">    各种列的信息 ··· , </span><br><span class="line">    [KEY|INDEX] 索引名 (需要被索引的单个列或多个列)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;其中的<code>KEY</code>和<code>INDEX</code>是同义词，任意选用一个就可以。我们也可以在修改表结构的时候添加索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;也可以在修改表结构的时候删除索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;比方说我们想在创建<code>index_demo</code>表的时候就为<code>c2</code>和<code>c3</code>列添加一个<code>联合索引</code>，可以这么写建表语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE index_demo(</span><br><span class="line">    c1 INT,</span><br><span class="line">    c2 INT,</span><br><span class="line">    c3 CHAR(1),</span><br><span class="line">    PRIMARY KEY(c1),</span><br><span class="line">    INDEX idx_c2_c3 (c2, c3)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;在这个建表语句中我们创建的索引名是<code>idx_c2_c3</code>，这个名称可以随便起，不过我们还是建议以<code>idx_</code>为前缀，后边跟着需要建立索引的列名，多个列名之间用下划线<code>_</code>分隔开。</p><p>&amp;emsp;&amp;emsp;如果我们想删除这个索引，可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE index_demo DROP INDEX idx_c2_c3;</span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/07-%E5%A5%BD%E4%B8%9C%E8%A5%BF%E4%B9%9F%E5%BE%97%E5%85%88%E5%AD%A6%E4%BC%9A%E6%80%8E%E4%B9%88%E7%94%A8-B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/10/31/model-mysql/mysql/07-%E5%A5%BD%E4%B8%9C%E8%A5%BF%E4%B9%9F%E5%BE%97%E5%85%88%E5%AD%A6%E4%BC%9A%E6%80%8E%E4%B9%88%E7%94%A8-B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="第7章-好东西也得先学会怎么用-B-树索引的使用"><a href="#第7章-好东西也得先学会怎么用-B-树索引的使用" class="headerlink" title="第7章 好东西也得先学会怎么用-B+树索引的使用"></a>第7章 好东西也得先学会怎么用-B+树索引的使用</h1><p>&amp;emsp;&amp;emsp;我们前面详细、详细又详细的介绍了<code>InnoDB</code>存储引擎的<code>B+</code>树索引，我们必须熟悉下面这些结论：</p><ul><li><p>每个索引都对应一棵<code>B+</code>树，<code>B+</code>树分为好多层，最下面一层是叶子节点，其余的是内节点。所有<code>用户记录</code>都存储在<code>B+</code>树的叶子节点，所有<code>目录项记录</code>都存储在内节点。</p></li><li><p><code>InnoDB</code>存储引擎会自动为主键（如果没有它会自动帮我们添加）建立<code>聚簇索引</code>，聚簇索引的叶子节点包含完整的用户记录。</p></li><li><p>我们可以为自己感兴趣的列建立<code>二级索引</code>，<code>二级索引</code>的叶子节点包含的用户记录由<code>索引列 + 主键</code>组成，所以如果想通过<code>二级索引</code>来查找完整的用户记录的话，需要通过<code>回表</code>操作，也就是在通过<code>二级索引</code>找到主键值之后再到<code>聚簇索引</code>中查找完整的用户记录。</p></li><li><p><code>B+</code>树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是<code>联合索引</code>的话，则页面和记录先按照<code>联合索引</code>前面的列排序，如果该列值相同，再按照<code>联合索引</code>后边的列排序。</p></li><li><p>通过索引查找记录是从<code>B+</code>树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了<code>Page Directory</code>（页目录），所以在这些页面中的查找非常快。</p></li></ul><p>&amp;emsp;&amp;emsp;如果你读上面的几点结论有些任何一点点疑惑的话，那下面的内容不适合你，回过头先去看前面的内容去。</p><h2 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h2><p>&amp;emsp;&amp;emsp;在熟悉了<code>B+</code>树索引原理之后，本篇文章的主题是介绍如何更好的使用索引，虽然索引是个好东西，可不能乱建，在介绍如何更好的使用索引之前先要了解一下使用这玩意儿的代价，它在空间和时间上都会拖后腿：</p><ul><li><p>空间上的代价</p><p>  &amp;emsp;&amp;emsp;这个是显而易见的，每建立一个索引都要为它建立一棵<code>B+</code>树，每一棵<code>B+</code>树的每一个节点都是一个数据页，一个页默认会占用<code>16KB</code>的存储空间，一棵很大的<code>B+</code>树由许多数据页组成，那可是很大的一片存储空间呢。</p></li><li><p>时间上的代价</p><p>  &amp;emsp;&amp;emsp;每次对表中的数据进行增、删、改操作时，都需要去修改各个<code>B+</code>树索引。而且我们讲过，<code>B+</code>树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收什么的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的<code>B+</code>树都要进行相关的维护操作，这还能不给性能拖后腿么？</p></li></ul><p>&amp;emsp;&amp;emsp;所以说，一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们先得学学这些索引在哪些条件下起作用的。</p><h2 id="B-树索引适用的条件"><a href="#B-树索引适用的条件" class="headerlink" title="B+树索引适用的条件"></a>B+树索引适用的条件</h2><p>&amp;emsp;&amp;emsp;下面我们将介绍许多种让<code>B+</code>树索引发挥最大效能的技巧和注意事项，不过大家要清楚，所有的技巧都是源自你对<code>B+</code>树索引本质的理解，所以如果你还不能保证对<code>B+</code>树索引充分的理解，那么再次建议回过头把前面的内容看完了再来，要不然读文章对你来说是一种折磨。首先，<code>B+</code>树索引并不是万能的，并不是所有的查询语句都能用到我们建立的索引。下面介绍几个我们可能使用<code>B+</code>树索引来进行查询的情况。为了故事的顺利发展，我们需要先创建一个表，这个表是用来存储人的一些基本信息的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE person_info(</span><br><span class="line">    id INT NOT NULL auto_increment,</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    birthday DATE NOT NULL,</span><br><span class="line">    phone_number CHAR(11) NOT NULL,</span><br><span class="line">    country varchar(100) NOT NULL,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name, birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;对于这个<code>person_info</code>表我们需要注意两点：</p><ul><li><p>表中的主键是<code>id</code>列，它存储一个自动递增的整数。所以<code>InnoDB</code>存储引擎会自动为<code>id</code>列建立聚簇索引。</p></li><li><p>我们额外定义了一个二级索引<code>idx_name_birthday_phone_number</code>，它是由3个列组成的联合索引。所以在这个索引对应的<code>B+</code>树的叶子节点处存储的用户记录只保留<code>name</code>、<code>birthday</code>、<code>phone_number</code>这三个列的值以及主键<code>id</code>的值，并不会保存<code>country</code>列的值。</p></li></ul><p>&amp;emsp;&amp;emsp;从这两点注意中我们可以再次看到，一个表中有多少索引就会建立多少棵<code>B+</code>树，<code>person_info</code>表会为聚簇索引和<code>idx_name_birthday_phone_number</code>索引建立2棵<code>B+</code>树。下面我们画一下索引<code>idx_name_birthday_phone_number</code>的示意图，不过既然我们已经掌握了<code>InnoDB</code>的<code>B+</code>树索引原理，那我们在画图的时候为了让图更加清晰，所以在省略一些不必要的部分，比如记录的额外信息，各页面的页号等等，其中内节点中目录项记录的页号信息我们用箭头来代替，在记录结构中只保留<code>name</code>、<code>birthday</code>、<code>phone_number</code>、<code>id</code>这四个列的真实数据值，所以示意图就长这样（留心的同学看出来了，这其实和《高性能MySQL》里举的例子的图差不多，我觉得这个例子特别好，所以就借鉴了一下）：</p><p><img src="/../images/07-01.png"></p><p>&amp;emsp;&amp;emsp;为了方便大家理解，我们特意标明了哪些是内节点，哪些是叶子节点。再次强调一下，内节点中存储的是<code>目录项记录</code>，叶子节点中存储的是<code>用户记录</code>（由于不是聚簇索引，所以用户记录是不完整的，缺少<code>country</code>列的值）。从图中可以看出，这个<code>idx_name_birthday_phone_number</code>索引对应的<code>B+</code>树中页面和记录的排序方式就是这样的：</p><ul><li>先按照<code>name</code>列的值进行排序。</li><li>如果<code>name</code>列的值相同，则按照<code>birthday</code>列的值进行排序。</li><li>如果<code>birthday</code>列的值也相同，则按照<code>phone_number</code>的值进行排序。</li></ul><p>&amp;emsp;&amp;emsp;这个排序方式<span style="color:red">十分</span>、<span style="color:red">特别</span>、<span style="color:red">非常</span>、<span style="color:red">巨</span>、<span style="color:red">very very very</span>重要，因为<span style="color:red">只要页面和记录是排好序的，我们就可以通过二分法来快速定位查找</span>。下面的内容都仰仗这个图了，大家对照着图理解。</p><h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>&amp;emsp;&amp;emsp;如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下面这个查找语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name = &#x27;Ashburn&#x27; AND birthday = &#x27;1990-09-27&#x27; AND phone_number = &#x27;15123983239&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们建立的<code>idx_name_birthday_phone_number</code>索引包含的3个列在这个查询语句中都展现出来了。大家可以想象一下这个查询过程：</p><ul><li><p>因为<code>B+</code>树的数据页和记录先是按照<code>name</code>列的值进行排序的，所以先可以很快定位<code>name</code>列的值是<code>Ashburn</code>的记录位置。</p></li><li><p>在<code>name</code>列相同的记录里又是按照<code>birthday</code>列的值进行排序的，所以在<code>name</code>列的值是<code>Ashburn</code>的记录里又可以快速定位<code>birthday</code>列的值是<code>&#39;1990-09-27&#39;</code>的记录。</p></li><li><p>如果很不幸，<code>name</code>和<code>birthday</code>列的值都是相同的，那记录是按照<code>phone_number</code>列的值排序的，所以联合索引中的三个列都可能被用到。</p></li></ul><p>&amp;emsp;&amp;emsp;有的同学也许有个疑问，<code>WHERE</code>子句中的几个搜索条件的顺序对查询结果有什么影响么？也就是说如果我们调换<code>name</code>、<code>birthday</code>、<code>phone_number</code>这几个搜索列的顺序对查询的执行过程有影响么？比方说写成下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE birthday = &#x27;1990-09-27&#x27; AND phone_number = &#x27;15123983239&#x27; AND name = &#x27;Ashburn&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;答案是：没影响。<code>MySQL</code>有一个叫查询优化器的东东，会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件。我们后边儿会有专门的章节来介绍查询优化器，敬请期待。</p><h3 id="匹配左边的列"><a href="#匹配左边的列" class="headerlink" title="匹配左边的列"></a>匹配左边的列</h3><p>&amp;emsp;&amp;emsp;其实在我们的搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行，比方说下面的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name = &#x27;Ashburn&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;或者包含多个左边的列也行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name = &#x27;Ashburn&#x27; AND birthday = &#x27;1990-09-27&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;那为什么搜索条件中必须出现左边的列才可以使用到这个<code>B+</code>树索引呢？比如下面的语句就用不到这个<code>B+</code>树索引么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE birthday = &#x27;1990-09-27&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;是的，的确用不到，因为<code>B+</code>树的数据页和记录先是按照<code>name</code>列的值排序的，在<code>name</code>列的值相同的情况下才使用<code>birthday</code>列进行排序，也就是说<code>name</code>列的值不同的记录中<code>birthday</code>的值可能是无序的。而现在你跳过<code>name</code>列直接根据<code>birthday</code>的值去查找，臣妾做不到呀～ 那如果我就想在只使用<code>birthday</code>的值去通过<code>B+</code>树索引进行查找咋办呢？这好办，你再对<code>birthday</code>列建一个<code>B+</code>树索引就行了，创建索引的语法不用我介绍了吧。</p><p>&amp;emsp;&amp;emsp;但是需要特别注意的一点是，<span style="color:red">如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列</span>。比方说联合索引<code>idx_name_birthday_phone_number</code>中列的定义顺序是<code>name</code>、<code>birthday</code>、<code>phone_number</code>，如果我们的搜索条件中只有<code>name</code>和<code>phone_number</code>，而没有中间的<code>birthday</code>，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name = &#x27;Ashburn&#x27; AND phone_number = &#x27;15123983239&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这样只能用到<code>name</code>列的索引，<code>birthday</code>和<code>phone_number</code>的索引就用不上了，因为<code>name</code>值相同的记录先按照<code>birthday</code>的值进行排序，<code>birthday</code>值相同的记录才按照<code>phone_number</code>值进行排序。</p><h3 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h3><p>&amp;emsp;&amp;emsp;我们前面说过为某个列建立索引的意思其实就是在对应的<code>B+</code>树的记录中使用该列的值进行排序，比方说<code>person_info</code>表上建立的联合索引<code>idx_name_birthday_phone_number</code>会先用<code>name</code>列的值进行排序，所以这个联合索引对应的<code>B+</code>树中的记录的<code>name</code>列的排列就是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Aaron</span><br><span class="line">Aaron</span><br><span class="line">...</span><br><span class="line">Aaron</span><br><span class="line">Asa</span><br><span class="line">Ashburn</span><br><span class="line">...</span><br><span class="line">Ashburn</span><br><span class="line">Baird</span><br><span class="line">Barlow</span><br><span class="line">...</span><br><span class="line">Barlow</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;字符串排序的本质就是比较哪个字符串大一点儿，哪个字符串小一点，比较字符串大小就用到了该列的字符集和比较规则，这个我们前面儿介绍过，就不多介绍了。这里需要注意的是，一般的比较规则都是逐个比较字符的大小，也就是说我们比较两个字符串的大小的过程其实是这样的：</p><ul><li><p>先比较字符串的第一个字符，第一个字符小的那个字符串就比较小。</p></li><li><p>如果两个字符串的第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小。</p></li><li><p>如果两个字符串的第二个字符也相同，那就接着比较第三个字符，依此类推。</p></li></ul><p>&amp;emsp;&amp;emsp;所以一个排好序的字符串列其实有这样的特点：</p><ul><li><p>先按照字符串的第一个字符进行排序。</p></li><li><p>如果第一个字符相同再按照第二个字符进行排序。</p></li><li><p>如果第二个字符相同再按照第三个字符进行排序，依此类推。</p></li></ul><p>&amp;emsp;&amp;emsp;也就是说这些字符串的前n个字符，也就是前缀都是排好序的，所以对于字符串类型的索引列来说，我们只匹配它的前缀也是可以快速定位记录的，比方说我们想查询名字以<code>&#39;As&#39;</code>开头的记录，那就可以这么写查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name LIKE &#x27;As%&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;但是需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name LIKE &#x27;%As%&#x27;;</span><br></pre></td></tr></table></figure><p><code>MySQL</code>就无法快速定位记录位置了，因为字符串中间有<code>&#39;As&#39;</code>的字符串并没有排好序，所以只能全表扫描了。有时候我们有一些匹配某些字符串后缀的需求，比方说某个表有一个<code>url</code>列，该列中存储了许多url：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----------------+</span><br><span class="line">| url            |</span><br><span class="line">+----------------+</span><br><span class="line">| www.baidu.com  |</span><br><span class="line">| www.google.com |</span><br><span class="line">| www.gov.cn     |</span><br><span class="line">| ...            |</span><br><span class="line">| www.wto.org    |</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;假设已经对该<code>url</code>列创建了索引，如果我们想查询以<code>com</code>为后缀的网址的话可以这样写查询条件：<code>WHERE url LIKE &#39;%com&#39;</code>，但是这样的话无法使用该<code>url</code>列的索引。为了在查询时用到这个索引而不至于全表扫描，我们可以把后缀查询改写成前缀查询，不过我们就得把表中的数据全部逆序存储一下，也就是说我们可以这样保存<code>url</code>列中的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----------------+</span><br><span class="line">| url            |</span><br><span class="line">+----------------+</span><br><span class="line">| moc.udiab.www  |</span><br><span class="line">| moc.elgoog.www |</span><br><span class="line">| nc.vog.www     |</span><br><span class="line">| ...            |</span><br><span class="line">| gro.otw.www    |</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这样再查找以<code>com</code>为后缀的网址时搜索条件便可以这么写：<code>WHERE url LIKE &#39;moc%&#39;</code>，这样就可以用到索引了。 </p><h3 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h3><p>&amp;emsp;&amp;emsp;回头看我们<code>idx_name_birthday_phone_number</code>索引的<code>B+</code>树示意图，<span style="color:red">所有记录都是按照索引列的值从小到大的顺序排好序的</span>，所以这极大的方便我们查找索引列的值在某个范围内的记录。比方说下面这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &gt; &#x27;Asa&#x27; AND name &lt; &#x27;Barlow&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;由于<code>B+</code>树中的数据页和记录是先按<code>name</code>列排序的，所以我们上面的查询过程其实是这样的：</p><ul><li>找到<code>name</code>值为<code>Asa</code>的记录。</li><li>找到<code>name</code>值为<code>Barlow</code>的记录。</li><li>哦啦，由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来喽～</li><li>找到这些记录的主键值，再到<code>聚簇索引</code>中<code>回表</code>查找完整的记录。</li></ul><p>&amp;emsp;&amp;emsp;不过在使用联合进行范围查找的时候需要注意，<span style="color:red">如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到<code>B+</code>树索引</span>，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &gt; &#x27;Asa&#x27; AND name &lt; &#x27;Barlow&#x27; AND birthday &gt; &#x27;1980-01-01&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;上面这个查询可以分成两个部分：</p><ol><li><p>通过条件<code>name &gt; &#39;Asa&#39; AND name &lt; &#39;Barlow&#39; </code>来对<code>name</code>进行范围，查找的结果可能有多条<code>name</code>值不同的记录，</p></li><li><p>对这些<code>name</code>值不同的记录继续通过<code>birthday &gt; &#39;1980-01-01&#39;</code>条件继续过滤。</p></li></ol><p>&amp;emsp;&amp;emsp;这样子对于联合索引<code>idx_name_birthday_phone_number</code>来说，只能用到<code>name</code>列的部分，而用不到<code>birthday</code>列的部分，因为只有<code>name</code>值相同的情况下才能用<code>birthday</code>列的值进行排序，而这个查询中<span style="color:red">通过<code>name</code>进行范围查找的记录中可能并不是按照<code>birthday</code>列进行排序的</span>，所以在搜索条件中继续以<code>birthday</code>列进行查找时是用不到这个<code>B+</code>树索引的。</p><h3 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="headerlink" title="精确匹配某一列并范围匹配另外一列"></a>精确匹配某一列并范围匹配另外一列</h3><p>&amp;emsp;&amp;emsp;对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name = &#x27;Ashburn&#x27; AND birthday &gt; &#x27;1980-01-01&#x27; AND birthday &lt; &#x27;2000-12-31&#x27; AND phone_number &gt; &#x27;15100000000&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个查询的条件可以分为3个部分：</p><ol><li><p><code>name = &#39;Ashburn&#39;</code>，对<code>name</code>列进行精确查找，当然可以使用<code>B+</code>树索引了。</p></li><li><p><code>birthday &gt; &#39;1980-01-01&#39; AND birthday &lt; &#39;2000-12-31&#39;</code>，由于<code>name</code>列是精确查找，所以通过<code>name = &#39;Ashburn&#39;</code>条件查找后得到的结果的<code>name</code>值都是相同的，它们会再按照<code>birthday</code>的值进行排序。所以此时对<code>birthday</code>列进行范围查找是可以用到<code>B+</code>树索引的。</p></li><li><p><code>phone_number &gt; &#39;15100000000&#39;</code>，通过<code>birthday</code>的范围查找的记录的<code>birthday</code>的值可能不同，所以这个条件无法再利用<code>B+</code>树索引了，只能遍历上一步查询得到的记录。</p></li></ol><p>&amp;emsp;&amp;emsp;同理，下面的查询也是可能用到这个<code>idx_name_birthday_phone_number</code>联合索引的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name = &#x27;Ashburn&#x27; AND birthday = &#x27;1980-01-01&#x27; AND phone_number &gt; &#x27;15100000000&#x27;;</span><br></pre></td></tr></table></figure><h3 id="用于排序"><a href="#用于排序" class="headerlink" title="用于排序"></a>用于排序</h3><p>&amp;emsp;&amp;emsp;我们在写查询语句的时候经常需要对查询出来的记录通过<code>ORDER BY</code>子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序、等等排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在<code>MySQL</code>中，把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：<code>filesort</code>），跟<code>文件</code>这个词儿一沾边儿，就显得这些排序操作非常慢了（磁盘和内存的速度比起来，就像是飞机和蜗牛的对比）。但是如果<code>ORDER BY</code>子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下面这个简单的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个查询的结果集需要先按照<code>name</code>值排序，如果记录的<code>name</code>值相同，则需要按照<code>birthday</code>来排序，如果<code>birthday</code>的值相同，则需要按照<code>phone_number</code>排序。大家可以回过头去看我们建立的<code>idx_name_birthday_phone_number</code>索引的示意图，因为这个<code>B+</code>树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行<code>回表</code>操作取出该索引中不包含的列就好了。简单吧？是的，索引就是这么牛逼。</p><h4 id="使用联合索引进行排序注意事项"><a href="#使用联合索引进行排序注意事项" class="headerlink" title="使用联合索引进行排序注意事项"></a>使用联合索引进行排序注意事项</h4><p>&amp;emsp;&amp;emsp;对于<code>联合索引</code>有个问题需要注意，<code>ORDER BY</code>的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出<code>ORDER BY phone_number, birthday, name</code>的顺序，那也是用不了<code>B+</code>树索引，这种颠倒顺序就不能使用索引的原因我们上面详细说过了，这就不赘述了。</p><p>&amp;emsp;&amp;emsp;同理，<code>ORDER BY name</code>、<code>ORDER BY name, birthday</code>这种匹配索引左边的列的形式可以使用部分的<code>B+</code>树索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name = &#x27;A&#x27; ORDER BY birthday, phone_number LIMIT 10;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个查询能使用联合索引进行排序是因为<code>name</code>列的值相同的记录是按照<code>birthday</code>, <code>phone_number</code>排序的，说了好多遍了都。</p><h4 id="不可以使用索引进行排序的几种情况"><a href="#不可以使用索引进行排序的几种情况" class="headerlink" title="不可以使用索引进行排序的几种情况"></a>不可以使用索引进行排序的几种情况</h4><h5 id="ASC、DESC混用"><a href="#ASC、DESC混用" class="headerlink" title="ASC、DESC混用"></a>ASC、DESC混用</h5><p>&amp;emsp;&amp;emsp;对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是<code>ASC</code>规则排序，要么都是<code>DESC</code>规则排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小贴士：</span><br><span class="line">ORDER BY子句后的列如果不加ASC或者DESC默认是按照ASC排序规则排序的，也就是升序排序的。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;为什么会有这种奇葩规定呢？这个还得回头想想这个<code>idx_name_birthday_phone_number</code>联合索引中记录的结构：</p><ul><li><p>先按照记录的<code>name</code>列的值进行升序排列。</p></li><li><p>如果记录的<code>name</code>列的值相同，再按照<code>birthday</code>列的值进行升序排列。</p></li><li><p>如果记录的<code>birthday</code>列的值相同，再按照<code>phone_number</code>列的值进行升序排列。</p></li></ul><p>&amp;emsp;&amp;emsp;如果查询中的各个排序列的排序顺序是一致的，比方说下面这两种情况：</p><ul><li><p><code>ORDER BY name, birthday LIMIT 10</code></p><p>  &amp;emsp;&amp;emsp;这种情况直接从索引的最左边开始往右读10行记录就可以了。</p></li><li><p><code>ORDER BY name DESC, birthday DESC LIMIT 10</code></p><p>  &amp;emsp;&amp;emsp;这种情况直接从索引的最右边开始往左读10行记录就可以了。</p></li></ul><p>&amp;emsp;&amp;emsp;但是如果我们查询的需求是先按照<code>name</code>列进行升序排列，再按照<code>birthday</code>列进行降序排列的话，比如说这样的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info ORDER BY name, birthday DESC LIMIT 10;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这样如果使用索引排序的话过程就是这样的：</p><ul><li><p>先从索引的最左边确定<code>name</code>列最小的值，然后找到<code>name</code>列等于该值的所有记录，然后从<code>name</code>列等于该值的最右边的那条记录开始往左找10条记录。</p></li><li><p>如果<code>name</code>列等于最小的值的记录不足10条，再继续往右找<code>name</code>值第二小的记录，重复上面那个过程，直到找到10条记录为止。</p></li></ul><p>&amp;emsp;&amp;emsp;累不累？累！重点是这样不能高效使用索引，而要采取更复杂的算法去从索引中取数据，设计<code>MySQL</code>的大佬觉得这样还不如直接文件排序来的快，所以就规定使用联合索引的各个排序列的排序顺序必须是一致的。</p><h5 id="WHERE子句中出现非排序使用到的索引列"><a href="#WHERE子句中出现非排序使用到的索引列" class="headerlink" title="WHERE子句中出现非排序使用到的索引列"></a>WHERE子句中出现非排序使用到的索引列</h5><p>&amp;emsp;&amp;emsp;如果WHERE子句中出现了非排序使用到的索引列，那么排序依然是使用不到索引的，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE country = &#x27;China&#x27; ORDER BY name LIMIT 10;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个查询只能先把符合搜索条件<code>country = &#39;China&#39;</code>的记录提取出来后再进行排序，是使用不到索引。注意和下面这个查询作区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name = &#x27;A&#x27; ORDER BY birthday, phone_number LIMIT 10;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;虽然这个查询也有搜索条件，但是<code>name = &#39;A&#39;</code>可以使用到索引<code>idx_name_birthday_phone_number</code>，而且过滤剩下的记录还是按照<code>birthday</code>、<code>phone_number</code>列排序的，所以还是可以使用索引进行排序的。</p><h5 id="排序列包含非同一个索引的列"><a href="#排序列包含非同一个索引的列" class="headerlink" title="排序列包含非同一个索引的列"></a>排序列包含非同一个索引的列</h5><p>&amp;emsp;&amp;emsp;有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序，比方说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info ORDER BY name, country LIMIT 10;</span><br></pre></td></tr></table></figure><p><code>name</code>和<code>country</code>并不属于一个联合索引中的列，所以无法使用索引进行排序，至于为什么我就不想再介绍了，自己用前面的理论自己捋一捋把～</p><h5 id="排序列使用了复杂的表达式"><a href="#排序列使用了复杂的表达式" class="headerlink" title="排序列使用了复杂的表达式"></a>排序列使用了复杂的表达式</h5><p>&amp;emsp;&amp;emsp;要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;使用了<code>UPPER</code>函数修饰过的列就不是单独的列啦，这样就无法使用索引进行排序啦。</p><h3 id="用于分组"><a href="#用于分组" class="headerlink" title="用于分组"></a>用于分组</h3><p>&amp;emsp;&amp;emsp;有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下面这个分组查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个查询语句相当于做了3次分组操作：</p><ol><li><p>先把记录按照<code>name</code>值进行分组，所有<code>name</code>值相同的记录划分为一组。</p></li><li><p>将每个<code>name</code>值相同的分组里的记录再按照<code>birthday</code>的值进行分组，将<code>birthday</code>值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。</p></li><li><p>再将上一步中产生的小分组按照<code>phone_number</code>的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把<code>大分组</code>分成若干个<code>小分组</code>，然后把若干个<code>小分组</code>再细分成更多的<code>小小分组</code>。</p></li></ol><p>&amp;emsp;&amp;emsp;然后针对那些<code>小小分组</code>进行统计，比如在我们这个查询语句中就是统计每个<code>小小分组</code>包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的<code>B+</code>树中的索引列的顺序是一致的，而我们的<code>B+</code>树索引又是按照索引列排好序的，这不正好么，所以可以直接使用<code>B+</code>树索引进行分组。</p><p>&amp;emsp;&amp;emsp;和使用<code>B+</code>树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组，等等的～</p><h2 id="回表的代价"><a href="#回表的代价" class="headerlink" title="回表的代价"></a>回表的代价</h2><p>&amp;emsp;&amp;emsp;上面的讨论对<code>回表</code>这个词儿多是一带而过，可能大家没什么深刻的体会，下面我们详细介绍下。还是用<code>idx_name_birthday_phone_number</code>索引为例，看下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &gt; &#x27;Asa&#x27; AND name &lt; &#x27;Barlow&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;在使用<code>idx_name_birthday_phone_number</code>索引进行查询时大致可以分为这两个步骤：</p><ol><li><p>从索引<code>idx_name_birthday_phone_number</code>对应的<code>B+</code>树中取出<code>name</code>值在<code>Asa</code>～<code>Barlow</code>之间的用户记录。</p></li><li><p>由于索引<code>idx_name_birthday_phone_number</code>对应的<code>B+</code>树用户记录中只包含<code>name</code>、<code>birthday</code>、<code>phone_number</code>、<code>id</code>这4个字段，而查询列表是<code>*</code>，意味着要查询表中所有字段，也就是还要包括<code>country</code>字段。这时需要把从上一步中获取到的每一条记录的<code>id</code>字段都到聚簇索引对应的<code>B+</code>树中找到完整的用户记录，也就是我们通常所说的<code>回表</code>，然后把完整的用户记录返回给查询用户。</p></li></ol><p>&amp;emsp;&amp;emsp;由于索引<code>idx_name_birthday_phone_number</code>对应的<code>B+</code>树中的记录首先会按照<code>name</code>列的值进行排序，所以值在<code>Asa</code>～<code>Barlow</code>之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为<code>顺序I/O</code>。根据第1步中获取到的记录的<code>id</code>字段的值可能并不相连，而在聚簇索引中记录是根据<code>id</code>（也就是主键）的顺序排列的，所以根据这些并不连续的<code>id</code>值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为<code>随机I/O</code>。一般情况下，顺序I&#x2F;O比随机I&#x2F;O的性能高很多，所以步骤1的执行可能很快，而步骤2就慢一些。所以这个使用索引<code>idx_name_birthday_phone_number</code>的查询有这么两个特点：</p><ul><li><p>会使用到两个<code>B+</code>树索引，一个二级索引，一个聚簇索引。</p></li><li><p>访问二级索引使用<code>顺序I/O</code>，访问聚簇索引使用<code>随机I/O</code>。</p></li></ul><p>&amp;emsp;&amp;emsp;<span style="color:red">需要回表的记录越多，使用二级索引的性能就越低</span>，甚至让某些查询宁愿使用全表扫描也不使用<code>二级索引</code>。比方说<code>name</code>值在<code>Asa</code>～<code>Barlow</code>之间的用户记录数量占全部记录数量90%以上，那么如果使用<code>idx_name_birthday_phone_number</code>索引的话，有90%多的<code>id</code>值需要回表，这不是吃力不讨好么，还不如直接去扫描聚簇索引（也就是全表扫描）。</p><p>&amp;emsp;&amp;emsp;那什么时候采用全表扫描的方式，什么时候使用采用<code>二级索引 + 回表</code>的方式去执行查询呢？这个就是传说中的查询优化器做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用<code>二级索引 + 回表</code>的方式。当然优化器做的分析工作不仅仅是这么简单，但是大致上是个这个过程。一般情况下，限制查询获取较少的记录数会让优化器更倾向于选择使用<code>二级索引 + 回表</code>的方式进行查询，因为回表的记录越少，性能提升就越高，比方说上面的查询可以改写成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &gt; &#x27;Asa&#x27; AND name &lt; &#x27;Barlow&#x27; LIMIT 10;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;添加了<code>LIMIT 10</code>的查询更容易让优化器采用<code>二级索引 + 回表</code>的方式进行查询。</p><p>&amp;emsp;&amp;emsp;对于有排序需求的查询，上面讨论的采用<code>全表扫描</code>还是<code>二级索引 + 回表</code>的方式进行查询的条件也是成立的，比方说下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info ORDER BY name, birthday, phone_number;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;由于查询列表是<code>*</code>，所以如果使用二级索引进行排序的话，需要把排序完的二级索引记录全部进行回表操作，这样操作的成本还不如直接遍历聚簇索引然后再进行文件排序（<code>filesort</code>）低，所以优化器会倾向于使用<code>全表扫描</code>的方式执行查询。如果我们加了<code>LIMIT</code>子句，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这样需要回表的记录特别少，优化器就会倾向于使用<code>二级索引 + 回表</code>的方式执行查询。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>&amp;emsp;&amp;emsp;为了彻底告别<code>回表</code>操作带来的性能损耗，我们建议：<span style="color:red">最好在查询列表里只包含索引列</span>，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, birthday, phone_number FROM person_info  </span><br><span class="line">    WHERE name &gt; &#x27;Asa&#x27; AND name &lt; &#x27;Barlow&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;因为我们只查询<code>name</code>, <code>birthday</code>, <code>phone_number</code>这三个索引列的值，所以在通过<code>idx_name_birthday_phone_number</code>索引得到结果后就不必到<code>聚簇索引</code>中再查找记录的剩余列，也就是<code>country</code>列的值了，这样就省去了<code>回表</code>操作带来的性能损耗。我们把这种只需要用到索引的查询方式称为<code>索引覆盖</code>。排序操作也优先使用<code>覆盖索引</code>的方式进行查询，比方说这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, birthday, phone_number  FROM person_info   </span><br><span class="line">    ORDER BY name, birthday, phone_number;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;虽然这个查询中没有<code>LIMIT</code>子句，但是采用了<code>覆盖索引</code>，所以查询优化器就会直接使用<code>idx_name_birthday_phone_number</code>索引进行排序而不需要回表操作了。</p><p>&amp;emsp;&amp;emsp;当然，如果业务需要查询出索引以外的列，那还是以保证业务需求为重。但是<span style="color:red">我们很不鼓励用<code>*</code>号作为查询列表，最好把我们需要查询的列依次标明</span>。</p><h2 id="如何挑选索引"><a href="#如何挑选索引" class="headerlink" title="如何挑选索引"></a>如何挑选索引</h2><p>&amp;emsp;&amp;emsp;上面我们以<code>idx_name_birthday_phone_number</code>索引为例对索引的适用条件进行了详细的介绍，下面看一下我们在建立索引时或者编写查询语句时就应该注意的一些事项。</p><h3 id="只为用于搜索、排序或分组的列创建索引"><a href="#只为用于搜索、排序或分组的列创建索引" class="headerlink" title="只为用于搜索、排序或分组的列创建索引"></a>只为用于搜索、排序或分组的列创建索引</h3><p>&amp;emsp;&amp;emsp;也就是说，只为出现在<code>WHERE</code>子句中的列、连接子句中的连接列，或者出现在<code>ORDER BY</code>或<code>GROUP BY</code>子句中的列创建索引。而出现在查询列表中的列就没必要建立索引了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT birthday, country FROM person_name WHERE name = &#x27;Ashburn&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;像查询列表中的<code>birthday</code>、<code>country</code>这两个列就不需要建立索引，我们只需要为出现在<code>WHERE</code>子句中的<code>name</code>列创建索引就可以了。</p><h3 id="考虑列的基数"><a href="#考虑列的基数" class="headerlink" title="考虑列的基数"></a>考虑列的基数</h3><p>&amp;emsp;&amp;emsp;<code>列的基数</code>指的是某一列中不重复数据的个数，比方说某个列包含值<code>2, 5, 8, 2, 5, 8, 2, 5, 8</code>，虽然有<code>9</code>条记录，但该列的基数却是<code>3</code>。也就是说，<span style="color:red">在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中</span>。这个<code>列的基数</code>指标非常重要，直接影响我们是否能有效的利用索引。假设某个列的基数为<code>1</code>，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，因为所有值都一样就无法排序，无法进行快速查找了～ 而且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。所以结论就是：<span style="color:red">最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好</span>。</p><h3 id="索引列的类型尽量小"><a href="#索引列的类型尽量小" class="headerlink" title="索引列的类型尽量小"></a>索引列的类型尽量小</h3><p>&amp;emsp;&amp;emsp;我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有<code>TINYINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>这么几种，它们占用的存储空间依次递增，我们这里所说的<code>类型大小</code>指的就是<span style="color:red">该类型表示的数据范围的大小</span>。能表示的整数范围当然也是依次递增，如果我们想要对某个整数列建立索引的话，<span style="color:red">在表示的整数范围允许的情况下，尽量让索引列使用较小的类型</span>，比如我们能使用<code>INT</code>就不要使用<code>BIGINT</code>，能使用<code>MEDIUMINT</code>就不要使用<code>INT</code>～ 这是因为：</p><ul><li><p>数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）</p></li><li><p>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘<code>I/O</code>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</p></li></ul><p>&amp;emsp;&amp;emsp;这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的<code>I/O</code>。</p><h3 id="索引字符串值的前缀"><a href="#索引字符串值的前缀" class="headerlink" title="索引字符串值的前缀"></a>索引字符串值的前缀</h3><p>&amp;emsp;&amp;emsp;我们知道一个字符串其实是由若干个字符组成，如果我们在<code>MySQL</code>中使用<code>utf8</code>字符集去存储字符串的话，编码一个字符需要占用<code>1~3</code>个字节。假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的<code>B+</code>树中有这么两个问题：</p><ul><li><p><code>B+</code>树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。</p></li><li><p>如果<code>B+</code>树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</p></li></ul><p>&amp;emsp;&amp;emsp;我们前面儿说过索引列的字符串前缀其实也是排好序的，所以索引的设计者提出了个方案 — <span style="color:red">只对字符串的前几个字符进行索引</span>也就是说在二级索引的记录中只保留字符串前几个字符。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。这样只在<code>B+</code>树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时间，还大概能解决排序的问题，何乐而不为，比方说我们在建表语句中只对<code>name</code>列的前10个字符进行索引可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE person_info(</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    birthday DATE NOT NULL,</span><br><span class="line">    phone_number CHAR(11) NOT NULL,</span><br><span class="line">    country varchar(100) NOT NULL,</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)</span><br><span class="line">);    </span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;<code>name(10)</code>就表示在建立的<code>B+</code>树索引中只保留记录的前<code>10</code>个字符的编码，这种<span style="color:red">只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候</span>。</p><h4 id="索引列前缀对排序的影响"><a href="#索引列前缀对排序的影响" class="headerlink" title="索引列前缀对排序的影响"></a>索引列前缀对排序的影响</h4><p>&amp;emsp;&amp;emsp;如果使用了索引列前缀，比方说前面只把<code>name</code>列的前10个字符放到了二级索引中，下面这个查询可能就有点儿尴尬了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person_info ORDER BY name LIMIT 10;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;因为二级索引中不包含完整的<code>name</code>列信息，所以无法对前十个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序，只好乖乖的用文件排序喽。</p><h3 id="让索引列在比较表达式中单独出现"><a href="#让索引列在比较表达式中单独出现" class="headerlink" title="让索引列在比较表达式中单独出现"></a>让索引列在比较表达式中单独出现</h3><p>&amp;emsp;&amp;emsp;假设表中有一个整数列<code>my_col</code>，我们为这个列建立了索引。下面的两个<code>WHERE</code>子句虽然语义是一致的，但是在效率上却有差别：</p><ol><li><p><code>WHERE my_col * 2 &lt; 4</code></p></li><li><p><code>WHERE my_col &lt; 4/2</code></p></li></ol><p>&amp;emsp;&amp;emsp;第1个<code>WHERE</code>子句中<code>my_col</code>列并<span style="color:red">不是</span>以单独列的形式出现的，而是以<code>my_col * 2</code>这样的表达式的形式出现的，存储引擎<span style="color:red">会依次遍历所有的记录，计算这个表达式的值是不是小于<code>4</code></span>，所以这种情况下是使用不到为<code>my_col</code>列建立的<code>B+</code>树索引的。而第2个<code>WHERE</code>子句中<code>my_col</code>列并<span style="color:red">是</span>以单独列的形式出现的，这样的情况可以直接使用<code>B+</code>树索引。</p><p>&amp;emsp;&amp;emsp;所以结论就是：<span style="color:red">如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的</span>。</p><h3 id="主键插入顺序"><a href="#主键插入顺序" class="headerlink" title="主键插入顺序"></a>主键插入顺序</h3><p>&amp;emsp;&amp;emsp;我们知道，对于一个使用<code>InnoDB</code>存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在<code>聚簇索引</code>的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，这就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在<code>1~100</code>之间：</p><p><img src="/../images/07-02.png"></p><p>&amp;emsp;&amp;emsp;如果此时再插入一条主键值为<code>9</code>的记录，那它插入的位置就如下图：</p><p><img src="/../images/07-03.png"></p><p>&amp;emsp;&amp;emsp;可这个数据页已经满了啊，再插进来咋办呢？我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着：<span style="color:red">性能损耗</span>！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。所以我们建议：<span style="color:red">让主键具有<code>AUTO_INCREMENT</code>，让存储引擎自己为表生成主键，而不是我们手动插入 </span>，比方说我们可以这样定义<code>person_info</code>表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE person_info(</span><br><span class="line">    id INT UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    birthday DATE NOT NULL,</span><br><span class="line">    phone_number CHAR(11) NOT NULL,</span><br><span class="line">    country varchar(100) NOT NULL,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)</span><br><span class="line">);    </span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们自定义的主键列<code>id</code>拥有<code>AUTO_INCREMENT</code>属性，在插入记录时存储引擎会自动为我们填入自增的主键值。</p><h3 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h3><p>&amp;emsp;&amp;emsp;有时候有的同学有意或者无意的就对同一个列创建了多个索引，比方说这样写建表语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE person_info(</span><br><span class="line">    id INT UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    birthday DATE NOT NULL,</span><br><span class="line">    phone_number CHAR(11) NOT NULL,</span><br><span class="line">    country varchar(100) NOT NULL,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number),</span><br><span class="line">    KEY idx_name (name(10))</span><br><span class="line">);    </span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们知道，通过<code>idx_name_birthday_phone_number</code>索引就可以对<code>name</code>列进行快速搜索，再创建一个专门针对<code>name</code>列的索引就算是一个<code>冗余</code>索引，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。</p><p>&amp;emsp;&amp;emsp;另一种情况，我们可能会对某个列重复建立索引，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE repeat_index_demo (</span><br><span class="line">    c1 INT PRIMARY KEY,</span><br><span class="line">    c2 INT,</span><br><span class="line">    UNIQUE uidx_c1 (c1),</span><br><span class="line">    INDEX idx_c1 (c1)</span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们看到，<code>c1</code>既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&amp;emsp;&amp;emsp;上面只是我们在创建和使用<code>B+</code>树索引的过程中需要注意的一些点，后边我们还会陆续介绍更多的优化方法和注意事项，敬请期待。本集内容总结如下：</p><ol><li><p><code>B+</code>树索引在空间和时间上都有代价，所以没事儿别瞎建索引。</p></li><li><p><code>B+</code>树索引适用于下面这些情况：</p><ul><li>全值匹配</li><li>匹配左边的列</li><li>匹配范围值</li><li>精确匹配某一列并范围匹配另外一列</li><li>用于排序</li><li>用于分组</li></ul></li><li><p>在使用索引时需要注意下面这些事项：</p><ul><li>只为用于搜索、排序或分组的列创建索引</li><li>为列的基数大的列创建索引</li><li>索引列的类型尽量小</li><li>可以只对字符串值的前缀建立索引</li><li>只有索引列在比较表达式中单独出现才可以适用索引</li><li>为了尽可能少的让<code>聚簇索引</code>发生页面分裂和记录移位的情况，建议让主键拥有<code>AUTO_INCREMENT</code>属性。</li><li>定位并删除表中的重复和冗余索引</li><li>尽量使用<code>覆盖索引</code>进行查询，避免<code>回表</code>带来的性能损耗。</li></ul></li></ol><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/10-%E6%9D%A1%E6%9D%A1%E5%A4%A7%E8%B7%AF%E9%80%9A%E7%BD%97%E9%A9%AC-%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/"/>
      <url>/2022/10/31/model-mysql/mysql/10-%E6%9D%A1%E6%9D%A1%E5%A4%A7%E8%B7%AF%E9%80%9A%E7%BD%97%E9%A9%AC-%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="第10章-条条大路通罗马-单表访问方法"><a href="#第10章-条条大路通罗马-单表访问方法" class="headerlink" title="第10章 条条大路通罗马-单表访问方法"></a>第10章 条条大路通罗马-单表访问方法</h1><p>&amp;emsp;&amp;emsp;对于我们这些<code>MySQL</code>的使用者来说，<code>MySQL</code>其实就是一个软件，平时用的最多的就是查询功能。DBA时不时丢过来一些慢查询语句让优化，我们如果连查询是怎么执行的都不清楚还优化个毛线，所以是时候掌握真正的技术了。我们在第一章的时候就曾说过，<code>MySQL Server</code>有一个称为<code>查询优化器</code>的模块，一条查询语句进行语法解析之后就会被交给查询优化器来进行优化，优化的结果就是生成一个所谓的<code>执行计划</code>，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是什么样的，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。不过查询优化这个主题有点儿大，在学会跑之前还得先学会走，所以本章先来看看<code>MySQL</code>怎么执行单表查询（就是<code>FROM</code>子句后边只有一个表，最简单的那种查询～）。不过需要强调的一点是，在学习本章前务必看过前面关于记录结构、数据页结构以及索引的部分，如果你不能保证这些东西已经完全掌握，那么本章不适合你。</p><p>&amp;emsp;&amp;emsp;为了故事的顺利发展，我们先得有个表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE single_table (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    UNIQUE KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们为这个<code>single_table</code>表建立了1个聚簇索引和4个二级索引，分别是：</p><ul><li><p>为<code>id</code>列建立的聚簇索引。</p></li><li><p>为<code>key1</code>列建立的<code>idx_key1</code>二级索引。</p></li><li><p>为<code>key2</code>列建立的<code>idx_key2</code>二级索引，而且该索引是唯一二级索引。</p></li><li><p>为<code>key3</code>列建立的<code>idx_key3</code>二级索引。</p></li><li><p>为<code>key_part1</code>、<code>key_part2</code>、<code>key_part3</code>列建立的<code>idx_key_part</code>二级索引，这也是一个联合索引。</p></li></ul><p>&amp;emsp;&amp;emsp;然后我们需要为这个表插入10000行记录，除<code>id</code>列外其余的列都插入随机值就好了，具体的插入语句我就不写了，自己写个程序插入吧（id列是自增主键列，不需要我们手动插入）。</p><h2 id="访问方法（access-method）的概念"><a href="#访问方法（access-method）的概念" class="headerlink" title="访问方法（access method）的概念"></a>访问方法（access method）的概念</h2><p>&amp;emsp;&amp;emsp;想必各位都用过高德地图来查找到某个地方的路线吧（此处没有为高德地图打广告的意思，他们没给我钱，大家用百度地图也可以啊），如果我们搜西安钟楼到大雁塔之间的路线的话，地图软件会给出n种路线供我们选择，如果我们实在闲的没事儿干并且足够有钱的话，还可以用南辕北辙的方式绕地球一圈到达目的地。也就是说，不论采用哪一种方式，我们最终的目标就是到达大雁塔这个地方。回到<code>MySQL</code>中来，我们平时所写的那些查询语句本质上只是一种声明式的语法，只是告诉<code>MySQL</code>我们要获取的数据符合哪些规则，至于<code>MySQL</code>背地里是怎么把查询结果搞出来的那是<code>MySQL</code>自己的事儿。对于单个表的查询来说，设计MySQL的大佬把查询的执行方式大致分为下面两种：</p><ul><li><p>使用全表扫描进行查询</p><p>  &amp;emsp;&amp;emsp;这种执行方式很好理解，就是把表的每一行记录都扫一遍嘛，把符合搜索条件的记录加入到结果集就完了。不管是什么查询都可以使用这种方式执行，当然，这种也是最笨的执行方式。</p></li><li><p>使用索引进行查询</p><p>  &amp;emsp;&amp;emsp;因为直接使用全表扫描的方式执行查询要遍历好多记录，所以代价可能太大了。如果查询语句中的搜索条件可以使用到某个索引，那直接使用索引来执行查询可能会加快查询执行的时间。使用索引来执行查询的方式五花八门，又可以细分为许多种类：</p><ul><li><p>针对主键或唯一二级索引的等值查询</p></li><li><p>针对普通二级索引的等值查询</p></li><li><p>针对索引列的范围查询</p></li><li><p>直接扫描整个索引</p></li></ul></li></ul><p>&amp;emsp;&amp;emsp;设计<code>MySQL</code>的大佬把<code>MySQL</code>执行查询语句的方式称之为<code>访问方法</code>或者<code>访问类型</code>。同一个查询语句可能可以使用多种不同的访问方法来执行，虽然最后的查询结果都是一样的，但是执行的时间可能差老鼻子远了，就像是从钟楼到大雁塔，你可以坐火箭去，也可以坐飞机去，当然也可以坐乌龟去。下面细细道来各种<code>访问方法</code>的具体内容。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>&amp;emsp;&amp;emsp;有的时候我们可以通过主键列来定位一条记录，比方说这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE id = 1438;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;<code>MySQL</code>会直接利用主键值在聚簇索引中定位对应的用户记录，就像这样：</p><p><img src="/../images/10-01.png"></p><p>&amp;emsp;&amp;emsp;原谅我把聚簇索引对应的复杂的<code>B+</code>树结构搞了一个极度精简版，为了突出重点，我们忽略掉了<code>页</code>的结构，直接把所有的叶子节点的记录都放在一起展示，而且记录中只展示我们关心的索引列，对于<code>single_table</code>表的聚簇索引来说，展示的就是<code>id</code>列。我们想突出的重点就是：<code>B+</code>树叶子节点中的记录是按照索引列排序的，对于的聚簇索引来说，它对应的<code>B+</code>树叶子节点中的记录就是按照<code>id</code>列排序的。<code>B+</code>树本来就是一个矮矮的大胖子，所以这样根据主键值定位一条记录的速度贼快。类似的，我们根据唯一二级索引列来定位一条记录的速度也是贼快的，比如下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 = 3841;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个查询的执行过程的示意图就是这样：</p><p><img src="/../images/10-02.png"></p><p>&amp;emsp;&amp;emsp;可以看到这个查询的执行分两步，第一步先从<code>idx_key2</code>对应的<code>B+</code>树索引中根据<code>key2</code>列与常数的等值比较条件定位到一条二级索引记录，然后再根据该记录的<code>id</code>值到聚簇索引中获取到完整的用户记录。</p><p>&amp;emsp;&amp;emsp;设计<code>MySQL</code>的大佬认为通过主键或者唯一二级索引列与常数的等值比较来定位一条记录是像坐火箭一样快的，所以他们把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为：<code>const</code>，意思是常数级别的，代价是可以忽略不计的。不过这种<code>const</code>访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，这个<code>const</code>访问方法才有效（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录）。</p><p>&amp;emsp;&amp;emsp;对于唯一二级索引来说，查询该列为<code>NULL</code>值的情况比较特殊，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 IS NULL;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;因为唯一二级索引列并不限制 NULL 值的数量，所以上述语句可能访问到多条记录，也就是说 上面这个语句不可以使用<code>const</code>访问方法来执行（至于是什么访问方法我们下面马上说）。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>&amp;emsp;&amp;emsp;有时候我们对某个普通的二级索引列与常数进行等值比较，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;对于这个查询，我们当然可以选择全表扫描来逐一对比搜索条件是否满足要求，我们也可以先使用二级索引找到对应记录的<code>id</code>值，然后再回表到聚簇索引中查找完整的用户记录。由于普通二级索引并不限制索引列值的唯一性，所以可能找到多条对应的记录，也就是说使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数。如果匹配的记录较少，则回表的代价还是比较低的，所以<code>MySQL</code>可能选择使用索引而不是全表扫描的方式来执行查询。设计<code>MySQL</code>的大佬就把这种搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为：<code>ref</code>。我们看一下采用<code>ref</code>访问方法执行查询的图示：</p><p><img src="/../images/10-03.png"></p><p>&amp;emsp;&amp;emsp;从图示中可以看出，对于普通的二级索引来说，通过索引列进行等值比较后可能匹配到多条连续的记录，而不是像主键或者唯一二级索引那样最多只能匹配1条记录，所以这种<code>ref</code>访问方法比<code>const</code>差了那么一丢丢，但是在二级索引等值比较时匹配的记录数较少时的效率还是很高的（如果匹配的二级索引记录太多那么回表的成本就太大了），跟坐高铁差不多。不过需要注意下面两种情况：</p><ul><li><p>二级索引列值为<code>NULL</code>的情况</p><p>  &amp;emsp;&amp;emsp;不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含<code>NULL</code>值的数量并不限制，所以我们采用<code>key IS NULL</code>这种形式的搜索条件最多只能使用<code>ref</code>的访问方法，而不是<code>const</code>的访问方法。</p></li><li><p>对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用<code>ref</code>的访问方法，比方说下面这几个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;god like&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;god like&#x27; AND key_part2 = &#x27;legendary&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;god like&#x27; AND key_part2 = &#x27;legendary&#x27; AND key_part3 = &#x27;penta kill&#x27;;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;但是如果最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能称为<code>ref</code>了，比方说这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;god like&#x27; AND key_part2 &gt; &#x27;legendary&#x27;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h2><p>&amp;emsp;&amp;emsp;有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为<code>NULL</code>的记录也找出来，就像下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_demo WHERE key1 = &#x27;abc&#x27; OR key1 IS NULL;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为<code>ref_or_null</code>，这个<code>ref_or_null</code>访问方法的执行过程如下：</p><p><img src="/../images/10-04.png">  </p><p>&amp;emsp;&amp;emsp;可以看到，上面的查询相当于先分别从<code>idx_key1</code>索引对应的<code>B+</code>树中找出<code>key1 IS NULL</code>和<code>key1 = &#39;abc&#39;</code>的两个连续的记录范围，然后根据这些二级索引记录中的<code>id</code>值再回表查找完整的用户记录。</p><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>&amp;emsp;&amp;emsp;我们之前介绍的几种访问方法都是在对索引列与某一个常数进行等值比较的时候才可能使用到（<code>ref_or_null</code>比较奇特，还计算了值为<code>NULL</code>的情况），但是有时候我们面对的搜索条件更复杂，比如下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 &gt;= 38 AND key2 &lt;= 79);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们当然还可以使用全表扫描的方式来执行这个查询，不过也可以使用<code>二级索引 + 回表</code>的方式执行，如果采用<code>二级索引 + 回表</code>的方式来执行的话，那么此时的搜索条件就不只是要求索引列与常数的等值匹配了，而是索引列需要匹配某个或某些范围的值，在本查询中<code>key2</code>列的值只要匹配下列3个范围中的任何一个就算是匹配成功了：</p><ul><li><p><code>key2</code>的值是<code>1438</code></p></li><li><p><code>key2</code>的值是<code>6328</code></p></li><li><p><code>key2</code>的值在<code>38</code>和<code>79</code>之间。</p></li></ul><p>&amp;emsp;&amp;emsp;设计<code>MySQL</code>的大佬把这种利用索引进行范围匹配的访问方法称之为：<code>range</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：此处所说的使用索引进行范围匹配中的 `索引` 可以是聚簇索引，也可以是二级索引。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;如果把这几个所谓的<code>key2</code>列的值需要满足的<code>范围</code>在数轴上体现出来的话，那应该是这个样子：</p><p><img src="/../images/10-05.png"></p><p>&amp;emsp;&amp;emsp;也就是从数学的角度看，每一个所谓的范围都是数轴上的一个<code>区间</code>，3个范围也就对应着3个区间：</p><ul><li><p>范围1：<code>key2 = 1438</code></p></li><li><p>范围2：<code>key2 = 6328</code></p></li><li><p>范围3：<code>key2 ∈ [38, 79]</code>，注意这里是闭区间。</p></li></ul><p>&amp;emsp;&amp;emsp;我们可以把那种索引列等值匹配的情况称之为<code>单点区间</code>，上面所说的<code>范围1</code>和<code>范围2</code>都可以被称为单点区间，像<code>范围3</code>这种的我们可以称为连续范围区间。</p><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>看下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;由于<code>key_part2</code>并不是联合索引<code>idx_key_part</code>最左索引列，所以我们无法使用<code>ref</code>或者<code>range</code>访问方法来执行这个语句。但是这个查询符合下面这两个条件：</p><ul><li><p>它的查询列表只有3个列：<code>key_part1</code>, <code>key_part2</code>, <code>key_part3</code>，而索引<code>idx_key_part</code>又包含这三个列。</p></li><li><p>搜索条件中只有<code>key_part2</code>列。这个列也包含在索引<code>idx_key_part</code>中。</p></li></ul><p>&amp;emsp;&amp;emsp;也就是说我们可以直接通过遍历<code>idx_key_part</code>索引的叶子节点的记录来比较<code>key_part2 = &#39;abc&#39;</code>这个条件是否成立，把匹配成功的二级索引记录的<code>key_part1</code>, <code>key_part2</code>, <code>key_part3</code>列的值直接加到结果集中就行了。由于二级索引记录比聚簇索记录小的多（聚簇索引记录要存储所有用户定义的列以及所谓的隐藏列，而二级索引记录只需要存放索引列和主键），而且这个过程也不用进行回表操作，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多，设计<code>MySQL</code>的大佬就把这种采用遍历二级索引记录的执行方式称之为：<code>index</code>。</p><h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><p>&amp;emsp;&amp;emsp;最直接的查询执行方式就是我们已经提了无数遍的全表扫描，对于<code>InnoDB</code>表来说也就是直接扫描聚簇索引，设计<code>MySQL</code>的大佬把这种使用全表扫描执行查询的方式称之为：<code>all</code>。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="重温-二级索引-回表"><a href="#重温-二级索引-回表" class="headerlink" title="重温 二级索引 + 回表"></a>重温 二级索引 + 回表</h3><p>&amp;emsp;&amp;emsp;<span style="color:red">一般情况下</span>只能利用单个二级索引执行查询，比方说下面的这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;abc&#x27; AND key2 &gt; 1000;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;查询优化器会识别到这个查询中的两个搜索条件：</p><ul><li><p><code>key1 = &#39;abc&#39;</code></p></li><li><p><code>key2 &gt; 1000</code></p></li></ul><p>&amp;emsp;&amp;emsp;优化器一般会根据<code>single_table</code>表的统计数据来判断到底使用哪个条件到对应的二级索引中查询扫描的行数会更少，选择那个扫描行数较少的条件到对应的二级索引中查询（关于如何比较的细节我们后边的章节中会介绍）。然后将从该二级索引中查询到的结果经过回表得到完整的用户记录后再根据其余的<code>WHERE</code>条件过滤记录。一般来说，等值查找比范围查找需要扫描的行数更少（也就是<code>ref</code>的访问方法一般比<code>range</code>好，但这也不总是一定的，也可能采用<code>ref</code>访问方法的那个索引列的值为特定值的行数特别多），所以这里假设优化器决定使用<code>idx_key1</code>索引进行查询，那么整个查询过程可以分为两个步骤：</p><ul><li><p>步骤1：使用二级索引定位记录的阶段，也就是根据条件<code>key1 = &#39;abc&#39;</code>从<code>idx_key1</code>索引代表的<code>B+</code>树中找到对应的二级索引记录。</p></li><li><p>步骤2：回表阶段，也就是根据上一步骤中找到的记录的主键值进行<code>回表</code>操作，也就是到聚簇索引中找到对应的完整的用户记录，再根据条件<code>key2 &gt; 1000</code>到完整的用户记录继续过滤。将最终符合过滤条件的记录返回给用户。</p></li></ul><p>&amp;emsp;&amp;emsp;这里需要特别提醒大家的一点是，<span style="color:red">因为二级索引的节点中的记录只包含索引列和主键，所以在步骤1中使用<code>idx_key1</code>索引进行查询时只会用到与<code>key1</code>列有关的搜索条件，其余条件，比如<code>key2 &gt; 1000</code>这个条件在步骤1中是用不到的，只有在步骤2完成回表操作后才能继续针对完整的用户记录中继续过滤</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：需要注意的是，我们说一般情况下执行一个查询只会用到单个二级索引，不过还是有特殊情况的，我们后边会详细介绍的。</span><br></pre></td></tr></table></figure><h3 id="明确range访问方法使用的范围区间"><a href="#明确range访问方法使用的范围区间" class="headerlink" title="明确range访问方法使用的范围区间"></a>明确range访问方法使用的范围区间</h3><p>&amp;emsp;&amp;emsp;其实对于<code>B+</code>树索引来说，只要索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者<code>LIKE</code>操作符连接起来，就可以产生一个所谓的<code>区间</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">小贴士：LIKE操作符比较特殊，只有在匹配完整字符串或者匹配字符串前缀时才可以利用索引，具体原因我们在前面的章节中介绍过了，这里就不赘述了。  </span><br><span class="line">IN操作符的效果和若干个等值匹配操作符`=`之间用`OR`连接起来是一样的，也就是说会产生多个单点区间，比如下面这两个语句的效果是一样的：  </span><br><span class="line">SELECT * FROM single_table WHERE key2 IN (1438, 6328);  </span><br><span class="line">SELECT * FROM single_table WHERE key2 = 1438 OR key2 = 6328;  </span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;不过在日常的工作中，一个查询的<code>WHERE</code>子句可能有很多个小的搜索条件，这些搜索条件需要使用<code>AND</code>或者<code>OR</code>操作符连接起来，虽然大家都知道这两个操作符的作用，但我还是要再说一遍：</p><ul><li><p><code>cond1 AND cond2</code> ：只有当<code>cond1</code>和<code>cond2</code>都为<code>TRUE</code>时整个表达式才为<code>TRUE</code>。</p></li><li><p><code>cond1 OR cond2</code>：只要<code>cond1</code>或者<code>cond2</code>中有一个为<code>TRUE</code>整个表达式就为<code>TRUE</code>。</p></li></ul><p>&amp;emsp;&amp;emsp;当我们想使用<code>range</code>访问方法来执行一个查询语句时，重点就是找出该查询可用的索引以及这些索引对应的范围区间。下面分两种情况看一下怎么从由<code>AND</code>或<code>OR</code>组成的复杂搜索条件中提取出正确的范围区间。</p><h4 id="所有搜索条件都可以使用某个索引的情况"><a href="#所有搜索条件都可以使用某个索引的情况" class="headerlink" title="所有搜索条件都可以使用某个索引的情况"></a>所有搜索条件都可以使用某个索引的情况</h4><p>&amp;emsp;&amp;emsp;有时候每个搜索条件都可以使用到某个索引，比如下面这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 &gt; 100 AND key2 &gt; 200;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个查询中的搜索条件都可以使用到<code>key2</code>，也就是说每个搜索条件都对应着一个<code>idx_key2</code>的范围区间。这两个小的搜索条件使用<code>AND</code>连接起来，也就是要取两个范围区间的交集，在我们使用<code>range</code>访问方法执行查询时，使用的<code>idx_key2</code>索引的范围区间的确定过程就如下图所示：</p><p><img src="/../images/10-06.png"></p><p>&amp;emsp;&amp;emsp;<code>key2 &gt; 100</code>和<code>key2 &gt; 200</code>交集当然就是<code>key2 &gt; 200</code>了，也就是说上面这个查询使用<code>idx_key2</code>的范围区间就是<code>(200, +∞)</code>。这东西小学都学过吧，再不济初中肯定都学过。我们再看一下使用<code>OR</code>将多个搜索条件连接在一起的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 &gt; 100 OR key2 &gt; 200;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;<code>OR</code>意味着需要取各个范围区间的并集，所以上面这个查询在我们使用<code>range</code>访问方法执行查询时，使用的<code>idx_key2</code>索引的范围区间的确定过程就如下图所示：</p><p><img src="/../images/10-07.png"></p><p>&amp;emsp;&amp;emsp;也就是说上面这个查询使用<code>idx_key2</code>的范围区间就是<code>(100， +∞)</code>。</p><h4 id="有的搜索条件无法使用索引的情况"><a href="#有的搜索条件无法使用索引的情况" class="headerlink" title="有的搜索条件无法使用索引的情况"></a>有的搜索条件无法使用索引的情况</h4><p>&amp;emsp;&amp;emsp;比如下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 &gt; 100 AND common_field = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;请注意，这个查询语句中能利用的索引只有<code>idx_key2</code>一个，而<code>idx_key2</code>这个二级索引的记录中又不包含<code>common_field</code>这个字段，所以在使用二级索引<code>idx_key2</code>定位记录的阶段用不到<code>common_field = &#39;abc&#39;</code>这个条件，这个条件是在回表获取了完整的用户记录后才使用的，而<code>范围区间</code>是为了到索引中取记录中提出的概念，所以在确定<code>范围区间</code>的时候不需要考虑<code>common_field = &#39;abc&#39;</code>这个条件，我们在为某个索引确定范围区间的时候只需要把用不到相关索引的搜索条件替换为<code>TRUE</code>就好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：之所以把用不到索引的搜索条件替换为TRUE，是因为我们不打算使用这些条件进行在该索引上进行过滤，所以不管索引的记录满不满足这些条件，我们都把它们选取出来，待到之后回表的时候再使用它们过滤。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们把上面的查询中用不到<code>idx_key2</code>的搜索条件替换后就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 &gt; 100 AND TRUE;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;化简之后就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 &gt; 100;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;也就是说最上面那个查询使用<code>idx_key2</code>的范围区间就是：<code>(100, +∞)</code>。</p><p>&amp;emsp;&amp;emsp;再来看一下使用<code>OR</code>的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 &gt; 100 OR common_field = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;同理，我们把使用不到<code>idx_key2</code>索引的搜索条件替换为<code>TRUE</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 &gt; 100 OR TRUE;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;接着化简：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE TRUE;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;额，这也就说说明如果我们强制使用<code>idx_key2</code>执行查询的话，对应的范围区间就是<code>(-∞, +∞)</code>，也就是需要将全部二级索引的记录进行回表，这个代价肯定比直接全表扫描都大了。也就是说一个使用到索引的搜索条件和没有使用该索引的搜索条件使用<code>OR</code>连接起来后是无法使用该索引的。</p><h4 id="复杂搜索条件下找出范围匹配的区间"><a href="#复杂搜索条件下找出范围匹配的区间" class="headerlink" title="复杂搜索条件下找出范围匹配的区间"></a>复杂搜索条件下找出范围匹配的区间</h4><p>&amp;emsp;&amp;emsp;有的查询的搜索条件可能特别复杂，光是找出范围匹配的各个区间就挺烦的，比方说下面这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE </span><br><span class="line">        (key1 &gt; &#x27;xyz&#x27; AND key2 = 748 ) OR</span><br><span class="line">        (key1 &lt; &#x27;abc&#x27; AND key1 &gt; &#x27;lmn&#x27;) OR</span><br><span class="line">        (key1 LIKE &#x27;%suf&#x27; AND key1 &gt; &#x27;zzz&#x27; AND (key2 &lt; 8000 OR common_field = &#x27;abc&#x27;)) ;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我滴个神，这个搜索条件真是绝了，不过大家不要被复杂的表象迷住了双眼，按着下面这个套路分析一下：</p><ul><li><p>首先查看<code>WHERE</code>子句中的搜索条件都涉及到了哪些列，哪些列可能使用到索引。</p><p>  &amp;emsp;&amp;emsp;这个查询的搜索条件涉及到了<code>key1</code>、<code>key2</code>、<code>common_field</code>这3个列，然后<code>key1</code>列有普通的二级索引<code>idx_key1</code>，<code>key2</code>列有唯一二级索引<code>idx_key2</code>。</p></li><li><p>对于那些可能用到的索引，分析它们的范围区间。</p><ul><li><p>假设我们使用<code>idx_key1</code>执行查询</p><ul><li><p>我们需要把那些用不到该索引的搜索条件暂时移除掉，移除方法也简单，直接把它们替换为<code>TRUE</code>就好了。上面的查询中除了有关<code>key2</code>和<code>common_field</code>列不能使用到<code>idx_key1</code>索引外，<code>key1 LIKE &#39;%suf&#39;</code>也使用不到索引，所以把这些搜索条件替换为<code>TRUE</code>之后的样子就是这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(key1 &gt; &#x27;xyz&#x27; AND TRUE ) OR</span><br><span class="line">(key1 &lt; &#x27;abc&#x27; AND key1 &gt; &#x27;lmn&#x27;) OR</span><br><span class="line">(TRUE AND key1 &gt; &#x27;zzz&#x27; AND (TRUE OR TRUE))</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;化简一下上面的搜索条件就是下面这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(key1 &gt; &#x27;xyz&#x27;) OR</span><br><span class="line">(key1 &lt; &#x27;abc&#x27; AND key1 &gt; &#x27;lmn&#x27;) OR</span><br><span class="line">(key1 &gt; &#x27;zzz&#x27;)</span><br></pre></td></tr></table></figure></li><li><p>替换掉永远为<code>TRUE</code>或<code>FALSE</code>的条件</p><p>  &amp;emsp;&amp;emsp;因为符合<code>key1 &lt; &#39;abc&#39; AND key1 &gt; &#39;lmn&#39;</code>永远为<code>FALSE</code>，所以上面的搜索条件可以被写成这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(key1 &gt; &#x27;xyz&#x27;) OR (key1 &gt; &#x27;zzz&#x27;)</span><br></pre></td></tr></table></figure></li><li><p>继续化简区间</p><p>  &amp;emsp;&amp;emsp;<code>key1 &gt; &#39;xyz&#39;</code>和<code>key1 &gt; &#39;zzz&#39;</code>之间使用<code>OR</code>操作符连接起来的，意味着要取并集，所以最终的结果化简的到的区间就是：<code>key1 &gt; xyz</code>。也就是说：<span style="color:red">上面那个有一坨搜索条件的查询语句如果使用 idx_key1 索引执行查询的话，需要把满足<code>key1 &gt; xyz</code>的二级索引记录都取出来，然后拿着这些记录的id再进行回表，得到完整的用户记录之后再使用其他的搜索条件进行过滤</span>。</p></li></ul></li><li><p>假设我们使用<code>idx_key2</code>执行查询</p><ul><li>我们需要把那些用不到该索引的搜索条件暂时使用<code>TRUE</code>条件替换掉，其中有关<code>key1</code>和<code>common_field</code>的搜索条件都需要被替换掉，替换结果就是：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(TRUE AND key2 = 748 ) OR</span><br><span class="line">(TRUE AND TRUE) OR</span><br><span class="line">(TRUE AND TRUE AND (key2 &lt; 8000 OR TRUE))</span><br></pre></td></tr></table></figure>  &amp;emsp;&amp;emsp;哎呀呀，<code>key2 &lt; 8000 OR TRUE</code>的结果肯定是<code>TRUE</code>呀，也就是说化简之后的搜索条件成这样了：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key2 = 748 OR TRUE</span><br></pre></td></tr></table></figure>  &amp;emsp;&amp;emsp;这个化简之后的结果就更简单了：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUE</span><br></pre></td></tr></table></figure>  &amp;emsp;&amp;emsp;这个结果也就意味着如果我们要使用<code>idx_key2</code>索引执行查询语句的话，需要扫描<code>idx_key2</code>二级索引的所有记录，然后再回表，这不是得不偿失么，所以这种情况下不会使用<code>idx_key2</code>索引的。</li></ul></li></ul></li></ul><h3 id="索引合并"><a href="#索引合并" class="headerlink" title="索引合并"></a>索引合并</h3><p>&amp;emsp;&amp;emsp;我们前面说过<code>MySQL</code>在一般情况下执行一个查询时最多只会用到单个二级索引，但不是还有特殊情况么，在这些特殊情况下也可能在一个查询中使用到多个二级索引，设计<code>MySQL</code>的大佬把这种使用到多个索引来完成一次查询的执行方法称之为：<code>index merge</code>，具体的索引合并算法有下面三种。</p><h4 id="Intersection合并"><a href="#Intersection合并" class="headerlink" title="Intersection合并"></a>Intersection合并</h4><p>&amp;emsp;&amp;emsp;<code>Intersection</code>翻译过来的意思是<code>交集</code>。这里是说某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，比方说下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND key3 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;假设这个查询使用<code>Intersection</code>合并的方式执行的话，那这个过程就是这样的：</p><ul><li><p>从<code>idx_key1</code>二级索引对应的<code>B+</code>树中取出<code>key1 = &#39;a&#39;</code>的相关记录。</p></li><li><p>从<code>idx_key3</code>二级索引对应的<code>B+</code>树中取出<code>key3 = &#39;b&#39;</code>的相关记录。</p></li><li><p>二级索引的记录都是由<code>索引列 + 主键</code>构成的，所以我们可以计算出这两个结果集中<code>id</code>值的交集。</p></li><li><p>按照上一步生成的<code>id</code>值列表进行回表操作，也就是从聚簇索引中把指定<code>id</code>值的完整用户记录取出来，返回给用户。</p></li></ul><p>&amp;emsp;&amp;emsp;这里有同学会思考：为什么不直接使用<code>idx_key1</code>或者<code>idx_key3</code>只根据某个搜索条件去读取一个二级索引，然后回表后再过滤另外一个搜索条件呢？这里要分析一下两种查询执行方式之间需要的成本代价。</p><p>&amp;emsp;&amp;emsp;只读取一个二级索引的成本：</p><ul><li><p>按照某个搜索条件读取一个二级索引</p></li><li><p>根据从该二级索引得到的主键值进行回表操作，然后再过滤其他的搜索条件</p></li></ul><p>&amp;emsp;&amp;emsp;读取多个二级索引之后取交集成本：</p><ul><li><p>按照不同的搜索条件分别读取不同的二级索引</p></li><li><p>将从多个二级索引得到的主键值取交集，然后进行回表操作</p></li></ul><p>&amp;emsp;&amp;emsp;虽然读取多个二级索引比读取一个二级索引消耗性能，但是读取二级索引的操作是<code>顺序I/O</code>，而回表操作是<code>随机I/O</code>，所以如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少，当节省的因为<code>回表</code>而造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低。</p><p>&amp;emsp;&amp;emsp;<code>MySQL</code>在某些特定的情况下才可能会使用到<code>Intersection</code>索引合并：</p><ul><li><p>情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。</p><p>  &amp;emsp;&amp;emsp;比方说下面这个查询可能用到<code>idx_key1</code>和<code>idx_key_part</code>这两个二级索引进行<code>Intersection</code>索引合并的操作：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27; AND key_part3 = &#x27;c&#x27;;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;而下面这两个查询就不能进行<code>Intersection</code>索引合并：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &gt; &#x27;a&#x27; AND key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27; AND key_part3 = &#x27;c&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND key_part1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;第一个查询是因为对<code>key1</code>进行了范围匹配，第二个查询是因为联合索引<code>idx_key_part</code>中的<code>key_part2</code>列并没有出现在搜索条件中，所以这两个查询不能进行<code>Intersection</code>索引合并。</p></li><li><p>情况二：主键列可以是范围匹配</p><p>  &amp;emsp;&amp;emsp;比方说下面这个查询可能用到主键和<code>idx_key1</code>进行<code>Intersection</code>索引合并的操作：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE id &gt; 100 AND key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;为什么呢？凭什么呀？突然冒出这么两个规定让大家一脸懵逼，下面我们慢慢品一品这里头的玄机。这话还得从<code>InnoDB</code>的索引结构说起，你要是记不清麻烦再回头看看。对于<code>InnoDB</code>的二级索引来说，记录先是按照索引列进行排序，如果该二级索引是一个联合索引，那么会按照联合索引中的各个列依次排序。而二级索引的用户记录是由<code>索引列 + 主键</code>构成的，二级索引列的值相同的记录可能会有好多条，这些索引列的值相同的记录又是按照<code>主键</code>的值进行排序的。所以重点来了，之所以在二级索引列都是等值匹配的情况下才可能使用<code>Intersection</code>索引合并，是因为<span style="color:red">只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的</span>。</p><p>&amp;emsp;&amp;emsp;so？还是没看懂根据二级索引查询出的结果集是按照主键值排序的对使用<code>Intersection</code>索引合并有什么好处？小伙子，别忘了<code>Intersection</code>索引合并会把从多个二级索引中查询出的主键值求交集，如果从各个二级索引中查询的到的结果集本身就是已经按照主键排好序的，那么求交集的过程就很easy啦。假设某个查询使用<code>Intersection</code>索引合并的方式从<code>idx_key1</code>和<code>idx_key2</code>这两个二级索引中获取到的主键值分别是：</p><ul><li><p>从<code>idx_key1</code>中获取到已经排好序的主键值：1、3、5</p></li><li><p>从<code>idx_key2</code>中获取到已经排好序的主键值：2、3、4</p></li></ul><p>&amp;emsp;&amp;emsp;那么求交集的过程就是这样：逐个取出这两个结果集中最小的主键值，如果两个值相等，则加入最后的交集结果中，否则丢弃当前较小的主键值，再取该丢弃的主键值所在结果集的后一个主键值来比较，直到某个结果集中的主键值用完了，如果还是觉得不太明白那继续往下看：</p><ul><li><p>先取出这两个结果集中较小的主键值做比较，因为<code>1 &lt; 2</code>，所以把<code>idx_key1</code>的结果集的主键值<code>1</code>丢弃，取出后边的<code>3</code>来比较。</p></li><li><p>因为<code>3 &gt; 2</code>，所以把<code>idx_key2</code>的结果集的主键值<code>2</code>丢弃，取出后边的<code>3</code>来比较。</p></li><li><p>因为<code>3 = 3</code>，所以把<code>3</code>加入到最后的交集结果中，继续两个结果集后边的主键值来比较。</p></li><li><p>后边的主键值也不相等，所以最后的交集结果中只包含主键值<code>3</code>。</p></li></ul><p>&amp;emsp;&amp;emsp;别看我们写的啰嗦，这个过程其实可快了，时间复杂度是<code>O(n)</code>，但是如果从各个二级索引中查询出的结果集并不是按照主键排序的话，那就要先把结果集中的主键值排序完再来做上面的那个过程，就比较耗时了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：按照有序的主键值去回表取记录有个专有名词儿，叫：Rowid Ordered Retrieval，简称ROR，以后大家在某些地方见到这个名词儿就眼熟了。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;另外，不仅是多个二级索引之间可以采用<code>Intersection</code>索引合并，索引合并也可以有聚簇索引参加，也就是我们上面写的<code>情况二</code>：在搜索条件中有主键的范围匹配的情况下也可以使用<code>Intersection</code>索引合并索引合并。为什么主键这就可以范围匹配了？还是得回到应用场景里，比如看下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND id &gt; 100;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;假设这个查询可以采用<code>Intersection</code>索引合并，我们理所当然的以为这个查询会分别按照<code>id &gt; 100</code>这个条件从聚簇索引中获取一些记录，在通过<code>key1 = &#39;a&#39;</code>这个条件从<code>idx_key1</code>二级索引中获取一些记录，然后再求交集，其实这样就把问题复杂化了，没必要从聚簇索引中获取一次记录。别忘了二级索引的记录中都带有主键值的，所以可以在从<code>idx_key1</code>中获取到的主键值上直接运用条件<code>id &gt; 100</code>过滤就行了，这样多简单。所以涉及主键的搜索条件只不过是为了从别的二级索引得到的结果集中过滤记录罢了，是不是等值匹配不重要。</p><p>&amp;emsp;&amp;emsp;当然，上面说的<code>情况一</code>和<code>情况二</code>只是发生<code>Intersection</code>索引合并的必要条件，不是充分条件。也就是说即使情况一、情况二成立，也不一定发生<code>Intersection</code>索引合并，这得看优化器的心情。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过<code>Intersection</code>索引合并后需要回表的记录数大大减少时才会使用<code>Intersection</code>索引合并。</p><h4 id="Union合并"><a href="#Union合并" class="headerlink" title="Union合并"></a>Union合并</h4><p>&amp;emsp;&amp;emsp;我们在写查询语句时经常想把既符合某个搜索条件的记录取出来，也把符合另外的某个搜索条件的记录取出来，我们说这些不同的搜索条件之间是<code>OR</code>关系。有时候<code>OR</code>关系的不同搜索条件会使用到不同的索引，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; OR key3 = &#x27;b&#x27;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;<code>Intersection</code>是交集的意思，这适用于使用不同索引的搜索条件之间使用<code>AND</code>连接起来的情况；<code>Union</code>是并集的意思，适用于使用不同索引的搜索条件之间使用<code>OR</code>连接起来的情况。与<code>Intersection</code>索引合并类似，<code>MySQL</code>在某些特定的情况下才可能会使用到<code>Union</code>索引合并：</p><ul><li><p>情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况。</p><p>  &amp;emsp;&amp;emsp;比方说下面这个查询可能用到<code>idx_key1</code>和<code>idx_key_part</code>这两个二级索引进行<code>Union</code>索引合并的操作：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; OR ( key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27; AND key_part3 = &#x27;c&#x27;);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;而下面这两个查询就不能进行<code>Union</code>索引合并：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &gt; &#x27;a&#x27; OR (key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27; AND key_part3 = &#x27;c&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; OR key_part1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;第一个查询是因为对<code>key1</code>进行了范围匹配，第二个查询是因为联合索引<code>idx_key_part</code>中的<code>key_part2</code>列并没有出现在搜索条件中，所以这两个查询不能进行<code>Union</code>索引合并。</p></li><li><p>情况二：主键列可以是范围匹配</p></li><li><p>情况三：使用<code>Intersection</code>索引合并的搜索条件</p><p>  &amp;emsp;&amp;emsp;这种情况其实也挺好理解，就是搜索条件的某些部分使用<code>Intersection</code>索引合并的方式得到的主键集合和其他方式得到的主键集合取交集，比方说这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27; AND key_part3 = &#x27;c&#x27; OR (key1 = &#x27;a&#x27; AND key3 = &#x27;b&#x27;);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;优化器可能采用这样的方式来执行这个查询：</p><ul><li><p>先按照搜索条件<code>key1 = &#39;a&#39; AND key3 = &#39;b&#39;</code>从索引<code>idx_key1</code>和<code>idx_key3</code>中使用<code>Intersection</code>索引合并的方式得到一个主键集合。</p></li><li><p>再按照搜索条件<code>key_part1 = &#39;a&#39; AND key_part2 = &#39;b&#39; AND key_part3 = &#39;c&#39;</code>从联合索引<code>idx_key_part</code>中得到另一个主键集合。</p></li><li><p>采用<code>Union</code>索引合并的方式把上述两个主键集合取并集，然后进行回表操作，将结果返回给用户。</p></li></ul></li></ul><p>&amp;emsp;&amp;emsp;当然，查询条件符合了这些情况也不一定就会采用<code>Union</code>索引合并，也得看优化器的心情。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过<code>Union</code>索引合并后进行访问的代价比全表扫描更小时才会使用<code>Union</code>索引合并。</p><h4 id="Sort-Union合并"><a href="#Sort-Union合并" class="headerlink" title="Sort-Union合并"></a>Sort-Union合并</h4><p>&amp;emsp;&amp;emsp;<code>Union</code>索引合并的使用条件太苛刻，必须保证各个二级索引列在进行等值匹配的条件下才可能被用到，比方说下面这个查询就无法使用到<code>Union</code>索引合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &lt; &#x27;a&#x27; OR key3 &gt; &#x27;z&#x27;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这是因为根据<code>key1 &lt; &#39;a&#39;</code>从<code>idx_key1</code>索引中获取的二级索引记录的主键值不是排好序的，根据<code>key3 &gt; &#39;z&#39;</code>从<code>idx_key3</code>索引中获取的二级索引记录的主键值也不是排好序的，但是<code>key1 &lt; &#39;a&#39;</code>和<code>key3 &gt; &#39;z&#39;</code>这两个条件又特别让我们动心，所以我们可以这样：</p><ul><li><p>先根据<code>key1 &lt; &#39;a&#39;</code>条件从<code>idx_key1</code>二级索引总获取记录，并按照记录的主键值进行排序</p></li><li><p>再根据<code>key3 &gt; &#39;z&#39;</code>条件从<code>idx_key3</code>二级索引总获取记录，并按照记录的主键值进行排序</p></li><li><p>因为上述的两个二级索引主键值都是排好序的，剩下的操作和<code>Union</code>索引合并方式就一样了。</p></li></ul><p>&amp;emsp;&amp;emsp;我们把上述这种先按照二级索引记录的主键值进行排序，之后按照<code>Union</code>索引合并方式执行的方式称之为<code>Sort-Union</code>索引合并，很显然，这种<code>Sort-Union</code>索引合并比单纯的<code>Union</code>索引合并多了一步对二级索引记录的主键值排序的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：为什么有Sort-Union索引合并，就没有Sort-Intersection索引合并么？是的，的确没有Sort-Intersection索引合并这么一说，Sort-Union的适用场景是单独根据搜索条件从某个二级索引中获取的记录数比较少，这样即使对这些二级索引记录按照主键值进行排序的成本也不会太高，而Intersection索引合并的适用场景是单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，合并后可以明显降低回表开销，但是如果加入Sort-Intersection后，就需要为大量的二级索引记录按照主键值进行排序，这个成本可能比回表查询都高了，所以也就没有引入Sort-Intersection这个玩意儿。  </span><br></pre></td></tr></table></figure><h4 id="索引合并注意事项"><a href="#索引合并注意事项" class="headerlink" title="索引合并注意事项"></a>索引合并注意事项</h4><h4 id="联合索引替代Intersection索引合并"><a href="#联合索引替代Intersection索引合并" class="headerlink" title="联合索引替代Intersection索引合并"></a>联合索引替代Intersection索引合并</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND key3 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个查询之所以可能使用<code>Intersection</code>索引合并的方式执行，还不是因为<code>idx_key1</code>和<code>idx_key3</code>是两个单独的<code>B+</code>树索引，你要是把这两个列搞一个联合索引，那直接使用这个联合索引就把事情搞定了，何必用什么索引合并呢，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE single_table drop index idx_key1, idx_key3, add index idx_key1_key3(key1, key3);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这样我们把没用的<code>idx_key1</code>、<code>idx_key3</code>都干掉，再添加一个联合索引<code>idx_key1_key3</code>，使用这个联合索引进行查询简直是又快又好，既不用多读一棵<code>B+</code>树，也不用合并结果，何乐而不为？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：不过小心有单独对key3列进行查询的业务场景，这样子不得不再把key3列的单独索引给加上。</span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/16-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2022/10/31/model-mysql/mysql/16-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="第16章-查询优化的百科全书-Explain详解（下）"><a href="#第16章-查询优化的百科全书-Explain详解（下）" class="headerlink" title="第16章 查询优化的百科全书-Explain详解（下）"></a>第16章 查询优化的百科全书-Explain详解（下）</h1><h2 id="执行计划输出中各列详解"><a href="#执行计划输出中各列详解" class="headerlink" title="执行计划输出中各列详解"></a>执行计划输出中各列详解</h2><p>&amp;emsp;&amp;emsp;本章紧接着上一节的内容，继续介绍<code>EXPLAIN</code>语句输出的各个列的意思。</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>&amp;emsp;&amp;emsp;顾名思义，<code>Extra</code>列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解<code>MySQL</code>到底将如何执行给定的查询语句。<code>MySQL</code>提供的额外信息有好几十个，我们就不一个一个介绍了（都介绍了感觉我们的文章就跟文档差不多了～），所以我们只挑一些平时常见的或者比较重要的额外信息介绍给大家。</p><ul><li><p><code>No tables used</code></p><p>  &amp;emsp;&amp;emsp;当查询语句的没有<code>FROM</code>子句时将会提示该额外信息，比如：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT 1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p><code>Impossible WHERE</code></p><p>  &amp;emsp;&amp;emsp;查询语句的<code>WHERE</code>子句永远为<code>FALSE</code>时将会提示该额外信息，比方说：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE 1 != 1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Impossible WHERE |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p><code>No matching min/max row</code></p><p>  &amp;emsp;&amp;emsp;当查询列表处有<code>MIN</code>或者<code>MAX</code>聚集函数，但是并没有符合<code>WHERE</code>子句中的搜索条件的记录时，将会提示该额外信息，比方说：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = &#x27;abcdefg&#x27;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                   |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No matching min/max row |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p><code>Using index</code></p><p>  &amp;emsp;&amp;emsp;当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在<code>Extra</code>列将会提示该额外信息。比方说下面这个查询中只需要用到<code>idx_key1</code>而不需要回表操作：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key1 FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p><code>Using index condition</code></p><p>  &amp;emsp;&amp;emsp;有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下面这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key1 LIKE &#x27;%a&#x27;;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;其中的<code>key1 &gt; &#39;z&#39;</code>可以使用到索引，但是<code>key1 LIKE &#39;%a&#39;</code>却无法使用到索引，在以前版本的<code>MySQL</code>中，是按照下面步骤来执行这个查询的：</p><ul><li>先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，从二级索引<code>idx_key1</code>中获取到对应的二级索引记录。</li><li>根据上一步骤得到的二级索引记录中的主键值进行回表，找到完整的用户记录再检测该记录是否符合<code>key1 LIKE &#39;%a&#39;</code>这个条件，将符合条件的记录加入到最后的结果集。</li></ul><p>  &amp;emsp;&amp;emsp;但是虽然<code>key1 LIKE &#39;%a&#39;</code>不能组成范围区间参与<code>range</code>访问方法的执行，但这个条件毕竟只涉及到了<code>key1</code>列，所以设计<code>MySQL</code>的大佬把上面的步骤改进了一下：</p><ul><li>先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，定位到二级索引<code>idx_key1</code>中对应的二级索引记录。</li><li>对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足<code>key1 LIKE &#39;%a&#39;</code>这个条件，如果这个条件不满足，则该二级索引记录压根儿就没必要回表。</li><li>对于满足<code>key1 LIKE &#39;%a&#39;</code>这个条件的二级索引记录执行回表操作。</li></ul><p>  &amp;emsp;&amp;emsp;我们说回表操作其实是一个随机<code>IO</code>，比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表操作的成本。设计<code>MySQL</code>的大佬们把他们的这个改进称之为<code>索引条件下推</code>（英文名：<code>Index Condition Pushdown</code>）。</p><p>  &amp;emsp;&amp;emsp;如果在查询语句的执行过程中将要使用<code>索引条件下推</code>这个特性，在<code>Extra</code>列中将会显示<code>Using index condition</code>，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key1 LIKE &#x27;%b&#x27;;</span><br><span class="line">  +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">  | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">  +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">  |  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |  266 |   100.00 | Using index condition |</span><br><span class="line">  +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">  1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p><code>Using where</code></p><p>  &amp;emsp;&amp;emsp;当我们使用全表扫描来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有针对该表的搜索条件时，在<code>Extra</code>列中会提示上述额外信息。比如下面这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE common_field = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |    10.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;当使用索引访问来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有除了该索引包含的列之外的其他搜索条件时，在<code>Extra</code>列中也会提示上述额外信息。比如下面这个查询虽然使用<code>idx_key1</code>索引执行查询，但是搜索条件中除了包含<code>key1</code>的搜索条件<code>key1 = &#39;a&#39;</code>，还有包含<code>common_field</code>的搜索条件，所以<code>Extra</code>列会显示<code>Using where</code>的提示：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; AND common_field = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |    10.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p><code>Using join buffer (Block Nested Loop)</code></p><p>  &amp;emsp;&amp;emsp;在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，<code>MySQL</code>一般会为其分配一块名叫<code>join buffer</code>的内存块来加快查询速度，也就是我们所讲的<code>基于块的嵌套循环算法</code>，比如下面这个查询语句：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;可以在对<code>s2</code>表的执行计划的<code>Extra</code>列显示了两个提示：</p><ul><li><p><code>Using join buffer (Block Nested Loop)</code>：这是因为对表<code>s2</code>的访问不能有效利用索引，只好退而求其次，使用<code>join buffer</code>来减少对<code>s2</code>表的访问次数，从而提高性能。</p></li><li><p><code>Using where</code>：可以看到查询语句中有一个<code>s1.common_field = s2.common_field</code>条件，因为<code>s1</code>是驱动表，<code>s2</code>是被驱动表，所以在访问<code>s2</code>表时，<code>s1.common_field</code>的值已经确定下来了，所以实际上查询<code>s2</code>表的条件就是<code>s2.common_field = 一个常数</code>，所以提示了<code>Using where</code>额外信息。</p></li></ul></li><li><p><code>Not exists</code></p><p>  &amp;emsp;&amp;emsp;当我们使用左（外）连接时，如果<code>WHERE</code>子句中包含要求被驱动表的某个列等于<code>NULL</code>值的搜索条件，而且那个列又是不允许存储<code>NULL</code>值的，那么在该表的执行计划的<code>Extra</code>列就会提示<code>Not exists</code>额外信息，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra                   |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL              | 9688 |   100.00 | NULL                    |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s1.key1 |    1 |    10.00 | Using where; Not exists |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;上述查询中<code>s1</code>表是驱动表，<code>s2</code>表是被驱动表，<code>s2.id</code>列是不允许存储<code>NULL</code>值的，而<code>WHERE</code>子句中又包含<code>s2.id IS NULL</code>的搜索条件，这意味着必定是驱动表的记录在被驱动表中找不到匹配<code>ON</code>子句条件的记录才会把该驱动表的记录加入到最终的结果集，所以对于某条驱动表中的记录来说，如果能在被驱动表中找到1条符合<code>ON</code>子句条件的记录，那么该驱动表的记录就不会被加入到最终的结果集，也就是说我们<span style="color:red">没有必要到被驱动表中找到全部符合ON子句条件的记录</span>，这样可以稍微节省一点性能。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：右（外）连接可以被转换为左（外）连接，所以就不提右（外）连接的情况了。</span><br></pre></td></tr></table></figure></li><li><p><code>Using intersect(...)</code>、<code>Using union(...)</code>和<code>Using sort_union(...)</code></p><p>  &amp;emsp;&amp;emsp;如果执行计划的<code>Extra</code>列出现了<code>Using intersect(...)</code>提示，说明准备使用<code>Intersect</code>索引合并的方式执行查询，括号中的<code>...</code>表示需要进行索引合并的索引名称；如果出现了<code>Using union(...)</code>提示，说明准备使用<code>Union</code>索引合并的方式执行查询；出现了<code>Using sort_union(...)</code>提示，说明准备使用<code>Sort-Union</code>索引合并的方式执行查询。比如这个查询的执行计划：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; AND key3 = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+-------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                           |</span><br><span class="line">+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+-------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key3,idx_key1 | 303,303 | NULL |    1 |   100.00 | Using intersect(idx_key3,idx_key1); Using where |</span><br><span class="line">+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+-------------------------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p> &amp;emsp;&amp;emsp;其中<code>Extra</code>列就显示了<code>Using intersect(idx_key3,idx_key1)</code>，表明<code>MySQL</code>即将使用<code>idx_key3</code>和<code>idx_key1</code>这两个索引进行<code>Intersect</code>索引合并的方式执行查询。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：剩下两种类型的索引合并的Extra列信息就不一一举例子了，自己写个查询看看呗～</span><br></pre></td></tr></table></figure></li><li><p><code>Zero limit</code></p><p>  &amp;emsp;&amp;emsp;当我们的<code>LIMIT</code>子句的参数为<code>0</code>时，表示压根儿不打算从表中读出任何记录，将会提示该额外信息，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 LIMIT 0;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra      |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Zero limit |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p><code>Using filesort</code></p><p>  &amp;emsp;&amp;emsp;有一些情况下对结果集中的记录进行排序是可以使用到索引的，比如下面这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key1 | 303     | NULL |   10 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这个查询语句可以利用<code>idx_key1</code>索引直接取出<code>key1</code>列的10条记录，然后再进行回表操作就好了。但是很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，设计<code>MySQL</code>的大佬把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：<code>filesort</code>）。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的<code>Extra</code>列中显示<code>Using filesort</code>提示，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;需要注意的是，如果查询中需要使用<code>filesort</code>的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法将使用<code>文件排序</code>的执行方式改为使用索引进行排序。</p></li><li><p><code>Using temporary</code></p><p>  &amp;emsp;&amp;emsp;在许多查询的执行过程中，<code>MySQL</code>可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含<code>DISTINCT</code>、<code>GROUP BY</code>、<code>UNION</code>等子句的查询过程中，如果不能有效利用索引来完成查询，<code>MySQL</code>很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的<code>Extra</code>列将会显示<code>Using temporary</code>提示，比方说这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT DISTINCT common_field FROM s1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | Using temporary |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;再比如：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                           |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | Using temporary; Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;不知道大家注意到没有，上述执行计划的<code>Extra</code>列不仅仅包含<code>Using temporary</code>提示，还包含<code>Using filesort</code>提示，可是我们的查询语句中明明没有写<code>ORDER BY</code>子句呀？这是因为<code>MySQL</code>会在包含<code>GROUP BY</code>子句的查询中默认添加上<code>ORDER BY</code>子句，也就是说上述查询其实和下面这个查询等价：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field ORDER BY common_field;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;如果我们并不想为包含<code>GROUP BY</code>子句的查询进行排序，需要我们显式的写上<code>ORDER BY NULL</code>，就像这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field ORDER BY NULL;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | Using temporary |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这回执行计划中就没有<code>Using filesort</code>的提示了，也就意味着执行查询时可以省去对记录进行文件排序的成本了。</p><p>  &amp;emsp;&amp;emsp;另外，执行计划中出现<code>Using temporary</code>并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能使用索引来替代掉使用临时表，比方说下面这个包含<code>GROUP BY</code>子句的查询就不需要使用临时表：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9688 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;从<code>Extra</code>的<code>Using index</code>的提示里我们可以看出，上述查询只需要扫描<code>idx_key1</code>索引就可以搞定了，不再需要临时表了。</p></li><li><p><code>Start temporary, End temporary</code></p><p>  &amp;emsp;&amp;emsp;我们前面介绍子查询的时候说过，查询优化器会优先尝试将<code>IN</code>子查询转换成<code>semi-join</code>，而<code>semi-join</code>又有好多种执行策略，当执行策略为<code>DuplicateWeedout</code>时，也就是通过建立临时表来实现为外层查询中的记录进行去重操作时，驱动表查询执行计划的<code>Extra</code>列将显示<code>Start temporary</code>提示，被驱动表查询执行计划的<code>Extra</code>列将显示<code>End temporary</code>提示，就是这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = &#x27;a&#x27;);</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra                        |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL              | 9954 |    10.00 | Using where; Start temporary |</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s2.key3 |    1 |   100.00 | End temporary                |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p><code>LooseScan</code></p><p>  &amp;emsp;&amp;emsp;在将<code>In</code>子查询转为<code>semi-join</code>时，如果采用的是<code>LooseScan</code>执行策略，则在驱动表执行计划的<code>Extra</code>列就是显示<code>LooseScan</code>提示，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key3 IN (SELECT key1 FROM s2 WHERE key1 &gt; &#x27;z&#x27;);</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+-------------------+------+----------+-------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref               | rows | filtered | Extra                               |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+-------------------+------+----------+-------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL              |  270 |   100.00 | Using where; Using index; LooseScan |</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref   | idx_key3      | idx_key3 | 303     | xiaohaizi.s2.key1 |    1 |   100.00 | NULL                                |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+-------------------+------+----------+-------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p><code>FirstMatch(tbl_name)</code></p><p>  &amp;emsp;&amp;emsp;在将<code>In</code>子查询转为<code>semi-join</code>时，如果采用的是<code>FirstMatch</code>执行策略，则在被驱动表执行计划的<code>Extra</code>列就是显示<code>FirstMatch(tbl_name)</code>提示，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key1 FROM s2 where s1.key3 = s2.key3);</span><br><span class="line">+----+-------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-----------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys     | key      | key_len | ref               | rows | filtered | Extra                       |</span><br><span class="line">+----+-------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-----------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key3          | NULL     | NULL    | NULL              | 9688 |   100.00 | Using where                 |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1,idx_key3 | idx_key3 | 303     | xiaohaizi.s1.key3 |    1 |     4.87 | Using where; FirstMatch(s1) |</span><br><span class="line">+----+-------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-----------------------------+</span><br><span class="line">2 rows in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Json格式的执行计划"><a href="#Json格式的执行计划" class="headerlink" title="Json格式的执行计划"></a>Json格式的执行计划</h2><p>&amp;emsp;&amp;emsp;我们上面介绍的<code>EXPLAIN</code>语句输出中缺少了一个衡量执行计划好坏的重要属性 —— <span style="color:red">成本</span>。不过设计<code>MySQL</code>的大佬贴心的为我们提供了一种查看某个执行计划花费的成本的方式：</p><ul><li>在<code>EXPLAIN</code>单词和真正的查询语句中间加上<code>FORMAT=JSON</code>。</li></ul><p>&amp;emsp;&amp;emsp;这样我们就可以得到一个<code>json</code>格式的执行计划，里边儿包含该计划花费的成本，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = &#x27;a&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line"></span><br><span class="line">EXPLAIN: &#123;</span><br><span class="line">  &quot;query_block&quot;: &#123;</span><br><span class="line">    &quot;select_id&quot;: 1,     # 整个查询语句只有1个SELECT关键字，该关键字对应的id号为1</span><br><span class="line">    &quot;cost_info&quot;: &#123;</span><br><span class="line">      &quot;query_cost&quot;: &quot;3197.16&quot;   # 整个查询的执行成本预计为3197.16</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;nested_loop&quot;: [    # 几个表之间采用嵌套循环连接算法执行</span><br><span class="line">    </span><br><span class="line">    # 以下是参与嵌套循环连接算法的各个表的信息</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s1&quot;,   # s1表是驱动表</span><br><span class="line">          &quot;access_type&quot;: &quot;ALL&quot;,     # 访问方法为ALL，意味着使用全表扫描访问</span><br><span class="line">          &quot;possible_keys&quot;: [    # 可能使用的索引</span><br><span class="line">            &quot;idx_key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: 9688,   # 查询一次s1表大致需要扫描9688条记录</span><br><span class="line">          &quot;rows_produced_per_join&quot;: 968,    # 驱动表s1的扇出是968</span><br><span class="line">          &quot;filtered&quot;: &quot;10.00&quot;,  # condition filtering代表的百分比</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;1840.84&quot;,     # 稍后解释</span><br><span class="line">            &quot;eval_cost&quot;: &quot;193.76&quot;,      # 稍后解释</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;2034.60&quot;,   # 单次查询s1表总共的成本</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;  # 读取的数据量</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [     # 执行查询中涉及到的列</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ],</span><br><span class="line">          </span><br><span class="line">          # 对s1表访问时针对单表查询的条件</span><br><span class="line">          &quot;attached_condition&quot;: &quot;((`xiaohaizi`.`s1`.`common_field` = &#x27;a&#x27;) and (`xiaohaizi`.`s1`.`key1` is not null))&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s2&quot;,   # s2表是被驱动表</span><br><span class="line">          &quot;access_type&quot;: &quot;ref&quot;,     # 访问方法为ref，意味着使用索引等值匹配的方式访问</span><br><span class="line">          &quot;possible_keys&quot;: [    # 可能使用的索引</span><br><span class="line">            &quot;idx_key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key&quot;: &quot;idx_key2&quot;,    # 实际使用的索引</span><br><span class="line">          &quot;used_key_parts&quot;: [   # 使用到的索引列</span><br><span class="line">            &quot;key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key_length&quot;: &quot;5&quot;,    # key_len</span><br><span class="line">          &quot;ref&quot;: [      # 与key2列进行等值匹配的对象</span><br><span class="line">            &quot;xiaohaizi.s1.key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: 1,  # 查询一次s2表大致需要扫描1条记录</span><br><span class="line">          &quot;rows_produced_per_join&quot;: 968,    # 被驱动表s2的扇出是968（由于后边没有多余的表进行连接，所以这个值也没什么用）</span><br><span class="line">          &quot;filtered&quot;: &quot;100.00&quot;,     # condition filtering代表的百分比</span><br><span class="line">          </span><br><span class="line">          # s2表使用索引进行查询的搜索条件</span><br><span class="line">          &quot;index_condition&quot;: &quot;(`xiaohaizi`.`s1`.`key1` = `xiaohaizi`.`s2`.`key2`)&quot;,</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;968.80&quot;,      # 稍后解释</span><br><span class="line">            &quot;eval_cost&quot;: &quot;193.76&quot;,      # 稍后解释</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;3197.16&quot;,   # 单次查询s1、多次查询s2表总共的成本</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;  # 读取的数据量</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [     # 执行查询中涉及到的列</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们使用<code>#</code>后边跟随注释的形式为大家解释了<code>EXPLAIN FORMAT=JSON</code>语句的输出内容，但是大家可能有疑问<code>&quot;cost_info&quot;</code>里边的成本看着怪怪的，它们是怎么计算出来的？先看<code>s1</code>表的<code>&quot;cost_info&quot;</code>部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">    &quot;read_cost&quot;: &quot;1840.84&quot;,</span><br><span class="line">    &quot;eval_cost&quot;: &quot;193.76&quot;,</span><br><span class="line">    &quot;prefix_cost&quot;: &quot;2034.60&quot;,</span><br><span class="line">    &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>read_cost</code>是由下面这两部分组成的：</p><ul><li><code>IO</code>成本</li><li>检测<code>rows × (1 - filter)</code>条记录的<code>CPU</code>成本</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：rows和filter都是我们前面介绍执行计划的输出列，在JSON格式的执行计划中，rows相当于rows_examined_per_scan，filtered名称不变。</span><br></pre></td></tr></table></figure></li><li><p><code>eval_cost</code>是这样计算的：</p><p> &amp;emsp;&amp;emsp;检测 <code>rows × filter</code>条记录的成本。</p></li><li><p><code>prefix_cost</code>就是单独查询<code>s1</code>表的成本，也就是：</p><p>  <code>read_cost + eval_cost</code> </p></li><li><p><code>data_read_per_join</code>表示在此次查询中需要读取的数据量，我们就不多介绍这个了。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：大家其实没必要关注MySQL为什么使用这么古怪的方式计算出read_cost和eval_cost，关注prefix_cost是查询s1表的成本就好了。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;对于<code>s2</code>表的<code>&quot;cost_info&quot;</code>部分是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">    &quot;read_cost&quot;: &quot;968.80&quot;,</span><br><span class="line">    &quot;eval_cost&quot;: &quot;193.76&quot;,</span><br><span class="line">    &quot;prefix_cost&quot;: &quot;3197.16&quot;,</span><br><span class="line">    &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;由于<code>s2</code>表是被驱动表，所以可能被读取多次，这里的<code>read_cost</code>和<code>eval_cost</code>是访问多次<code>s2</code>表后累加起来的值，大家主要关注里边儿的<code>prefix_cost</code>的值代表的是整个连接查询预计的成本，也就是单次查询<code>s1</code>表和多次查询<code>s2</code>表后的成本的和，也就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">968.80 + 193.76 + 2034.60 = 3197.16</span><br></pre></td></tr></table></figure><h2 id="Extented-EXPLAIN"><a href="#Extented-EXPLAIN" class="headerlink" title="Extented EXPLAIN"></a>Extented EXPLAIN</h2><p>&amp;emsp;&amp;emsp;最后，设计<code>MySQL</code>的大佬还为我们留了个彩蛋，在我们使用<code>EXPLAIN</code>语句查看了某个查询的执行计划后，紧接着还可以使用<code>SHOW WARNINGS</code>语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL              | 9954 |    90.00 | Using where |</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s2.key1 |    1 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW WARNINGS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Level: Note</span><br><span class="line">   Code: 1003</span><br><span class="line">Message: /* select#1 */ select `xiaohaizi`.`s1`.`key1` AS `key1`,`xiaohaizi`.`s2`.`key1` AS `key1` from `xiaohaizi`.`s1` join `xiaohaizi`.`s2` where ((`xiaohaizi`.`s1`.`key1` = `xiaohaizi`.`s2`.`key1`) and (`xiaohaizi`.`s2`.`common_field` is not null))</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;大家可以看到<code>SHOW WARNINGS</code>展示出来的信息有三个字段，分别是<code>Level</code>、<code>Code</code>、<code>Message</code>。我们最常见的就是<code>Code</code>为<code>1003</code>的信息，当<code>Code</code>值为<code>1003</code>时，<code>Message</code>字段展示的信息<span style="color:red">类似于</span>查询优化器将我们的查询语句重写后的语句。比如我们上面的查询本来是一个左（外）连接查询，但是有一个<code>s2.common_field IS NOT NULL</code>的条件，着就会导致查询优化器把左（外）连接查询优化为内连接查询，从<code>SHOW WARNINGS</code>的<code>Message</code>字段也可以看出来，原本的<code>LEFT JOIN</code>已经变成了<code>JOIN</code>。</p><p>&amp;emsp;&amp;emsp;但是大家一定要注意，我们说<code>Message</code>字段展示的信息<span style="color:red">类似于</span>查询优化器将我们的查询语句重写后的语句，并不是等价于，也就是说<code>Message</code>字段展示的信息并不是标准的查询语句，在很多情况下并不能直接拿到黑框框中运行，它只能作为帮助我们理解查<code>MySQL</code>将如何执行查询语句的一个参考依据而已。</p><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/20-%E8%AF%B4%E8%BF%87%E7%9A%84%E8%AF%9D%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E5%8A%9E%E5%88%B0-redo%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2022/10/31/model-mysql/mysql/20-%E8%AF%B4%E8%BF%87%E7%9A%84%E8%AF%9D%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E5%8A%9E%E5%88%B0-redo%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="第20章-说过的话就一定要办到-redo日志（上）"><a href="#第20章-说过的话就一定要办到-redo日志（上）" class="headerlink" title="第20章 说过的话就一定要办到-redo日志（上）"></a>第20章 说过的话就一定要办到-redo日志（上）</h1><h2 id="事先说明"><a href="#事先说明" class="headerlink" title="事先说明"></a>事先说明</h2><p>&amp;emsp;&amp;emsp;本文以及接下来的几篇文章将会频繁的使用到我们前面介绍的<code>InnoDB</code>记录行格式、页面格式、索引原理、表空间的组成等各种基础知识，如果大家对这些东西理解的不透彻，那么阅读下面的文字可能会有些吃力，为保证您的阅读体验，请确保自己已经掌握了我前面介绍的这些知识。</p><h2 id="redo日志是什么"><a href="#redo日志是什么" class="headerlink" title="redo日志是什么"></a>redo日志是什么</h2><p>&amp;emsp;&amp;emsp;我们知道<code>InnoDB</code>存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。我们前面介绍<code>Buffer Pool</code>的时候说过，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。但是在介绍事务的时候又强调过一个称之为<code>持久性</code>的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。但是如果我们只在内存的<code>Buffer Pool</code>中修改了页面，假设在事务提交后突然发生了某个故障，导致内存中的数据都失效了，那么这个已经提交了的事务对数据库中所做的更改也就跟着丢失了，这是我们所不能忍受的（想想ATM机已经提示狗哥转账成功，但之后由于服务器出现故障，重启之后猫爷发现自己没收到钱，猫爷就被砍死了）。那么如何保证这个<code>持久性</code>呢？一个很简单的做法就是<span style="color:red">在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘</span>，但是这个简单粗暴的做法有些问题：</p><ul><li><p>刷新一个完整的数据页太浪费了</p><p>  &amp;emsp;&amp;emsp;有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在<code>InnoDB</code>中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。</p></li><li><p>随机IO刷起来比较慢</p><p>  &amp;emsp;&amp;emsp;一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，倒霉催的是该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的<code>Buffer Pool</code>中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</p></li></ul><p>&amp;emsp;&amp;emsp;咋办呢？再次回到我们的初心：<span style="color:red">我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来</span>。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要<span style="color:red">把修改了哪些东西记录一下就好</span>，比方说某个事务将系统表空间中的第100号页面中偏移量为1000处的那个字节的值<code>1</code>改成<code>2</code>我们只需要记录一下：</p><blockquote><p>将第0号表空间的100号页面的偏移量为1000处的值更新为<code>2</code>。</p></blockquote><p>&amp;emsp;&amp;emsp;这样我们在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据页，那么该事务对数据库中所做的修改又可以被恢复出来，也就意味着满足<code>持久性</code>的要求。因为在系统奔溃重启时需要按照上述内容所记录的步骤重新更新数据页，所以上述内容也被称之为<code>重做日志</code>，英文名为<code>redo log</code>，我们也可以土洋结合，称之为<code>redo日志</code>。与在事务提交时将所有修改过的内存中的页面刷新到磁盘中相比，只将该事务执行过程中产生的<code>redo</code>日志刷新到磁盘的好处如下：</p><ul><li><p><code>redo</code>日志占用的空间非常小</p><p>  &amp;emsp;&amp;emsp;存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的，关于<code>redo</code>日志的格式我们稍后会详细介绍，现在只要知道一条<code>redo</code>日志占用的空间不是很大就好了。</p></li><li><p><code>redo</code>日志是顺序写入磁盘的</p><p>  &amp;emsp;&amp;emsp;在执行事务的过程中，每执行一条语句，就可能产生若干条<code>redo</code>日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。</p></li></ul><h2 id="redo日志格式"><a href="#redo日志格式" class="headerlink" title="redo日志格式"></a>redo日志格式</h2><p>&amp;emsp;&amp;emsp;通过上面的内容我们知道，<code>redo</code>日志本质上只是<span style="color:red">记录了一下事务对数据库做了哪些修改</span>。 设计<code>InnoDB</code>的大佬们针对事务对数据库的不同修改场景定义了多种类型的<code>redo</code>日志，但是绝大部分类型的<code>redo</code>日志都有下面这种通用的结构：</p><p><img src="/../images/20-01.png"></p><p>&amp;emsp;&amp;emsp;各个部分的详细释义如下：</p><ul><li><p><code>type</code>：该条<code>redo</code>日志的类型。</p><p>  &amp;emsp;&amp;emsp;在<code>MySQL 5.7.21</code>这个版本中，设计<code>InnoDB</code>的大佬一共为<code>redo</code>日志设计了53种不同的类型，稍后会详细介绍不同类型的<code>redo</code>日志。</p></li><li><p><code>space ID</code>：表空间ID。</p></li><li><p><code>page number</code>：页号。</p></li><li><p><code>data</code>：该条<code>redo</code>日志的具体内容。</p></li></ul><h3 id="简单的redo日志类型"><a href="#简单的redo日志类型" class="headerlink" title="简单的redo日志类型"></a>简单的redo日志类型</h3><p>&amp;emsp;&amp;emsp;我们前面介绍<code>InnoDB</code>的记录行格式的时候说过，如果我们没有为某个表显式的定义主键，并且表中也没有定义<code>Unique</code>键，那么<code>InnoDB</code>会自动的为表添加一个称之为<code>row_id</code>的隐藏列作为主键。为这个<code>row_id</code>隐藏列赋值的方式如下：</p><ul><li>服务器会在内存中维护一个全局变量，每当向某个包含隐藏的<code>row_id</code>列的表中插入一条记录时，就会把该变量的值当作新记录的<code>row_id</code>列的值，并且把该变量自增1。</li><li>每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间的页号为<code>7</code>的页面中一个称之为<code>Max Row ID</code>的属性处（我们前面介绍表空间结构时详细说过）。</li><li>当系统启动时，会将上面提到的<code>Max Row ID</code>属性加载到内存中，将该值加上256之后赋值给我们前面提到的全局变量（因为在上次关机时该全局变量的值可能大于<code>Max Row ID</code>属性值）。</li></ul><p>&amp;emsp;&amp;emsp;这个<code>Max Row ID</code>属性占用的存储空间是8个字节，当某个事务向某个包含<code>row_id</code>隐藏列的表插入一条记录，并且为该记录分配的<code>row_id</code>值为256的倍数时，就会向系统表空间页号为7的页面的相应偏移量处写入8个字节的值。但是我们要知道，这个写入实际上是在<code>Buffer Pool</code>中完成的，我们需要为这个页面的修改记录一条<code>redo</code>日志，以便在系统奔溃后能将已经提交的该事务对该页面所做的修改恢复出来。这种情况下对页面的修改是极其简单的，<code>redo</code>日志中只需要<span style="color:red">记录一下在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是什么就好了</span>，设计<code>InnoDB</code>的大佬把这种极其简单的<code>redo</code>日志称之为<code>物理日志</code>，并且根据在页面中写入数据的多少划分了几种不同的<code>redo</code>日志类型：</p><ul><li><code>MLOG_1BYTE</code>（<code>type</code>字段对应的十进制数字为<code>1</code>）：表示在页面的某个偏移量处写入1个字节的<code>redo</code>日志类型。</li><li><code>MLOG_2BYTE</code>（<code>type</code>字段对应的十进制数字为<code>2</code>）：表示在页面的某个偏移量处写入2个字节的<code>redo</code>日志类型。</li><li><code>MLOG_4BYTE</code>（<code>type</code>字段对应的十进制数字为<code>4</code>）：表示在页面的某个偏移量处写入4个字节的<code>redo</code>日志类型。</li><li><code>MLOG_8BYTE</code>（<code>type</code>字段对应的十进制数字为<code>8</code>）：表示在页面的某个偏移量处写入8个字节的<code>redo</code>日志类型。</li><li><code>MLOG_WRITE_STRING</code>（<code>type</code>字段对应的十进制数字为<code>30</code>）：表示在页面的某个偏移量处写入一串数据。</li></ul><p>&amp;emsp;&amp;emsp;我们上面提到的<code>Max Row ID</code>属性实际占用8个字节的存储空间，所以在修改页面中的该属性时，会记录一条类型为<code>MLOG_8BYTE</code>的<code>redo</code>日志，<code>MLOG_8BYTE</code>的<code>redo</code>日志结构如下所示：</p><p><img src="/../images/20-02.png"></p><p>&amp;emsp;&amp;emsp;其余<code>MLOG_1BYTE</code>、<code>MLOG_2BYTE</code>、<code>MLOG_4BYTE</code>类型的<code>redo</code>日志结构和<code>MLOG_8BYTE</code>的类似，只不过具体数据中包含对应个字节的数据罢了。<code>MLOG_WRITE_STRING</code>类型的<code>redo</code>日志表示写入一串数据，但是因为不能确定写入的具体数据占用多少字节，所以需要在日志结构中添加一个<code>len</code>字段：</p><p><img src="/../images/20-03.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：只要将MLOG_WRITE_STRING类型的redo日志的len字段填充上1、2、4、8这些数字，就可以分别替代MLOG_1BYTE、MLOG_2BYTE、MLOG_4BYTE、MLOG_8BYTE这些类型的redo日志，为什么还要多此一举设计这么多类型呢？还不是因为省空间啊，能不写len字段就不写len字段，省一个字节算一个字节。</span><br></pre></td></tr></table></figure><h3 id="复杂一些的redo日志类型"><a href="#复杂一些的redo日志类型" class="headerlink" title="复杂一些的redo日志类型"></a>复杂一些的redo日志类型</h3><p>&amp;emsp;&amp;emsp;有时候执行一条语句会修改非常多的页面，包括系统数据页面和用户数据页面（用户数据指的就是聚簇索引和二级索引对应的<code>B+</code>树）。以一条<code>INSERT</code>语句为例，它除了要向<code>B+</code>树的页面中插入数据，也可能更新系统数据<code>Max Row ID</code>的值，不过对于我们用户来说，平时更关心的是语句对<code>B+</code>树所做更新：</p><ul><li>表中包含多少个索引，一条<code>INSERT</code>语句就可能更新多少棵<code>B+</code>树。</li><li>针对某一棵<code>B+</code>树来说，既可能更新叶子节点页面，也可能更新内节点页面，也可能创建新的页面（在该记录插入的叶子节点的剩余空间比较少，不足以存放该记录时，会进行页面的分裂，在内节点页面中添加<code>目录项记录</code>）。</li></ul><p>&amp;emsp;&amp;emsp;在语句执行过程中，<code>INSERT</code>语句对所有页面的修改都得保存到<code>redo</code>日志中去。这句话说的比较轻巧，做起来可就比较麻烦了，比方说将记录插入到聚簇索引中时，如果定位到的叶子节点的剩余空间足够存储该记录时，那么只更新该叶子节点页面就好，那么只记录一条<code>MLOG_WRITE_STRING</code>类型的<code>redo</code>日志，表明在页面的某个偏移量处增加了哪些数据就好了么？那就too young too naive了～ 别忘了一个数据页中除了存储实际的记录之后，还有什么<code>File Header</code>、<code>Page Header</code>、<code>Page Directory</code>等等部分（在介绍数据页的章节有详细讲解），所以每往叶子节点代表的数据页里插入一条记录时，还有其他很多地方会跟着更新，比如说：</p><ul><li>可能更新<code>Page Directory</code>中的槽信息。</li><li><code>Page Header</code>中的各种页面统计信息，比如<code>PAGE_N_DIR_SLOTS</code>表示的槽数量可能会更改，<code>PAGE_HEAP_TOP</code>代表的还未使用的空间最小地址可能会更改，<code>PAGE_N_HEAP</code>代表的本页面中的记录数量可能会更改，等等，各种信息都可能会被修改。</li><li>我们知道在数据页里的记录是按照索引列从小到大的顺序组成一个单向链表的，每插入一条记录，还需要更新上一条记录的记录头信息中的<code>next_record</code>属性来维护这个单向链表。</li><li>还有别的等等的更新的地方，就不一一介绍了…</li></ul><p>&amp;emsp;&amp;emsp;画一个简易的示意图就像是这样：</p><p><img src="/../images/20-04.png"></p><p>&amp;emsp;&amp;emsp;说了这么多，就是想表达：<span style="color:red">把一条记录插入到一个页面时需要更改的地方非常多</span>。这时我们如果使用上面介绍的简单的物理<code>redo</code>日志来记录这些修改时，可以有两种解决方案：</p><ul><li><p>方案一：在每个修改的地方都记录一条<code>redo</code>日志。</p><p>  &amp;emsp;&amp;emsp;也就是如上图所示，有多少个加粗的块，就写多少条物理<code>redo</code>日志。这样子记录<code>redo</code>日志的缺点是显而易见的，因为被修改的地方是在太多了，可能记录的<code>redo</code>日志占用的空间都比整个页面占用的空间都多了～</p></li><li><p>方案二：将整个页面的<code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间所有的数据当成是一条物理<code>redo</code>日志中的具体数据。</p><p>  &amp;emsp;&amp;emsp;从图中也可以看出来，<code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间仍然有许多没有修改过的数据，我们把这些没有修改的数据也加入到<code>redo</code>日志中去岂不是太浪费了～</p></li></ul><p>&amp;emsp;&amp;emsp;正因为上述两种使用物理<code>redo</code>日志的方式来记录某个页面中做了哪些修改比较浪费，设计<code>InnoDB</code>的大佬本着勤俭节约的初心，提出了一些新的<code>redo</code>日志类型，比如：</p><ul><li><code>MLOG_REC_INSERT</code>（对应的十进制数字为<code>9</code>）：表示插入一条使用非紧凑行格式的记录时的<code>redo</code>日志类型。</li><li><code>MLOG_COMP_REC_INSERT</code>（对应的十进制数字为<code>38</code>）：表示插入一条使用紧凑行格式的记录时的<code>redo</code>日志类型。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：Redundant是一种比较原始的行格式，它就是非紧凑的。而Compact、Dynamic以及Compressed行格式是较新的行格式，它们是紧凑的（占用更小的存储空间）。</span><br></pre></td></tr></table></figure><ul><li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type</code>字段对应的十进制数字为<code>58</code>）：表示创建一个存储紧凑行格式记录的页面的<code>redo</code>日志类型。</li><li><code>MLOG_COMP_REC_DELETE</code>（<code>type</code>字段对应的十进制数字为<code>42</code>）：表示删除一条使用紧凑行格式记录的<code>redo</code>日志类型。</li><li><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type</code>字段对应的十进制数字为<code>44</code>）：表示从某条给定记录开始删除页面中的一系列使用紧凑行格式记录的<code>redo</code>日志类型。</li><li><code>MLOG_COMP_LIST_END_DELETE</code>（<code>type</code>字段对应的十进制数字为<code>43</code>）：与<code>MLOG_COMP_LIST_START_DELETE</code>类型的<code>redo</code>日志呼应，表示删除一系列记录直到<code>MLOG_COMP_LIST_END_DELETE</code>类型的<code>redo</code>日志对应的记录为止。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：我们前面介绍InnoDB数据页格式的时候重点强调过，数据页中的记录是按照索引列大小的顺序组成单向链表的。有时候我们会有删除索引列的值在某个区间范围内的所有记录的需求，这时候如果我们每删除一条记录就写一条redo日志的话，效率可能有点低，所以提出MLOG_COMP_LIST_START_DELETE和MLOG_COMP_LIST_END_DELETE类型的redo日志，可以很大程度上减少redo日志的条数。</span><br></pre></td></tr></table></figure><ul><li><code>MLOG_ZIP_PAGE_COMPRESS</code>（<code>type</code>字段对应的十进制数字为<code>51</code>）：表示压缩一个数据页的<code>redo</code>日志类型。</li><li>······还有很多很多种类型，这就不列举了，等用到再说～</li></ul><p>&amp;emsp;&amp;emsp;这些类型的<code>redo</code>日志既包含<code>物理</code>层面的意思，也包含<code>逻辑</code>层面的意思，具体指：</p><ul><li>物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。</li><li>逻辑层面看，在系统奔溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统奔溃前的样子。</li></ul><p>&amp;emsp;&amp;emsp;大家看到这可能有些懵逼，我们还是以类型为<code>MLOG_COMP_REC_INSERT</code>这个代表插入一条使用紧凑行格式的记录时的<code>redo</code>日志为例来理解一下我们上面所说的<code>物理</code>层面和<code>逻辑</code>层面到底是什么意思。废话少说，直接看一下这个类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志的结构（由于字段太多了，我们把它们竖着看效果好些）：</p><p><img src="/../images/20-05.png"></p><p>&amp;emsp;&amp;emsp;这个类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志结构有几个地方需要大家注意：</p><ul><li>我们前面在介绍索引的时候说过，在一个数据页里，不论是叶子节点还是非叶子节点，记录都是按照索引列从小到大的顺序排序的。对于二级索引来说，当索引列的值相同时，记录还需要按照主键值进行排序。图中<code>n_uniques</code>的值的含义是在一条记录中，需要几个字段的值才能确保记录的唯一性，这样当插入一条记录时就可以按照记录的前<code>n_uniques</code>个字段进行排序。对于聚簇索引来说，<code>n_uniques</code>的值为主键的列数，对于其他二级索引来说，该值为索引列数+主键列数。这里需要注意的是，唯一二级索引的值可能为<code>NULL</code>，所以该值仍然为索引列数+主键列数。</li><li><code>field1_len ~ fieldn_len</code>代表着该记录若干个字段占用存储空间的大小，需要注意的是，这里不管该字段的类型是固定长度大小的（比如<code>INT</code>），还是可变长度大小（比如<code>VARCHAR(M)</code>）的，该字段占用的大小始终要写入<code>redo</code>日志中。</li><li><code>offset</code>代表的是该记录的前一条记录在页面中的地址。为什么要记录前一条记录的地址呢？这是因为每向数据页插入一条记录，都需要修改该页面中维护的记录链表，每条记录的<code>记录头信息</code>中都包含一个称为<code>next_record</code>的属性，所以在插入新记录时，需要修改前一条记录的<code>next_record</code>属性。</li><li>我们知道一条记录其实由<code>额外信息</code>和<code>真实数据</code>这两部分组成，这两个部分的总大小就是一条记录占用存储空间的总大小。通过<code>end_seg_len</code>的值可以间接的计算出一条记录占用存储空间的总大小，为什么不直接存储一条记录占用存储空间的总大小呢？这是因为写<code>redo</code>日志是一个非常频繁的操作，设计<code>InnoDB</code>的大佬想方设法想减小<code>redo</code>日志本身占用的存储空间大小，所以想了一些弯弯绕的算法来实现这个目标，<code>end_seg_len</code>这个字段就是为了节省<code>redo</code>日志存储空间而提出来的。至于具体设计<code>InnoDB</code>的大佬到底是用了什么神奇魔法减小<code>redo</code>日志大小的，我们这就不多介绍了，因为的确有那么一丢丢小复杂，说清楚还是有一点点麻烦的，而且说明白了也没什么用。</li><li><code>mismatch_index</code>的值也是为了节省<code>redo</code>日志的大小而设立的，大家可以忽略。</li></ul><p>&amp;emsp;&amp;emsp;很显然这个类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志并没有记录<code>PAGE_N_DIR_SLOTS</code>的值修改为了什么，<code>PAGE_HEAP_TOP</code>的值修改为了什么，<code>PAGE_N_HEAP</code>的值修改为了什么等等这些信息，而只是把在本页面中插入一条记录所有必备的要素记了下来，之后系统奔溃重启时，服务器会调用相关向某个页面插入一条记录的那个函数，而<code>redo</code>日志中的那些数据就可以被当成是调用这个函数所需的参数，在调用完该函数后，页面中的<code>PAGE_N_DIR_SLOTS</code>、<code>PAGE_HEAP_TOP</code>、<code>PAGE_N_HEAP</code>等等的值也就都被恢复到系统奔溃前的样子了。这就是所谓的<code>逻辑</code>日志的意思。</p><h3 id="redo日志格式小结"><a href="#redo日志格式小结" class="headerlink" title="redo日志格式小结"></a>redo日志格式小结</h3><p>&amp;emsp;&amp;emsp;虽然上面说了一大堆关于<code>redo</code>日志格式的内容，但是如果你不是为了写一个解析<code>redo</code>日志的工具或者自己开发一套<code>redo</code>日志系统的话，那就没必要把<code>InnoDB</code>中的各种类型的<code>redo</code>日志格式都研究的透透的，没那个必要。上面我只是象征性的介绍了几种类型的<code>redo</code>日志格式，目的还是想让大家明白：<span style="color:red">redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：为了节省redo日志占用的存储空间大小，设计InnoDB的大佬对redo日志中的某些数据还可能进行压缩处理，比方说spacd ID和page number一般占用4个字节来存储，但是经过压缩后，可能使用更小的空间来存储。具体压缩算法就不介绍了。</span><br></pre></td></tr></table></figure><h2 id="Mini-Transaction"><a href="#Mini-Transaction" class="headerlink" title="Mini-Transaction"></a>Mini-Transaction</h2><h3 id="以组的形式写入redo日志"><a href="#以组的形式写入redo日志" class="headerlink" title="以组的形式写入redo日志"></a>以组的形式写入redo日志</h3><p>&amp;emsp;&amp;emsp;语句在执行过程中可能修改若干个页面。比如我们前面说的一条<code>INSERT</code>语句可能修改系统表空间页号为<code>7</code>的页面的<code>Max Row ID</code>属性（当然也可能更新别的系统页面，只不过我们没有都列举出来而已），还会更新聚簇索引和二级索引对应<code>B+</code>树中的页面。由于对这些页面的更改都发生在<code>Buffer Pool</code>中，所以在修改完页面之后，需要记录一下相应的<code>redo</code>日志。在执行语句的过程中产生的<code>redo</code>日志被设计<code>InnoDB</code>的大佬人为的划分成了若干个不可分割的组，比如：</p><ul><li>更新<code>Max Row ID</code>属性时产生的<code>redo</code>日志是不可分割的。</li><li>向聚簇索引对应<code>B+</code>树的页面中插入一条记录时产生的<code>redo</code>日志是不可分割的。</li><li>向某个二级索引对应<code>B+</code>树的页面中插入一条记录时产生的<code>redo</code>日志是不可分割的。</li><li>还有其他的一些对页面的访问操作时产生的<code>redo</code>日志是不可分割的。。。</li></ul><p>&amp;emsp;&amp;emsp;怎么理解这个<code>不可分割</code>的意思呢？我们以向某个索引对应的<code>B+</code>树插入一条记录为例，在向<code>B+</code>树中插入这条记录之前，需要先定位到这条记录应该被插入到哪个叶子节点代表的数据页中，定位到具体的数据页之后，有两种可能的情况：</p><ul><li><p>情况一：该数据页的剩余的空闲空间充足，足够容纳这一条待插入记录，那么事情很简单，直接把记录插入到这个数据页中，记录一条类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志就好了，我们把这种情况称之为<code>乐观插入</code>。假如某个索引对应的<code>B+</code>树长这样：</p><p>  <img src="/../images/20-06.png"></p><p>  &amp;emsp;&amp;emsp;现在我们要插入一条键值为<code>10</code>的记录，很显然需要被插入到<code>页b</code>中，由于<code>页b</code>现在有足够的空间容纳一条记录，所以直接将该记录插入到<code>页b</code>中就好了，就像这样：</p><p>  <img src="/../images/20-07.png"></p></li><li><p>情况二：该数据页剩余的空闲空间不足，那么事情就悲剧了，我们前面说过，遇到这种情况要进行所谓的<code>页分裂</code>操作，也就是新建一个叶子节点，然后把原先数据页中的一部分记录复制到这个新的数据页中，然后再把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在内节点中添加一条<code>目录项记录</code>指向这个新创建的页面。很显然，这个过程要对多个页面进行修改，也就意味着会产生多条<code>redo</code>日志，我们把这种情况称之为<code>悲观插入</code>。假如某个索引对应的<code>B+</code>树长这样：</p><p>  <img src="/../images/20-08.png"></p><p>  &amp;emsp;&amp;emsp;现在我们要插入一条键值为<code>10</code>的记录，很显然需要被插入到<code>页b</code>中，但是从图中也可以看出来，此时<code>页b</code>已经塞满了记录，没有更多的空闲空间来容纳这条新记录了，所以我们需要进行页面的分裂操作，就像这样：</p><p>  <img src="/../images/20-09.png"></p><p>  &amp;emsp;&amp;emsp;如果作为内节点的<code>页a</code>的剩余空闲空间也不足以容纳增加一条<code>目录项记录</code>，那需要继续做内节点<code>页a</code>的分裂操作，也就意味着会修改更多的页面，从而产生更多的<code>redo</code>日志。另外，对于<code>悲观插入</code>来说，由于需要新申请数据页，还需要改动一些系统页面，比方说要修改各种段、区的统计信息信息，各种链表的统计信息（比如什么<code>FREE</code>链表、<code>FSP_FREE_FRAG</code>链表等等我们在介绍表空间那一章中介绍过的各种东东）等等等等，反正总共需要记录的<code>redo</code>日志有二、三十条。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：其实不光是悲观插入一条记录会生成许多条redo日志，设计InnoDB的大佬为了其他的一些功能，在乐观插入时也可能产生多条redo日志（具体是为了什么功能我们就不多说了，要不篇幅就受不了了～）。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;设计<code>InnoDB</code>的大佬们认为向某个索引对应的<code>B+</code>树中插入一条记录的这个过程必须是原子的，不能说插了一半之后就停止了。比方说在悲观插入过程中，新的页面已经分配好了，数据也复制过去了，新的记录也插入到页面中了，可是没有向内节点中插入一条<code>目录项记录</code>，这个插入过程就是不完整的，这样会形成一棵不正确的<code>B+</code>树。我们知道<code>redo</code>日志是为了在系统奔溃重启时恢复崩溃前的状态，如果在悲观插入的过程中只记录了一部分<code>redo</code>日志，那么在系统奔溃重启时会将索引对应的<code>B+</code>树恢复成一种不正确的状态，这是设计<code>InnoDB</code>的大佬们所不能忍受的。所以他们规定在执行这些需要保证原子性的操作时必须以<code>组</code>的形式来记录的<code>redo</code>日志，在进行系统奔溃重启恢复时，针对某个组中的<code>redo</code>日志，要么把全部的日志都恢复掉，要么一条也不恢复。怎么做到的呢？这得分情况讨论：</p><ul><li><p>有的需要保证原子性的操作会生成多条<code>redo</code>日志，比如向某个索引对应的<code>B+</code>树中进行一次悲观插入就需要生成许多条<code>redo</code>日志。</p><p>  &amp;emsp;&amp;emsp;如何把这些<code>redo</code>日志划分到一个组里边儿呢？设计<code>InnoDB</code>的大佬做了一个很简单的小把戏，就是在该组中的最后一条<code>redo</code>日志后边加上一条特殊类型的<code>redo</code>日志，该类型名称为<code>MLOG_MULTI_REC_END</code>，<code>type</code>字段对应的十进制数字为<code>31</code>，该类型的<code>redo</code>日志结构很简单，只有一个<code>type</code>字段：</p><p>  <img src="/../images/20-10.png"></p><p>  &amp;emsp;&amp;emsp;所以某个需要保证原子性的操作产生的一系列<code>redo</code>日志必须要以一个类型为<code>MLOG_MULTI_REC_END</code>结尾，就像这样：</p><p>  <img src="/../images/20-11.png">    </p><p>  &amp;emsp;&amp;emsp;这样在系统奔溃重启进行恢复时，只有当解析到类型为<code>MLOG_MULTI_REC_END</code>的<code>redo</code>日志，才认为解析到了一组完整的<code>redo</code>日志，才会进行恢复。否则的话直接放弃前面解析到的<code>redo</code>日志。</p></li><li><p>有的需要保证原子性的操作只生成一条<code>redo</code>日志，比如更新<code>Max Row ID</code>属性的操作就只会生成一条<code>redo</code>日志。</p><p>  &amp;emsp;&amp;emsp;其实在一条日志后边跟一个类型为<code>MLOG_MULTI_REC_END</code>的<code>redo</code>日志也是可以的，不过设计<code>InnoDB</code>的大佬比较勤俭节约，他们不想浪费一个比特位。别忘了虽然<code>redo</code>日志的类型比较多，但撑死了也就是几十种，是小于<code>127</code>这个数字的，也就是说我们用7个比特位就足以包括所有的<code>redo</code>日志类型，而<code>type</code>字段其实是占用1个字节的，也就是说我们可以省出来一个比特位用来表示该需要保证原子性的操作只产生单一的一条<code>redo</code>日志，示意图如下：</p><p>  <img src="/../images/20-12.png"></p><p>  &amp;emsp;&amp;emsp;如果<code>type</code>字段的第一个比特位为<code>1</code>，代表该需要保证原子性的操作只产生了单一的一条<code>redo</code>日志，否则表示该需要保证原子性的操作产生了一系列的<code>redo</code>日志。</p></li></ul><h3 id="Mini-Transaction的概念"><a href="#Mini-Transaction的概念" class="headerlink" title="Mini-Transaction的概念"></a>Mini-Transaction的概念</h3><p>&amp;emsp;&amp;emsp;设计<code>MySQL</code>的大佬把对底层页面中的一次原子访问的过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，比如上面所说的修改一次<code>Max Row ID</code>的值算是一个<code>Mini-Transaction</code>，向某个索引对应的<code>B+</code>树中插入一条记录的过程也算是一个<code>Mini-Transaction</code>。通过上面的叙述我们也知道，一个所谓的<code>mtr</code>可以包含一组<code>redo</code>日志，在进行奔溃恢复时这一组<code>redo</code>日志作为一个不可分割的整体。</p><p>&amp;emsp;&amp;emsp;一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条<code>redo</code>日志，画个图表示它们的关系就是这样：</p><p><img src="/../images/20-13.png"></p><h2 id="redo日志的写入过程"><a href="#redo日志的写入过程" class="headerlink" title="redo日志的写入过程"></a>redo日志的写入过程</h2><h3 id="redo-log-block"><a href="#redo-log-block" class="headerlink" title="redo log block"></a>redo log block</h3><p>&amp;emsp;&amp;emsp;设计<code>InnoDB</code>的大佬为了更好的进行系统奔溃恢复，他们把通过<code>mtr</code>生成的<code>redo</code>日志都放在了大小为<code>512字节</code>的<code>页</code>中。为了和我们前面提到的表空间中的页做区别，我们这里把用来存储<code>redo</code>日志的页称为<code>block</code>（你心里清楚页和block的意思其实差不多就行了）。一个<code>redo log block</code>的示意图如下：</p><p><img src="/../images/20-14.png"></p><p>&amp;emsp;&amp;emsp;真正的<code>redo</code>日志都是存储到占用<code>496</code>字节大小的<code>log block body</code>中，图中的<code>log block header</code>和<code>log block trailer</code>存储的是一些管理信息。我们来看看这些所谓的<code>管理信息</code>都是什么：</p><p><img src="/../images/20-15.png"></p><p>&amp;emsp;&amp;emsp;其中<code>log block header</code>的几个属性的意思分别如下：</p><ul><li><code>LOG_BLOCK_HDR_NO</code>：每一个block都有一个大于0的唯一标号，本属性就表示该标号值。</li><li><code>LOG_BLOCK_HDR_DATA_LEN</code>：表示block中已经使用了多少字节，初始值为<code>12</code>（因为<code>log block body</code>从第12个字节处开始）。随着往block中写入的redo日志越来也多，本属性值也跟着增长。如果<code>log block body</code>已经被全部写满，那么本属性的值被设置为<code>512</code>。</li><li><code>LOG_BLOCK_FIRST_REC_GROUP</code>：一条<code>redo</code>日志也可以称之为一条<code>redo</code>日志记录（<code>redo log record</code>），一个<code>mtr</code>会生产多条<code>redo</code>日志记录，这些<code>redo</code>日志记录被称之为一个<code>redo</code>日志记录组（<code>redo log record group</code>）。<code>LOG_BLOCK_FIRST_REC_GROUP</code>就代表该block中第一个<code>mtr</code>生成的<code>redo</code>日志记录组的偏移量（其实也就是这个block里第一个<code>mtr</code>生成的第一条<code>redo</code>日志的偏移量）。</li><li><code>LOG_BLOCK_CHECKPOINT_NO</code>：表示所谓的<code>checkpoint</code>的序号，<code>checkpoint</code>是我们后续内容的重点，现在先不用清楚它的意思，稍安勿躁。</li></ul><p><code>log block trailer</code>中属性的意思如下：</p><ul><li><code>LOG_BLOCK_CHECKSUM</code>：表示block的校验值，用于正确性校验，我们暂时不关心它。</li></ul><h3 id="redo日志缓冲区"><a href="#redo日志缓冲区" class="headerlink" title="redo日志缓冲区"></a>redo日志缓冲区</h3><p>&amp;emsp;&amp;emsp;我们前面说过，设计<code>InnoDB</code>的大佬为了解决磁盘速度过慢的问题而引入了<code>Buffer Pool</code>。同理，写入<code>redo</code>日志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为<code>redo log buffer</code>的连续内存空间，翻译成中文就是<code>redo日志缓冲区</code>，我们也可以简称为<code>log buffer</code>。这片内存空间被划分成若干个连续的<code>redo log block</code>，就像这样：</p><p><img src="/../images/20-16.png"></p><p>&amp;emsp;&amp;emsp;我们可以通过启动参数<code>innodb_log_buffer_size</code>来指定<code>log buffer</code>的大小，在<code>MySQL 5.7.21</code>这个版本中，该启动参数的默认值为<code>16MB</code>。</p><h3 id="redo日志写入log-buffer"><a href="#redo日志写入log-buffer" class="headerlink" title="redo日志写入log buffer"></a>redo日志写入log buffer</h3><p>&amp;emsp;&amp;emsp;向<code>log buffer</code>中写入<code>redo</code>日志的过程是顺序的，也就是先往前面的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往<code>log buffer</code>中写入<code>redo</code>日志时，第一个遇到的问题就是应该写在哪个<code>block</code>的哪个偏移量处，所以设计<code>InnoDB</code>的大佬特意提供了一个称之为<code>buf_free</code>的全局变量，该变量指明后续写入的<code>redo</code>日志应该写入到<code>log buffer</code>中的哪个位置，如图所示：</p><p><img src="/../images/20-17.png">   </p><p>&amp;emsp;&amp;emsp;我们前面说过一个<code>mtr</code>执行过程中可能产生若干条<code>redo</code>日志，这些<code>redo</code>日志是一个不可分割的组，所以其实并不是每生成一条<code>redo</code>日志，就将其插入到<code>log buffer</code>中，而是每个<code>mtr</code>运行过程中产生的日志先暂时存到一个地方，当该<code>mtr</code>结束的时候，将过程中产生的一组<code>redo</code>日志再全部复制到<code>log buffer</code>中。我们现在假设有两个名为<code>T1</code>、<code>T2</code>的事务，每个事务都包含2个<code>mtr</code>，我们给这几个<code>mtr</code>命名一下：</p><ul><li>事务<code>T1</code>的两个<code>mtr</code>分别称为<code>mtr_T1_1</code>和<code>mtr_T1_2</code>。</li><li>事务<code>T2</code>的两个<code>mtr</code>分别称为<code>mtr_T2_1</code>和<code>mtr_T2_2</code>。</li></ul><p>&amp;emsp;&amp;emsp;每个<code>mtr</code>都会产生一组<code>redo</code>日志，用示意图来描述一下这些<code>mtr</code>产生的日志情况：</p><p><img src="/../images/20-18.png"></p><p>&amp;emsp;&amp;emsp;不同的事务可能是并发执行的，所以<code>T1</code>、<code>T2</code>之间的<code>mtr</code>可能是交替执行的。每当一个<code>mtr</code>执行完成时，伴随该<code>mtr</code>生成的一组<code>redo</code>日志就需要被复制到<code>log buffer</code>中，也就是说不同事务的<code>mtr</code>可能是交替写入<code>log buffer</code>的，我们画个示意图（为了美观，我们把一个<code>mtr</code>中产生的所有的<code>redo</code>日志当作一个整体来画）：</p><p><img src="/../images/20-19.png"></p><p>&amp;emsp;&amp;emsp;从示意图中我们可以看出来，不同的<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间可能不一样，有的<code>mtr</code>产生的<code>redo</code>日志量很少，比如<code>mtr_t1_1</code>、<code>mtr_t2_1</code>就被放到同一个block中存储，有的<code>mtr</code>产生的<code>redo</code>日志量非常大，比如<code>mtr_t1_2</code>产生的<code>redo</code>日志甚至占用了3个block来存储。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：对照着上图，自己分析一下每个block的LOG_BLOCK_HDR_DATA_LEN、LOG_BLOCK_FIRST_REC_GROUP属性值都是什么～</span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/22-%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2022/10/31/model-mysql/mysql/22-%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="第22章-后悔了怎么办-undo日志（上）"><a href="#第22章-后悔了怎么办-undo日志（上）" class="headerlink" title="第22章 后悔了怎么办-undo日志（上）"></a>第22章 后悔了怎么办-undo日志（上）</h1><h2 id="事务回滚的需求"><a href="#事务回滚的需求" class="headerlink" title="事务回滚的需求"></a>事务回滚的需求</h2><p>&amp;emsp;&amp;emsp;我们说过<code>事务</code>需要保证<code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但是偏偏有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入<code>ROLLBACK</code>语句结束当前的事务的执行。</li></ul><p>&amp;emsp;&amp;emsp;这两种情况都会导致事务执行到一半就结束，但是事务执行过程中可能已经修改了很多东西，为了保证事务的原子性，我们需要把东西改回原先的样子，这个过程就称之为<code>回滚</code>（英文名：<code>rollback</code>），这样就可以造成一个假象：<span style="color:red">这个事务看起来什么都没做</span>，所以符合<code>原子性</code>要求。</p><p>&amp;emsp;&amp;emsp;小时候我非常痴迷于象棋，总是想找厉害的大人下棋，赢棋是不可能赢棋的，这辈子都不可能赢棋的，又不想认输，只能偷偷的悔棋才能勉强玩的下去。<code>悔棋</code>就是一种非常典型的<code>回滚</code>操作，比如棋子往前走两步，<code>悔棋</code>对应的操作就是向后走两步；比如棋子往左走一步，<code>悔棋</code>对应的操作就是向右走一步。数据库中的回滚跟<code>悔棋</code>差不多，你插入了一条记录，<code>回滚</code>操作对应的就是把这条记录删除掉；你更新了一条记录，<code>回滚</code>操作对应的就是把该记录更新为旧值；你删除了一条记录，<code>回滚</code>操作对应的自然就是把该记录再插进去。说的貌似很简单的样子[手动偷笑😏]。</p><p>&amp;emsp;&amp;emsp;从上面的描述中我们已经能隐约感觉到，每当我们要对一条记录做改动时（这里的<code>改动</code>可以指<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>），都需要留一手 —— <span style="color:red">把回滚时所需的东西都给记下来</span>。比方说：</p><ul><li>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</li><li>你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。</li><li>你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</li></ul><p>&amp;emsp;&amp;emsp;设计数据库的大佬把这些为了回滚而记录的这些东东称之为撤销日志，英文名为<code>undo log</code>，我们也可以土洋结合，称之为<code>undo日志</code>。这里需要注意的一点是，由于查询操作（<code>SELECT</code>）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的<code>undo日志</code>。在真实的<code>InnoDB</code>中，<code>undo日志</code>其实并不像我们上面所说的那么简单，不同类型的操作产生的<code>undo日志</code>的格式也是不同的，不过先暂时把这些容易让人脑子糊的具体细节放一放，我们先回过头来看看<code>事务id</code>是个神马玩意儿。</p><h2 id="事务id"><a href="#事务id" class="headerlink" title="事务id"></a>事务id</h2><h3 id="给事务分配id的时机"><a href="#给事务分配id的时机" class="headerlink" title="给事务分配id的时机"></a>给事务分配id的时机</h3><p>&amp;emsp;&amp;emsp;我们前面在介绍<code>事务简介</code>时说过，一个事务可以是一个只读事务，或者是一个读写事务：</p><ul><li><p>我们可以通过<code>START TRANSACTION READ ONLY</code>语句开启一个只读事务。</p><p>  &amp;emsp;&amp;emsp;在只读事务中不可以对普通的表（其他事务也能访问到的表）进行增、删、改操作，但可以对临时表做增、删、改操作。</p></li><li><p>我们可以通过<code>START TRANSACTION READ WRITE</code>语句开启一个读写事务，或者使用<code>BEGIN</code>、<code>START TRANSACTION</code>语句开启的事务默认也算是读写事务。</p><p>  &amp;emsp;&amp;emsp;在读写事务中可以对表执行增删改查操作。</p></li></ul><p>&amp;emsp;&amp;emsp;如果某个事务执行过程中对某个表执行了增、删、改操作，那么<code>InnoDB</code>存储引擎就会给它分配一个独一无二的<code>事务id</code>，分配方式如下：</p><ul><li><p>对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个<code>事务id</code>，否则的话是不分配<code>事务id</code>的。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：我们前面说过对某个查询语句执行EXPLAIN分析它的查询计划时，有时候在Extra列会看到Using temporary的提示，这个表明在执行该查询语句时会用到内部临时表。这个所谓的内部临时表和我们手动用CREATE TEMPORARY TABLE创建的用户临时表并不一样，在事务回滚时并不需要把执行SELECT语句过程中用到的内部临时表也回滚，在执行SELECT语句用到内部临时表时并不会为它分配事务id。</span><br></pre></td></tr></table></figure></li><li><p>对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个<code>事务id</code>，否则的话也是不分配<code>事务id</code>的。</p><p>  &amp;emsp;&amp;emsp;有的时候虽然我们开启了一个读写事务，但是在这个事务中全是查询语句，并没有执行增、删、改的语句，那也就意味着这个事务并不会被分配一个<code>事务id</code>。</p></li></ul><p>&amp;emsp;&amp;emsp;说了半天，<code>事务id</code>有什么子用？这个先保密，后边会一步步的详细介绍。现在只要知道只有在事务对表中的记录做改动时才会为这个事务分配一个唯一的<code>事务id</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：上面描述的事务id分配策略是针对MySQL 5.7来说的，前面的版本的分配方式可能不同～</span><br></pre></td></tr></table></figure><h3 id="事务id是怎么生成的"><a href="#事务id是怎么生成的" class="headerlink" title="事务id是怎么生成的"></a>事务id是怎么生成的</h3><p>&amp;emsp;&amp;emsp;这个<code>事务id</code>本质上就是一个数字，它的分配策略和我们前面提到的对隐藏列<code>row_id</code>（当用户没有为表创建主键和<code>UNIQUE</code>键时<code>InnoDB</code>自动创建的列）的分配策略大抵相同，具体策略如下：</p><ul><li>服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个<code>事务id</code>时，就会把该变量的值当作<code>事务id</code>分配给该事务，并且把该变量自增1。</li><li>每当这个变量的值为<code>256</code>的倍数时，就会将该变量的值刷新到系统表空间的页号为<code>5</code>的页面中一个称之为<code>Max Trx ID</code>的属性处，这个属性占用<code>8</code>个字节的存储空间。</li><li>当系统下一次重新启动时，会将上面提到的<code>Max Trx ID</code>属性加载到内存中，将该值加上256之后赋值给我们前面提到的全局变量（因为在上次关机时该全局变量的值可能大于<code>Max Trx ID</code>属性值）。</li></ul><p>&amp;emsp;&amp;emsp;这样就可以保证整个系统中分配的<code>事务id</code>值是一个递增的数字。先被分配<code>id</code>的事务得到的是较小的<code>事务id</code>，后被分配<code>id</code>的事务得到的是较大的<code>事务id</code>。</p><h3 id="trx-id隐藏列"><a href="#trx-id隐藏列" class="headerlink" title="trx_id隐藏列"></a>trx_id隐藏列</h3><p>&amp;emsp;&amp;emsp;我们前面介绍<code>InnoDB</code>记录行格式的时候重点强调过：<span style="color:red">聚簇索引的记录除了会保存完整的用户数据以外，而且还会自动添加名为trx_id、roll_pointer的隐藏列，如果用户没有在表中定义主键以及UNIQUE键，还会自动添加一个名为row_id的隐藏列</span>。所以一条记录在页面中的真实结构看起来就是这样的：</p><p><img src="/../images/22-01.png"></p><p>&amp;emsp;&amp;emsp;其中的<code>trx_id</code>列其实还蛮好理解的，就是某个对这个聚簇索引记录做改动的语句所在的事务对应的<code>事务id</code>而已（此处的改动可以是<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>操作）。至于<code>roll_pointer</code>隐藏列我们后边分析～</p><h2 id="undo日志的格式"><a href="#undo日志的格式" class="headerlink" title="undo日志的格式"></a>undo日志的格式</h2><p>&amp;emsp;&amp;emsp;为了实现事务的<code>原子性</code>，<code>InnoDB</code>存储引擎在实际进行增、删、改一条记录时，都需要<span style="color:red">先</span>把对应的<code>undo日志</code>记下来。一般每对一条记录做一次改动，就对应着一条<code>undo日志</code>，但在某些更新记录的操作中，也可能会对应着2条<code>undo日志</code>，这个我们后边会仔细介绍。一个事务在执行过程中可能新增、删除、更新若干条记录，也就是说需要记录很多条对应的<code>undo日志</code>，这些<code>undo日志</code>会被从<code>0</code>开始编号，也就是说根据生成的顺序分别被称为<code>第0号undo日志</code>、<code>第1号undo日志</code>、…、<code>第n号undo日志</code>等，这个编号也被称之为<code>undo no</code>。</p><p>&amp;emsp;&amp;emsp;这些<code>undo日志</code>是被记录到类型为<code>FIL_PAGE_UNDO_LOG</code>（对应的十六进制是<code>0x0002</code>，忘记了页面类型是什么的同学需要回过头再看看前面的章节）的页面中。这些页面可以从系统表空间中分配，也可以从一种专门存放<code>undo日志</code>的表空间，也就是所谓的<code>undo tablespace</code>中分配。不过关于如何分配存储<code>undo日志</code>的页面这个事情我们稍后再说，现在先来看看不同操作都会产生什么样子的<code>undo日志</code>吧～ 为了故事的顺利发展，我们先来创建一个名为<code>undo_demo</code>的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE undo_demo (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    col VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1)</span><br><span class="line">)Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个表中有3个列，其中<code>id</code>列是主键，我们为<code>key1</code>列建立了一个二级索引，<code>col</code>列是一个普通的列。我们前面介绍<code>InnoDB</code>的数据字典时说过，每个表都会被分配一个唯一的<code>table id</code>，我们可以通过系统数据库<code>information_schema</code>中的<code>innodb_sys_tables</code>表来查看某个表对应的<code>table id</code>是什么，现在我们查看一下<code>undo_demo</code>对应的<code>table id</code>是多少：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#x27;xiaohaizi/undo_demo&#x27;;</span><br><span class="line">+----------+---------------------+------+--------+-------+-------------+------------+---------------+------------+</span><br><span class="line">| TABLE_ID | NAME                | FLAG | N_COLS | SPACE | FILE_FORMAT | ROW_FORMAT | ZIP_PAGE_SIZE | SPACE_TYPE |</span><br><span class="line">+----------+---------------------+------+--------+-------+-------------+------------+---------------+------------+</span><br><span class="line">|      138 | xiaohaizi/undo_demo |   33 |      6 |   482 | Barracuda   | Dynamic    |             0 | Single     |</span><br><span class="line">+----------+---------------------+------+--------+-------+-------------+------------+---------------+------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;从查询结果可以看出，<code>undo_demo</code>表对应的<code>table id</code>为<code>138</code>，先把这个值记住，我们后边有用。</p><h3 id="INSERT操作对应的undo日志"><a href="#INSERT操作对应的undo日志" class="headerlink" title="INSERT操作对应的undo日志"></a>INSERT操作对应的undo日志</h3><p>&amp;emsp;&amp;emsp;我们前面说过，当我们向表中插入一条记录时会有<code>乐观插入</code>和<code>悲观插入</code>的区分，但是不管怎么插入，最终导致的结果就是这条记录被放到了一个数据页中。如果希望回滚这个插入操作，那么把这条记录删除就好了，也就是说在写对应的<code>undo</code>日志时，主要是把这条记录的主键信息记上。所以设计<code>InnoDB</code>的大佬设计了一个类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>，它的完整结构如下图所示：</p><p><img src="/../images/22-02.png"></p><p>根据示意图我们强调几点：</p><ul><li><code>undo no</code>在一个事务中是从<code>0</code>开始递增的，也就是说只要事务没提交，每生成一条<code>undo日志</code>，那么该条日志的<code>undo no</code>就增1。</li><li>如果记录中的主键只包含一个列，那么在类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>中只需要把该列占用的存储空间大小和真实值记录下来，如果记录中的主键包含多个列，那么每个列占用的存储空间大小和对应的真实值都需要记录下来（图中的<code>len</code>就代表列占用的存储空间大小，<code>value</code>就代表列的真实值）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：当我们向某个表中插入一条记录时，实际上需要向聚簇索引和所有的二级索引都插入一条记录。不过记录undo日志时，我们只需要考虑向聚簇索引插入记录时的情况就好了，因为其实聚簇索引记录和二级索引记录是一一对应的，我们在回滚插入操作时，只需要知道这条记录的主键信息，然后根据主键信息做对应的删除操作，做删除操作时就会顺带着把所有二级索引中相应的记录也删除掉。后边说到的DELETE操作和UPDATE操作对应的undo日志也都是针对聚簇索引记录而言的，我们之后就不强调了。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;现在我们向<code>undo_demo</code>中插入两条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;  # 显式开启一个事务，假设该事务的id为100</span><br><span class="line"></span><br><span class="line"># 插入两条记录</span><br><span class="line">INSERT INTO undo_demo(id, key1, col) </span><br><span class="line">    VALUES (1, &#x27;AWM&#x27;, &#x27;狙击枪&#x27;), (2, &#x27;M416&#x27;, &#x27;步枪&#x27;);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;因为记录的主键只包含一个<code>id</code>列，所以我们在对应的<code>undo日志</code>中只需要将待插入记录的<code>id</code>列占用的存储空间长度（<code>id</code>列的类型为<code>INT</code>，<code>INT</code>类型占用的存储空间长度为<code>4</code>个字节）和真实值记录下来。本例中插入了两条记录，所以会产生两条类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>:</p><ul><li><p>第一条<code>undo日志</code>的<code>undo no</code>为<code>0</code>，记录主键占用的存储空间长度为<code>4</code>，真实值为<code>1</code>。画一个示意图就是这样：</p><p>  <img src="/../images/22-03.png"></p></li><li><p>第二条<code>undo日志</code>的<code>undo no</code>为<code>1</code>，记录主键占用的存储空间长度为<code>4</code>，真实值为<code>2</code>。画一个示意图就是这样（与第一条<code>undo日志</code>对比，<code>undo no</code>和主键各列信息有不同）：</p><p>  <img src="/../images/22-04.png"></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：为了最大限度的节省undo日志占用的存储空间，和我们前面说过的redo日志类似，设计InnoDB的大佬会给undo日志中的某些属性进行压缩处理，具体的压缩细节我们就不介绍了。</span><br></pre></td></tr></table></figure><h4 id="roll-pointer隐藏列的含义"><a href="#roll-pointer隐藏列的含义" class="headerlink" title="roll_pointer隐藏列的含义"></a>roll_pointer隐藏列的含义</h4><p>&amp;emsp;&amp;emsp;是时候揭开<code>roll_pointer</code>的真实面纱了，这个占用<code>7</code>个字节的字段其实一点都不神秘，本质上就是一个指向记录对应的<code>undo日志</code>的一个指针。比方说我们上面向<code>undo_demo</code>表里插入了2条记录，每条记录都有与其对应的一条<code>undo日志</code>。记录被存储到了类型为<code>FIL_PAGE_INDEX</code>的页面中（就是我们前面一直所说的<code>数据页</code>），<code>undo日志</code>被存放到了类型为<code>FIL_PAGE_UNDO_LOG</code>的页面中。效果如图所示：</p><p><img src="/../images/22-05.png"></p><p>&amp;emsp;&amp;emsp;从图中也可以更直观的看出来，<code>roll_pointer</code><span style="color:red">本质就是一个指针，指向记录对应的undo日志</span>。不过这<code>7</code>个字节的<code>roll_pointer</code>的每一个字节具体的含义我们后边介绍完如何分配存储<code>undo</code>日志的页面之后再具体说～</p><h3 id="DELETE操作对应的undo日志"><a href="#DELETE操作对应的undo日志" class="headerlink" title="DELETE操作对应的undo日志"></a>DELETE操作对应的undo日志</h3><p>&amp;emsp;&amp;emsp;我们知道插入到页面中的记录会根据记录头信息中的<code>next_record</code>属性组成一个单向链表，我们把这个链表称之为<code>正常记录链表</code>；我们在前面介绍数据页结构的时候说过，被删除的记录其实也会根据记录头信息中的<code>next_record</code>属性组成一个链表，只不过这个链表中的记录占用的存储空间可以被重新利用，所以也称这个链表为<code>垃圾链表</code>。<code>Page Header</code>部分有一个称之为<code>PAGE_FREE</code>的属性，它指向由被删除记录组成的垃圾链表中的头节点。为了故事的顺利发展，我们先画一个图，假设此刻某个页面中的记录分布情况是这样的（这个不是<code>undo_demo</code>表中的记录，只是我们随便举的一个例子）：</p><p><img src="/../images/22-06.png"></p><p>&amp;emsp;&amp;emsp;为了突出主题，在这个简化版的示意图中，我们只把记录的<code>delete_mask</code>标志位展示了出来。从图中可以看出，<code>正常记录链表</code>中包含了3条正常记录，<code>垃圾链表</code>里包含了2条已删除记录，在<code>垃圾链表</code>中的这些记录占用的存储空间可以被重新利用。页面的<code>Page Header</code>部分的<code>PAGE_FREE</code>属性的值代表指向<code>垃圾链表</code>头节点的指针。假设现在我们准备使用<code>DELETE</code>语句把<code>正常记录链表</code>中的最后一条记录给删除掉，其实这个删除的过程需要经历两个阶段：</p><ul><li><p>阶段一：仅仅将记录的<code>delete_mask</code>标识位设置为<code>1</code>，其他的不做修改（其实会修改记录的<code>trx_id</code>、<code>roll_pointer</code>这些隐藏列的值）。设计<code>InnoDB</code>的大佬把这个阶段称之为<code>delete mark</code>。</p><p>  &amp;emsp;&amp;emsp;把这个过程画下来就是这样：</p><p>  <img src="/../images/22-07.png"></p><p>  &amp;emsp;&amp;emsp;可以看到，<code>正常记录链表</code>中的最后一条记录的<code>delete_mask</code>值被设置为<code>1</code>，但是并没有被加入到<code>垃圾链表</code>。也就是此时记录处于一个<code>中间状态</code>，跟猪八戒照镜子——里外不是人似的。在删除语句所在的事务提交之前，被删除的记录一直都处于这种所谓的<code>中间状态</code>。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：为什么会有这种奇怪的中间状态呢？其实主要是为了实现一个称之为MVCC的功能，稍后再介绍。</span><br></pre></td></tr></table></figure></li><li><p>阶段二：<span style="color:red">当该删除语句所在的事务提交之后</span>，会有<span style="color:red">专门的线程后</span>来真正的把记录删除掉。所谓真正的删除就是把该记录从<code>正常记录链表</code>中移除，并且加入到<code>垃圾链表</code>中，然后还要调整一些页面的其他信息，比如页面中的用户记录数量<code>PAGE_N_RECS</code>、上次插入记录的位置<code>PAGE_LAST_INSERT</code>、垃圾链表头节点的指针<code>PAGE_FREE</code>、页面中可重用的字节数量<code>PAGE_GARBAGE</code>、还有页目录的一些信息等等。设计<code>InnoDB</code>的大佬把这个阶段称之为<code>purge</code>。</p><p>  &amp;emsp;&amp;emsp;把<code>阶段二</code>执行完了，这条记录就算是真正的被删除掉了。这条已删除记录占用的存储空间也可以被重新利用了。画下来就是这样：</p><p>  <img src="/../images/22-08.png"></p><p>  &amp;emsp;&amp;emsp;对照着图我们还要注意一点，将被删除记录加入到<code>垃圾链表</code>时，实际上加入到链表的头节点处，会跟着修改<code>PAGE_FREE</code>属性的值。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：页面的Page Header部分有一个PAGE_GARBAGE属性，该属性记录着当前页面中可重用存储空间占用的总字节数。每当有已删除记录被加入到垃圾链表后，都会把这个PAGE_GARBAGE属性的值加上该已删除记录占用的存储空间大小。PAGE_FREE指向垃圾链表的头节点，之后每当新插入记录时，首先判断PAGE_FREE指向的头节点代表的已删除记录占用的存储空间是否足够容纳这条新插入的记录，如果不可以容纳，就直接向页面中申请新的空间来存储这条记录（是的，你没看错，并不会尝试遍历整个垃圾链表，找到一个可以容纳新记录的节点）。如果可以容纳，那么直接重用这条已删除记录的存储空间，并且把PAGE_FREE指向垃圾链表中的下一条已删除记录。但是这里有一个问题，如果新插入的那条记录占用的存储空间大小小于垃圾链表的头节点占用的存储空间大小，那就意味头节点对应的记录占用的存储空间里有一部分空间用不到，这部分空间就被称之为碎片空间。那这些碎片空间岂不是永远都用不到了么？其实也不是，这些碎片空间占用的存储空间大小会被统计到PAGE_GARBAGE属性中，这些碎片空间在整个页面快使用完前并不会被重新利用，不过当页面快满时，如果再插入一条记录，此时页面中并不能分配一条完整记录的空间，这时候会首先看一看PAGE_GARBAGE的空间和剩余可利用的空间加起来是不是可以容纳下这条记录，如果可以的话，InnoDB会尝试重新组织页内的记录，重新组织的过程就是先开辟一个临时页面，把页面内的记录依次插入一遍，因为依次插入时并不会产生碎片，之后再把临时页面的内容复制到本页面，这样就可以把那些碎片空间都解放出来（很显然重新组织页面内的记录比较耗费性能）。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;从上面的描述中我们也可以看出来，在删除语句所在的事务提交之前，只会经历<code>阶段一</code>，也就是<code>delete mark</code>阶段（提交之后我们就不用回滚了，所以只需考虑对删除操作的<code>阶段一</code>做的影响进行回滚）。设计<code>InnoDB</code>的大佬为此设计了一种称之为<code>TRX_UNDO_DEL_MARK_REC</code>类型的<code>undo日志</code>，它的完整结构如下图所示：</p><p><img src="/../images/22-09.png"></p><p>&amp;emsp;&amp;emsp;这个里边的属性也太多了点儿吧～（其实大部分属性的意思我们上面已经介绍过了） 是的，的确有点多，不过大家千万不要在意，如果记不住千万不要勉强自己，我这里把它们都列出来让大家混个脸熟而已。劳烦大家先克服一下密集恐急症，再抬头大致看一遍上面的这个类型为<code>TRX_UNDO_DEL_MARK_REC</code>的<code>undo日志</code>中的属性，特别注意一下这几点：</p><ul><li><p>在对一条记录进行<code>delete mark</code>操作前，需要把该记录的旧的<code>trx_id</code>和<code>roll_pointer</code>隐藏列的值都给记到对应的<code>undo日志</code>中来，就是我们图中显示的<code>old trx_id</code>和<code>old roll_pointer</code>属性。这样有一个好处，那就是可以通过<code>undo日志</code>的<code>old roll_pointer</code>找到记录在修改之前对应的<code>undo</code>日志。比方说在一个事务中，我们先插入了一条记录，然后又执行对该记录的删除操作，这个过程的示意图就是这样：</p><p>  <img src="/../images/22-10.png"></p><p>  &amp;emsp;&amp;emsp;从图中可以看出来，执行完<code>delete mark</code>操作后，它对应的<code>undo</code>日志和<code>INSERT</code>操作对应的<code>undo</code>日志就串成了一个链表。这个很有意思啊，这个链表就称之为<code>版本链</code>，现在貌似看不出这个<code>版本链</code>有什么用，等我们再往后看看，讲完<code>UPDATE</code>操作对应的<code>undo</code>日志后，这个所谓的<code>版本链</code>就慢慢的展现出它的牛逼之处了。</p></li><li><p>与类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>不同，类型为<code>TRX_UNDO_DEL_MARK_REC</code>的<code>undo</code>日志还多了一个<code>索引列各列信息</code>的内容，也就是说如果某个列被包含在某个索引中，那么它的相关信息就应该被记录到这个<code>索引列各列信息</code>部分，所谓的相关信息包括该列在记录中的位置（用<code>pos</code>表示），该列占用的存储空间大小（用<code>len</code>表示），该列实际值（用<code>value</code>表示）。所以<code>索引列各列信息</code>存储的内容实质上就是<code>&lt;pos, len, value&gt;</code>的一个列表。这部分信息主要是用在事务提交后，对该<code>中间状态记录</code>做真正删除的阶段二，也就是<code>purge</code>阶段中使用的，具体如何使用现在我们可以忽略～</p></li></ul><p>&amp;emsp;&amp;emsp;该介绍的我们介绍完了，现在继续在上面那个事务id为<code>100</code>的事务中删除一条记录，比如我们把<code>id</code>为1的那条记录删除掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;  # 显式开启一个事务，假设该事务的id为100</span><br><span class="line"></span><br><span class="line"># 插入两条记录</span><br><span class="line">INSERT INTO undo_demo(id, key1, col) </span><br><span class="line">    VALUES (1, &#x27;AWM&#x27;, &#x27;狙击枪&#x27;), (2, &#x27;M416&#x27;, &#x27;步枪&#x27;);</span><br><span class="line">    </span><br><span class="line"># 删除一条记录    </span><br><span class="line">DELETE FROM undo_demo WHERE id = 1; </span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个<code>delete mark</code>操作对应的<code>undo日志</code>的结构就是这样：</p><p><img src="/../images/22-11.png"></p><p>&amp;emsp;&amp;emsp;对照着这个图，我们得注意下面几点：</p><ul><li><p>因为这条<code>undo</code>日志是<code>id</code>为<code>100</code>的事务中产生的第3条<code>undo</code>日志，所以它对应的<code>undo no</code>就是<code>2</code>。</p></li><li><p>在对记录做<code>delete mark</code>操作时，记录的<code>trx_id</code>隐藏列的值是<code>100</code>（也就是说对该记录最近的一次修改就发生在本事务中），所以把<code>100</code>填入<code>old trx_id</code>属性中。然后把记录的<code>roll_pointer</code>隐藏列的值取出来，填入<code>old roll_pointer</code>属性中，这样就可以通过<code>old roll_pointer</code>属性值找到最近一次对该记录做改动时产生的<code>undo日志</code>。</p></li><li><p>由于<code>undo_demo</code>表中有2个索引：一个是聚簇索引，一个是二级索引<code>idx_key1</code>。只要是包含在索引中的列，那么这个列在记录中的位置（<code>pos</code>），占用存储空间大小（<code>len</code>）和实际值（<code>value</code>）就需要存储到<code>undo日志</code>中。</p><ul><li><p>对于主键来说，只包含一个<code>id</code>列，存储到<code>undo日志</code>中的相关信息分别是：</p><ul><li><code>pos</code>：<code>id</code>列是主键，也就是在记录的第一个列，它对应的<code>pos</code>值为<code>0</code>。<code>pos</code>占用1个字节来存储。</li><li><code>len</code>：<code>id</code>列的类型为<code>INT</code>，占用4个字节，所以<code>len</code>的值为<code>4</code>。<code>len</code>占用1个字节来存储。</li><li><code>value</code>：在被删除的记录中<code>id</code>列的值为<code>1</code>，也就是<code>value</code>的值为<code>1</code>。<code>value</code>占用4个字节来存储。</li></ul><p>  &amp;emsp;&amp;emsp;画一个图演示一下就是这样：</p><p>  <img src="/../images/22-12.png"></p><p>  &amp;emsp;&amp;emsp;所以对于<code>id</code>列来说，最终存储的结果就是<code>&lt;0, 4, 1&gt;</code>，存储这些信息占用的存储空间大小为<code>1 + 1 + 4 = 6</code>个字节。</p></li><li><p>对于<code>idx_key1</code>来说，只包含一个<code>key1</code>列，存储到<code>undo日志</code>中的相关信息分别是：</p><ul><li><code>pos</code>：<code>key1</code>列是排在<code>id</code>列、<code>trx_id</code>列、<code>roll_pointer</code>列之后的，它对应的<code>pos</code>值为<code>3</code>。<code>pos</code>占用1个字节来存储。</li><li><code>len</code>：<code>key1</code>列的类型为<code>VARCHAR(100)</code>，使用<code>utf8</code>字符集，被删除的记录实际存储的内容是<code>AWM</code>，所以一共占用3个字节，也就是所以<code>len</code>的值为<code>3</code>。<code>len</code>占用1个字节来存储。</li><li><code>value</code>：在被删除的记录中<code>key1</code>列的值为<code>AWM</code>，也就是<code>value</code>的值为<code>AWM</code>。<code>value</code>占用3个字节来存储。</li></ul><p> &amp;emsp;&amp;emsp;画一个图演示一下就是这样：</p><p> <img src="/../images/22-13.png"></p><p> &amp;emsp;&amp;emsp;所以对于<code>key1</code>列来说，最终存储的结果就是<code>&lt;3, 3, &#39;AWM&#39;&gt;</code>，存储这些信息占用的存储空间大小为<code>1 + 1 + 3 = 5</code>个字节。</p></li></ul><p>  &amp;emsp;&amp;emsp;从上面的叙述中可以看到，<code>&lt;0, 4, 1&gt;</code>和<code>&lt;3, 3, &#39;AWM&#39;&gt;</code>共占用<code>11</code>个字节。然后<code>index_col_info len</code>本身占用<code>2</code>个字节，所以加起来一共占用<code>13</code>个字节，把数字<code>13</code>就填到了<code>index_col_info len</code>的属性中。</p></li></ul><h3 id="UPDATE操作对应的undo日志"><a href="#UPDATE操作对应的undo日志" class="headerlink" title="UPDATE操作对应的undo日志"></a>UPDATE操作对应的undo日志</h3><p>&amp;emsp;&amp;emsp;在执行<code>UPDATE</code>语句时，<code>InnoDB</code>对更新主键和不更新主键这两种情况有截然不同的处理方案。</p><h4 id="不更新主键的情况"><a href="#不更新主键的情况" class="headerlink" title="不更新主键的情况"></a>不更新主键的情况</h4><p>&amp;emsp;&amp;emsp;在不更新主键的情况下，又可以细分为被更新的列占用的存储空间不发生变化和发生变化的情况。</p><ul><li><p>就地更新（in-place update）</p><p>  &amp;emsp;&amp;emsp;更新记录时，对于被更新的<span style="color:red">每个列</span>来说，如果更新后的列和更新前的列占用的存储空间都一样大，那么就可以进行<code>就地更新</code>，也就是直接在原记录的基础上修改对应列的值。再次强调一边，是<span style="color:red">每个列</span>在更新前后占用的存储空间一样大，有任何一个被更新的列更新前比更新后占用的存储空间大，或者更新前比更新后占用的存储空间小都不能进行<code>就地更新</code>。比方说现在<code>undo_demo</code>表里还有一条<code>id</code>值为<code>2</code>的记录，它的各个列占用的大小如图所示（因为采用<code>utf8</code>字符集，所以<code>&#39;步枪&#39;</code>这两个字符占用6个字节）：</p><p>  <img src="/../images/22-14.png">        </p><p>  &amp;emsp;&amp;emsp;假如我们有这样的<code>UPDATE</code>语句：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE undo_demo </span><br><span class="line">    SET key1 = &#x27;P92&#x27;, col = &#x27;手枪&#x27; </span><br><span class="line">    WHERE id = 2;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;在这个<code>UPDATE</code>语句中，<code>col</code>列从<code>步枪</code>被更新为<code>手枪</code>，前后都占用6个字节，也就是占用的存储空间大小未改变；<code>key1</code>列从<code>M416</code>被更新为<code>P92</code>，也就是从<code>4</code>个字节被更新为<code>3</code>个字节，这就不满足<code>就地更新</code>需要的条件了，所以不能进行<code>就地更新</code>。但是如果<code>UPDATE</code>语句长这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE undo_demo </span><br><span class="line">    SET key1 = &#x27;M249&#x27;, col = &#x27;机枪&#x27; </span><br><span class="line">    WHERE id = 2;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;由于各个被更新的列在更新前后占用的存储空间是一样大的，所以这样的语句可以执行<code>就地更新</code>。</p></li><li><p>先删除掉旧记录，再插入新记录</p><p>  &amp;emsp;&amp;emsp;在不更新主键的情况下，如果有<span style="color:red">任何一个</span>被更新的列更新前和更新后占用的存储空间大小不一致，那么就需要先把这条旧的记录从聚簇索引页面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面中。</p><p>  &amp;emsp;&amp;emsp;请注意一下，我们这里所说的<code>删除</code>并不是<code>delete mark</code>操作，而是真正的删除掉，也就是把这条记录从<code>正常记录链表</code>中移除并加入到<code>垃圾链表</code>中，并且修改页面中相应的统计信息（比如<code>PAGE_FREE</code>、<code>PAGE_GARBAGE</code>等这些信息）。不过这里做真正删除操作的线程并不是在介绍<code>DELETE</code>语句中做<code>purge</code>操作时使用的另外专门的线程，而是由用户线程同步执行真正的删除操作，真正删除之后紧接着就要根据各个列更新后的值创建的新记录插入。</p><p>  &amp;emsp;&amp;emsp;这里如果新创建的记录占用的存储空间大小不超过旧记录占用的空间，那么可以直接重用被加入到<code>垃圾链表</code>中的旧记录所占用的存储空间，否则的话需要在页面中新申请一段空间以供新记录使用，如果本页面内已经没有可用的空间的话，那就需要进行页面分裂操作，然后再插入新记录。</p></li></ul><p>&amp;emsp;&amp;emsp;针对<code>UPDATE</code>不更新主键的情况（包括上面所说的就地更新和先删除旧记录再插入新记录），设计<code>InnoDB</code>的大佬们设计了一种类型为<code>TRX_UNDO_UPD_EXIST_REC</code>的<code>undo日志</code>，它的完整结构如下：</p><p><img src="/../images/22-15.png"></p><p>&amp;emsp;&amp;emsp;其实大部分属性和我们介绍过的<code>TRX_UNDO_DEL_MARK_REC</code>类型的<code>undo日志</code>是类似的，不过还是要注意这么几点：</p><ul><li><p><code>n_updated</code>属性表示本条<code>UPDATE</code>语句执行后将有几个列被更新，后边跟着的<code>&lt;pos, old_len, old_value&gt;</code>分别表示被更新列在记录中的位置、更新前该列占用的存储空间大小、更新前该列的真实值。</p></li><li><p>如果在<code>UPDATE</code>语句中更新的列包含索引列，那么也会添加<code>索引列各列信息</code>这个部分，否则的话是不会添加这个部分的。</p></li></ul><p>&amp;emsp;&amp;emsp;现在继续在上面那个事务id为100的事务中更新一条记录，比如我们把id为2的那条记录更新一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;  # 显式开启一个事务，假设该事务的id为100</span><br><span class="line"></span><br><span class="line"># 插入两条记录</span><br><span class="line">INSERT INTO undo_demo(id, key1, col) </span><br><span class="line">    VALUES (1, &#x27;AWM&#x27;, &#x27;狙击枪&#x27;), (2, &#x27;M416&#x27;, &#x27;步枪&#x27;);</span><br><span class="line">    </span><br><span class="line"># 删除一条记录    </span><br><span class="line">DELETE FROM undo_demo WHERE id = 1; </span><br><span class="line"></span><br><span class="line"># 更新一条记录</span><br><span class="line">UPDATE undo_demo</span><br><span class="line">    SET key1 = &#x27;M249&#x27;, col = &#x27;机枪&#x27;</span><br><span class="line">    WHERE id = 2;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个<code>UPDATE</code>语句更新的列大小都没有改动，所以可以采用<code>就地更新</code>的方式来执行，在真正改动页面记录时，会先记录一条类型为<code>TRX_UNDO_UPD_EXIST_REC</code>的<code>undo日志</code>，长这样：</p><p><img src="/../images/22-16.png"></p><p>&amp;emsp;&amp;emsp;对照着这个图我们注意一下这几个地方：</p><ul><li>因为这条<code>undo日志</code>是<code>id</code>为<code>100</code>的事务中产生的第4条<code>undo日志</code>，所以它对应的<code>undo no</code>就是3。</li><li>这条日志的<code>roll_pointer</code>指向<code>undo no</code>为<code>1</code>的那条日志，也就是插入主键值为<code>2</code>的记录时产生的那条<code>undo日志</code>，也就是最近一次对该记录做改动时产生的<code>undo日志</code>。</li><li>由于本条<code>UPDATE</code>语句中更新了索引列<code>key1</code>的值，所以需要记录一下<code>索引列各列信息</code>部分，也就是把主键和<code>key1</code>列更新前的信息填入。</li></ul><h4 id="更新主键的情况"><a href="#更新主键的情况" class="headerlink" title="更新主键的情况"></a>更新主键的情况</h4><p>&amp;emsp;&amp;emsp;在聚簇索引中，记录是按照主键值的大小连成了一个单向链表的，如果我们更新了某条记录的主键值，意味着这条记录在聚簇索引中的位置将会发生改变，比如你将记录的主键值从1更新为10000，如果还有非常多的记录的主键值分布在<code>1 ~ 10000</code>之间的话，那么这两条记录在聚簇索引中就有可能离得非常远，甚至中间隔了好多个页面。针对<code>UPDATE</code>语句中更新了记录主键值的这种情况，<code>InnoDB</code>在聚簇索引中分了两步处理：</p><ul><li><p>将旧记录进行<code>delete mark</code>操作</p><p>  &amp;emsp;&amp;emsp;高能注意：<span style="color:red">这里是delete mark操作！这里是delete mark操作！这里是delete mark操作！</span>也就是说在<code>UPDATE</code>语句所在的事务提交前，对旧记录只做一个<code>delete mark</code>操作，在事务提交后才由<span style="color:red">专门的线程做purge操作，把它加入到垃圾链表中</span>。这里一定要和我们上面所说的在不更新记录主键值时，先真正删除旧记录，再插入新记录的方式区分开！</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：之所以只对旧记录做delete mark操作，是因为别的事务同时也可能访问这条记录，如果把它真正的删除加入到垃圾链表后，别的事务就访问不到了。这个功能就是所谓的MVCC，我们后边的章节中会详细介绍什么是个MVCC。</span><br></pre></td></tr></table></figure></li><li><p>根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重新定位插入的位置）。</p><p>  &amp;emsp;&amp;emsp;由于更新后的记录主键值发生了改变，所以需要重新从聚簇索引中定位这条记录所在的位置，然后把它插进去。</p></li></ul><p>针对<code>UPDATE</code>语句更新记录主键值的这种情况，在对该记录进行<code>delete mark</code>操作前，会记录一条类型为<code>TRX_UNDO_DEL_MARK_REC</code>的<code>undo日志</code>；之后插入新记录时，会记录一条类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>，也就是说每对一条记录的主键值做改动时，会记录2条<code>undo日志</code>。这些日志的格式我们上面都介绍过了，就不赘述了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：其实还有一种称为TRX_UNDO_UPD_DEL_REC的undo日志的类型我们没有介绍，主要是想避免引入过多的复杂度，如果大家对这种类型的undo日志的使用感兴趣的话，可以额外查一下别的资料。</span><br></pre></td></tr></table></figure><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/23-%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2022/10/31/model-mysql/mysql/23-%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="第23章-后悔了怎么办-undo日志（下）"><a href="#第23章-后悔了怎么办-undo日志（下）" class="headerlink" title="第23章 后悔了怎么办-undo日志（下）"></a>第23章 后悔了怎么办-undo日志（下）</h1><p>&amp;emsp;&amp;emsp;上一章我们主要介绍了为什么需要<code>undo日志</code>，以及<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>这些会对数据做改动的语句都会产生什么类型的<code>undo日志</code>，还有不同类型的<code>undo日志</code>的具体格式是什么。本章会继续介绍这些<code>undo日志</code>会被具体写到什么地方，以及在写入过程中需要注意的一些问题。</p><h2 id="通用链表结构"><a href="#通用链表结构" class="headerlink" title="通用链表结构"></a>通用链表结构</h2><p>&amp;emsp;&amp;emsp;在写入<code>undo日志</code>的过程中会使用到多个链表，很多链表都有同样的节点结构，如图所示：</p><p><img src="/../images/23-01.png"></p><p>&amp;emsp;&amp;emsp;在某个表空间内，我们可以通过一个页的页号和在页内的偏移量来唯一定位一个节点的位置，这两个信息也就相当于指向这个节点的一个指针。所以：</p><ul><li><code>Pre Node Page Number</code>和<code>Pre Node Offset</code>的组合就是指向前一个节点的指针</li><li><code>Next Node Page Number</code>和<code>Next Node Offset</code>的组合就是指向后一个节点的指针。</li></ul><p>&amp;emsp;&amp;emsp;整个<code>List Node</code>占用<code>12</code>个字节的存储空间。</p><p>&amp;emsp;&amp;emsp;为了更好的管理链表，设计<code>InnoDB</code>的大佬还提出了一个基节点的结构，里边存储了这个链表的<code>头节点</code>、<code>尾节点</code>以及链表长度信息，基节点的结构示意图如下：</p><p><img src="/../images/23-02.png"></p><p>其中：</p><ul><li><code>List Length</code>表明该链表一共有多少节点。</li><li><code>First Node Page Number</code>和<code>First Node Offset</code>的组合就是指向链表头节点的指针。</li><li><code>Last Node Page Number</code>和<code>Last Node Offset</code>的组合就是指向链表尾节点的指针。</li></ul><p>&amp;emsp;&amp;emsp;整个<code>List Base Node</code>占用<code>16</code>个字节的存储空间。</p><p>&amp;emsp;&amp;emsp;所以使用<code>List Base Node</code>和<code>List Node</code>这两个结构组成的链表的示意图就是这样：</p><p><img src="/../images/23-03.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：上述链表结构我们在前面的文章中频频提到，尤其是在表空间那一章重点描述过，不过我不敢奢求大家都记住了，所以在这里又强调一遍，希望大家不要嫌我烦，我只是怕大家忘了学习后续内容吃力而已～</span><br></pre></td></tr></table></figure><h2 id="FIL-PAGE-UNDO-LOG页面"><a href="#FIL-PAGE-UNDO-LOG页面" class="headerlink" title="FIL_PAGE_UNDO_LOG页面"></a>FIL_PAGE_UNDO_LOG页面</h2><p>&amp;emsp;&amp;emsp;我们前面介绍表空间的时候说过，表空间其实是由许许多多的页面构成的，页面默认大小为<code>16KB</code>。这些页面有不同的类型，比如类型为<code>FIL_PAGE_INDEX</code>的页面用于存储聚簇索引以及二级索引，类型为<code>FIL_PAGE_TYPE_FSP_HDR</code>的页面用于存储表空间头部信息的，还有其他各种类型的页面，其中有一种称之为<code>FIL_PAGE_UNDO_LOG</code>类型的页面是专门用来存储<code>undo日志</code>的，这种类型的页面的通用结构如下图所示（以默认的<code>16KB</code>大小为例）：</p><p><img src="/../images/23-04.png"></p><p>&amp;emsp;&amp;emsp;“类型为<code>FIL_PAGE_UNDO_LOG</code>的页”这种说法太绕口，以后我们就简称为<code>Undo页面</code>了。上图中的<code>File Header</code>和<code>File Trailer</code>是各种页面都有的通用结构，我们前面介绍过很多遍了，这里就不赘述了（忘记了的可以到讲述数据页结构或者表空间的章节中查看）。<code>Undo Page Header</code>是<code>Undo页面</code>所特有的，我们来看一下它的结构：</p><p><img src="/../images/23-05.png"></p><p>&amp;emsp;&amp;emsp;其中各个属性的意思如下：</p><ul><li><p><code>TRX_UNDO_PAGE_TYPE</code>：本页面准备存储什么种类的<code>undo日志</code>。</p><p>  &amp;emsp;&amp;emsp;我们前面介绍了好几种类型的<code>undo日志</code>，它们可以被分为两个大类：</p><ul><li><code>TRX_UNDO_INSERT</code>（使用十进制<code>1</code>表示）：类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>属于此大类，一般由<code>INSERT</code>语句产生，或者在<code>UPDATE</code>语句中有更新主键的情况也会产生此类型的<code>undo日志</code>。</li><li><code>TRX_UNDO_UPDATE</code>（使用十进制<code>2</code>表示），除了类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>，其他类型的<code>undo日志</code>都属于这个大类，比如我们前面说的<code>TRX_UNDO_DEL_MARK_REC</code>、<code>TRX_UNDO_UPD_EXIST_REC</code>什么的，一般由<code>DELETE</code>、<code>UPDATE</code>语句产生的<code>undo日志</code>属于这个大类。</li></ul><p>  &amp;emsp;&amp;emsp;这个<code>TRX_UNDO_PAGE_TYPE</code>属性可选的值就是上面的两个，用来标记本页面用于存储哪个大类的<code>undo日志</code>，不同大类的<code>undo日志</code>不能混着存储，比如一个<code>Undo页面</code>的<code>TRX_UNDO_PAGE_TYPE</code>属性值为<code>TRX_UNDO_INSERT</code>，那么这个页面就只能存储类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>，其他类型的<code>undo日志</code>就不能放到这个页面中了。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：之所以把undo日志分成两个大类，是因为类型为TRX_UNDO_INSERT_REC的undo日志在事务提交后可以直接删除掉，而其他类型的undo日志还需要为所谓的MVCC服务，不能直接删除掉，对它们的处理需要区别对待。当然，如果你看这段话迷迷糊糊的话，那就不需要再看一遍了，现在只需要知道undo日志分为2个大类就好了，更详细的东西我们后边会仔细介绍的。</span><br></pre></td></tr></table></figure></li><li><p><code>TRX_UNDO_PAGE_START</code>：表示在当前页面中是从什么位置开始存储<code>undo日志</code>的，或者说表示第一条<code>undo日志</code>在本页面中的起始偏移量。</p></li><li><p><code>TRX_UNDO_PAGE_FREE</code>：与上面的<code>TRX_UNDO_PAGE_START</code>对应，表示当前页面中存储的最后一条<code>undo</code>日志结束时的偏移量，或者说从这个位置开始，可以继续写入新的<code>undo日志</code>。</p><p>  &amp;emsp;&amp;emsp;假设现在向页面中写入了3条<code>undo日志</code>，那么<code>TRX_UNDO_PAGE_START</code>和<code>TRX_UNDO_PAGE_FREE</code>的示意图就是这样：</p><p>  <img src="/../images/23-06.png"></p><p>  &amp;emsp;&amp;emsp;当然，在最初一条<code>undo日志</code>也没写入的情况下，<code>TRX_UNDO_PAGE_START</code>和<code>TRX_UNDO_PAGE_FREE</code>的值是相同的。</p></li><li><p><code>TRX_UNDO_PAGE_NODE</code>：代表一个<code>List Node</code>结构（链表的普通节点，我们上面刚说的）。</p><p>  &amp;emsp;&amp;emsp;下面马上用到这个属性，稍安勿躁。</p></li></ul><h2 id="Undo页面链表"><a href="#Undo页面链表" class="headerlink" title="Undo页面链表"></a>Undo页面链表</h2><h3 id="单个事务中的Undo页面链表"><a href="#单个事务中的Undo页面链表" class="headerlink" title="单个事务中的Undo页面链表"></a>单个事务中的Undo页面链表</h3><p>&amp;emsp;&amp;emsp;因为一个事务可能包含多个语句，而且一个语句可能对若干条记录进行改动，而对每条记录进行改动前，都需要记录1条或2条的<code>undo日志</code>，所以在一个事务执行过程中可能产生很多<code>undo日志</code>，这些日志可能一个页面放不下，需要放到多个页面中，这些页面就通过我们上面介绍的<code>TRX_UNDO_PAGE_NODE</code>属性连成了链表：</p><p><img src="/../images/23-07.png"></p><p>&amp;emsp;&amp;emsp;大家往上再瞅一瞅上面的图，我们特意把链表中的第一个<code>Undo页面</code>给标了出来，称它为<code>first undo page</code>，其余的<code>Undo页面</code>称之为<code>normal undo page</code>，这是因为在<code>first undo page</code>中除了记录<code>Undo Page Header</code>之外，还会记录其他的一些管理信息，这个我们稍后再说。</p><p>&amp;emsp;&amp;emsp;在一个事务执行过程中，可能混着执行<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句，也就意味着会产生不同类型的<code>undo日志</code>。但是我们前面又强调过，同一个<code>Undo页面</code>要么只存储<code>TRX_UNDO_INSERT</code>大类的<code>undo日志</code>，要么只存储<code>TRX_UNDO_UPDATE</code>大类的<code>undo日志</code>，反正不能混着存，所以在一个事务执行过程中就可能需要2个<code>Undo页面</code>的链表，一个称之为<code>insert undo链表</code>，另一个称之为<code>update undo链表</code>，画个示意图就是这样：</p><p><img src="/../images/23-08.png"></p><p>&amp;emsp;&amp;emsp;另外，设计<code>InnoDB</code>的大佬规定对普通表和临时表的记录改动时产生的<code>undo日志</code>要分别记录（我们稍后阐释为什么这么做），所以在一个事务中<span style="color:red">最多</span>有4个以<code>Undo页面</code>为节点组成的链表：</p><p><img src="/../images/23-09.png"></p><p>&amp;emsp;&amp;emsp;当然，并不是在事务一开始就会为这个事务分配这4个链表，具体分配策略如下：</p><ul><li>刚刚开启事务时，一个<code>Undo页面</code>链表也不分配。</li><li>当事务执行过程中向普通表中插入记录或者执行更新记录主键的操作之后，就会为其分配一个<code>普通表的insert undo链表</code>。</li><li>当事务执行过程中删除或者更新了普通表中的记录之后，就会为其分配一个<code>普通表的update undo链表</code>。</li><li>当事务执行过程中向临时表中插入记录或者执行更新记录主键的操作之后，就会为其分配一个<code>临时表的insert undo链表</code>。</li><li>当事务执行过程中删除或者更新了临时表中的记录之后，就会为其分配一个<code>临时表的update undo链表</code>。</li></ul><p>&amp;emsp;&amp;emsp;总结一句就是：<span style="color:red">按需分配，什么时候需要什么时候再分配，不需要就不分配</span>。</p><h3 id="多个事务中的Undo页面链表"><a href="#多个事务中的Undo页面链表" class="headerlink" title="多个事务中的Undo页面链表"></a>多个事务中的Undo页面链表</h3><p>&amp;emsp;&amp;emsp;为了尽可能提高<code>undo日志</code>的写入效率，<span style="color:red">不同事务执行过程中产生的undo日志需要被写入到不同的Undo页面链表中</span>。比方说现在有事务<code>id</code>分别为<code>1</code>、<code>2</code>的两个事务，我们分别称之为<code>trx 1</code>和<code>trx 2</code>，假设在这两个事务执行过程中：</p><ul><li><p><code>trx 1</code>对普通表做了<code>DELETE</code>操作，对临时表做了<code>INSERT</code>和<code>UPDATE</code>操作。</p><p>  <code>InnoDB</code>会为<code>trx 1</code>分配3个链表，分别是：</p><ul><li>针对普通表的<code>update undo链表</code></li><li>针对临时表的<code>insert undo链表</code></li><li>针对临时表的<code>update undo链表</code>。</li></ul></li><li><p><code>trx 2</code>对普通表做了<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>操作，没有对临时表做改动。</p><p>  <code>InnoDB</code>会为<code>trx 2</code>分配2个链表，分别是：</p><ul><li>针对普通表的<code>insert undo链表</code></li><li>针对普通表的<code>update undo链表</code>。</li></ul></li></ul><p>&amp;emsp;&amp;emsp;综上所述，在<code>trx 1</code>和<code>trx 2</code>执行过程中，<code>InnoDB</code>共需为这两个事务分配5个<code>Undo页面</code>链表，画个图就是这样：</p><p><img src="/../images/23-10.png"></p><p>&amp;emsp;&amp;emsp;如果有更多的事务，那就意味着可能会产生更多的<code>Undo页面</code>链表。</p><h2 id="undo日志具体写入过程"><a href="#undo日志具体写入过程" class="headerlink" title="undo日志具体写入过程"></a>undo日志具体写入过程</h2><h3 id="段（Segment）的概念"><a href="#段（Segment）的概念" class="headerlink" title="段（Segment）的概念"></a>段（Segment）的概念</h3><p>&amp;emsp;&amp;emsp;如果你有认真看过表空间那一章的话，对这个<code>段</code>的概念应该印象深刻，我们当时花了非常大的篇幅来介绍这个概念。简单讲，这个<code>段</code>是一个逻辑上的概念，本质上是由若干个零散页面和若干个完整的区组成的。比如一个<code>B+</code>树索引被划分成两个段，一个叶子节点段，一个非叶子节点段，这样叶子节点就可以被尽可能的存到一起，非叶子节点被尽可能的存到一起。每一个段对应一个<code>INODE Entry</code>结构，这个<code>INODE Entry</code>结构描述了这个段的各种信息，比如段的<code>ID</code>，段内的各种链表基节点，零散页面的页号有哪些等信息（具体该结构中每个属性的意思大家可以到表空间那一章里再次重温一下）。我们前面也说过，为了定位一个<code>INODE Entry</code>，设计<code>InnoDB</code>的大佬设计了一个<code>Segment Header</code>的结构：</p><p><img src="/../images/23-11.png"></p><p>&amp;emsp;&amp;emsp;整个<code>Segment Header</code>占用10个字节大小，各个属性的意思如下：</p><ul><li><code>Space ID of the INODE Entry</code>：<code>INODE Entry</code>结构所在的表空间ID。</li><li><code>Page Number of the INODE Entry</code>：<code>INODE Entry</code>结构所在的页面页号。</li><li><code>Byte Offset of the INODE Ent</code>：<code>INODE Entry</code>结构在该页面中的偏移量</li></ul><p>&amp;emsp;&amp;emsp;知道了表空间ID、页号、页内偏移量，不就可以唯一定位一个<code>INODE Entry</code>的地址了么～</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：这部分关于段的各种概念我们在表空间那一章中都有详细解释，在这里重提一下只是为了唤醒大家沉睡的记忆，如果有任何不清楚的地方可以再次跳回表空间的那一章仔细读一下。</span><br></pre></td></tr></table></figure><h3 id="Undo-Log-Segment-Header"><a href="#Undo-Log-Segment-Header" class="headerlink" title="Undo Log Segment Header"></a>Undo Log Segment Header</h3><p>&amp;emsp;&amp;emsp;设计<code>InnoDB</code>的大佬规定，每一个<code>Undo页面</code>链表都对应着一个<code>段</code>，称之为<code>Undo Log Segment</code>。也就是说链表中的页面都是从这个段里边申请的，所以他们在<code>Undo页面</code>链表的第一个页面，也就是上面提到的<code>first undo page</code>中设计了一个称之为<code>Undo Log Segment Header</code>的部分，这个部分中包含了该链表对应的段的<code>segment header</code>信息以及其他的一些关于这个段的信息，所以<code>Undo</code>页面链表的第一个页面其实长这样：</p><p><img src="/../images/23-12.png"></p><p>&amp;emsp;&amp;emsp;可以看到这个<code>Undo</code>链表的第一个页面比普通页面多了个<code>Undo Log Segment Header</code>，我们来看一下它的结构：</p><p><img src="/../images/23-13.png"></p><p>其中各个属性的意思如下：</p><ul><li><p><code>TRX_UNDO_STATE</code>：本<code>Undo页面</code>链表处在什么状态。</p><p>  一个<code>Undo Log Segment</code>可能处在的状态包括：</p><ul><li><code>TRX_UNDO_ACTIVE</code>：活跃状态，也就是一个活跃的事务正在往这个段里边写入<code>undo日志</code>。</li><li><code>TRX_UNDO_CACHED</code>：被缓存的状态。处在该状态的<code>Undo页面</code>链表等待着之后被其他事务重用。</li><li><code>TRX_UNDO_TO_FREE</code>：对于<code>insert undo</code>链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。</li><li><code>TRX_UNDO_TO_PURGE</code>：对于<code>update undo</code>链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。</li><li><code>TRX_UNDO_PREPARED</code>：包含处于<code>PREPARE</code>阶段的事务产生的<code>undo日志</code>。</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：Undo页面链表什么时候会被重用，怎么重用我们之后会详细说的。事务的PREPARE阶段是在所谓的分布式事务中才出现的，本书中不会介绍更多关于分布式事务的事情，所以大家目前忽略这个状态就好了。</span><br></pre></td></tr></table></figure></li><li><p><code>TRX_UNDO_LAST_LOG</code>：本<code>Undo页面</code>链表中最后一个<code>Undo Log Header</code>的位置。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：关于什么是Undo Log Header，我们稍后马上介绍。</span><br></pre></td></tr></table></figure></li><li><p><code>TRX_UNDO_FSEG_HEADER</code>：本<code>Undo页面</code>链表对应的段的<code>Segment Header</code>信息（就是我们上一节介绍的那个10字节结构，通过这个信息可以找到该段对应的<code>INODE Entry</code>）。</p></li><li><p><code>TRX_UNDO_PAGE_LIST</code>：<code>Undo页面</code>链表的基节点。</p><p>  &amp;emsp;&amp;emsp;我们上面说<code>Undo页面</code>的<code>Undo Page Header</code>部分有一个12字节大小的<code>TRX_UNDO_PAGE_NODE</code>属性，这个属性代表一个<code>List Node</code>结构。每一个<code>Undo页面</code>都包含<code>Undo Page Header</code>结构，这些页面就可以通过这个属性连成一个链表。这个<code>TRX_UNDO_PAGE_LIST</code>属性代表着这个链表的基节点，当然这个基节点只存在于<code>Undo页面</code>链表的第一个页面，也就是<code>first undo page</code>中。</p></li></ul><h3 id="Undo-Log-Header"><a href="#Undo-Log-Header" class="headerlink" title="Undo Log Header"></a>Undo Log Header</h3><p>&amp;emsp;&amp;emsp;一个事务在向<code>Undo页面</code>中写入<code>undo日志</code>时的方式是十分简单暴力的，就是直接往里怼，写完一条紧接着写另一条，各条<code>undo日志</code>之间是亲密无间的。写完一个<code>Undo页面</code>后，再从段里申请一个新页面，然后把这个页面插入到<code>Undo页面</code>链表中，继续往这个新申请的页面中写。设计<code>InnoDB</code>的大佬认为同一个事务向一个<code>Undo页面</code>链表中写入的<code>undo日志</code>算是一个组，比方说我们上面介绍的<code>trx 1</code>由于会分配3个<code>Undo页面</code>链表，也就会写入3个组的<code>undo日志</code>；<code>trx 2</code>由于会分配2个<code>Undo页面</code>链表，也就会写入2个组的<code>undo日志</code>。在每写入一组<code>undo日志</code>时，都会在这组<code>undo日志</code>前先记录一下关于这个组的一些属性，设计<code>InnoDB</code>的大佬把存储这些属性的地方称之为<code>Undo Log Header</code>。所以<code>Undo页面</code>链表的第一个页面在真正写入<code>undo日志</code>前，其实都会被填充<code>Undo Page Header</code>、<code>Undo Log Segment Header</code>、<code>Undo Log Header</code>这3个部分，如图所示：</p><p><img src="/../images/23-14.png"></p><p>这个<code>Undo Log Header</code>具体的结构如下：</p><p><img src="/../images/23-15.png"></p><p>&amp;emsp;&amp;emsp;哇唔，映入眼帘的又是一大坨属性，我们先大致看一下它们都是什么意思：</p><ul><li><p><code>TRX_UNDO_TRX_ID</code>：生成本组<code>undo日志</code>的事务<code>id</code>。</p></li><li><p><code>TRX_UNDO_TRX_NO</code>：事务提交后生成的一个需要序号，使用此序号来标记事务的提交顺序（先提交的此序号小，后提交的此序号大）。</p></li><li><p><code>TRX_UNDO_DEL_MARKS</code>：标记本组<code>undo</code>日志中是否包含由于<code>Delete mark</code>操作产生的<code>undo日志</code>。</p></li><li><p><code>TRX_UNDO_LOG_START</code>：表示本组<code>undo</code>日志中第一条<code>undo日志</code>的在页面中的偏移量。</p></li><li><p><code>TRX_UNDO_XID_EXISTS</code>：本组<code>undo日志</code>是否包含XID信息。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：本书不会讲述更多关于XID是个什么东东，有兴趣的同学可以到搜索引擎或者文档中搜一搜。</span><br></pre></td></tr></table></figure></li><li><p><code>TRX_UNDO_DICT_TRANS</code>：标记本组<code>undo日志</code>是不是由DDL语句产生的。</p></li><li><p><code>TRX_UNDO_TABLE_ID</code>：如果<code>TRX_UNDO_DICT_TRANS</code>为真，那么本属性表示DDL语句操作的表的<code>table id</code>。</p></li><li><p><code>TRX_UNDO_NEXT_LOG</code>：下一组的<code>undo日志</code>在页面中开始的偏移量。</p></li><li><p><code>TRX_UNDO_PREV_LOG</code>：上一组的<code>undo日志</code>在页面中开始的偏移量。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：一般来说一个Undo页面链表只存储一个事务执行过程中产生的一组undo日志，但是在某些情况下，可能会在一个事务提交之后，之后开启的事务重复利用这个Undo页面链表，这样就会导致一个Undo页面中可能存放多组Undo日志，TRX_UNDO_NEXT_LOG和TRX_UNDO_PREV_LOG就是用来标记下一组和上一组undo日志在页面中的偏移量的。关于什么时候重用Undo页面链表，怎么重用这个链表我们稍后会详细说明的，现在先理解TRX_UNDO_NEXT_LOG和TRX_UNDO_PREV_LOG这两个属性的意思就好了。</span><br></pre></td></tr></table></figure></li><li><p><code>TRX_UNDO_HISTORY_NODE</code>：一个12字节的<code>List Node</code>结构，代表一个称之为<code>History</code>链表的节点。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：关于History链表我们后边会格外详细的介绍，现在先不用管。</span><br></pre></td></tr></table></figure></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&amp;emsp;&amp;emsp;对于没有被重用的<code>Undo页面</code>链表来说，链表的第一个页面，也就是<code>first undo page</code>在真正写入<code>undo日志</code>前，会填充<code>Undo Page Header</code>、<code>Undo Log Segment Header</code>、<code>Undo Log Header</code>这3个部分，之后才开始正式写入<code>undo日志</code>。对于其他的页面来说，也就是<code>normal undo page</code>在真正写入<code>undo日志</code>前，只会填充<code>Undo Page Header</code>。链表的<code>List Base Node</code>存放到<code>first undo page</code>的<code>Undo Log Segment Header</code>部分，<code>List Node</code>信息存放到每一个<code>Undo页面</code>的<code>undo Page Header</code>部分，所以画一个<code>Undo页面</code>链表的示意图就是这样：</p><p><img src="/../images/23-16.png"></p><h2 id="重用Undo页面"><a href="#重用Undo页面" class="headerlink" title="重用Undo页面"></a>重用Undo页面</h2><p>&amp;emsp;&amp;emsp;我们前面说为了能提高并发执行的多个事务写入<code>undo日志</code>的性能，设计<code>InnoDB</code>的大佬决定为每个事务单独分配相应的<code>Undo页面</code>链表（最多可能单独分配4个链表）。但是这样也造成了一些问题，比如其实大部分事务执行过程中可能只修改了一条或几条记录，针对某个<code>Undo页面</code>链表只产生了非常少的<code>undo日志</code>，这些<code>undo日志</code>可能只占用一丢丢存储空间，每开启一个事务就新创建一个<code>Undo页面</code>链表（虽然这个链表中只有一个页面）来存储这么一丢丢<code>undo日志</code>岂不是太浪费了么？的确是挺浪费，于是设计<code>InnoDB</code>的大佬本着勤俭节约的优良传统，决定在事务提交后在某些情况下重用该事务的<code>Undo页面</code>链表。一个<code>Undo页面</code>链表是否可以被重用的条件很简单：</p><ul><li><p>该链表中只包含一个<code>Undo页面</code>。</p><p>  &amp;emsp;&amp;emsp;如果一个事务执行过程中产生了非常多的<code>undo日志</code>，那么它可能申请非常多的页面加入到<code>Undo页面</code>链表中。在该事物提交后，如果将整个链表中的页面都重用，那就意味着即使新的事务并没有向该<code>Undo页面</code>链表中写入很多<code>undo日志</code>，那该链表中也得维护非常多的页面，那些用不到的页面也不能被别的事务所使用，这样就造成了另一种浪费。所以设计<code>InnoDB</code>的大佬们规定，只有在<code>Undo页面</code>链表中只包含一个<code>Undo页面</code>时，该链表才可以被下一个事务所重用。</p></li><li><p>该<code>Undo页面</code>已经使用的空间小于整个页面空间的3&#x2F;4。</p></li></ul><p>&amp;emsp;&amp;emsp;我们前面说过，<code>Undo页面</code>链表按照存储的<code>undo日志</code>所属的大类可以被分为<code>insert undo链表</code>和<code>update undo链表</code>两种，这两种链表在被重用时的策略也是不同的，我们分别看一下：</p><ul><li><p>insert undo链表</p><p>  &amp;emsp;&amp;emsp;<code>insert undo链表</code>中只存储类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>，这种类型的<code>undo日志</code>在事务提交之后就没用了，就可以被清除掉。所以在某个事务提交后，重用这个事务的<code>insert undo链表</code>（这个链表中只有一个页面）时，可以直接把之前事务写入的一组<code>undo日志</code>覆盖掉，从头开始写入新事务的一组<code>undo日志</code>，如下图所示：</p><p>  <img src="/../images/23-17.png"></p><p>  &amp;emsp;&amp;emsp;如图所示，假设有一个事务使用的<code>insert undo链表</code>，到事务提交时，只向<code>insert undo链表</code>中插入了3条<code>undo日志</code>，这个<code>insert undo链表</code>只申请了一个<code>Undo页面</code>。假设此刻该页面已使用的空间小于整个页面大小的3&#x2F;4，那么下一个事务就可以重用这个<code>insert undo链表</code>（链表中只有一个页面）。假设此时有一个新事务重用了该<code>insert undo链表</code>，那么可以直接把旧的一组<code>undo日志</code>覆盖掉，写入一组新的<code>undo日志</code>。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：当然，在重用Undo页面链表写入新的一组undo日志时，不仅会写入新的Undo Log Header，还会适当调整Undo Page Header、Undo Log Segment Header、Undo Log Header中的一些属性，比如TRX_UNDO_PAGE_START、TRX_UNDO_PAGE_FREE等等等等，这些我们就不具体介绍了。</span><br></pre></td></tr></table></figure></li><li><p>update undo链表</p><p>  &amp;emsp;&amp;emsp;在一个事务提交后，它的<code>update undo链表</code>中的<code>undo日志</code>也不能立即删除掉（这些日志用于MVCC，我们后边会说的）。所以如果之后的事务想重用<code>update undo链表</code>时，就不能覆盖之前事务写入的<code>undo日志</code>。这样就相当于在同一个<code>Undo页面</code>中写入了多组的<code>undo日志</code>，效果看起来就是这样：</p><p>  <img src="/../images/23-18.png"></p></li></ul><h2 id="回滚段"><a href="#回滚段" class="headerlink" title="回滚段"></a>回滚段</h2><h3 id="回滚段的概念"><a href="#回滚段的概念" class="headerlink" title="回滚段的概念"></a>回滚段的概念</h3><p>&amp;emsp;&amp;emsp;我们现在知道一个事务在执行过程中最多可以分配4个<code>Undo页面</code>链表，在同一时刻不同事务拥有的<code>Undo页面</code>链表是不一样的，所以在同一时刻系统里其实可以有许许多多个<code>Undo页面</code>链表存在。为了更好的管理这些链表，设计<code>InnoDB</code>的大佬又设计了一个称之为<code>Rollback Segment Header</code>的页面，在这个页面中存放了各个<code>Undo页面</code>链表的<code>frist undo page</code>的<code>页号</code>，他们把这些<code>页号</code>称之为<code>undo slot</code>。我们可以这样理解，每个<code>Undo页面</code>链表都相当于是一个班，这个链表的<code>first undo page</code>就相当于这个班的班长，找到了这个班的班长，就可以找到班里的其他同学（其他同学相当于<code>normal undo page</code>）。有时候学校需要向这些班级传达一下精神，就需要把班长都召集在会议室，这个<code>Rollback Segment Header</code>就相当于是一个会议室。</p><p>&amp;emsp;&amp;emsp;我们看一下这个称之为<code>Rollback Segment Header</code>的页面长什么样（以默认的16KB为例）：</p><p><img src="/../images/23-19.png"></p><p>&amp;emsp;&amp;emsp;设计<code>InnoDB</code>的大佬规定，每一个<code>Rollback Segment Header</code>页面都对应着一个段，这个段就称为<code>Rollback Segment</code>，翻译过来就是<code>回滚段</code>。与我们之前介绍的各种段不同的是，这个<code>Rollback Segment</code>里其实只有一个页面（这可能是设计<code>InnoDB</code>的大佬们的一种洁癖，他们可能觉得为了某个目的去分配页面的话都得先申请一个段，或者他们觉得虽然目前版本的<code>MySQL</code>里<code>Rollback Segment</code>里其实只有一个页面，但可能之后的版本里会增加页面也说不定）。</p><p>&amp;emsp;&amp;emsp;了解了<code>Rollback Segment</code>的含义之后，我们再来看看这个称之为<code>Rollback Segment Header</code>的页面的各个部分的含义都是什么意思：</p><ul><li><p><code>TRX_RSEG_MAX_SIZE</code>：本<code>Rollback Segment</code>中管理的所有<code>Undo页面</code>链表中的<code>Undo页面</code>数量之和的最大值。换句话说，本<code>Rollback Segment</code>中所有<code>Undo页面</code>链表中的<code>Undo页面</code>数量之和不能超过<code>TRX_RSEG_MAX_SIZE</code>代表的值。</p><p>  &amp;emsp;&amp;emsp;该属性的值默认为无限大，也就是我们想写多少<code>Undo页面</code>都可以。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：无限大其实也只是个夸张的说法，4个字节能表示最大的数也就是0xFFFFFFFF，但是我们之后会看到，0xFFFFFFFF这个数有特殊用途，所以实际上TRX_RSEG_MAX_SIZE的值为0xFFFFFFFE。</span><br></pre></td></tr></table></figure></li><li><p><code>TRX_RSEG_HISTORY_SIZE</code>：<code>History</code>链表占用的页面数量。</p></li><li><p><code>TRX_RSEG_HISTORY</code>：<code>History</code>链表的基节点。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：History链表后边讲，稍安勿躁。</span><br></pre></td></tr></table></figure></li><li><p><code>TRX_RSEG_FSEG_HEADER</code>：本<code>Rollback Segment</code>对应的10字节大小的<code>Segment Header</code>结构，通过它可以找到本段对应的<code>INODE Entry</code>。</p></li><li><p><code>TRX_RSEG_UNDO_SLOTS</code>：各个<code>Undo页面</code>链表的<code>first undo page</code>的<code>页号</code>集合，也就是<code>undo slot</code>集合。</p><p>  一个页号占用<code>4</code>个字节，对于<code>16KB</code>大小的页面来说，这个<code>TRX_RSEG_UNDO_SLOTS</code>部分共存储了<code>1024</code>个<code>undo slot</code>，所以共需<code>1024 × 4 = 4096</code>个字节。</p></li></ul><h3 id="从回滚段中申请Undo页面链表"><a href="#从回滚段中申请Undo页面链表" class="headerlink" title="从回滚段中申请Undo页面链表"></a>从回滚段中申请Undo页面链表</h3><p>&amp;emsp;&amp;emsp;初始情况下，由于未向任何事务分配任何<code>Undo页面</code>链表，所以对于一个<code>Rollback Segment Header</code>页面来说，它的各个<code>undo slot</code>都被设置成了一个特殊的值：<code>FIL_NULL</code>（对应的十六进制就是<code>0xFFFFFFFF</code>），表示该<code>undo slot</code>不指向任何页面。</p><p>&amp;emsp;&amp;emsp;随着时间的流逝，开始有事务需要分配<code>Undo页面</code>链表了，就从回滚段的第一个<code>undo slot</code>开始，看看该<code>undo slot</code>的值是不是<code>FIL_NULL</code>：</p><ul><li>如果是<code>FIL_NULL</code>，那么在表空间中新创建一个段（也就是<code>Undo Log Segment</code>），然后从段里申请一个页面作为<code>Undo页面</code>链表的<code>first undo page</code>，然后把该<code>undo slot</code>的值设置为刚刚申请的这个页面的地址，这样也就意味着这个<code>undo slot</code>被分配给了这个事务。</li><li>如果不是<code>FIL_NULL</code>，说明该<code>undo slot</code>已经指向了一个<code>undo链表</code>，也就是说这个<code>undo slot</code>已经被别的事务占用了，那就跳到下一个<code>undo slot</code>，判断该<code>undo slot</code>的值是不是<code>FIL_NULL</code>，重复上面的步骤。</li></ul><p>&amp;emsp;&amp;emsp;一个<code>Rollback Segment Header</code>页面中包含<code>1024</code>个<code>undo slot</code>，如果这<code>1024</code>个<code>undo slot</code>的值都不为<code>FIL_NULL</code>，这就意味着这<code>1024</code>个<code>undo slot</code>都已经名花有主（被分配给了某个事务），此时由于新事务无法再获得新的<code>Undo页面</code>链表，就会回滚这个事务并且给用户报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Too many active concurrent transactions</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;用户看到这个错误，可以选择重新执行这个事务（可能重新执行时有别的事务提交了，该事务就可以被分配<code>Undo页面</code>链表了）。</p><p>&amp;emsp;&amp;emsp;当一个事务提交时，它所占用的<code>undo slot</code>有两种命运：</p><ul><li><p>如果该<code>undo slot</code>指向的<code>Undo页面</code>链表符合被重用的条件（就是我们上面说的<code>Undo页面</code>链表只占用一个页面并且已使用空间小于整个页面的3&#x2F;4）。</p><p>  &amp;emsp;&amp;emsp;该<code>undo slot</code>就处于被缓存的状态，设计<code>InnoDB</code>的大佬规定这时该<code>Undo页面</code>链表的<code>TRX_UNDO_STATE</code>属性（该属性在<code>first undo page</code>的<code>Undo Log Segment Header</code>部分）会被设置为<code>TRX_UNDO_CACHED</code>。</p><p>  &amp;emsp;&amp;emsp;被缓存的<code>undo slot</code>都会被加入到一个链表，根据对应的<code>Undo页面</code>链表的类型不同，也会被加入到不同的链表：</p><ul><li>如果对应的<code>Undo页面</code>链表是<code>insert undo链表</code>，则该<code>undo slot</code>会被加入<code>insert undo cached链表</code>。</li><li>如果对应的<code>Undo页面</code>链表是<code>update undo链表</code>，则该<code>undo slot</code>会被加入<code>update undo cached链表</code>。</li></ul><p>  &amp;emsp;&amp;emsp;一个回滚段就对应着上述两个<code>cached链表</code>，如果有新事务要分配<code>undo slot</code>时，先从对应的<code>cached链表</code>中找。如果没有被缓存的<code>undo slot</code>，才会到回滚段的<code>Rollback Segment Header</code>页面中再去找。</p></li><li><p>如果该<code>undo slot</code>指向的<code>Undo页面</code>链表不符合被重用的条件，那么针对该<code>undo slot</code>对应的<code>Undo页面</code>链表类型不同，也会有不同的处理：</p><ul><li>如果对应的<code>Undo页面</code>链表是<code>insert undo链表</code>，则该<code>Undo页面</code>链表的<code>TRX_UNDO_STATE</code>属性会被设置为<code>TRX_UNDO_TO_FREE</code>，之后该<code>Undo页面</code>链表对应的段会被释放掉（也就意味着段中的页面可以被挪作他用），然后把该<code>undo slot</code>的值设置为<code>FIL_NULL</code>。</li><li>如果对应的<code>Undo页面</code>链表是<code>update undo链表</code>，则该<code>Undo页面</code>链表的<code>TRX_UNDO_STATE</code>属性会被设置为<code>TRX_UNDO_TO_PRUGE</code>，则会将该<code>undo slot</code>的值设置为<code>FIL_NULL</code>，然后将本次事务写入的一组<code>undo</code>日志放到所谓的<code>History链表</code>中（需要注意的是，这里并不会将<code>Undo页面</code>链表对应的段给释放掉，因为这些<code>undo</code>日志还有用呢～）。</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：更多关于History链表的事我们稍后再说，稍安勿躁。</span><br></pre></td></tr></table></figure></li></ul><h3 id="多个回滚段"><a href="#多个回滚段" class="headerlink" title="多个回滚段"></a>多个回滚段</h3><p>&amp;emsp;&amp;emsp;我们说一个事务执行过程中最多分配<code>4</code>个<code>Undo页面</code>链表，而一个回滚段里只有<code>1024</code>个<code>undo slot</code>，很显然<code>undo slot</code>的数量有点少啊。我们即使假设一个读写事务执行过程中只分配<code>1</code>个<code>Undo页面</code>链表，那<code>1024</code>个<code>undo slot</code>也只能支持<code>1024</code>个读写事务同时执行，再多了就崩溃了。这就相当于会议室只能容下1024个班长同时开会，如果有几千人同时到会议室开会的话，那后来的那些班长就没地方坐了，只能等待前面的人开完会自己再进去开。</p><p>&amp;emsp;&amp;emsp;话说在<code>InnoDB</code>的早期发展阶段的确只有一个回滚段，但是设计<code>InnoDB</code>的大佬后来意识到了这个问题，咋解决这问题呢？会议室不够，多盖几个会议室不就得了。所以设计<code>InnoDB</code>的大佬一口气定义了<code>128</code>个回滚段，也就相当于有了<code>128 × 1024 = 131072</code>个<code>undo slot</code>。假设一个读写事务执行过程中只分配<code>1</code>个<code>Undo页面</code>链表，那么就可以同时支持<code>131072</code>个读写事务并发执行（这么多事务在一台机器上并发执行，还真没见过呢～）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：只读事务并不需要分配Undo页面链表，MySQL 5.7中所有刚开启的事务默认都是只读事务，只有在事务执行过程中对记录做了某些改动时才会被升级为读写事务。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;每个回滚段都对应着一个<code>Rollback Segment Header</code>页面，有128个回滚段，自然就要有128个<code>Rollback Segment Header</code>页面，这些页面的地址总得找个地方存一下吧！于是设计<code>InnoDB</code>的大佬在系统表空间的第<code>5</code>号页面的某个区域包含了128个8字节大小的格子： </p><p><img src="/../images/23-20.png"></p><p>&amp;emsp;&amp;emsp;每个8字节的格子的构造就像这样：</p><p><img src="/../images/23-21.png"></p><p>&amp;emsp;&amp;emsp;如果所示，每个8字节的格子其实由两部分组成：</p><ul><li>4字节大小的<code>Space ID</code>，代表一个表空间的ID。</li><li>4字节大小的<code>Page number</code>，代表一个页号。</li></ul><p>&amp;emsp;&amp;emsp;也就是说每个8字节大小的<code>格子</code>相当于一个指针，指向某个表空间中的某个页面，这些页面就是<code>Rollback Segment Header</code>。这里需要注意的一点事，要定位一个<code>Rollback Segment Header</code>还需要知道对应的表空间ID，这也就意味着<span style="color:red">不同的回滚段可能分布在不同的表空间中</span>。</p><p>&amp;emsp;&amp;emsp;所以通过上面的叙述我们可以大致清楚，在系统表空间的第<code>5</code>号页面中存储了128个<code>Rollback Segment Header</code>页面地址，每个<code>Rollback Segment Header</code>就相当于一个回滚段。在<code>Rollback Segment Header</code>页面中，又包含<code>1024</code>个<code>undo slot</code>，每个<code>undo slot</code>都对应一个<code>Undo页面</code>链表。我们画个示意图：</p><p><img src="/../images/23-22.png"></p><p>把图一画出来就清爽多了。</p><h3 id="回滚段的分类"><a href="#回滚段的分类" class="headerlink" title="回滚段的分类"></a>回滚段的分类</h3><p>&amp;emsp;&amp;emsp;我们把这128个回滚段给编一下号，最开始的回滚段称之为<code>第0号回滚段</code>，之后依次递增，最后一个回滚段就称之为<code>第127号回滚段</code>。这128个回滚段可以被分成两大类：</p><ul><li><p>第<code>0</code>号、第<code>33～127</code>号回滚段属于一类。其中第<code>0</code>号回滚段必须在系统表空间中（就是说第<code>0</code>号回滚段对应的<code>Rollback Segment Header</code>页面必须在系统表空间中），第<code>33～127</code>号回滚段既可以在系统表空间中，也可以在自己配置的<code>undo</code>表空间中，关于怎么配置我们稍后再说。</p><p>  &amp;emsp;&amp;emsp;如果一个事务在执行过程中由于对普通表的记录做了改动需要分配<code>Undo页面</code>链表时，必须从这一类的段中分配相应的<code>undo slot</code>。</p></li><li><p>第<code>1～32</code>号回滚段属于一类。这些回滚段必须在临时表空间（对应着数据目录中的<code>ibtmp1</code>文件）中。</p><p>  &amp;emsp;&amp;emsp;如果一个事务在执行过程中由于对临时表的记录做了改动需要分配<code>Undo页面</code>链表时，必须从这一类的段中分配相应的<code>undo slot</code>。</p></li></ul><p>&amp;emsp;&amp;emsp;也就是说如果一个事务在执行过程中既对普通表的记录做了改动，又对临时表的记录做了改动，那么需要为这个记录分配2个回滚段，再分别到这两个回滚段中分配对应的<code>undo slot</code>。</p><p>&amp;emsp;&amp;emsp;不知道大家有没有疑惑，为什么要把针对普通表和临时表来划分不同种类的<code>回滚段</code>呢？这个还得从<code>Undo页面</code>本身说起，我们说<code>Undo页面</code>其实是类型为<code>FIL_PAGE_UNDO_LOG</code>的页面的简称，说到底它也是一个普通的页面。我们前面说过，在修改页面之前一定要先把对应的<code>redo日志</code>写上，这样在系统奔溃重启时才能恢复到奔溃前的状态。我们向<code>Undo页面</code>写入<code>undo日志</code>本身也是一个写页面的过程，设计<code>InnoDB</code>的大佬为此还设计了许多种<code>redo日志</code>的类型，比方说<code>MLOG_UNDO_HDR_CREATE</code>、<code>MLOG_UNDO_INSERT</code>、<code>MLOG_UNDO_INIT</code>等等等等，也就是说我们对<code>Undo页面</code>做的任何改动都会记录相应类型的<code>redo日志</code>。但是对于临时表来说，因为修改临时表而产生的<code>undo日志</code>只需要在系统运行过程中有效，如果系统奔溃了，那么在重启时也不需要恢复这些<code>undo</code>日志所在的页面，所以在写针对临时表的<code>Undo页面</code>时，并不需要记录相应的<code>redo日志</code>。总结一下针对普通表和临时表划分不同种类的<code>回滚段</code>的原因：<span style="color:red">在修改针对普通表的回滚段中的Undo页面时，需要记录对应的redo日志，而修改针对临时表的回滚段中的Undo页面时，不需要记录对应的redo日志</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：实际上在MySQL 5.7.21这个版本中，如果我们仅仅对普通表的记录做了改动，那么只会为该事务分配针对普通表的回滚段，不分配针对临时表的回滚段。但是如果我们仅仅对临时表的记录做了改动，那么既会为该事务分配针对普通表的回滚段，又会为其分配针对临时表的回滚段（不过分配了回滚段并不会立即分配undo slot，只有在真正需要Undo页面链表时才会去分配回滚段中的undo slot）。</span><br></pre></td></tr></table></figure><h3 id="为事务分配Undo页面链表详细过程"><a href="#为事务分配Undo页面链表详细过程" class="headerlink" title="为事务分配Undo页面链表详细过程"></a>为事务分配Undo页面链表详细过程</h3><p>&amp;emsp;&amp;emsp;上面说了一大堆的概念，大家应该有一点点的小晕，接下来我们以事务对普通表的记录做改动为例，给大家梳理一下事务执行过程中分配<code>Undo页面</code>链表时的完整过程，</p><ul><li><p>事务在执行过程中对普通表的记录首次做改动之前，首先会到系统表空间的第<code>5</code>号页面中分配一个回滚段（其实就是获取一个<code>Rollback Segment Header</code>页面的地址）。一旦某个回滚段被分配给了这个事务，那么之后该事务中再对普通表的记录做改动时，就不会重复分配了。</p><p>  &amp;emsp;&amp;emsp;使用传说中的<code>round-robin</code>（循环使用）方式来分配回滚段。比如当前事务分配了第<code>0</code>号回滚段，那么下一个事务就要分配第<code>33</code>号回滚段，下下个事务就要分配第<code>34</code>号回滚段，简单一点的说就是这些回滚段被轮着分配给不同的事务（就是这么简单粗暴，没什么好说的）。</p></li><li><p>在分配到回滚段后，首先看一下这个回滚段的两个<code>cached链表</code>有没有已经缓存了的<code>undo slot</code>，比如如果事务做的是<code>INSERT</code>操作，就去回滚段对应的<code>insert undo cached链表</code>中看看有没有缓存的<code>undo slot</code>；如果事务做的是<code>DELETE</code>操作，就去回滚段对应的<code>update undo cached链表</code>中看看有没有缓存的<code>undo slot</code>。如果有缓存的<code>undo slot</code>，那么就把这个缓存的<code>undo slot</code>分配给该事务。</p></li><li><p>如果没有缓存的<code>undo slot</code>可供分配，那么就要到<code>Rollback Segment Header</code>页面中找一个可用的<code>undo slot</code>分配给当前事务。</p><p>  &amp;emsp;&amp;emsp;从<code>Rollback Segment Header</code>页面中分配可用的<code>undo slot</code>的方式我们上面也说过了，就是从第<code>0</code>个<code>undo slot</code>开始，如果该<code>undo slot</code>的值为<code>FIL_NULL</code>，意味着这个<code>undo slot</code>是空闲的，就把这个<code>undo slot</code>分配给当前事务，否则查看第<code>1</code>个<code>undo slot</code>是否满足条件，依次类推，直到最后一个<code>undo slot</code>。如果这<code>1024</code>个<code>undo slot</code>都没有值为<code>FIL_NULL</code>的情况，就直接报错喽（一般不会出现这种情况）～</p></li><li><p>找到可用的<code>undo slot</code>后，如果该<code>undo slot</code>是从<code>cached链表</code>中获取的，那么它对应的<code>Undo Log Segment</code>已经分配了，否则的话需要重新分配一个<code>Undo Log Segment</code>，然后从该<code>Undo Log Segment</code>中申请一个页面作为<code>Undo页面</code>链表的<code>first undo page</code>。</p></li><li><p>然后事务就可以把<code>undo日志</code>写入到上面申请的<code>Undo页面</code>链表了！</p></li></ul><p>&amp;emsp;&amp;emsp;对临时表的记录做改动的步骤和上述的一样，就不赘述了。不错需要再次强调一次，<span style="color:red">如果一个事务在执行过程中既对普通表的记录做了改动，又对临时表的记录做了改动，那么需要为这个记录分配2个回滚段。并发执行的不同事务其实也可以被分配相同的回滚段，只要分配不同的undo slot就可以了</span>。</p><h2 id="回滚段相关配置"><a href="#回滚段相关配置" class="headerlink" title="回滚段相关配置"></a>回滚段相关配置</h2><h3 id="配置回滚段数量"><a href="#配置回滚段数量" class="headerlink" title="配置回滚段数量"></a>配置回滚段数量</h3><p>&amp;emsp;&amp;emsp;我们前面说系统中一共有<code>128</code>个回滚段，其实这只是默认值，我们可以通过启动参数<code>innodb_rollback_segments</code>来配置回滚段的数量，可配置的范围是<code>1~128</code>。但是这个参数并不会影响针对临时表的回滚段数量，针对临时表的回滚段数量一直是<code>32</code>，也就是说：</p><ul><li>如果我们把<code>innodb_rollback_segments</code>的值设置为<code>1</code>，那么只会有1个针对普通表的可用回滚段，但是仍然有32个针对临时表的可用回滚段。</li><li>如果我们把<code>innodb_rollback_segments</code>的值设置为<code>2～33</code>之间的数，效果和将其设置为<code>1</code>是一样的。</li><li>如果我们把<code>innodb_rollback_segments</code>设置为大于<code>33</code>的数，那么针对普通表的可用回滚段数量就是该值减去32。</li></ul><h3 id="配置undo表空间"><a href="#配置undo表空间" class="headerlink" title="配置undo表空间"></a>配置undo表空间</h3><p>&amp;emsp;&amp;emsp;默认情况下，针对普通表设立的回滚段（第<code>0</code>号以及第<code>33~127</code>号回滚段）都是被分配到系统表空间的。其中的第第<code>0</code>号回滚段是一直在系统表空间的，但是第<code>33~127</code>号回滚段可以通过配置放到自定义的<code>undo表空间</code>中。但是这种配置只能在系统初始化（创建数据目录时）的时候使用，一旦初始化完成，之后就不能再次更改了。我们看一下相关启动参数：</p><ul><li><p>通过<code>innodb_undo_directory</code>指定<code>undo表空间</code>所在的目录，如果没有指定该参数，则默认<code>undo表空间</code>所在的目录就是数据目录。</p></li><li><p>通过<code>innodb_undo_tablespaces</code>定义<code>undo表空间</code>的数量。该参数的默认值为<code>0</code>，表明不创建任何<code>undo表空间</code>。</p><p>  &amp;emsp;&amp;emsp;第<code>33~127</code>号回滚段可以平均分布到不同的<code>undo表空间</code>中。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：如果我们在系统初始化的时候指定了创建了undo表空间，那么系统表空间中的第0号回滚段将处于不可用状态。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;比如我们在系统初始化时指定的<code>innodb_rollback_segments</code>为<code>35</code>，<code>innodb_undo_tablespaces</code>为<code>2</code>，这样就会将第<code>33</code>、<code>34</code>号回滚段分别分布到一个<code>undo表空间</code>中。</p><p>&amp;emsp;&amp;emsp;设立<code>undo表空间</code>的一个好处就是在<code>undo表空间</code>中的文件大到一定程度时，可以自动的将该<code>undo表空间</code>截断（truncate）成一个小文件。而系统表空间的大小只能不断的增大，却不能截断。</p><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/09-%E5%AD%98%E6%94%BE%E9%A1%B5%E7%9A%84%E5%A4%A7%E6%B1%A0%E5%AD%90-InnoDB%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
      <url>/2022/10/31/model-mysql/mysql/09-%E5%AD%98%E6%94%BE%E9%A1%B5%E7%9A%84%E5%A4%A7%E6%B1%A0%E5%AD%90-InnoDB%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="第9章-存放页的大池子-InnoDB的表空间"><a href="#第9章-存放页的大池子-InnoDB的表空间" class="headerlink" title="第9章 存放页的大池子-InnoDB的表空间"></a>第9章 存放页的大池子-InnoDB的表空间</h1><p>&amp;emsp;&amp;emsp;通过前面儿的内容大家知道，<code>表空间</code>是一个抽象的概念，对于系统表空间来说，对应着文件系统中一个或多个实际文件；对于每个独立表空间来说，对应着文件系统中一个名为<code>表名.ibd</code>的实际文件。大家可以把表空间想象成被切分为许许多多个<code>页</code>的池子，当我们想为某个表插入一条记录的时候，就从池子中捞出一个对应的页来把数据写进去。本章内容会深入到表空间的各个细节中，带领大家在<code>InnoDB</code>存储结构的池子中畅游。由于本章中将会涉及比较多的概念，虽然这些概念都不难，但是却相互依赖，所以奉劝大家在看的时候：</p><ul><li><p><span style="color:red">不要跳着看！</span></p></li><li><p><span style="color:red">不要跳着看！</span></p></li><li><p><span style="color:red">不要跳着看！</span></p></li></ul><h2 id="回忆一些旧知识"><a href="#回忆一些旧知识" class="headerlink" title="回忆一些旧知识"></a>回忆一些旧知识</h2><h3 id="页类型"><a href="#页类型" class="headerlink" title="页类型"></a>页类型</h3><p>&amp;emsp;&amp;emsp;再一次强调，InnoDB是以页为单位管理存储空间的，我们的聚簇索引（也就是完整的表数据）和其他的二级索引都是以<code>B+</code>树的形式保存到表空间的，而<code>B+</code>树的节点就是数据页。我们前面说过，这个数据页的类型名其实是：<code>FIL_PAGE_INDEX</code>，除了这种存放索引数据的页类型之外，InnoDB也为了不同的目的设计了若干种不同类型的页，为了唤醒大家的记忆，我们再一次把各种常用的页类型提出来：</p><table><thead><tr><th align="center">类型名称</th><th align="center">十六进制</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>FIL_PAGE_TYPE_ALLOCATED</code></td><td align="center">0x0000</td><td align="center">最新分配，还没使用</td></tr><tr><td align="center"><code>FIL_PAGE_UNDO_LOG</code></td><td align="center">0x0002</td><td align="center">Undo日志页</td></tr><tr><td align="center"><code>FIL_PAGE_INODE</code></td><td align="center">0x0003</td><td align="center">段信息节点</td></tr><tr><td align="center"><code>FIL_PAGE_IBUF_FREE_LIST</code></td><td align="center">0x0004</td><td align="center">Insert Buffer空闲列表</td></tr><tr><td align="center"><code>FIL_PAGE_IBUF_BITMAP</code></td><td align="center">0x0005</td><td align="center">Insert Buffer位图</td></tr><tr><td align="center"><code>FIL_PAGE_TYPE_SYS</code></td><td align="center">0x0006</td><td align="center">系统页</td></tr><tr><td align="center"><code>FIL_PAGE_TYPE_TRX_SYS</code></td><td align="center">0x0007</td><td align="center">事务系统数据</td></tr><tr><td align="center"><code>FIL_PAGE_TYPE_FSP_HDR</code></td><td align="center">0x0008</td><td align="center">表空间头部信息</td></tr><tr><td align="center"><code>FIL_PAGE_TYPE_XDES</code></td><td align="center">0x0009</td><td align="center">扩展描述页</td></tr><tr><td align="center"><code>FIL_PAGE_TYPE_BLOB</code></td><td align="center">0x000A</td><td align="center">BLOB页</td></tr><tr><td align="center"><code>FIL_PAGE_INDEX</code></td><td align="center">0x45BF</td><td align="center">索引页，也就是我们所说的<code>数据页</code></td></tr></tbody></table><p>&amp;emsp;&amp;emsp;因为页类型前面都有个<code>FIL_PAGE</code>或者<code>FIL_PAGE_TYPE</code>的前缀，为简便起见我们后边介绍页类型的时候就把这些前缀省略掉了，比方说<code>FIL_PAGE_TYPE_ALLOCATED</code>类型称为<code>ALLOCATED</code>类型，<code>FIL_PAGE_INDEX</code>类型称为<code>INDEX</code>类型。</p><h3 id="页通用部分"><a href="#页通用部分" class="headerlink" title="页通用部分"></a>页通用部分</h3><p>&amp;emsp;&amp;emsp;我们前面说过数据页，也就是<code>INDEX</code>类型的页由7个部分组成，其中的两个部分是所有类型的页都通用的。当然我不能寄希望于你把我说的话都记住，所以在这里重新强调一遍，任何类型的页都有下面这种通用的结构：</p><p><img src="/../images/09-01.png"></p><p>&amp;emsp;&amp;emsp;从上图中可以看出，任何类型的页都会包含这两个部分：</p><ul><li><p><code>File Header</code>：记录页的一些通用信息</p></li><li><p><code>File Trailer</code>：校验页是否完整，保证从内存到磁盘刷新时内容的一致性。</p></li></ul><p>&amp;emsp;&amp;emsp;对于<code>File Trailer</code>我们不再做过多强调，全部忘记了的话可以到将数据页的那一章回顾一下。我们这里再强调一遍<code>File Header</code>的各个组成部分：</p><table><thead><tr><th align="center">名称</th><th align="center">占用空间大小</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td><td align="center"><code>4</code>字节</td><td align="center">页的校验和（checksum值）</td></tr><tr><td align="center"><code>FIL_PAGE_OFFSET</code></td><td align="center"><code>4</code>字节</td><td align="center">页号</td></tr><tr><td align="center"><code>FIL_PAGE_PREV</code></td><td align="center"><code>4</code>字节</td><td align="center">上一个页的页号</td></tr><tr><td align="center"><code>FIL_PAGE_NEXT</code></td><td align="center"><code>4</code>字节</td><td align="center">下一个页的页号</td></tr><tr><td align="center"><code>FIL_PAGE_LSN</code></td><td align="center"><code>8</code>字节</td><td align="center">页被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr><td align="center"><code>FIL_PAGE_TYPE</code></td><td align="center"><code>2</code>字节</td><td align="center">该页的类型</td></tr><tr><td align="center"><code>FIL_PAGE_FILE_FLUSH_LSN</code></td><td align="center"><code>8</code>字节</td><td align="center">仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td align="center"><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td><td align="center"><code>4</code>字节</td><td align="center">页属于哪个表空间</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;现在除了名称里边儿带有<code>LSN</code>的两个字段大家可能看不懂以外，其他的字段肯定都是倍儿熟了，不过我们仍要强调这么几点：</p><ul><li><p>表空间中的每一个页都对应着一个页号，也就是<code>FIL_PAGE_OFFSET</code>，这个页号由4个字节组成，也就是32个比特位，所以一个表空间最多可以拥有2³²个页，如果按照页的默认大小16KB来算，一个表空间最多支持64TB的数据。表空间的第一个页的页号为0，之后的页号分别是1，2，3…依此类推</p></li><li><p>某些类型的页可以组成链表，链表中的页可以不按照物理顺序存储，而是根据<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>来存储上一个页和下一个页的页号。需要注意的是，这两个字段主要是为了<code>INDEX</code>类型的页，也就是我们之前一直说的数据页建立<code>B+</code>树后，为每层节点建立双向链表用的，一般类型的页是不使用这两个字段的。</p></li><li><p>每个页的类型由<code>FIL_PAGE_TYPE</code>表示，比如像数据页的该字段的值就是<code>0x45BF</code>，我们后边会介绍各种不同类型的页，不同类型的页在该字段上的值是不同的。</p></li></ul><h2 id="独立表空间结构"><a href="#独立表空间结构" class="headerlink" title="独立表空间结构"></a>独立表空间结构</h2><p>&amp;emsp;&amp;emsp;我们知道<code>InnoDB</code>支持许多种类型的表空间，本章重点关注独立表空间和系统表空间的结构。它们的结构比较相似，但是由于系统表空间中额外包含了一些关于整个系统的信息，所以我们先挑简单一点的独立表空间来介绍，稍后再说系统表空间的结构。</p><h3 id="区（extent）的概念"><a href="#区（extent）的概念" class="headerlink" title="区（extent）的概念"></a>区（extent）的概念</h3><p>&amp;emsp;&amp;emsp;表空间中的页实在是太多了，为了更好的管理这些页，设计<code>InnoDB</code>的大佬们提出了<code>区</code>（英文名：<code>extent</code>）的概念。对于16KB的页来说，连续的64个页就是一个<code>区</code>，也就是说一个区默认占用1MB空间大小。不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组。画个图表示就是这样：</p><p><img src="/../images/09-02.png">  </p><p>&amp;emsp;&amp;emsp;其中<code>extent 0</code> ~ <code>extent 255</code>这256个区算是第一个组，<code>extent 256</code> ~ <code>extent 511</code>这256个区算是第二个组，<code>extent 512</code> ~ <code>extent 767</code>这256个区算是第三个组（上图中并未画全第三个组全部的区，请自行脑补），依此类推可以划分更多的组。这些组的头几个页的类型都是类似的，就像这样：</p><p><img src="/../images/09-03.png"></p><p>&amp;emsp;&amp;emsp;从上图中我们能得到如下信息：</p><ul><li><p>第一个组最开始的3个页的类型是固定的，也就是说<code>extent 0</code>这个区最开始的3个页的类型是固定的，分别是：</p><ul><li><p><code>FSP_HDR</code>类型：这个类型的页是用来登记整个表空间的一些整体属性以及本组所有的<code>区</code>，也就是<code>extent 0</code> ~ <code>extent 255</code>这256个区的属性，稍后详细介绍。需要注意的一点是，整个表空间只有一个<code>FSP_HDR</code>类型的页。</p></li><li><p><code>IBUF_BITMAP</code>类型：这个类型的页是存储本组所有的区的所有页关于<code>INSERT BUFFER</code>的信息。当然，你现在不用知道什么是个<code>INSERT BUFFER</code>，后边会详细说到你吐。</p></li><li><p><code>INODE</code>类型：这个类型的页存储了许多称为<code>INODE</code>的数据结构，还是那句话，现在你不需要知道什么是个<code>INODE</code>，后边儿会说到你吐。</p></li></ul></li><li><p>其余各组最开始的2个页的类型是固定的，也就是说<code>extent 256</code>、<code>extent 512</code>这些区最开始的2个页的类型是固定的，分别是：</p><ul><li><p><code>XDES</code>类型：全称是<code>extent descriptor</code>，用来登记本组256个区的属性，也就是说对于在<code>extent 256</code>区中的该类型页存储的就是<code>extent 256</code> ~ <code>extent 511</code>这些区的属性，对于在<code>extent 512</code>区中的该类型页存储的就是<code>extent 512</code> ~ <code>extent 767</code>这些区的属性。上面介绍的<code>FSP_HDR</code>类型的页其实和<code>XDES</code>类型的页的作用类似，只不过<code>FSP_HDR</code>类型的页还会额外存储一些表空间的属性。</p></li><li><p><code>IBUF_BITMAP</code>类型：上面介绍过了。</p></li></ul></li></ul><p>&amp;emsp;&amp;emsp;好了，宏观的结构介绍完了，里边儿的名词大家也不用记清楚，只要大致记得：表空间被划分为许多连续的<code>区</code>，每个区默认由64个页组成，每256个区划分为一组，每个组的最开始的几个页类型是固定的就好了。</p><h3 id="段（segment）的概念"><a href="#段（segment）的概念" class="headerlink" title="段（segment）的概念"></a>段（segment）的概念</h3><p>&amp;emsp;&amp;emsp;为什么好端端的提出一个<code>区</code>（<code>extent</code>）的概念呢？我们以前分析问题的套路都是这样的：表中的记录存储到页里边儿，然后页作为节点组成<code>B+</code>树，这个<code>B+</code>树就是索引，然后等等一堆聚簇索引和二级索引的区别。这套路也没什么不妥的呀～ </p><p>&amp;emsp;&amp;emsp;是的，如果我们表中数据量很少的话，比如说你的表中只有几十条、几百条数据的话，的确用不到<code>区</code>的概念，因为简单的几个页就能把对应的数据存储起来，但是你架不住表里的记录越来越多呀。</p><p>&amp;emsp;&amp;emsp;什么？？表里的记录多了又怎样？<code>B+</code>树的每一层中的页都会形成一个双向链表呀，<code>File Header</code>中的<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>字段不就是为了形成双向链表设置的么？</p><p>&amp;emsp;&amp;emsp;是的是的，您说的都对，从理论上说，不引入<code>区</code>的概念只使用<code>页</code>的概念对存储引擎的运行并没什么影响，但是我们来考虑一下下面这个场景：</p><ul><li>我们每向表中插入一条记录，本质上就是向该表的聚簇索引以及所有二级索引代表的<code>B+</code>树的节点中插入数据。而<code>B+</code>树的每一层中的页都会形成一个双向链表，如果是以<code>页</code>为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。我们介绍<code>B+</code>树索引的适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的<code>随机I/O</code>。再一次强调，磁盘的速度和内存的速度差了好几个数量级，<code>随机I/O</code>是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的<code>顺序I/O</code>。</li></ul><p>&amp;emsp;&amp;emsp;所以，所以，所以才引入了<code>区</code>（<code>extent</code>）的概念，一个区就是在物理位置上连续的64个页。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照<code>区</code>为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足填充满整个区），但是从性能角度看，可以消除很多的随机<code>I/O</code>，功大于过嘛！</p><p>&amp;emsp;&amp;emsp;事情到这里就结束了么？太天真了，我们提到的范围查询，其实是对<code>B+</code>树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以设计<code>InnoDB</code>的大佬们对<code>B+</code>树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的<code>区</code>，非叶子节点也有自己独有的<code>区</code>。存放叶子节点的区的集合就算是一个<code>段</code>（<code>segment</code>），存放非叶子节点的区的集合也算是一个<code>段</code>。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。</p><p>&amp;emsp;&amp;emsp;默认情况下一个使用<code>InnoDB</code>存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。设计<code>InnoDB</code>的大佬们都挺节俭的，当然也考虑到了这种情况。这个问题的症结在于到现在为止我们介绍的区都是非常<code>纯粹</code>的，也就是一个区被整个分配给某一个段，或者说区中的所有页都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页，那余下的页也不能挪作他用。现在为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，设计<code>InnoDB</code>的大佬们提出了一个碎片（fragment）区的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。所以此后为某个段分配存储空间的策略是这样的：</p><ul><li><p>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页为单位来分配存储空间的。</p></li><li><p>当某个段已经占用了32个碎片区页之后，就会以完整的区为单位来分配存储空间。</p></li></ul><p>&amp;emsp;&amp;emsp;所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页以及一些完整的区的集合。除了索引的叶子节点段和非叶子节点段之外，<code>InnoDB</code>中还有为存储一些特殊的数据而定义的段，比如回滚段，当然我们现在并不关心别的类型的段，现在只需要知道段是一些零散的页以及一些完整的区的集合就好了。</p><h3 id="区的分类"><a href="#区的分类" class="headerlink" title="区的分类"></a>区的分类</h3><p>&amp;emsp;&amp;emsp;通过上面一通介绍，大家知道了表空间的是由若干个区组成的，这些区大体上可以分为4种类型：</p><ul><li><p>空闲的区：现在还没有用到这个区中的任何页。</p></li><li><p>有剩余空间的碎片区：表示碎片区中还有可用的页。</p></li><li><p>没有剩余空间的碎片区：表示碎片区中的所有页都被使用，没有空闲页。</p></li><li><p>附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。</p></li></ul><p>&amp;emsp;&amp;emsp;这4种类型的区也可以被称为区的4种状态（<code>State</code>），设计<code>InnoDB</code>的大佬们为这4种状态的区定义了特定的名词儿：</p><table><thead><tr><th align="center">状态名</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>FREE</code></td><td align="center">空闲的区</td></tr><tr><td align="center"><code>FREE_FRAG</code></td><td align="center">有剩余空间的碎片区</td></tr><tr><td align="center"><code>FULL_FRAG</code></td><td align="center">没有剩余空间的碎片区</td></tr><tr><td align="center"><code>FSEG</code></td><td align="center">附属于某个段的区</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;需要再次强调一遍的是，处于<code>FREE</code>、<code>FREE_FRAG</code>以及<code>FULL_FRAG</code>这三种状态的区都是独立的，算是直属于表空间；而处于<code>FSEG</code>状态的区是附属于某个段的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于`FSEG`的区全都隶属于某个段，而处于`FREE`、`FREE_FRAG`以及`FULL_FRAG`这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;为了方便管理这些区，设计<code>InnoDB</code>的大佬设计了一个称为<code>XDES Entry</code>的结构（全称就是Extent Descriptor Entry），每一个区都对应着一个<code>XDES Entry</code>结构，这个结构记录了对应的区的一些属性。我们先看图来对这个结构有个大致的了解：</p><p><img src="/../images/09-04.png"></p><p>&amp;emsp;&amp;emsp;从图中我们可以看出，<code>XDES Entry</code>是一个40个字节的结构，大致分为4个部分，各个部分的释义如下：</p><ul><li><p><code>Segment ID</code>（8字节）</p><p>  &amp;emsp;&amp;emsp;每一个段都有一个唯一的编号，用ID表示，此处的<code>Segment ID</code>字段表示就是该区所在的段。当然前提是该区已经被分配给某个段了，不然的话该字段的值没什么意义。</p></li><li><p><code>List Node</code>（12字节）</p><p>  &amp;emsp;&amp;emsp;这个部分可以将若干个<code>XDES Entry</code>结构串联成一个链表，大家看一下这个<code>List Node</code>的结构：</p><p>  <img src="/../images/09-05.png"></p><p>  &amp;emsp;&amp;emsp;如果我们想定位表空间内的某一个位置的话，只需指定页号以及该位置在指定页号中的页内偏移量即可。所以：</p><ul><li><p><code>Pre Node Page Number</code>和<code>Pre Node Offset</code>的组合就是指向前一个<code>XDES Entry</code>的指针</p></li><li><p><code>Next Node Page Number</code>和<code>Next Node Offset</code>的组合就是指向后一个<code>XDES Entry</code>的指针。</p></li></ul><p>  &amp;emsp;&amp;emsp;把一些<code>XDES Entry</code>结构连成一个链表有什么用？稍安勿躁，我们稍后介绍<code>XDES Entry</code>结构组成的链表问题。  </p></li><li><p><code>State</code>（4字节）</p><p>  &amp;emsp;&amp;emsp;这个字段表明区的状态。可选的值就是我们前面说过的那4个，分别是：<code>FREE</code>、<code>FREE_FRAG</code>、<code>FULL_FRAG</code>和<code>FSEG</code>。具体释义就不多介绍了，前面说的够仔细了。</p></li><li><p><code>Page State Bitmap</code>（16字节）</p><p>  &amp;emsp;&amp;emsp;这个部分共占用16个字节，也就是128个比特位。我们说一个区默认有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，对应区中的一个页。比如<code>Page State Bitmap</code>部分的第1和第2个比特位对应着区中的第1个页，第3和第4个比特位对应着区中的第2个页，依此类推，<code>Page State Bitmap</code>部分的第127和128个比特位对应着区中的第64个页。这两个比特位的第一个位表示对应的页是否是空闲的，第二个比特位还没有用。</p></li></ul><h4 id="XDES-Entry链表"><a href="#XDES-Entry链表" class="headerlink" title="XDES Entry链表"></a>XDES Entry链表</h4><p>&amp;emsp;&amp;emsp;到现在为止，我们已经提出了五花八门的概念，什么区、段、碎片区、附属于段的区、<code>XDES Entry</code>结构等等的概念，走远了千万别忘了自己为什么出发，我们把事情搞这么麻烦的初心，仅仅是想提高向表插入数据的效率，又不至于数据量少的表浪费空间。现在我们知道向表中插入数据本质上就是向表中各个索引的叶子节点段、非叶子节点段插入数据，也知道了不同的区有不同的状态，再回到最初的起点，捋一捋向某个段中插入数据的过程：</p><ul><li><p>当段中数据较少的时候，首先会查看表空间中是否有状态为<code>FREE_FRAG</code>的区，也就是找还有空闲空间的碎片区，如果找到了，那么从该区中取一些零碎的页把数据插进去；否则到表空间下申请一个状态为<code>FREE</code>的区，也就是空闲的区，把该区的状态变为<code>FREE_FRAG</code>，然后从该新申请的区中取一些零碎的页把数据插进去。之后不同的段使用零碎页的时候都会从该区中取，直到该区中没有空闲空间，然后该区的状态就变成了<code>FULL_FRAG</code>。</p><p>  &amp;emsp;&amp;emsp;现在的问题是你怎么知道表空间里的哪些区是<code>FREE</code>的，哪些区的状态是<code>FREE_FRAG</code>的，哪些区是<code>FULL_FRAG</code>的？要知道表空间的大小是可以不断增大的，当增长到GB级别的时候，区的数量也就上千了，我们总不能每次都遍历这些区对应的<code>XDES Entry</code>结构吧？这时候就是<code>XDES Entry</code>中的<code>List Node</code>部分发挥奇效的时候了，我们可以通过<code>List Node</code>中的指针，做这么三件事：</p><ul><li><p>把状态为<code>FREE</code>的区对应的<code>XDES Entry</code>结构通过<code>List Node</code>来连接成一个链表，这个链表我们就称之为<code>FREE</code>链表。</p></li><li><p>把状态为<code>FREE_FRAG</code>的区对应的<code>XDES Entry</code>结构通过<code>List Node</code>来连接成一个链表，这个链表我们就称之为<code>FREE_FRAG</code>链表。</p></li><li><p>把状态为<code>FULL_FRAG</code>的区对应的<code>XDES Entry</code>结构通过<code>List Node</code>来连接成一个链表，这个链表我们就称之为<code>FULL_FRAG</code>链表。</p></li></ul><p>  &amp;emsp;&amp;emsp;这样每当我们想找一个<code>FREE_FRAG</code>状态的区时，就直接把<code>FREE_FRAG</code>链表的头节点拿出来，从这个节点中取一些零碎的页来插入数据，当这个节点对应的区用完时，就修改一下这个节点的<code>State</code>字段的值，然后从<code>FREE_FRAG</code>链表中移到<code>FULL_FRAG</code>链表中。同理，如果<code>FREE_FRAG</code>链表中一个节点都没有，那么就直接从<code>FREE</code>链表中取一个节点移动到<code>FREE_FRAG</code>链表的状态，并修改该节点的<code>STATE</code>字段值为<code>FREE_FRAG</code>，然后从这个节点对应的区中获取零碎的页就好了。  </p></li><li><p>当段中数据已经占满了32个零散的页后，就直接申请完整的区来插入数据了。</p><p>  &amp;emsp;&amp;emsp;还是那个问题，我们怎么知道哪些区属于哪个段的呢？再遍历各个<code>XDES Entry</code>结构？遍历是不可能遍历的，这辈子都不可能遍历的，有链表还遍历个毛线啊。所以我们把状态为<code>FSEG</code>的区对应的<code>XDES Entry</code>结构都加入到一个链表喽？傻呀，不同的段哪能共用一个区呢？你想把索引a的叶子节点段和索引b的叶子节点段都存储到一个区中么？显然我们想要每个段都有它独立的链表，所以可以根据段号（也就是<code>Segment ID</code>）来建立链表，有多少个段就建多少个链表？好像也有点问题，因为一个段中可以有好多个区，有的区是完全空闲的，有的区还有一些页可以用，有的区已经没有空闲页可以用了，所以我们有必要继续细分，设计<code>InnoDB</code>的大佬们为每个段中的区对应的<code>XDES Entry</code>结构建立了三个链表：</p><ul><li><p><code>FREE</code>链表：同一个段中，所有页都是空闲的区对应的<code>XDES Entry</code>结构会被加入到这个链表。注意和直属于表空间的<code>FREE</code>链表区别开了，此处的<code>FREE</code>链表是附属于某个段的。</p></li><li><p><code>NOT_FULL</code>链表：同一个段中，仍有空闲空间的区对应的<code>XDES Entry</code>结构会被加入到这个链表。</p></li><li><p><code>FULL</code>链表：同一个段中，已经没有空闲空间的区对应的<code>XDES Entry</code>结构会被加入到这个链表。</p></li></ul><p>  &amp;emsp;&amp;emsp;再次强调一遍，每一个索引都对应两个段，每个段都会维护上述的3个链表，比如下面这个表：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t (</span><br><span class="line">    c1 INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    c2 VARCHAR(100),</span><br><span class="line">    c3 VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (c1),</span><br><span class="line">    KEY idx_c2 (c2)</span><br><span class="line">)ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这个表<code>t</code>共有两个索引，一个聚簇索引，一个二级索引<code>idx_c2</code>，所以这个表共有4个段，每个段都会维护上述3个链表，总共是12个链表，加上我们上面说过的直属于表空间的3个链表，整个独立表空间共需要维护15个链表。所以段在数据量比较大时插入数据的话，会先获取<code>NOT_FULL</code>链表的头节点，直接把数据插入这个头节点对应的区中即可，如果该区的空间已经被用完，就把该节点移到<code>FULL</code>链表中。</p></li></ul><h4 id="链表基节点"><a href="#链表基节点" class="headerlink" title="链表基节点"></a>链表基节点</h4><p>&amp;emsp;&amp;emsp;上面光是介绍了一堆链表，可我们怎么找到这些链表呢，或者说怎么找到某个链表的头节点或者尾节点在表空间中的位置呢？设计<code>InnoDB</code>的大佬当然考虑了这个问题，他们设计了一个叫<code>List Base Node</code>的结构，翻译成中文就是链表的基节点。这个结构中包含了链表的头节点和尾节点的指针以及这个链表中包含了多少节点的信息，我们画图看一下这个结构的示意图：</p><p><img src="/../images/09-06.png"></p><p>&amp;emsp;&amp;emsp;我们上面介绍的每个链表都对应这么一个<code>List Base Node</code>结构，其中：</p><ul><li><p><code>List Length</code>表明该链表一共有多少节点，</p></li><li><p><code>First Node Page Number</code>和<code>First Node Offset</code>表明该链表的头节点在表空间中的位置。</p></li><li><p><code>Last Node Page Number</code>和<code>Last Node Offset</code>表明该链表的尾节点在表空间中的位置。</p></li></ul><p>&amp;emsp;&amp;emsp;一般我们把某个链表对应的<code>List Base Node</code>结构放置在表空间中固定的位置，这样想找定位某个链表就变得so easy啦。</p><h4 id="链表小结"><a href="#链表小结" class="headerlink" title="链表小结"></a>链表小结</h4><p>&amp;emsp;&amp;emsp;综上所述，表空间是由若干个区组成的，每个区都对应一个<code>XDES Entry</code>的结构，直属于表空间的区对应的<code>XDES Entry</code>结构可以分成<code>FREE</code>、<code>FREE_FRAG</code>和<code>FULL_FRAG</code>这3个链表；每个段可以附属若干个区，每个段中的区对应的<code>XDES Entry</code>结构可以分成<code>FREE</code>、<code>NOT_FULL</code>和<code>FULL</code>这3个链表。每个链表都对应一个<code>List Base Node</code>的结构，这个结构里记录了链表的头、尾节点的位置以及该链表中包含的节点数。正是因为这些链表的存在，管理这些区才变成了一件so easy的事情。</p><h3 id="段的结构"><a href="#段的结构" class="headerlink" title="段的结构"></a>段的结构</h3><p>&amp;emsp;&amp;emsp;我们前面说过，段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页以及一些完整的区组成。像每个区都有对应的<code>XDES Entry</code>来记录这个区中的属性一样，设计<code>InnoDB</code>的大佬为每个段都定义了一个<code>INODE Entry</code>结构来记录一下段中的属性。大家看一下示意图：</p><p><img src="/../images/09-07.png"></p><p>它的各个部分释义如下：</p><ul><li><p><code>Segment ID</code></p><p>  &amp;emsp;&amp;emsp;就是指这个<code>INODE Entry</code>结构对应的段的编号（ID）。</p></li><li><p><code>NOT_FULL_N_USED</code></p><p>  &amp;emsp;&amp;emsp;这个字段指的是在<code>NOT_FULL</code>链表中已经使用了多少个页。下次从<code>NOT_FULL</code>链表分配空闲页时可以直接根据这个字段的值定位到。而不用从链表中的第一个页开始遍历着寻找空闲页。</p></li><li><p>3个<code>List Base Node</code></p><p>  &amp;emsp;&amp;emsp;分别为段的<code>FREE</code>链表、<code>NOT_FULL</code>链表、<code>FULL</code>链表定义了<code>List Base Node</code>，这样我们想查找某个段的某个链表的头节点和尾节点的时候，就可以直接到这个部分找到对应链表的<code>List Base Node</code>。so easy!</p></li><li><p><code>Magic Number</code>：</p><p>  &amp;emsp;&amp;emsp;这个值是用来标记这个<code>INODE Entry</code>是否已经被初始化了（初始化的意思就是把各个字段的值都填进去了）。如果这个数字是值的<code>97937874</code>，表明该<code>INODE Entry</code>已经初始化，否则没有被初始化。（不用纠结这个值有什么特殊含义，人家规定的）。</p></li><li><p><code>Fragment Array Entry</code></p><p>  &amp;emsp;&amp;emsp;我们前面强调过无数次：段是一些零散页和一些完整的区的集合，每个<code>Fragment Array Entry</code>结构都对应着一个零散的页，这个结构一共4个字节，表示一个零散页的页号。</p></li></ul><p>&amp;emsp;&amp;emsp;结合着这个<code>INODE Entry</code>结构，大家可能对段是一些零散页和一些完整的区的集合的理解再次深刻一些。</p><h3 id="各类型页详细情况"><a href="#各类型页详细情况" class="headerlink" title="各类型页详细情况"></a>各类型页详细情况</h3><p>&amp;emsp;&amp;emsp;到现在为止我们已经大概清楚了表空间、段、区、XDES Entry、INODE Entry、各种以<code>XDES Enty</code>为节点的链表的基本概念了，可是总有一种飞在天上不踏实的感觉，每个区对应的<code>XDES Entry</code>结构到底存储在表空间的什么地方？直属于表空间的<code>FREE</code>、<code>FREE_FRAG</code>、<code>FULL_FRAG</code>链表的基节点到底存储在表空间的什么地方？每个段对应的<code>INODE Entry</code>结构到底存在表空间的什么地方？我们前面介绍了每256个连续的区算是一个组，想解决刚才提出来的这些个疑问还得从每个组开头的一些类型相同的页说起，接下来我们一个页一个页的分析，真相马上就要浮出水面了。</p><h4 id="FSP-HDR类型"><a href="#FSP-HDR类型" class="headerlink" title="FSP_HDR类型"></a><code>FSP_HDR</code>类型</h4><p>&amp;emsp;&amp;emsp;首先看第一个组的第一个页，当然也是表空间的第一个页，页号为<code>0</code>。这个页的类型是<code>FSP_HDR</code>，它存储了表空间的一些整体属性以及第一个组内256个区的对应的<code>XDES Entry</code>结构，直接看这个类型的页的示意图：</p><p><img src="/../images/09-08.png"></p><p>&amp;emsp;&amp;emsp;从图中可以看出，一个完整的<code>FSP_HDR</code>类型的页大致由5个部分组成，各个部分的具体释义如下表：</p><table><thead><tr><th align="center">名称</th><th align="center">中文名</th><th align="center">占用空间大小</th><th align="center">简单描述</th></tr></thead><tbody><tr><td align="center"><code>File Header</code></td><td align="center">文件头部</td><td align="center"><code>38</code>字节</td><td align="center">页的一些通用信息</td></tr><tr><td align="center"><code>File Space Header</code></td><td align="center">表空间头部</td><td align="center"><code>112</code>字节</td><td align="center">表空间的一些整体属性信息</td></tr><tr><td align="center"><code>XDES Entry</code></td><td align="center">区描述信息</td><td align="center"><code>10240</code>字节</td><td align="center">存储本组256个区对应的属性信息</td></tr><tr><td align="center"><code>Empty Space</code></td><td align="center">尚未使用空间</td><td align="center"><code>5986</code>字节</td><td align="center">用于页结构的填充，没什么实际意义</td></tr><tr><td align="center"><code>File Trailer</code></td><td align="center">文件尾部</td><td align="center"><code>8</code>字节</td><td align="center">校验页是否完整</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;<code>File Header</code>和<code>File Trailer</code>就不再强调了，另外的几个部分中，<code>Empty Space</code>是尚未使用的空间，我们不用管它，重点来看看<code>File Space Header</code>和<code>XDES Entry</code>这两个部分。</p><h5 id="File-Space-Header部分"><a href="#File-Space-Header部分" class="headerlink" title="File Space Header部分"></a>File Space Header部分</h5><p>&amp;emsp;&amp;emsp;从名字就可以看出来，这个部分是用来存储表空间的一些整体属性的，废话少说，看图：</p><p><img src="/../images/09-09.png"></p><p>&amp;emsp;&amp;emsp;哇唔，字段有点儿多哦，不急一个一个慢慢看。下面是各个属性的简单描述：</p><table><thead><tr><th align="center">名称</th><th align="center">占用空间大小</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>Space ID</code></td><td align="center"><code>4</code>字节</td><td align="center">表空间的ID</td></tr><tr><td align="center"><code>Not Used</code></td><td align="center"><code>4</code>字节</td><td align="center">这4个字节未被使用，可以忽略</td></tr><tr><td align="center"><code>Size</code></td><td align="center"><code>4</code>字节</td><td align="center">当前表空间占有的页数</td></tr><tr><td align="center"><code>FREE Limit</code></td><td align="center"><code>4</code>字节</td><td align="center">尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入FREE链表</td></tr><tr><td align="center"><code>Space Flags</code></td><td align="center"><code>4</code>字节</td><td align="center">表空间的一些占用存储空间比较小的属性</td></tr><tr><td align="center"><code>FRAG_N_USED</code></td><td align="center"><code>4</code>字节</td><td align="center">FREE_FRAG链表中已使用的页数量</td></tr><tr><td align="center"><code>List Base Node for FREE List</code></td><td align="center"><code>16</code>字节</td><td align="center">FREE链表的基节点</td></tr><tr><td align="center"><code>List Base Node for FREE_FRAG List</code></td><td align="center"><code>16</code>字节</td><td align="center">FREE_FREG链表的基节点</td></tr><tr><td align="center"><code>List Base Node for FULL_FRAG List</code></td><td align="center"><code>16</code>字节</td><td align="center">FULL_FREG链表的基节点</td></tr><tr><td align="center"><code>Next Unused Segment ID</code></td><td align="center"><code>8</code>字节</td><td align="center">当前表空间中下一个未使用的 Segment ID</td></tr><tr><td align="center"><code>List Base Node for SEG_INODES_FULL List</code></td><td align="center"><code>16</code>字节</td><td align="center">SEG_INODES_FULL链表的基节点</td></tr><tr><td align="center"><code>List Base Node for SEG_INODES_FREE List</code></td><td align="center"><code>16</code>字节</td><td align="center">SEG_INODES_FREE链表的基节点</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;这里头的<code>Space ID</code>、<code>Not Used</code>、<code>Size</code>这三个字段大家肯定一看就懂，其他的字段我们再详细看看，为了大家的阅读体验，我就不严格按照实际的字段顺序来解释各个字段了。</p><ul><li><p><code>List Base Node for FREE List</code>、<code>List Base Node for FREE_FRAG List</code>、<code>List Base Node for FULL_FRAG List</code>。</p><p>  &amp;emsp;&amp;emsp;这三个大家看着太亲切了，分别是直属于表空间的<code>FREE</code>链表的基节点、<code>FREE_FRAG</code>链表的基节点、<code>FULL_FRAG</code>链表的基节点，这三个链表的基节点在表空间的位置是固定的，就是在表空间的第一个页（也就是<code>FSP_HDR</code>类型的页）的<code>File Space Header</code>部分。所以之后定位这几个链表就so easy啦。</p></li><li><p><code>FRAG_N_USED</code></p><p>  &amp;emsp;&amp;emsp;这个字段表明在<code>FREE_FRAG</code>链表中已经使用的页数量，方便之后在链表中查找空闲的页。</p></li><li><p><code>FREE Limit</code></p><p>  &amp;emsp;&amp;emsp;我们知道表空间都对应着具体的磁盘文件，一开始我们创建表空间的时候对应的磁盘文件中都没有数据，所以我们需要对表空间完成一个初始化操作，包括为表空间中的区建立<code>XDES Entry</code>结构，为各个段建立<code>INODE Entry</code>结构，建立各种链表等等的各种操作。我们可以一开始就为表空间申请一个特别大的空间，但是实际上有绝大部分的区是空闲的，我们可以选择把所有的这些空闲区对应的<code>XDES Entry</code>结构加入<code>FREE</code>链表，也可以选择只把一部分的空闲区加入<code>FREE</code>链表，等什么时候空闲链表中的<code>XDES Entry</code>结构对应的区不够使了，再把之前没有加入<code>FREE</code>链表的空闲区对应的<code>XDES Entry</code>结构加入<code>FREE</code>链表，中心思想就是什么时候用到什么时候初始化，设计<code>InnoDB</code>的大佬采用的就是后者，他们为表空间定义了<code>FREE Limit</code>这个字段，在该字段表示的页号之前的区都被初始化了，之后的区尚未被初始化。</p></li><li><p><code>Next Unused Segment ID</code></p><p>  &amp;emsp;&amp;emsp;表中每个索引都对应2个段，每个段都有一个唯一的ID，那当我们为某个表新创建一个索引的时候，就意味着要创建两个新的段。那怎么为这个新创建的段找一个唯一的ID呢？去遍历现在表空间中所有的段么？我们说过，遍历是不可能遍历的，这辈子都不可能遍历，所以设计<code>InnoDB</code>的大佬们提出了这个名叫<code>Next Unused Segment ID</code>的字段，该字段表明当前表空间中最大的段ID的下一个ID，这样在创建新段的时候赋予新段一个唯一的ID值就so easy啦，直接使用这个字段的值就好了。</p></li><li><p><code>Space Flags</code></p><p>&amp;emsp;&amp;emsp;表空间对于一些布尔类型的属性，或者只需要寥寥几个比特位搞定的属性都放在了这个<code>Space Flags</code>中存储，虽然它只有4个字节，32个比特位大小，却存储了好多表空间的属性，详细情况如下表：</p></li></ul><table><thead><tr><th align="center">标志名称</th><th align="center">占用的空间（单位：bit）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>POST_ANTELOPE</code></td><td align="center">1</td><td align="center">表示文件格式是否大于<code>ANTELOPE</code></td></tr><tr><td align="center"><code>ZIP_SSIZE</code></td><td align="center">4</td><td align="center">表示压缩页的大小</td></tr><tr><td align="center"><code>ATOMIC_BLOBS</code></td><td align="center">1</td><td align="center">表示是否自动把值非常长的字段放到BLOB页里</td></tr><tr><td align="center"><code>PAGE_SSIZE</code></td><td align="center">4</td><td align="center">页大小</td></tr><tr><td align="center"><code>DATA_DIR</code></td><td align="center">1</td><td align="center">表示表空间是否是从默认的数据目录中获取的</td></tr><tr><td align="center"><code>SHARED</code></td><td align="center">1</td><td align="center">是否为共享表空间</td></tr><tr><td align="center"><code>TEMPORARY</code></td><td align="center">1</td><td align="center">是否为临时表空间</td></tr><tr><td align="center"><code>ENCRYPTION</code></td><td align="center">1</td><td align="center">表空间是否加密</td></tr><tr><td align="center"><code>UNUSED</code></td><td align="center">18</td><td align="center">没有使用到的比特位</td></tr></tbody></table>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：不同MySQL版本里 SPACE_FLAGS 代表的属性可能有些差异，我们这里列举的是5.7.21版本的。不过大家现在不必深究它们的意思，因为我们一旦把这些概念 展开，就需要非常大的篇幅，主要怕大家受不了。我们还是先挑重要的看，把主要的表空间结构了解完，这些 SPACE_FLAGS 里的属性的细节就暂时不深究了。</span><br></pre></td></tr></table></figure><ul><li><p><code>List Base Node for SEG_INODES_FULL List</code>和<code>List Base Node for SEG_INODES_FREE List</code></p><p>  &amp;emsp;&amp;emsp;每个段对应的<code>INODE Entry</code>结构会集中存放到一个类型位<code>INODE</code>的页中，如果表空间中的段特别多，则会有多个<code>INODE Entry</code>结构，可能一个页放不下，这些<code>INODE</code>类型的页会组成两种列表：</p><ul><li><p><code>SEG_INODES_FULL</code>链表，该链表中的<code>INODE</code>类型的页都已经被<code>INODE Entry</code>结构填充满了，没空闲空间存放额外的<code>INODE Entry</code>了。</p></li><li><p><code>SEG_INODES_FREE</code>链表，该链表中的<code>INODE</code>类型的页都已经仍有空闲空间来存放<code>INODE Entry</code>结构。</p></li></ul><p>  &amp;emsp;&amp;emsp;由于我们现在还没有详细介绍<code>INODE</code>类型页，所以等会说过<code>INODE</code>类型的页之后再回过头来看着两个链表。</p></li></ul><h5 id="XDES-Entry部分"><a href="#XDES-Entry部分" class="headerlink" title="XDES Entry部分"></a>XDES Entry部分</h5><p>&amp;emsp;&amp;emsp;紧接着<code>File Space Header</code>部分的就是<code>XDES Entry</code>部分了，我们嘴上介绍过无数次，却从没见过真身的<code>XDES Entry</code>就是在表空间的第一个页中保存的。我们知道一个<code>XDES Entry</code>结构的大小是40字节，但是一个页的大小有限，只能存放有限个<code>XDES Entry</code>结构，所以我们才把256个区划分成一组，在每组的第一个页中存放256个<code>XDES Entry</code>结构。大家回看那个<code>FSP_HDR</code>类型页的示意图，<code>XDES Entry 0</code>就对应着<code>extent 0</code>，<code>XDES Entry 1</code>就对应着<code>extent 1</code>… 依此类推，<code>XDES Entry255</code>就对应着<code>extent 255</code>。</p><p>&amp;emsp;&amp;emsp;因为每个区对应的<code>XDES Entry</code>结构的地址是固定的，所以我们访问这些结构就so easy啦，至于该结构的详细使用情况我们已经介绍的够明白了，在这就不赘述了。</p><h4 id="XDES类型"><a href="#XDES类型" class="headerlink" title="XDES类型"></a><code>XDES</code>类型</h4><p>&amp;emsp;&amp;emsp;我们说过，每一个<code>XDES Entry</code>结构对应表空间的一个区，虽然一个<code>XDES Entry</code>结构只占用40字节，但你抵不住表空间的区的数量也多啊。在区的数量非常多时，一个单独的页可能就不够存放足够多的<code>XDES Entry</code>结构，所以我们把表空间的区分为了若干个组，每组开头的一个页记录着本组内所有的区对应的<code>XDES Entry</code>结构。由于第一个组的第一个页有些特殊，因为它也是整个表空间的第一个页，所以除了记录本组中的所有区对应的<code>XDES Entry</code>结构以外，还记录着表空间的一些整体属性，这个页的类型就是我们刚刚说完的<code>FSP_HDR</code>类型，整个表空间里只有一个这个类型的页。除去第一个分组以外，之后的每个分组的第一个页只需要记录本组内所有的区对应的<code>XDES Entry</code>结构即可，不需要再记录表空间的属性了，为了和<code>FSP_HDR</code>类型做区别，我们把之后每个分组的第一个页的类型定义为<code>XDES</code>，它的结构和<code>FSP_HDR</code>类型是非常相似的：</p><p><img src="/../images/09-10.png"></p><p>&amp;emsp;&amp;emsp;与<code>FSP_HDR</code>类型的页对比，除了少了<code>File Space Header</code>部分之外，也就是除了少了记录表空间整体属性的部分之外，其余的部分是一样一样的。由于我们上面介绍的已经够仔细了，对于<code>XDES</code>类型的页也就不重复介绍了。</p><h4 id="IBUF-BITMAP类型"><a href="#IBUF-BITMAP类型" class="headerlink" title="IBUF_BITMAP类型"></a><code>IBUF_BITMAP</code>类型</h4><p>&amp;emsp;&amp;emsp;对比前面介绍表空间的图，每个分组的第二个页的类型都是<code>IBUF_BITMAP</code>，这种类型的页里边记录了一些有关<code>Change Buffer</code>的东东，由于这个<code>Change Buffer</code>里又包含了贼多的概念，考虑到大家在一章中接受这么多新概念有点呼吸不适，怕大家心脏病犯了所以就把<code>Change Buffer</code>的相关知识放到后边的章节中，大家稍安勿躁。</p><h4 id="INODE类型"><a href="#INODE类型" class="headerlink" title="INODE类型"></a><code>INODE</code>类型</h4><p>&amp;emsp;&amp;emsp;再次对比前面介绍表空间的图，第一个分组的第三个页的类型是<code>INODE</code>。我们前面说过设计<code>InnoDB</code>的大佬为每个索引定义了两个段，而且为某些特殊功能定义了些特殊的段。为了方便管理，他们又为每个段设计了一个<code>INODE Entry</code>结构，这个结构中记录了关于这个段的相关属性。而我们这会儿要介绍的这个<code>INODE</code>类型的页就是为了存储<code>INODE Entry</code>结构而存在的。好了，废话少说，直接看图：</p><p><img src="/../images/09-11.png"></p><p>&amp;emsp;&amp;emsp;从图中可以看出，一个<code>INODE</code>类型的页是由这几部分构成的：</p><table><thead><tr><th align="center">名称</th><th align="center">中文名</th><th align="center">占用空间大小</th><th align="center">简单描述</th></tr></thead><tbody><tr><td align="center"><code>File Header</code></td><td align="center">文件头部</td><td align="center"><code>38</code>字节</td><td align="center">页的一些通用信息</td></tr><tr><td align="center"><code>List Node for INODE Page List</code></td><td align="center">通用链表节点</td><td align="center"><code>12</code>字节</td><td align="center">存储上一个INODE页和下一个INODE页的指针</td></tr><tr><td align="center"><code>INODE Entry</code></td><td align="center">段描述信息</td><td align="center"><code>16128</code>字节</td><td align="center"></td></tr><tr><td align="center"><code>Empty Space</code></td><td align="center">尚未使用空间</td><td align="center"><code>6</code>字节</td><td align="center">用于页结构的填充，没什么实际意义</td></tr><tr><td align="center"><code>File Trailer</code></td><td align="center">文件尾部</td><td align="center"><code>8</code>字节</td><td align="center">校验页是否完整</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;除了<code>File Header</code>、<code>Empty Space</code>、<code>File Trailer</code>这几个老朋友外，我们重点关注<code>List Node for INODE Page List</code>和<code>INODE Entry</code>这两个部分。</p><p>&amp;emsp;&amp;emsp;首先看<code>INODE Entry</code>部分，我们前面已经详细介绍过这个结构的组成了，主要包括对应的段内零散页的地址以及附属于该段的<code>FREE</code>、<code>NOT_FULL</code>和<code>FULL</code>链表的基节点。每个<code>INODE Entry</code>结构占用192字节，一个页里可以存储<code>85</code>个这样的结构。</p><p>&amp;emsp;&amp;emsp;重点看一下<code>List Node for INODE Page List</code>这个玩意儿，因为一个表空间中可能存在超过85个段，所以可能一个<code>INODE</code>类型的页不足以存储所有的段对应的<code>INODE Entry</code>结构，所以就需要额外的<code>INODE</code>类型的页来存储这些结构。还是为了方便管理这些<code>INODE</code>类型的页，设计<code>InnoDB</code>的大佬们将这些<code>INODE</code>类型的页串联成两个不同的链表：</p><ul><li><p><code>SEG_INODES_FULL</code>链表：该链表中的<code>INODE</code>类型的页中已经没有空闲空间来存储额外的<code>INODE Entry</code>结构了。</p></li><li><p><code>SEG_INODES_FREE</code>链表：该链表中的<code>INODE</code>类型的页中还有空闲空间来存储额外的<code>INODE Entry</code>结构了。</p></li></ul><p>&amp;emsp;&amp;emsp;想必大家已经认出这两个链表了，我们前面提到过这两个链表的基节点就存储在<code>File Space Header</code>里边，也就是说这两个链表的基节点的位置是固定的，所以我们可以很轻松的访问到这两个链表。以后每当我们新创建一个段（创建索引时就会创建段）时，都会创建一个<code>INODE Entry</code>结构与之对应，存储<code>INODE Entry</code>的大致过程就是这样的：</p><ul><li><p>先看看<code>SEG_INODES_FREE</code>链表是否为空，如果不为空，直接从该链表中获取一个节点，也就相当于获取到一个仍有空闲空间的<code>INODE</code>类型的页，然后把该<code>INODE Entry</code>结构防到该页中。当该页中无剩余空间时，就把该页放到<code>SEG_INODES_FULL</code>链表中。</p></li><li><p>如果<code>SEG_INODES_FREE</code>链表为空，则需要从表空间的<code>FREE_FRAG</code>链表中申请一个页，修改该页的类型为<code>INODE</code>，把该页放到<code>SEG_INODES_FREE</code>链表中，与此同时把该<code>INODE Entry</code>结构放入该页。</p></li></ul><h3 id="Segment-Header-结构的运用"><a href="#Segment-Header-结构的运用" class="headerlink" title="Segment Header 结构的运用"></a>Segment Header 结构的运用</h3><p>&amp;emsp;&amp;emsp;我们知道一个索引会产生两个段，分别是叶子节点段和非叶子节点段，而每个段都会对应一个<code>INODE Entry</code>结构，那我们怎么知道某个段对应哪个<code>INODE Entry</code>结构呢？所以得找个地方记下来这个对应关系。希望你还记得我们在介绍数据页，也就是<code>INDEX</code>类型的页时有一个<code>Page Header</code>部分，当然我不能指望你记住，所以把<code>Page Header</code>部分再抄一遍给你看：</p><center><b>Page Header部分</b>（为突出重点，省略了好多属性）</center><table><thead><tr><th align="center">名称</th><th align="center">占用空间大小</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td></tr><tr><td align="center"><code>PAGE_BTR_SEG_LEAF</code></td><td align="center"><code>10</code>字节</td><td align="center">B+树叶子段的头部信息，仅在B+树的根页定义</td></tr><tr><td align="center"><code>PAGE_BTR_SEG_TOP</code></td><td align="center"><code>10</code>字节</td><td align="center">B+树非叶子段的头部信息，仅在B+树的根页定义</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;其中的<code>PAGE_BTR_SEG_LEAF</code>和<code>PAGE_BTR_SEG_TOP</code>都占用10个字节，它们其实对应一个叫<code>Segment Header</code>的结构，该结构图示如下：</p><p><img src="/../images/09-12.png"></p><p>&amp;emsp;&amp;emsp;各个部分的具体释义如下：</p><table><thead><tr><th align="center">名称</th><th align="center">占用字节数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>Space ID of the INODE Entry </code></td><td align="center"><code>4</code></td><td align="center">INODE Entry结构所在的表空间ID</td></tr><tr><td align="center"><code>Page Number of the INODE Entry </code></td><td align="center"><code>4</code></td><td align="center">INODE Entry结构所在的页页号</td></tr><tr><td align="center"><code>Byte Offset of the INODE Ent</code></td><td align="center"><code>2</code></td><td align="center">INODE Entry结构在该页中的偏移量</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;这样子就很清晰了，<code>PAGE_BTR_SEG_LEAF</code>记录着叶子节点段对应的<code>INODE Entry</code>结构的地址是哪个表空间的哪个页的哪个偏移量，<code>PAGE_BTR_SEG_TOP</code>记录着非叶子节点段对应的<code>INODE Entry</code>结构的地址是哪个表空间的哪个页的哪个偏移量。这样子索引和其对应的段的关系就建立起来了。不过需要注意的一点是，因为一个索引只对应两个段，所以只需要在索引的根页中记录这两个结构即可。</p><h3 id="真实表空间对应的文件大小"><a href="#真实表空间对应的文件大小" class="headerlink" title="真实表空间对应的文件大小"></a>真实表空间对应的文件大小</h3><p>&amp;emsp;&amp;emsp;等会儿等会儿，上面的这些概念已经压的快喘不过气了。不过独立表空间有那么大么？我到数据目录里看了，一个新建的表对应的<code>.ibd</code>文件只占用了96K，才6个页大小，上面的内容该不是扯犊子吧？</p><p>&amp;emsp;&amp;emsp;一开始表空间占用的空间自然是很小，因为表里边都没有数据嘛！不过别忘了这些<code>.ibd</code>文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。</p><h2 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h2><p>&amp;emsp;&amp;emsp;了解完了独立表空间的基本结构，系统表空间的结构也就好理解多了，系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页，所以会比独立表空间多出一些记录这些信息的页。因为这个系统表空间最牛逼，相当于是表空间之首，所以它的<code>表空间 ID</code>（Space ID）是<code>0</code>。</p><h3 id="系统表空间的整体结构"><a href="#系统表空间的整体结构" class="headerlink" title="系统表空间的整体结构"></a>系统表空间的整体结构</h3><p>&amp;emsp;&amp;emsp;系统表空间与独立表空间的一个非常明显的不同之处就是在表空间开头有许多记录整个系统属性的页，如图：</p><p><img src="/../images/09-13.png"></p><p>&amp;emsp;&amp;emsp;可以看到，系统表空间和独立表空间的前三个页（页号分别为<code>0</code>、<code>1</code>、<code>2</code>，类型分别是<code>FSP_HDR</code>、<code>IBUF_BITMAP</code>、<code>INODE</code>）的类型是一致的，只是页号为<code>3</code>～<code>7</code>的页是系统表空间特有的，我们来看一下这些多出来的页都是干什么使的：</p><table><thead><tr><th align="center">页号</th><th align="center">页类型</th><th align="center">英文描述</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>3</code></td><td align="center"><code>SYS</code></td><td align="center">Insert Buffer Header</td><td align="left">存储Insert Buffer的头部信息</td></tr><tr><td align="center"><code>4</code></td><td align="center"><code>INDEX</code></td><td align="center">Insert Buffer Root</td><td align="left">存储Insert Buffer的根页</td></tr><tr><td align="center"><code>5</code></td><td align="center"><code>TRX_SYS</code></td><td align="center">Transction System</td><td align="left">事务系统的相关信息</td></tr><tr><td align="center"><code>6</code></td><td align="center"><code>SYS</code></td><td align="center">First Rollback Segment</td><td align="left">第一个回滚段的页</td></tr><tr><td align="center"><code>7</code></td><td align="center"><code>SYS</code></td><td align="center">Data Dictionary Header</td><td align="left">数据字典头部信息</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;除了这几个记录系统属性的页之外，系统表空间的<code>extent 1</code>和<code>extent 2</code>这两个区，也就是页号从<code>64</code>~&#96;191<code>这128个页被称为</code>Doublewrite buffer&#96;，也就是双写缓冲区。不过上述的大部分知识都涉及到了事务和多版本控制的问题，这些问题我们会放在后边的章节集中介绍，现在讲述太影响用户体验，所以现在我们只介绍一下有关InnoDB数据字典的知识，其余的概念在后边再看。</p><h4 id="InnoDB数据字典"><a href="#InnoDB数据字典" class="headerlink" title="InnoDB数据字典"></a>InnoDB数据字典</h4><p>&amp;emsp;&amp;emsp;我们平时使用<code>INSERT</code>语句向表中插入的那些记录称之为用户数据，MySQL只是作为一个软件来为我们来保管这些数据，提供方便的增删改查接口而已。但是每当我们向一个表中插入一条记录的时候，MySQL先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页是哪个表空间的哪个页，然后把记录插入对应索引的<code>B+</code>树中。所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：</p><ul><li><p>某个表属于哪个表空间，表里边有多少列</p></li><li><p>表对应的每一个列的类型是什么</p></li><li><p>该表有多少索引，每个索引对应哪几个字段，该索引对应的根页在哪个表空间的哪个页</p></li><li><p>该表有哪些外键，外键对应哪个表的哪些列</p></li><li><p>某个表空间对应文件系统上文件路径是什么</p></li><li><p>balabala … 还有好多，不一一列举了</p></li></ul><p>&amp;emsp;&amp;emsp;上述这些数据并不是我们使用<code>INSERT</code>语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为<code>元数据</code>。InnoDB存储引擎特意定义了一些列的内部系统表（internal system table）来记录这些这些<code>元数据</code>：</p><table><thead><tr><th align="center">表名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>SYS_TABLES</code></td><td align="center">整个InnoDB存储引擎中所有的表的信息</td></tr><tr><td align="center"><code>SYS_COLUMNS</code></td><td align="center">整个InnoDB存储引擎中所有的列的信息</td></tr><tr><td align="center"><code>SYS_INDEXES</code></td><td align="center">整个InnoDB存储引擎中所有的索引的信息</td></tr><tr><td align="center"><code>SYS_FIELDS</code></td><td align="center">整个InnoDB存储引擎中所有的索引对应的列的信息</td></tr><tr><td align="center"><code>SYS_FOREIGN</code></td><td align="center">整个InnoDB存储引擎中所有的外键的信息</td></tr><tr><td align="center"><code>SYS_FOREIGN_COLS</code></td><td align="center">整个InnoDB存储引擎中所有的外键对应列的信息</td></tr><tr><td align="center"><code>SYS_TABLESPACES</code></td><td align="center">整个InnoDB存储引擎中所有的表空间信息</td></tr><tr><td align="center"><code>SYS_DATAFILES</code></td><td align="center">整个InnoDB存储引擎中所有的表空间对应文件系统的文件路径信息</td></tr><tr><td align="center"><code>SYS_VIRTUAL</code></td><td align="center">整个InnoDB存储引擎中所有的虚拟生成列的信息</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;这些系统表也被称为<code>数据字典</code>，它们都是以<code>B+</code>树的形式保存在系统表空间的某些页中，其中<code>SYS_TABLES</code>、<code>SYS_COLUMNS</code>、<code>SYS_INDEXES</code>、<code>SYS_FIELDS</code>这四个表尤其重要，称之为基本系统表（basic system tables），我们先看看这4个表的结构：</p><h5 id="SYS-TABLES表"><a href="#SYS-TABLES表" class="headerlink" title="SYS_TABLES表"></a>SYS_TABLES表</h5><center><b>SYS_TABLES表的列</b></center><table><thead><tr><th align="center">列名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>NAME</code></td><td align="center">表的名称</td></tr><tr><td align="center"><code>ID</code></td><td align="center">InnoDB存储引擎中每个表都有一个唯一的ID</td></tr><tr><td align="center"><code>N_COLS</code></td><td align="center">该表拥有列的个数</td></tr><tr><td align="center"><code>TYPE</code></td><td align="center">表的类型，记录了一些文件格式、行格式、压缩等信息</td></tr><tr><td align="center"><code>MIX_ID</code></td><td align="center">已过时，忽略</td></tr><tr><td align="center"><code>MIX_LEN</code></td><td align="center">表的一些额外的属性</td></tr><tr><td align="center"><code>CLUSTER_ID</code></td><td align="center">未使用，忽略</td></tr><tr><td align="center"><code>SPACE</code></td><td align="center">该表所属表空间的ID</td></tr></tbody></table><p>这个<code>SYS_TABLES</code>表有两个索引：</p><ul><li><p>以<code>NAME</code>列为主键的聚簇索引</p></li><li><p>以<code>ID</code>列建立的二级索引</p></li></ul><h5 id="SYS-COLUMNS表"><a href="#SYS-COLUMNS表" class="headerlink" title="SYS_COLUMNS表"></a>SYS_COLUMNS表</h5><center><b>SYS_COLUMNS表的列</b></center><table><thead><tr><th align="center">列名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>TABLE_ID</code></td><td align="center">该列所属表对应的ID</td></tr><tr><td align="center"><code>POS</code></td><td align="center">该列在表中是第几列</td></tr><tr><td align="center"><code>NAME</code></td><td align="center">该列的名称</td></tr><tr><td align="center"><code>MTYPE</code></td><td align="center">main data type，主数据类型，就是那堆INT、CHAR、VARCHAR、FLOAT、DOUBLE之类的东东</td></tr><tr><td align="center"><code>PRTYPE</code></td><td align="center">precise type，精确数据类型，就是修饰主数据类型的那堆东东，比如是否允许NULL值，是否允许负数什么的</td></tr><tr><td align="center"><code>LEN</code></td><td align="center">该列最多占用存储空间的字节数</td></tr><tr><td align="center"><code>PREC</code></td><td align="center">该列的精度，不过这列貌似都没有使用，默认值都是0</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;这个<code>SYS_COLUMNS</code>表只有一个聚集索引：</p><ul><li>以<code>(TABLE_ID, POS)</code>列为主键的聚簇索引</li></ul><h5 id="SYS-INDEXES表"><a href="#SYS-INDEXES表" class="headerlink" title="SYS_INDEXES表"></a>SYS_INDEXES表</h5><center><b>SYS_INDEXES表的列</b></center><table><thead><tr><th align="center">列名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>TABLE_ID</code></td><td align="center">该索引所属表对应的ID</td></tr><tr><td align="center"><code>ID</code></td><td align="center">InnoDB存储引擎中每个索引都有一个唯一的ID</td></tr><tr><td align="center"><code>NAME</code></td><td align="center">该索引的名称</td></tr><tr><td align="center"><code>N_FIELDS</code></td><td align="center">该索引包含列的个数</td></tr><tr><td align="center"><code>TYPE</code></td><td align="center">该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型</td></tr><tr><td align="center"><code>SPACE</code></td><td align="center">该索引根页所在的表空间ID</td></tr><tr><td align="center"><code>PAGE_NO</code></td><td align="center">该索引根页所在的页号</td></tr><tr><td align="center"><code>MERGE_THRESHOLD</code></td><td align="center">如果页中的记录被删除到某个比例，就把该页和相邻页合并，这个值就是这个比例</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;这个<code>SYS_INEXES</code>表只有一个聚集索引：</p><ul><li>以<code>(TABLE_ID, ID)</code>列为主键的聚簇索引</li></ul><h5 id="SYS-FIELDS表"><a href="#SYS-FIELDS表" class="headerlink" title="SYS_FIELDS表"></a>SYS_FIELDS表</h5><center><b>SYS_FIELDS表的列</b></center><table><thead><tr><th align="center">列名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>INDEX_ID</code></td><td align="center">该索引列所属的索引的ID</td></tr><tr><td align="center"><code>POS</code></td><td align="center">该索引列在某个索引中是第几列</td></tr><tr><td align="center"><code>COL_NAME</code></td><td align="center">该索引列的名称</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;这个<code>SYS_INEXES</code>表只有一个聚集索引：</p><ul><li>以<code>(INDEX_ID, POS)</code>列为主键的聚簇索引</li></ul><h5 id="Data-Dictionary-Header页"><a href="#Data-Dictionary-Header页" class="headerlink" title="Data Dictionary Header页"></a>Data Dictionary Header页</h5><p>&amp;emsp;&amp;emsp;只要有了上述4个基本系统表，也就意味着可以获取其他系统表以及用户定义的表的所有元数据。比方说我们想看看<code>SYS_TABLESPACES</code>这个系统表里存储了哪些表空间以及表空间对应的属性，那就可以：</p><ul><li><p>到<code>SYS_TABLES</code>表中根据表名定位到具体的记录，就可以获取到<code>SYS_TABLESPACES</code>表的<code>TABLE_ID</code></p></li><li><p>使用这个<code>TABLE_ID</code>到<code>SYS_COLUMNS</code>表中就可以获取到属于该表的所有列的信息。</p></li><li><p>使用这个<code>TABLE_ID</code>还可以到<code>SYS_INDEXES</code>表中获取所有的索引的信息，索引的信息中包括对应的<code>INDEX_ID</code>，还记录着该索引对应的<code>B+</code>数根页是哪个表空间的哪个页。</p></li><li><p>使用<code>INDEX_ID</code>就可以到<code>SYS_FIELDS</code>表中获取所有索引列的信息。</p></li></ul><p>&amp;emsp;&amp;emsp;也就是说这4个表是表中之表，那这4个表的元数据去哪里获取呢？没法搞了，只能把这4个表的元数据，就是它们有哪些列、哪些索引等信息硬编码到代码中，然后设计<code>InnoDB</code>的大佬又拿出一个固定的页来记录这4个表的聚簇索引和二级索引对应的<code>B+树</code>位置，这个页就是页号为<code>7</code>的页，类型为<code>SYS</code>，记录了<code>Data Dictionary Header</code>，也就是数据字典的头部信息。除了这4个表的5个索引的根页信息外，这个页号为<code>7</code>的页还记录了整个InnoDB存储引擎的一些全局属性，说话太啰嗦，直接看这个页的示意图：</p><p><img src="/../images/09-14.png"></p><p>&amp;emsp;&amp;emsp;可以看到这个页由下面几个部分组成：</p><table><thead><tr><th align="center">名称</th><th align="center">中文名</th><th align="center">占用空间大小</th><th align="center">简单描述</th></tr></thead><tbody><tr><td align="center"><code>File Header</code></td><td align="center">文件头部</td><td align="center"><code>38</code>字节</td><td align="center">页的一些通用信息</td></tr><tr><td align="center"><code>Data Dictionary Header</code></td><td align="center">数据字典头部信息</td><td align="center"><code>56</code>字节</td><td align="center">记录一些基本系统表的根页位置以及InnoDB存储引擎的一些全局信息</td></tr><tr><td align="center"><code>Segment Header</code></td><td align="center">段头部信息</td><td align="center"><code>10</code>字节</td><td align="center">记录本页所在段对应的INODE Entry位置信息</td></tr><tr><td align="center"><code>Empty Space</code></td><td align="center">尚未使用空间</td><td align="center"><code>16272</code>字节</td><td align="center">用于页结构的填充，没什么实际意义</td></tr><tr><td align="center"><code>File Trailer</code></td><td align="center">文件尾部</td><td align="center"><code>8</code>字节</td><td align="center">校验页是否完整</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;可以看到这个页里竟然有<code>Segment Header</code>部分，意味着设计InnoDB的大佬把这些有关数据字典的信息当成一个段来分配存储空间，我们就姑且称之为<code>数据字典段</code>吧。由于目前我们需要记录的数据字典信息非常少（可以看到<code>Data Dictionary Header</code>部分仅占用了56字节），所以该段只有一个碎片页，也就是页号为<code>7</code>的这个页。</p><p>&amp;emsp;&amp;emsp;接下来我们需要细细介绍一下<code>Data Dictionary Header</code>部分的各个字段：</p><ul><li><p><code>Max Row ID</code>：我们说过如果我们不显式的为表定义主键，而且表中也没有<code>UNIQUE</code>索引，那么<code>InnoDB</code>存储引擎会默认为我们生成一个名为<code>row_id</code>的列作为主键。因为它是主键，所以每条记录的<code>row_id</code>列的值不能重复。原则上只要一个表中的<code>row_id</code>列不重复就可以了，也就是说表a和表b拥有一样的<code>row_id</code>列也没什么关系，不过设计InnoDB的大佬只提供了这个<code>Max Row ID</code>字段，不论哪个拥有<code>row_id</code>列的表插入一条记录时，该记录的<code>row_id</code>列的值就是<code>Max Row ID</code>对应的值，然后再把<code>Max Row ID</code>对应的值加1，也就是说这个<code>Max Row ID</code>是全局共享的。</p></li><li><p><code>Max Table ID</code>：InnoDB存储引擎中的所有的表都对应一个唯一的ID，每次新建一个表时，就会把本字段的值作为该表的ID，然后自增本字段的值。</p></li><li><p><code>Max Index ID</code>：InnoDB存储引擎中的所有的索引都对应一个唯一的ID，每次新建一个索引时，就会把本字段的值作为该索引的ID，然后自增本字段的值。</p></li><li><p><code>Max Space ID</code>：InnoDB存储引擎中的所有的表空间都对应一个唯一的ID，每次新建一个表空间时，就会把本字段的值作为该表空间的ID，然后自增本字段的值。</p></li><li><p><code>Mix ID Low(Unused)</code>：这个字段没什么用，跳过。</p></li><li><p><code>Root of SYS_TABLES clust index</code>：本字段代表<code>SYS_TABLES</code>表聚簇索引的根页的页号。</p></li><li><p><code>Root of SYS_TABLE_IDS sec index</code>：本字段代表<code>SYS_TABLES</code>表为<code>ID</code>列建立的二级索引的根页的页号。</p></li><li><p><code>Root of SYS_COLUMNS clust index</code>：本字段代表<code>SYS_COLUMNS</code>表聚簇索引的根页的页号。</p></li><li><p><code>Root of SYS_INDEXES clust index</code>本字段代表<code>SYS_INDEXES</code>表聚簇索引的根页的页号。</p></li><li><p><code>Root of SYS_FIELDS clust index</code>：本字段代表<code>SYS_FIELDS</code>表聚簇索引的根页的页号。</p></li><li><p><code>Unused</code>：这4个字节没用，跳过。</p></li></ul><p>&amp;emsp;&amp;emsp;以上就是页号为<code>7</code>的页的全部内容，初次看可能会懵逼（因为有点儿绕），大家多瞅几次。</p><h5 id="information-schema系统数据库"><a href="#information-schema系统数据库" class="headerlink" title="information_schema系统数据库"></a>information_schema系统数据库</h5><p>&amp;emsp;&amp;emsp;需要注意一点的是，用户是不能直接访问<code>InnoDB</code>的这些内部系统表的，除非你直接去解析系统表空间对应文件系统上的文件。不过设计InnoDB的大佬考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库<code>information_schema</code>中提供了一些以<code>innodb_sys</code>开头的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE information_schema;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW TABLES LIKE &#x27;innodb_sys%&#x27;;</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| Tables_in_information_schema (innodb_sys%) |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| INNODB_SYS_DATAFILES                       |</span><br><span class="line">| INNODB_SYS_VIRTUAL                         |</span><br><span class="line">| INNODB_SYS_INDEXES                         |</span><br><span class="line">| INNODB_SYS_TABLES                          |</span><br><span class="line">| INNODB_SYS_FIELDS                          |</span><br><span class="line">| INNODB_SYS_TABLESPACES                     |</span><br><span class="line">| INNODB_SYS_FOREIGN_COLS                    |</span><br><span class="line">| INNODB_SYS_COLUMNS                         |</span><br><span class="line">| INNODB_SYS_FOREIGN                         |</span><br><span class="line">| INNODB_SYS_TABLESTATS                      |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;在<code>information_schema</code>数据库中的这些以<code>INNODB_SYS</code>开头的表并不是真正的内部系统表（内部系统表就是我们上面介绍的以<code>SYS</code>开头的那些表），而是在存储引擎启动时读取这些以<code>SYS</code>开头的系统表，然后填充到这些以<code>INNODB_SYS</code>开头的表中。以<code>INNODB_SYS</code>开头的表和以<code>SYS</code>开头的表中的字段并不完全一样，但供大家参考已经足矣。这些表太多了，我就不介绍了，大家自个儿动手试着查一查这些表中的数据吧～</p><h3 id="总结图"><a href="#总结图" class="headerlink" title="总结图"></a>总结图</h3><p>&amp;emsp;&amp;emsp;小册微信交流群2群中一个昵称为<code>think</code>同学非常有心的为表空间画了一个全局图，希望能对各位有帮助（这种学习态度实在让我感动😹）：</p><p><img src="/../images/09-15.png"></p><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/12-%E8%B0%81%E6%9C%80%E4%BE%BF%E5%AE%9C%E5%B0%B1%E9%80%89%E8%B0%81-MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/"/>
      <url>/2022/10/31/model-mysql/mysql/12-%E8%B0%81%E6%9C%80%E4%BE%BF%E5%AE%9C%E5%B0%B1%E9%80%89%E8%B0%81-MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="第12章-谁最便宜就选谁-MySQL基于成本的优化"><a href="#第12章-谁最便宜就选谁-MySQL基于成本的优化" class="headerlink" title="第12章 谁最便宜就选谁-MySQL基于成本的优化"></a>第12章 谁最便宜就选谁-MySQL基于成本的优化</h1><h2 id="什么是成本"><a href="#什么是成本" class="headerlink" title="什么是成本"></a>什么是成本</h2><p>&amp;emsp;&amp;emsp;我们之前老说<code>MySQL</code>执行一个查询可以有不同的执行方案，它会选择其中成本最低，或者说代价最低的那种方案去真正的执行查询。不过我们之前对<code>成本</code>的描述是非常模糊的，其实在<code>MySQL</code>中一条查询语句的执行成本是由下面这两个方面组成的：</p><ul><li><p><code>I/O</code>成本</p><p>  &amp;emsp;&amp;emsp;我们的表经常使用的<code>MyISAM</code>、<code>InnoDB</code>存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称之为<code>I/O</code>成本。</p></li><li><p><code>CPU</code>成本</p><p>  &amp;emsp;&amp;emsp;读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为<code>CPU</code>成本。</p></li></ul><p>&amp;emsp;&amp;emsp;对于<code>InnoDB</code>存储引擎来说，页是磁盘和内存之间交互的基本单位，设计<code>MySQL</code>的大佬规定读取一个页面花费的成本默认是<code>1.0</code>，读取以及检测一条记录是否符合搜索条件的成本默认是<code>0.2</code>。<code>1.0</code>、<code>0.2</code>这些数字称之为<code>成本常数</code>，这两个成本常数我们最常用到，其余的成本常数我们后边再说。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：需要注意的是，不管读取记录时需不需要检测是否满足搜索条件，其成本都算是0.2。</span><br></pre></td></tr></table></figure><h2 id="单表查询的成本"><a href="#单表查询的成本" class="headerlink" title="单表查询的成本"></a>单表查询的成本</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>&amp;emsp;&amp;emsp;为了故事的顺利发展，我们还得把之前用到的<code>single_table</code>表搬来，怕大家忘了这个表长什么样，再给大家抄一遍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE single_table (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    UNIQUE KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;还是假设这个表里边儿有10000条记录，除<code>id</code>列外其余的列都插入随机值。下面正式开始我们的表演。</p><h3 id="基于成本的优化步骤"><a href="#基于成本的优化步骤" class="headerlink" title="基于成本的优化步骤"></a>基于成本的优化步骤</h3><p>&amp;emsp;&amp;emsp;在一条单表查询语句真正执行之前，<code>MySQL</code>的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的<code>执行计划</code>，之后才会调用存储引擎提供的接口真正的执行查询，这个过程总结一下就是这样：</p><ol><li>根据搜索条件，找出所有可能使用的索引</li><li>计算全表扫描的代价</li><li>计算使用不同索引执行查询的代价</li><li>对比各种执行方案的代价，找出成本最低的那一个</li></ol><p>&amp;emsp;&amp;emsp;下面我们就以一个实例来分析一下这些步骤，单表查询语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE </span><br><span class="line">    key1 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND </span><br><span class="line">    key2 &gt; 10 AND key2 &lt; 1000 AND </span><br><span class="line">    key3 &gt; key2 AND </span><br><span class="line">    key_part1 LIKE &#x27;%hello%&#x27; AND</span><br><span class="line">    common_field = &#x27;123&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;乍看上去有点儿复杂，我们一步一步分析一下。</p><h4 id="根据搜索条件，找出所有可能使用的索引"><a href="#根据搜索条件，找出所有可能使用的索引" class="headerlink" title="根据搜索条件，找出所有可能使用的索引"></a>根据搜索条件，找出所有可能使用的索引</h4><p>&amp;emsp;&amp;emsp;我们前面说过，对于<code>B+</code>树索引来说，只要索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者<code>LIKE</code>操作符连接起来，就可以产生一个所谓的<code>范围区间</code>（<code>LIKE</code>匹配字符串前缀也行），也就是说这些搜索条件都可能使用到索引，设计<code>MySQL</code>的大佬把一个查询中可能使用到的索引称之为<code>possible keys</code>。</p><p>&amp;emsp;&amp;emsp;我们分析一下上面查询中涉及到的几个搜索条件：</p><ul><li><code>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code>，这个搜索条件可以使用二级索引<code>idx_key1</code>。</li><li><code>key2 &gt; 10 AND key2 &lt; 1000</code>，这个搜索条件可以使用二级索引<code>idx_key2</code>。</li><li><code>key3 &gt; key2</code>，这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引。</li><li><code>key_part1 LIKE &#39;%hello%&#39;</code>，<code>key_part1</code>通过<code>LIKE</code>操作符和以通配符开头的字符串做比较，不可以适用索引。</li><li><code>common_field = &#39;123&#39;</code>，由于该列上压根儿没有索引，所以不会用到索引。</li></ul><p>&amp;emsp;&amp;emsp;综上所述，上面的查询语句可能用到的索引，也就是<code>possible keys</code>只有<code>idx_key1</code>和<code>idx_key2</code>。</p><h4 id="计算全表扫描的代价"><a href="#计算全表扫描的代价" class="headerlink" title="计算全表扫描的代价"></a>计算全表扫描的代价</h4><p>&amp;emsp;&amp;emsp;对于<code>InnoDB</code>存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。由于查询成本&#x3D;<code>I/O</code>成本+<code>CPU</code>成本，所以计算全表扫描的代价需要两个信息：</p><ul><li>聚簇索引占用的页面数</li><li>该表中的记录数</li></ul><p>&amp;emsp;&amp;emsp;这两个信息从哪来呢？设计<code>MySQL</code>的大佬为每个表维护了一系列的<code>统计信息</code>，关于这些统计信息是如何收集起来的我们放在本章后边详细介绍，现在看看怎么查看这些统计信息。设计<code>MySQL</code>的大佬给我们提供了<code>SHOW TABLE STATUS</code>语句来查看表的统计信息，如果要看指定的某个表的统计信息，在该语句后加对应的<code>LIKE</code>语句就好了，比方说我们要查看<code>single_table</code>这个表的统计信息可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE xiaohaizi;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW TABLE STATUS LIKE &#x27;single_table&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: single_table</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Dynamic</span><br><span class="line">           Rows: 9693</span><br><span class="line"> Avg_row_length: 163</span><br><span class="line">    Data_length: 1589248</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 2752512</span><br><span class="line">      Data_free: 4194304</span><br><span class="line"> Auto_increment: 10001</span><br><span class="line">    Create_time: 2018-12-10 13:37:23</span><br><span class="line">    Update_time: 2018-12-10 13:38:03</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8_general_ci</span><br><span class="line">       Checksum: NULL</span><br><span class="line"> Create_options:</span><br><span class="line">        Comment:</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;虽然出现了很多统计选项，但我们目前只关心两个：</p><ul><li><p><code>Rows</code></p><p>  &amp;emsp;&amp;emsp;本选项表示表中的记录条数。对于使用<code>MyISAM</code>存储引擎的表来说，该值是准确的，对于使用<code>InnoDB</code>存储引擎的表来说，该值是一个估计值。从查询结果我们也可以看出来，由于我们的<code>single_table</code>表是使用<code>InnoDB</code>存储引擎的，所以虽然实际上表中有10000条记录，但是<code>SHOW TABLE STATUS</code>显示的<code>Rows</code>值只有9693条记录。</p></li><li><p><code>Data_length</code></p><p>  &amp;emsp;&amp;emsp;本选项表示表占用的存储空间字节数。使用<code>MyISAM</code>存储引擎的表来说，该值就是数据文件的大小，对于使用<code>InnoDB</code>存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小，也就是说可以这样计算该值的大小：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data_length = 聚簇索引的页面数量 x 每个页面的大小</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;我们的<code>single_table</code>使用默认<code>16KB</code>的页面大小，而上面查询结果显示<code>Data_length</code>的值是<code>1589248</code>，所以我们可以反向来推导出<code>聚簇索引的页面数量</code>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">聚簇索引的页面数量 = 1589248 ÷ 16 ÷ 1024 = 97</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;我们现在已经得到了聚簇索引占用的页面数量以及该表记录数的估计值，所以就可以计算全表扫描成本了，但是设计<code>MySQL</code>的大佬在真实计算成本时会进行一些<code>微调</code>，这些微调的值是直接硬编码到代码里的，由于没有注释，我也不知道这些微调值是什么子意思，但是由于这些微调的值十分的小，并不影响我们分析，所以我们也没有必要在这些微调值上纠结了。现在可以看一下全表扫描成本的计算过程：</p><ul><li><p><code>I/O</code>成本</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">97 x 1.0 + 1.1 = 98.1</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;<code>97</code>指的是聚簇索引占用的页面数，<code>1.0</code>指的是加载一个页面的成本常数，后边的<code>1.1</code>是一个微调值，我们不用在意。</p></li><li><p><code>CPU</code>成本：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9693 x 0.2 + 1.0 = 1939.6</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;<code>9693</code>指的是统计数据中表的记录数，对于<code>InnoDB</code>存储引擎来说是一个估计值，<code>0.2</code>指的是访问一条记录所需的成本常数，后边的<code>1.0</code>是一个微调值，我们不用在意。</p></li><li><p>总成本：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">98.1 + 1939.6 = 2037.7</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;综上所述，对于<code>single_table</code>的全表扫描所需的总成本就是<code>2037.7</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：我们前面说过表中的记录其实都存储在聚簇索引对应B+树的叶子节点中，所以只要我们通过根节点获得了最左边的叶子节点，就可以沿着叶子节点组成的双向链表把所有记录都查看一遍。也就是说全表扫描这个过程其实有的B+树内节点是不需要访问的，但是设计MySQL的大佬们在计算全表扫描成本时直接使用聚簇索引占用的页面数作为计算I/O成本的依据，是不区分内节点和叶子节点的，有点儿简单暴力，大家注意一下就好了。</span><br></pre></td></tr></table></figure><h4 id="计算使用不同索引执行查询的代价"><a href="#计算使用不同索引执行查询的代价" class="headerlink" title="计算使用不同索引执行查询的代价"></a>计算使用不同索引执行查询的代价</h4><p>&amp;emsp;&amp;emsp;从第1步分析我们得到，上述查询可能使用到<code>idx_key1</code>和<code>idx_key2</code>这两个索引，我们需要分别分析单独使用这些索引执行查询的成本，最后还要分析是否可能使用到索引合并。这里需要提一点的是，<code>MySQL</code>查询优化器先分析使用唯一二级索引的成本，再分析使用普通索引的成本，所以我们也先分析<code>idx_key2</code>的成本，然后再看使用<code>idx_key1</code>的成本。</p><h5 id="使用idx-key2执行查询的成本分析"><a href="#使用idx-key2执行查询的成本分析" class="headerlink" title="使用idx_key2执行查询的成本分析"></a>使用idx_key2执行查询的成本分析</h5><p>&amp;emsp;&amp;emsp;<code>idx_key2</code>对应的搜索条件是：<code>key2 &gt; 10 AND key2 &lt; 1000</code>，也就是说对应的范围区间就是：<code>(10, 1000)</code>，使用<code>idx_key2</code>搜索的示意图就是这样子：</p><p><img src="/../images/12-01.png"></p><p>&amp;emsp;&amp;emsp;对于使用<code>二级索引 + 回表</code>方式的查询，设计<code>MySQL</code>的大佬计算这种查询的成本依赖两个方面的数据：</p><ul><li><p>范围区间数量</p><p>  &amp;emsp;&amp;emsp;不论某个范围区间的二级索引到底占用了多少页面，查询优化器粗暴的认为读取索引的一个范围区间的<code>I/O</code>成本和读取一个页面是相同的。本例中使用<code>idx_key2</code>的范围区间只有一个：<code>(10, 1000)</code>，所以相当于访问这个范围区间的二级索引付出的<code>I/O</code>成本就是：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 x 1.0 = 1.0</span><br></pre></td></tr></table></figure></li><li><p>需要回表的记录数</p><p>  &amp;emsp;&amp;emsp;优化器需要计算二级索引的某个范围区间到底包含多少条记录，对于本例来说就是要计算<code>idx_key2</code>在<code>(10, 1000)</code>这个范围区间中包含多少二级索引记录，计算过程是这样的：</p><ul><li><p>步骤1：先根据<code>key2 &gt; 10</code>这个条件访问一下<code>idx_key2</code>对应的<code>B+</code>树索引，找到满足<code>key2 &gt; 10</code>这个条件的第一条记录，我们把这条记录称之为<code>区间最左记录</code>。我们前头说过在<code>B+</code>数树中定位一条记录的过程是贼快的，是常数级别的，所以这个过程的性能消耗是可以忽略不计的。</p></li><li><p>步骤2：然后再根据<code>key2 &lt; 1000</code>这个条件继续从<code>idx_key2</code>对应的<code>B+</code>树索引中找出第一条满足这个条件的记录，我们把这条记录称之为<code>区间最右记录</code>，这个过程的性能消耗也可以忽略不计的。</p></li><li><p>步骤3：如果<code>区间最左记录</code>和<code>区间最右记录</code>相隔不太远（在<code>MySQL 5.7.21</code>这个版本里，只要相隔不大于10个页面即可），那就可以精确统计出满足<code>key2 &gt; 10 AND key2 &lt; 1000</code>条件的二级索引记录条数。否则只沿着<code>区间最左记录</code>向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以<code>区间最左记录</code>和<code>区间最右记录</code>之间的页面数量就可以了。那么问题又来了，怎么估计<code>区间最左记录</code>和<code>区间最右记录</code>之间有多少个页面呢？解决这个问题还得回到<code>B+</code>树索引的结构中来：</p><p>  <img src="/../images/12-02.png"></p><p>  &amp;emsp;&amp;emsp;如图，我们假设<code>区间最左记录</code>在<code>页b</code>中，<code>区间最右记录</code>在<code>页c</code>中，那么我们想计算<code>区间最左记录</code>和<code>区间最右记录</code>之间的页面数量就相当于计算<code>页b</code>和<code>页c</code>之间有多少页面，而每一条<code>目录项记录</code>都对应一个数据页，所以计算<code>页b</code>和<code>页c</code>之间有多少页面就相当于<span style="color:red">计算它们父节点（也就是页a）中对应的目录项记录之间隔着几条记录</span>。在一个页面中统计两条记录之间有几条记录的成本就贼小了。</p><p>  &amp;emsp;&amp;emsp;不过还有问题，如果<code>页b</code>和<code>页c</code>之间的页面实在太多，以至于<code>页b</code>和<code>页c</code>对应的目录项记录都不在一个页面中该咋办？继续递归啊，也就是再统计<code>页b</code>和<code>页c</code>对应的目录项记录所在页之间有多少个页面。之前我们说过一个<code>B+</code>树有4层高已经很了不得了，所以这个统计过程也不是很耗费性能。</p></li></ul><p>  &amp;emsp;&amp;emsp;知道了如何统计二级索引某个范围区间的记录数之后，就需要回到现实问题中来，根据上述算法测得<code>idx_key2</code>在区间<code>(10, 1000)</code>之间大约有<code>95</code>条记录。读取这<code>95</code>条二级索引记录需要付出的<code>CPU</code>成本就是：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 0.2 + 0.01 = 19.01</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;其中<code>95</code>是需要读取的二级索引记录条数，<code>0.2</code>是读取一条记录成本常数，<code>0.01</code>是微调。</p><p>  &amp;emsp;&amp;emsp;在通过二级索引获取到记录之后，还需要干两件事儿：</p><ul><li><p>根据这些记录里的主键值到聚簇索引中做回表操作</p><p>  &amp;emsp;&amp;emsp;这里需要大家使劲儿睁大自己滴溜溜的大眼睛仔细瞧，设计<code>MySQL</code>的大佬评估回表操作的<code>I/O</code>成本依旧很豪放，他们认为每次回表操作都相当于访问一个页面，也就是说二级索引范围区间有多少记录，就需要进行多少次回表操作，也就是需要进行多少次页面<code>I/O</code>。我们上面统计了使用<code>idx_key2</code>二级索引执行查询时，预计有<code>95</code>条二级索引记录需要进行回表操作，所以回表操作带来的<code>I/O</code>成本就是：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 1.0 = 95.0</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;其中<code>95</code>是预计的二级索引记录数，<code>1.0</code>是一个页面的<code>I/O</code>成本常数。</p></li><li><p>回表操作后得到的完整用户记录，然后再检测其他搜索条件是否成立</p><p>  &amp;emsp;&amp;emsp;回表操作的本质就是通过二级索引记录的主键值到聚簇索引中找到完整的用户记录，然后再检测除<code>key2 &gt; 10 AND key2 &lt; 1000</code>这个搜索条件以外的搜索条件是否成立。因为我们通过范围区间获取到二级索引记录共<code>95</code>条，也就对应着聚簇索引中<code>95</code>条完整的用户记录，读取并检测这些完整的用户记录是否符合其余的搜索条件的<code>CPU</code>成本如下：</p><p>  &amp;emsp;&amp;emsp;设计<code>MySQL</code>的大佬只计算这个查找过程所需的<code>I/O</code>成本，也就是我们上一步骤中得到的<code>95.0</code>，在内存中的定位完整用户记录的过程的成本是忽略不计的。在定位到这些完整的用户记录后，需要检测除<code>key2 &gt; 10 AND key2 &lt; 1000</code>这个搜索条件以外的搜索条件是否成立，这个比较过程花费的<code>CPU</code>成本就是：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 0.2 = 19.0</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;其中<code>95</code>是待检测记录的条数，<code>0.2</code>是检测一条记录是否符合给定的搜索条件的成本常数。</p></li></ul></li></ul><p>&amp;emsp;&amp;emsp;所以本例中使用<code>idx_key2</code>执行查询的成本就如下所示：</p><ul><li><p><code>I/O</code>成本：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0 + 95 x 1.0 = 96.0 (范围区间的数量 + 预估的二级索引记录条数)</span><br></pre></td></tr></table></figure></li><li><p><code>CPU</code>成本：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 0.2 + 0.01 + 95 x 0.2 = 38.01 （读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本）</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;综上所述，使用<code>idx_key2</code>执行查询的总成本就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">96.0 + 38.01 = 134.01</span><br></pre></td></tr></table></figure><h5 id="使用idx-key1执行查询的成本分析"><a href="#使用idx-key1执行查询的成本分析" class="headerlink" title="使用idx_key1执行查询的成本分析"></a>使用idx_key1执行查询的成本分析</h5><p>&amp;emsp;&amp;emsp;<code>idx_key1</code>对应的搜索条件是：<code>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code>，也就是说相当于3个单点区间：</p><ul><li><code>[&#39;a&#39;, &#39;a&#39;]</code></li><li><code>[&#39;b&#39;, &#39;b&#39;]</code></li><li><code>[&#39;c&#39;, &#39;c&#39;]</code></li></ul><p>&amp;emsp;&amp;emsp;使用<code>idx_key1</code>搜索的示意图如下：</p><p><img src="/../images/12-03.png"></p><p>&amp;emsp;&amp;emsp;与使用<code>idx_key2</code>的情况类似，我们也需要计算使用<code>idx_key1</code>时需要访问的范围区间数量以及需要回表的记录数：</p><ul><li><p>范围区间数量</p><p>  &amp;emsp;&amp;emsp;使用<code>idx_key1</code>执行查询时很显然有3个单点区间，所以访问这3个范围区间的二级索引付出的I&#x2F;O成本就是：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 x 1.0 = 3.0</span><br></pre></td></tr></table></figure></li><li><p>需要回表的记录数</p><p>  &amp;emsp;&amp;emsp;由于使用<code>idx_key1</code>时有3个单点区间，所以每个单点区间都需要查找一遍对应的二级索引记录数：</p><ul><li><p>查找单点区间<code>[&#39;a&#39;, &#39;a&#39;]</code>对应的二级索引记录数</p><p>  &amp;emsp;&amp;emsp;计算单点区间对应的二级索引记录数和计算连续范围区间对应的二级索引记录数是一样的，都是先计算<code>区间最左记录</code>和<code>区间最右记录</code>，然后再计算它们之间的记录数，具体算法上面都介绍过了，就不赘述了。最后计算得到单点区间<code>[&#39;a&#39;, &#39;a&#39;]</code>对应的二级索引记录数是：<code>35</code>。</p></li><li><p>查找单点区间<code>[&#39;b&#39;, &#39;b&#39;]</code>对应的二级索引记录数</p><p>  &amp;emsp;&amp;emsp;与上同理，计算得到本单点区间对应的记录数是：<code>44</code>。</p></li><li><p>查找单点区间<code>[&#39;c&#39;, &#39;c&#39;]</code>对应的二级索引记录数</p><p>  &amp;emsp;&amp;emsp;与上同理，计算得到本单点区间对应的记录数是：<code>39</code>。</p></li></ul><p>  &amp;emsp;&amp;emsp;所以，这三个单点区间总共需要回表的记录数就是：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35 + 44 + 39 = 118</span><br></pre></td></tr></table></figure></p><p>  &amp;emsp;&amp;emsp;读取这些二级索引记录的<code>CPU</code>成本就是：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 0.2 + 0.01 = 23.61</span><br></pre></td></tr></table></figure></p><p>  &amp;emsp;&amp;emsp;得到总共需要回表的记录数之后，就要考虑：</p><ul><li><p>根据这些记录里的主键值到聚簇索引中做回表操作</p><p>  所需的<code>I/O</code>成本就是：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 1.0 = 118.0</span><br></pre></td></tr></table></figure></li><li><p>回表操作后得到的完整用户记录，然后再比较其他搜索条件是否成立</p><p>  此步骤对应的<code>CPU</code>成本就是：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 0.2 = 23.6</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>&amp;emsp;&amp;emsp;所以本例中使用<code>idx_key1</code>执行查询的成本就如下所示：</p><ul><li><p><code>I/O</code>成本：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.0 + 118 x 1.0 = 121.0 (范围区间的数量 + 预估的二级索引记录条数)</span><br></pre></td></tr></table></figure></li><li><p><code>CPU</code>成本：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 0.2 + 0.01 + 118 x 0.2 = 47.21 （读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本）</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;综上所述，使用<code>idx_key1</code>执行查询的总成本就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">121.0 + 47.21 = 168.21</span><br></pre></td></tr></table></figure><h5 id="是否有可能使用索引合并（Index-Merge）"><a href="#是否有可能使用索引合并（Index-Merge）" class="headerlink" title="是否有可能使用索引合并（Index Merge）"></a>是否有可能使用索引合并（Index Merge）</h5><p>&amp;emsp;&amp;emsp;本例中有关<code>key1</code>和<code>key2</code>的搜索条件是使用<code>AND</code>连接起来的，而对于<code>idx_key1</code>和<code>idx_key2</code>都是范围查询，也就是说查找到的二级索引记录并不是按照主键值进行排序的，并不满足使用<code>Intersection</code>索引合并的条件，所以并不会使用索引合并。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：MySQL查询优化器计算索引合并成本的算法也比较麻烦，所以我们这也就不展开介绍了。</span><br></pre></td></tr></table></figure><h4 id="4-对比各种执行方案的代价，找出成本最低的那一个"><a href="#4-对比各种执行方案的代价，找出成本最低的那一个" class="headerlink" title="4. 对比各种执行方案的代价，找出成本最低的那一个"></a>4. 对比各种执行方案的代价，找出成本最低的那一个</h4><p>&amp;emsp;&amp;emsp;下面把执行本例中的查询的各种可执行方案以及它们对应的成本列出来：</p><ul><li>全表扫描的成本：<code>2037.7</code></li><li>使用<code>idx_key2</code>的成本：<code>134.01</code></li><li>使用<code>idx_key1</code>的成本：<code>168.21</code></li></ul><p>&amp;emsp;&amp;emsp;很显然，使用<code>idx_key2</code>的成本最低，所以当然选择<code>idx_key2</code>来执行查询喽。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：考虑到大家的阅读体验，为了最大限度的减少大家在理解优化器工作原理的过程中遇到的懵逼情况，这里对优化器在单表查询中对比各种执行方案的代价的方式稍稍的做了简化，不过毕竟大部分同学不需要去看MySQL的源码，把大致的精神传递正确就好了。</span><br></pre></td></tr></table></figure><h3 id="基于索引统计数据的成本计算"><a href="#基于索引统计数据的成本计算" class="headerlink" title="基于索引统计数据的成本计算"></a>基于索引统计数据的成本计算</h3><p>&amp;emsp;&amp;emsp;有时候使用索引执行查询时会有许多单点区间，比如使用<code>IN</code>语句就很容易产生非常多的单点区间，比如下面这个查询（下面查询语句中的<code>...</code>表示还有很多参数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 IN (&#x27;aa1&#x27;, &#x27;aa2&#x27;, &#x27;aa3&#x27;, ... , &#x27;zzz&#x27;);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;很显然，这个查询可能使用到的索引就是<code>idx_key1</code>，由于这个索引并不是唯一二级索引，所以并不能确定一个单点区间对应的二级索引记录的条数有多少，需要我们去计算。计算方式我们上面已经介绍过了，就是先获取索引对应的<code>B+</code>树的<code>区间最左记录</code>和<code>区间最右记录</code>，然后再计算这两条记录之间有多少记录（记录条数少的时候可以做到精确计算，多的时候只能估算）。设计<code>MySQL</code>的大佬把这种通过直接访问索引对应的<code>B+</code>树来计算某个范围区间对应的索引记录条数的方式称之为<code>index dive</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：dive直译为中文的意思是跳水、俯冲的意思，原谅我的英文水平捉急，我实在不知道怎么翻译 index dive，索引跳水？索引俯冲？好像都不太合适，所以压根儿就不翻译了。不过大家要意会index dive就是直接利用索引对应的B+树来计算某个范围区间对应的记录条数。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;有零星几个单点区间的话，使用<code>index dive</code>的方式去计算这些单点区间对应的记录数也不是什么问题，可是你架不住有的孩子憋足了劲往<code>IN</code>语句里塞东西呀，我就见过有的同学写的<code>IN</code>语句里有20000个参数的🤣🤣，这就意味着<code>MySQL</code>的查询优化器为了计算这些单点区间对应的索引记录条数，要进行20000次<code>index dive</code>操作，这性能损耗可就大了，搞不好计算这些单点区间对应的索引记录条数的成本比直接全表扫描的成本都大了。设计<code>MySQL</code>的大佬们多聪明啊，他们当然考虑到了这种情况，所以提供了一个系统变量<code>eq_range_index_dive_limit</code>，我们看一下在<code>MySQL 5.7.21</code>中这个系统变量的默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;%dive%&#x27;;</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| Variable_name             | Value |</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| eq_range_index_dive_limit | 200   |</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">1 row in set (0.08 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;也就是说如果我们的<code>IN</code>语句中的参数个数小于200个的话，将使用<code>index dive</code>的方式计算各个单点区间对应的记录条数，如果大于或等于200个的话，可就不能使用<code>index dive</code>了，要使用所谓的索引统计数据来进行估算。怎么个估算法？继续往下看。</p><p>&amp;emsp;&amp;emsp;像会为每个表维护一份统计数据一样，<code>MySQL</code>也会为表中的每一个索引维护一份统计数据，查看某个表中索引的统计数据可以使用<code>SHOW INDEX FROM 表名</code>的语法，比如我们查看一下<code>single_table</code>的各个索引的统计数据可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM single_table;</span><br><span class="line">+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table        | Non_unique | Key_name     | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| single_table |          0 | PRIMARY      |            1 | id          | A         |       9693  |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| single_table |          0 | idx_key2     |            1 | key2        | A         |       9693  |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key1     |            1 | key1        | A         |        968 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key3     |            1 | key3        | A         |        799 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key_part |            1 | key_part1   | A         |        9673 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key_part |            2 | key_part2   | A         |        9999 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key_part |            3 | key_part3   | A         |       10000 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">7 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;哇唔，竟然有这么多属性，不过好在这些属性都不难理解，我们就都介绍一遍吧：</p><table><thead><tr><th align="center">属性名</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>Table</code></td><td>索引所属表的名称。</td></tr><tr><td align="center"><code>Non_unique</code></td><td>索引列的值是否是唯一的，聚簇索引和唯一二级索引的该列值为<code>0</code>，普通二级索引该列值为<code>1</code>。</td></tr><tr><td align="center"><code>Key_name</code></td><td>索引的名称。</td></tr><tr><td align="center"><code>Seq_in_index</code></td><td>索引列在索引中的位置，从1开始计数。比如对于联合索引<code>idx_key_part</code>，来说，<code>key_part1</code>、<code>key_part2</code>和<code>key_part3</code>对应的位置分别是1、2、3。</td></tr><tr><td align="center"><code>Column_name</code></td><td>索引列的名称。</td></tr><tr><td align="center"><code>Collation</code></td><td>索引列中的值是按照何种排序方式存放的，值为<code>A</code>时代表升序存放，为<code>NULL</code>时代表降序存放。</td></tr><tr><td align="center"><code>Cardinality</code></td><td>索引列中不重复值的数量。后边我们会重点看这个属性的。</td></tr><tr><td align="center"><code>Sub_part</code></td><td>对于存储字符串或者字节串的列来说，有时候我们只想对这些串的前<code>n</code>个字符或字节建立索引，这个属性表示的就是那个<code>n</code>值。如果对完整的列建立索引的话，该属性的值就是<code>NULL</code>。</td></tr><tr><td align="center"><code>Packed</code></td><td>索引列如何被压缩，<code>NULL</code>值表示未被压缩。这个属性我们暂时不了解，可以先忽略掉。</td></tr><tr><td align="center"><code>Null</code></td><td>该索引列是否允许存储<code>NULL</code>值。</td></tr><tr><td align="center"><code>Index_type</code></td><td>使用索引的类型，我们最常见的就是<code>BTREE</code>，其实也就是<code>B+</code>树索引。</td></tr><tr><td align="center"><code>Comment</code></td><td>索引列注释信息。</td></tr><tr><td align="center"><code>Index_comment</code></td><td>索引注释信息。</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;上述属性除了<code>Packed</code>大家可能看不懂以外，应该没有什么看不懂的了，如果有的话肯定是大家看前面文章的时候跳过了什么东西。其实我们现在最在意的是<code>Cardinality</code>属性，<code>Cardinality</code>直译过来就是<code>基数</code>的意思，表示索引列中不重复值的个数。比如对于一个一万行记录的表来说，某个索引列的<code>Cardinality</code>属性是<code>10000</code>，那意味着该列中没有重复的值，如果<code>Cardinality</code>属性是<code>1</code>的话，就意味着该列的值全部是重复的。不过需要注意的是，<span style="color:red">对于InnoDB存储引擎来说，使用SHOW INDEX语句展示出来的某个索引列的Cardinality属性是一个估计值，并不是精确的</span>。关于这个<code>Cardinality</code>属性的值是如何被计算出来的我们后边再说，先看看它有什么用途。</p><p>&amp;emsp;&amp;emsp;前面说道，当<code>IN</code>语句中的参数个数大于或等于系统变量<code>eq_range_index_dive_limit</code>的值的话，就不会使用<code>index dive</code>的方式计算各个单点区间对应的索引记录条数，而是使用索引统计数据，这里所指的<code>索引统计数据</code>指的是这两个值：</p><ul><li><p>使用<code>SHOW TABLE STATUS</code>展示出的<code>Rows</code>值，也就是一个表中有多少条记录。</p><p>  &amp;emsp;&amp;emsp;这个统计数据我们在前面介绍全表扫描成本的时候说过很多遍了，就不赘述了。</p></li><li><p>使用<code>SHOW INDEX</code>语句展示出的<code>Cardinality</code>属性。</p><p>  &amp;emsp;&amp;emsp;结合上一个<code>Rows</code>统计数据，我们可以针对索引列，计算出平均一个值重复多少次。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个值的重复次数 ≈ Rows ÷ Cardinality</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;以<code>single_table</code>表的<code>idx_key1</code>索引为例，它的<code>Rows</code>值是<code>9693</code>，它对应索引列<code>key1</code>的<code>Cardinality</code>值是<code>968</code>，所以我们可以计算<code>key1</code>列平均单个值的重复次数就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9693 ÷ 968 ≈ 10（条）</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;此时再看上面那条查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 IN (&#x27;aa1&#x27;, &#x27;aa2&#x27;, &#x27;aa3&#x27;, ... , &#x27;zzz&#x27;);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;假设<code>IN</code>语句中有20000个参数的话，就直接使用统计数据来估算这些参数需要单点区间对应的记录条数了，每个参数大约对应<code>10</code>条记录，所以总共需要回表的记录数就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20000 x 10 = 200000</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;使用统计数据来计算单点区间对应的索引记录条数可比<code>index dive</code>的方式简单多了，但是它的致命弱点就是：<span style="color:red">不精确！</span>。使用统计数据算出来的查询成本与实际所需的成本可能相差非常大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：大家需要注意一下，在MySQL 5.7.3以及之前的版本中，eq_range_index_dive_limit的默认值为10，之后的版本默认值为200。所以如果大家采用的是5.7.3以及之前的版本的话，很容易采用索引统计数据而不是index dive的方式来计算查询成本。当你的查询中使用到了IN查询，但是却实际没有用到索引，就应该考虑一下是不是由于 eq_range_index_dive_limit 值太小导致的。</span><br></pre></td></tr></table></figure><h2 id="连接查询的成本"><a href="#连接查询的成本" class="headerlink" title="连接查询的成本"></a>连接查询的成本</h2><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>&amp;emsp;&amp;emsp;连接查询至少是要有两个表的，只有一个<code>single_table</code>表是不够的，所以为了故事的顺利发展，我们直接构造一个和<code>single_table</code>表一模一样的<code>single_table2</code>表。为了简便起见，我们把<code>single_table</code>表称为<code>s1</code>表，把<code>single_table2</code>表称为<code>s2</code>表。</p><h3 id="Condition-filtering介绍"><a href="#Condition-filtering介绍" class="headerlink" title="Condition filtering介绍"></a>Condition filtering介绍</h3><p>&amp;emsp;&amp;emsp;我们前面说过，<code>MySQL</code>中连接查询采用的是嵌套循环连接算法，驱动表会被访问一次，被驱动表可能会被访问多次，所以对于两表连接查询来说，它的查询成本由下面两个部分构成：</p><ul><li>单次查询驱动表的成本</li><li>多次查询被驱动表的成本（<span style="color:red">具体查询多少次取决于对驱动表查询的结果集中有多少条记录</span>）</li></ul><p>&amp;emsp;&amp;emsp;我们把对驱动表进行查询后得到的记录条数称之为驱动表的<code>扇出</code>（英文名：<code>fanout</code>）。很显然驱动表的扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低。当查询优化器想计算整个连接查询所使用的成本时，就需要计算出驱动表的扇出值，有的时候扇出值的计算是很容易的，比如下面这两个查询：</p><ul><li><p>查询一：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;假设使用<code>s1</code>表作为驱动表，很显然对驱动表的单表查询只能使用全表扫描的方式执行，驱动表的扇出值也很明确，那就是驱动表中有多少记录，扇出值就是多少。我们前面说过，统计数据中<code>s1</code>表的记录行数是<code>9693</code>，也就是说优化器就直接会把<code>9693</code>当作在<code>s1</code>表的扇出值。</p></li><li><p>查询二：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">WHERE s1.key2 &gt;10 AND s1.key2 &lt; 1000;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;仍然假设<code>s1</code>表是驱动表的话，很显然对驱动表的单表查询可以使用<code>idx_key2</code>索引执行查询。此时<code>idx_key2</code>的范围区间<code>(10, 1000)</code>中有多少条记录，那么扇出值就是多少。我们前面计算过，满足<code>idx_key2</code>的范围区间<code>(10, 1000)</code>的记录数是95条，也就是说本查询中优化器会把<code>95</code>当作驱动表<code>s1</code>的扇出值。</p></li></ul><p>&amp;emsp;&amp;emsp;事情当然不会总是一帆风顺的，要不然剧情就太平淡了。有的时候扇出值的计算就变得很棘手，比方说下面几个查询：</p><ul><li><p>查询三：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    WHERE s1.common_field &gt; &#x27;xyz&#x27;;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;本查询和<code>查询一</code>类似，只不过对于驱动表<code>s1</code>多了一个<code>common_field &gt; &#39;xyz&#39;</code>的搜索条件。查询优化器又不会真正的去执行查询，所以它只能<code>猜</code>这<code>9693</code>记录里有多少条记录满足<code>common_field &gt; &#39;xyz&#39;</code>条件。</p></li><li><p>查询四：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    WHERE s1.key2 &gt; 10 AND s1.key2 &lt; 1000 AND</span><br><span class="line">          s1.common_field &gt; &#x27;xyz&#x27;;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;本查询和<code>查询二</code>类似，只不过对于驱动表<code>s1</code>也多了一个<code>common_field &gt; &#39;xyz&#39;</code>的搜索条件。不过因为本查询可以使用<code>idx_key2</code>索引，所以只需要从符合二级索引范围区间的记录中猜有多少条记录符合<code>common_field &gt; &#39;xyz&#39;</code>条件，也就是只需要猜在<code>95</code>条记录中有多少符合<code>common_field &gt; &#39;xyz&#39;</code>条件。</p></li><li><p>查询五：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    WHERE s1.key2 &gt; 10 AND s1.key2 &lt; 1000 AND</span><br><span class="line">          s1.key1 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND</span><br><span class="line">          s1.common_field &gt; &#x27;xyz&#x27;;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;本查询和<code>查询二</code>类似，不过在驱动表<code>s1</code>选取<code>idx_key2</code>索引执行查询后，优化器需要从符合二级索引范围区间的记录中猜有多少条记录符合下面两个条件：</p><ul><li><p><code>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code></p></li><li><p><code>common_field &gt; &#39;xyz&#39;</code></p></li></ul><p>  &amp;emsp;&amp;emsp;也就是优化器需要猜在<code>95</code>条记录中有多少符合上述两个条件的。</p></li></ul><p>&amp;emsp;&amp;emsp;说了这么多，其实就是想表达在这两种情况下计算驱动表扇出值时需要靠<code>猜</code>：</p><ul><li>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。</li><li>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</li></ul><p>&amp;emsp;&amp;emsp;设计<code>MySQL</code>的大佬把这个<code>猜</code>的过程称之为<code>condition filtering</code>。当然，这个过程可能会使用到索引，也可能使用到统计数据，也可能就是设计<code>MySQL</code>的大佬单纯的瞎猜，整个评估过程挺复杂的，再仔细的介绍一遍可能引起大家的生理不适，所以我们就跳过了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：在MySQL 5.7之前的版本中，查询优化器在计算驱动表扇出时，如果是使用全表扫描的话，就直接使用表中记录的数量作为扇出值，如果使用索引的话，就直接使用满足范围条件的索引记录条数作为扇出值。在MySQL 5.7中，设计MySQL的大佬引入了这个condition filtering的功能，就是还要猜一猜剩余的那些搜索条件能把驱动表中的记录再过滤多少条，其实本质上就是为了让成本估算更精确。我们所说的纯粹瞎猜其实是很不严谨的，设计MySQL的大佬们称之为启发式规则（heuristic），大家有兴趣的可以再深入了解一下。</span><br></pre></td></tr></table></figure><h3 id="两表连接的成本分析"><a href="#两表连接的成本分析" class="headerlink" title="两表连接的成本分析"></a>两表连接的成本分析</h3><p>&amp;emsp;&amp;emsp;连接查询的成本计算公式是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;对于左（外）连接和右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要：</p><ul><li>分别为驱动表和被驱动表选择成本最低的访问方法。</li></ul><p>&amp;emsp;&amp;emsp;可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：</p><ul><li>不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。</li><li>然后分别为驱动表和被驱动表选择成本最低的访问方法。</li></ul><p>&amp;emsp;&amp;emsp;很显然，计算内连接查询成本的方式更麻烦一些，下面我们就以内连接为例来看看如何计算出最优的连接查询方案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：左（外）连接和右（外）连接查询在某些特殊情况下可以被优化为内连接查询，我们在之后的章节中会仔细介绍的，稍安勿躁。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;比如对于下面这个查询来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    ON s1.key1 = s2.common_field </span><br><span class="line">    WHERE s1.key2 &gt; 10 AND s1.key2 &lt; 1000 AND </span><br><span class="line">          s2.key2 &gt; 1000 AND s2.key2 &lt; 2000;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以选择的连接顺序有两种：</p><ul><li><code>s1</code>连接<code>s2</code>，也就是<code>s1</code>作为驱动表，<code>s2</code>作为被驱动表。</li><li><code>s2</code>连接<code>s1</code>，也就是<code>s2</code>作为驱动表，<code>s1</code>作为被驱动表。</li></ul><p>&amp;emsp;&amp;emsp;查询优化器需要<span style="color:red">分别考虑这两种情况下的最优查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划</span>。我们分别来看一下（定性的分析一下，不像分析单表查询那样定量的分析了）：</p><ul><li><p>使用<code>s1</code>作为驱动表的情况</p><ul><li><p>分析对于驱动表的成本最低的执行方案</p><p>  &amp;emsp;&amp;emsp;首先看一下涉及<code>s1</code>表单表的搜索条件有哪些：</p><ul><li><code>s1.key2 &gt; 10 AND s1.key2 &lt; 1000</code></li></ul><p>  &amp;emsp;&amp;emsp;所以这个查询可能使用到<code>idx_key2</code>索引，从全表扫描和使用<code>idx_key2</code>这两个方案中选出成本最低的那个，这个过程我们上面都介绍过了，很显然使用<code>idx_key2</code>执行查询的成本更低些。  </p></li><li><p>然后分析对于被驱动表的成本最低的执行方案</p><p>  &amp;emsp;&amp;emsp;此时涉及被驱动表<code>idx_key2</code>的搜索条件就是：</p><ul><li><p><code>s2.common_field = 常数</code>（这是因为对驱动表<code>s1</code>结果集中的每一条记录，都需要进行一次被驱动表<code>s2</code>的访问，此时那些涉及两表的条件现在相当于只涉及被驱动表<code>s2</code>了。）</p></li><li><p><code>s2.key2 &gt; 1000 AND s2.key2 &lt; 2000</code></p></li></ul><p>  &amp;emsp;&amp;emsp;很显然，第一个条件由于<code>common_field</code>没有用到索引，所以并没有什么卵用，此时访问<code>single_table2</code>表时可用的方案也是全表扫描和使用<code>idx_key2</code>两种，很显然使用<code>idx_key2</code>的成本更小。</p></li></ul><p>  &amp;emsp;&amp;emsp;所以此时使用<code>single_table</code>作为驱动表时的总成本就是（暂时不考虑使用<code>join buffer</code>对成本的影响）：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用idx_key2访问s1的成本 + s1的扇出 × 使用idx_key2访问s2的成本</span><br></pre></td></tr></table></figure></p></li><li><p>使用<code>s2</code>作为驱动表的情况</p><ul><li><p>分析对于驱动表的成本最低的执行方案</p><p>  &amp;emsp;&amp;emsp;首先看一下涉及<code>s2</code>表单表的搜索条件有哪些：</p><ul><li><code>s2.key2 &gt; 10 AND s2.key2 &lt; 1000</code></li></ul><p>  &amp;emsp;&amp;emsp;所以这个查询可能使用到<code>idx_key2</code>索引，从全表扫描和使用<code>idx_key2</code>这两个方案中选出成本最低的那个，这个过程我们上面都介绍过了，很显然使用<code>idx_key2</code>执行查询的成本更低些。  </p></li><li><p>然后分析对于被驱动表的成本最低的执行方案</p><p>  &amp;emsp;&amp;emsp;此时涉及被驱动表<code>idx_key2</code>的搜索条件就是：</p><ul><li><code>s1.key1 = 常数</code></li><li><code>s1.key2 &gt; 1000 AND s1.key2 &lt; 2000</code></li></ul><p>  &amp;emsp;&amp;emsp;这时就很有趣了，使用<code>idx_key1</code>可以进行<code>ref</code>方式的访问，使用<code>idx_key2</code>可以使用<code>range</code>方式的访问。这是优化器需要从全表扫描、使用<code>idx_key1</code>、使用<code>idx_key2</code>这几个方案里选出一个成本最低的方案。这里有个问题啊，因为<code>idx_key2</code>的范围区间是确定的：<code>(10, 1000)</code>，怎么计算使用<code>idx_key2</code>的成本我们上面已经说过了，可是在没有真正执行查询前，<code>s1.key1 = 常数</code>中的<code>常数</code>值我们是不知道的，怎么衡量使用<code>idx_key1</code>执行查询的成本呢？其实很简单，直接使用索引统计数据就好了（就是索引列平均一个值重复多少次）。一般情况下，<code>ref</code>的访问方式要比<code>range</code>成本最低，这里假设使用<code>idx_key1</code>进行对<code>s2</code>的访问。</p></li></ul><p>  &amp;emsp;&amp;emsp;所以此时使用<code>single_table</code>作为驱动表时的总成本就是：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用idx_key2访问s2的成本 + s2的扇出 × 使用idx_key1访问s1的成本</span><br></pre></td></tr></table></figure></p></li></ul><p>&amp;emsp;&amp;emsp;最后优化器会比较这两种方式的最优访问成本，选取那个成本更低的连接顺序去真正的执行查询。从上面的计算过程也可以看出来，连接查询成本占大头的其实是<code>驱动表扇出数 x 单次访问被驱动表的成本</code>，所以我们的优化重点其实是下面这两个部分：</p><ul><li><p>尽量减少驱动表的扇出</p></li><li><p>对被驱动表的访问成本尽量低</p><p>  &amp;emsp;&amp;emsp;这一点对于我们实际书写连接查询语句时十分有用，我们需要<span style="color:red">尽量在被驱动表的连接列上建立索引</span>，这样就可以使用<code>ref</code>访问方法来降低访问被驱动表的成本了。如果可以，被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样就可以把访问被驱动表的成本降到更低了。</p></li></ul><h3 id="多表连接的成本分析"><a href="#多表连接的成本分析" class="headerlink" title="多表连接的成本分析"></a>多表连接的成本分析</h3><p>&amp;emsp;&amp;emsp;首先要考虑一下多表连接时可能产生出多少种连接顺序：</p><ul><li><p>对于两表连接，比如表A和表B连接</p><p>  &amp;emsp;&amp;emsp;只有 AB、BA这两种连接顺序。其实相当于<code>2 × 1 = 2</code>种连接顺序。</p></li><li><p>对于三表连接，比如表A、表B、表C进行连接</p><p>  &amp;emsp;&amp;emsp;有ABC、ACB、BAC、BCA、CAB、CBA这么6种连接顺序。其实相当于<code>3 × 2 × 1 = 6</code>种连接顺序。</p></li><li><p>对于四表连接的话，则会有<code>4 × 3 × 2 × 1 = 24</code>种连接顺序。</p></li><li><p>对于<code>n</code>表连接的话，则有 <code>n × (n-1) × (n-2) × ··· × 1</code>种连接顺序，就是n的阶乘种连接顺序，也就是<code>n!</code>。</p></li></ul><p>&amp;emsp;&amp;emsp;有<code>n</code>个表进行连接，<code>MySQL</code>查询优化器要每一种连接顺序的成本都计算一遍么？那可是<code>n!</code>种连接顺序呀。其实真的是要都算一遍，不过设计<code>MySQL</code>的大佬们想了很多办法减少计算非常多种连接顺序的成本的方法：</p><ul><li><p>提前结束某种顺序的成本评估</p><p>  &amp;emsp;&amp;emsp;<code>MySQL</code>在计算各种链接顺序的成本之前，会维护一个全局的变量，这个变量表示当前最小的连接查询成本。如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本，那就压根儿不对该连接顺序继续往下分析了。比方说A、B、C三个表进行连接，已经得到连接顺序<code>ABC</code>是当前的最小连接成本，比方说<code>10.0</code>，在计算连接顺序<code>BCA</code>时，发现<code>B</code>和<code>C</code>的连接成本就已经大于<code>10.0</code>时，就不再继续往后分析<code>BCA</code>这个连接顺序的成本了。</p></li><li><p>系统变量<code>optimizer_search_depth</code></p><p>  &amp;emsp;&amp;emsp;为了防止无穷无尽的分析各种连接顺序的成本，设计<code>MySQL</code>的大佬们提出了<code>optimizer_search_depth</code>系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对与<code>optimizer_search_depth</code>值相同数量的表进行穷举分析。很显然，该值越大，成本分析的越精确，越容易得到好的执行计划，但是消耗的时间也就越长，否则得到不是很好的执行计划，但可以省掉很多分析连接成本的时间。</p></li><li><p>根据某些规则压根儿就不考虑某些连接顺序</p><p>  &amp;emsp;&amp;emsp;即使是有上面两条规则的限制，但是分析多个表不同连接顺序成本花费的时间还是会很长，所以设计<code>MySQL</code>的大佬干脆提出了一些所谓的<code>启发式规则</code>（就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序压根儿就不分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。他们提供了一个系统变量<code>optimizer_prune_level</code>来控制到底是不是用这些启发式规则。</p></li></ul><h2 id="调节成本常数"><a href="#调节成本常数" class="headerlink" title="调节成本常数"></a>调节成本常数</h2><p>&amp;emsp;&amp;emsp;我们前面之介绍了两个<code>成本常数</code>：</p><ul><li>读取一个页面花费的成本默认是<code>1.0</code></li><li>检测一条记录是否符合搜索条件的成本默认是<code>0.2</code></li></ul><p>&amp;emsp;&amp;emsp;其实除了这两个成本常数，<code>MySQL</code>还支持好多呢，它们被存储到了<code>mysql</code>数据库（这是一个系统数据库，我们之前介绍过）的两个表中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES FROM mysql LIKE &#x27;%cost%&#x27;;</span><br><span class="line">+--------------------------+</span><br><span class="line">| Tables_in_mysql (%cost%) |</span><br><span class="line">+--------------------------+</span><br><span class="line">| engine_cost              |</span><br><span class="line">| server_cost              |</span><br><span class="line">+--------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们在第一章中就说过，一条语句的执行其实是分为两层的：</p><ul><li><p><code>server</code>层</p></li><li><p>存储引擎层</p></li></ul><p>&amp;emsp;&amp;emsp;在<code>server</code>层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。也就是说一条语句在<code>server</code>层中执行的成本是和它操作的表使用的存储引擎是没关系的，所以关于这些操作对应的<code>成本常数</code>就存储在了<code>server_cost</code>表中，而依赖于存储引擎的一些操作对应的<code>成本常数</code>就存储在了<code>engine_cost</code>表中。</p><h3 id="mysql-server-cost表"><a href="#mysql-server-cost表" class="headerlink" title="mysql.server_cost表"></a>mysql.server_cost表</h3><p>&amp;emsp;&amp;emsp;<code>server_cost</code>表中在<code>server</code>层进行的一些操作对应的<code>成本常数</code>，具体内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.server_cost;</span><br><span class="line">+------------------------------+------------+---------------------+---------+</span><br><span class="line">| cost_name                    | cost_value | last_update         | comment |</span><br><span class="line">+------------------------------+------------+---------------------+---------+</span><br><span class="line">| disk_temptable_create_cost   |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| disk_temptable_row_cost      |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| key_compare_cost             |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| memory_temptable_create_cost |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| memory_temptable_row_cost    |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| row_evaluate_cost            |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">+------------------------------+------------+---------------------+---------+</span><br><span class="line">6 rows in set (0.05 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们先看一下<code>server_cost</code>各个列都分别是什么意思：</p><ul><li><code>cost_name</code>：表示成本常数的名称。</li><li><code>cost_value</code>：表示成本常数对应的值。如果该列的值为<code>NULL</code>的话，意味着对应的成本常数会采用默认值。</li><li><code>last_update</code>：表示最后更新记录的时间。</li><li><code>comment</code>：注释。</li></ul><p>&amp;emsp;&amp;emsp;从<code>server_cost</code>中的内容可以看出来，目前在<code>server</code>层的一些操作对应的<code>成本常数</code>有以下几种：</p><table><thead><tr><th align="center">成本常数名称</th><th align="center">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>disk_temptable_create_cost</code></td><td align="center"><code>40.0</code></td><td align="left">创建基于磁盘的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td></tr><tr><td align="center"><code>disk_temptable_row_cost</code></td><td align="center"><code>1.0</code></td><td align="left">向基于磁盘的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td></tr><tr><td align="center"><code>key_compare_cost</code></td><td align="center"><code>0.1</code></td><td align="left">两条记录做比较操作的成本，多用在排序操作上，如果增大这个值的话会提升<code>filesort</code>的成本，让优化器可能更倾向于使用索引完成排序而不是<code>filesort</code>。</td></tr><tr><td align="center"><code>memory_temptable_create_cost</code></td><td align="center"><code>2.0</code></td><td align="left">创建基于内存的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td></tr><tr><td align="center"><code>memory_temptable_row_cost</code></td><td align="center"><code>0.2</code></td><td align="left">向基于内存的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td></tr><tr><td align="center"><code>row_evaluate_cost</code></td><td align="center"><code>0.2</code></td><td align="left">这个就是我们之前一直使用的检测一条记录是否符合搜索条件的成本，增大这个值可能让优化器更倾向于使用索引而不是直接全表扫描。</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：MySQL在执行诸如DISTINCT查询、分组查询、Union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表，使用这个临时表来辅助完成查询（比如对于DISTINCT查询可以建一个带有UNIQUE索引的临时表，直接把需要去重的记录插入到这个临时表中，插入完成之后的记录就是结果集了）。在数据量大的情况下可能创建基于磁盘的临时表，也就是为该临时表使用MyISAM、InnoDB等存储引擎，在数据量不大时可能创建基于内存的临时表，也就是使用Memory存储引擎。关于更多临时表的细节我们并不打算展开介绍，因为展开可能又需要好几万字了，大家知道创建临时表和对这个临时表进行写入和读取的操作代价还是很高的就行了。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这些成本常数在<code>server_cost</code>中的初始值都是<code>NULL</code>，意味着优化器会使用它们的默认值来计算某个操作的成本，如果我们想修改某个成本常数的值的话，需要做两个步骤：</p><ul><li><p>对我们感兴趣的成本常数做更新操作</p><p>  &amp;emsp;&amp;emsp;比方说我们想把检测一条记录是否符合搜索条件的成本增大到<code>0.4</code>，那么就可以这样写更新语句：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mysql.server_cost </span><br><span class="line">    SET cost_value = 0.4</span><br><span class="line">    WHERE cost_name = &#x27;row_evaluate_cost&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>让系统重新加载这个表的值。</p><p>  使用下面语句即可：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;当然，在你修改完某个成本常数后想把它们再改回默认值的话，可以直接把<code>cost_value</code>的值设置为<code>NULL</code>，再使用<code>FLUSH OPTIMIZER_COSTS</code>语句让系统重新加载它就好了。</p><h3 id="mysql-engine-cost表"><a href="#mysql-engine-cost表" class="headerlink" title="mysql.engine_cost表"></a>mysql.engine_cost表</h3><p>&amp;emsp;&amp;emsp;<code>engine_cost表</code>表中在存储引擎层进行的一些操作对应的<code>成本常数</code>，具体内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.engine_cost;</span><br><span class="line">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br><span class="line">| engine_name | device_type | cost_name              | cost_value | last_update         | comment |</span><br><span class="line">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br><span class="line">| default     |           0 | io_block_read_cost     |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| default     |           0 | memory_block_read_cost |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br><span class="line">2 rows in set (0.05 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;与<code>server_cost</code>相比，<code>engine_cost</code>多了两个列：</p><ul><li><code>engine_name</code>列：指成本常数适用的存储引擎名称。如果该值为<code>default</code>，意味着对应的成本常数适用于所有的存储引擎。</li><li><code>device_type</code>列：指存储引擎使用的设备类型，这主要是为了区分常规的机械硬盘和固态硬盘，不过在<code>MySQL 5.7.21</code>这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分，所以该值默认是<code>0</code>。</li></ul><p>&amp;emsp;&amp;emsp;我们从<code>engine_cost</code>表中的内容可以看出来，目前支持的存储引擎成本常数只有两个：</p><table><thead><tr><th align="center">成本常数名称</th><th align="center">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>io_block_read_cost</code></td><td align="center"><code>1.0</code></td><td align="left">从磁盘上读取一个块对应的成本。请注意我使用的是<code>块</code>，而不是<code>页</code>这个词儿。对于<code>InnoDB</code>存储引擎来说，一个<code>页</code>就是一个块，不过对于<code>MyISAM</code>存储引擎来说，默认是以<code>4096</code>字节作为一个块的。增大这个值会加重<code>I/O</code>成本，可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描。</td></tr><tr><td align="center"><code>memory_block_read_cost</code></td><td align="center"><code>1.0</code></td><td align="left">与上一个参数类似，只不过衡量的是从内存中读取一个块对应的成本。</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;大家看完这两个成本常数的默认值是不是有些疑惑，怎么从内存中和从磁盘上读取一个块的默认成本是一样的，脑子瓦特了？这主要是因为在<code>MySQL</code>目前的实现中，并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中，有哪些块还停留在磁盘上，所以设计<code>MySQL</code>的大佬们很粗暴的认为不管这个块有没有加载到内存中，使用的成本都是<code>1.0</code>，不过随着<code>MySQL</code>的发展，等到可以准确预测哪些块在磁盘上，那些块在内存中的那一天，这两个成本常数的默认值可能会改一改吧。</p><p>&amp;emsp;&amp;emsp;与更新<code>server_cost</code>表中的记录一样，我们也可以通过更新<code>engine_cost</code>表中的记录来更改关于存储引擎的成本常数，我们也可以通过为<code>engine_cost</code>表插入新记录的方式来添加只针对某种存储引擎的成本常数：</p><ul><li><p>插入针对某个存储引擎的成本常数</p><p>  &amp;emsp;&amp;emsp;比如我们想增大<code>InnoDB</code>存储引擎页面<code>I/O</code>的成本，书写正常的插入语句即可：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO mysql.engine_cost</span><br><span class="line">    VALUES (&#x27;InnoDB&#x27;, 0, &#x27;io_block_read_cost&#x27;, 2.0,</span><br><span class="line">    CURRENT_TIMESTAMP, &#x27;increase Innodb I/O cost&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>让系统重新加载这个表的值。</p><p>  使用下面语句即可：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure></li></ul><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/14-%E4%B8%8D%E5%A5%BD%E7%9C%8B%E5%B0%B1%E8%A6%81%E5%A4%9A%E6%95%B4%E5%AE%B9-MySQL%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%88%E5%86%85%E5%90%AB%E5%85%B3%E4%BA%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%BA%8C%E4%B8%89%E4%BA%8B%E5%84%BF%EF%BC%89/"/>
      <url>/2022/10/31/model-mysql/mysql/14-%E4%B8%8D%E5%A5%BD%E7%9C%8B%E5%B0%B1%E8%A6%81%E5%A4%9A%E6%95%B4%E5%AE%B9-MySQL%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%88%E5%86%85%E5%90%AB%E5%85%B3%E4%BA%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%BA%8C%E4%B8%89%E4%BA%8B%E5%84%BF%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="第14章-不好看就要多整容-MySQL基于规则的优化（内含关于子查询优化二三事儿）"><a href="#第14章-不好看就要多整容-MySQL基于规则的优化（内含关于子查询优化二三事儿）" class="headerlink" title="第14章 不好看就要多整容-MySQL基于规则的优化（内含关于子查询优化二三事儿）"></a>第14章 不好看就要多整容-MySQL基于规则的优化（内含关于子查询优化二三事儿）</h1><p>&amp;emsp;&amp;emsp;大家别忘了<code>MySQL</code>本质上是一个软件，设计<code>MySQL</code>的大佬并不能要求使用这个软件的人个个都是数据库高高手，就像我写这本书的时候并不能要求各位在学之前就会了里边儿的知识。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吐槽一下：都会了的人谁还看呢，难道是为了精神上受感化？</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;也就是说我们无法避免某些同学写一些执行起来十分耗费性能的语句。即使是这样，设计<code>MySQL</code>的大佬还是依据一些规则，竭尽全力的把这个很糟糕的语句转换成某种可以比较高效执行的形式，这个过程也可以被称作<code>查询重写</code>（就是人家觉得你写的语句不好，自己再重写一遍）。本章详细介绍一下一些比较重要的重写规则。</p><h2 id="条件化简"><a href="#条件化简" class="headerlink" title="条件化简"></a>条件化简</h2><p>&amp;emsp;&amp;emsp;我们编写的查询语句的搜索条件本质上是一个表达式，这些表达式可能比较繁杂，或者不能高效的执行，<code>MySQL</code>的查询优化器会为我们简化这些表达式。为了方便大家理解，我们后边举例子的时候都使用诸如<code>a</code>、<code>b</code>、<code>c</code>之类的简单字母代表某个表的列名。</p><h3 id="移除不必要的括号"><a href="#移除不必要的括号" class="headerlink" title="移除不必要的括号"></a>移除不必要的括号</h3><p>&amp;emsp;&amp;emsp;有时候表达式里有许多无用的括号，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((a = 5 AND b = c) OR ((a &gt; c) AND (c &lt; 5)))</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;看着就很烦，优化器会把那些用不到的括号给干掉，就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a = 5 and b = c) OR (a &gt; c AND c &lt; 5)</span><br></pre></td></tr></table></figure><h3 id="常量传递（constant-propagation）"><a href="#常量传递（constant-propagation）" class="headerlink" title="常量传递（constant_propagation）"></a>常量传递（constant_propagation）</h3><p>&amp;emsp;&amp;emsp;有时候某个表达式是某个列和某个常量做等值匹配，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;当这个表达式和其他涉及列<code>a</code>的表达式使用<code>AND</code>连接起来时，可以将其他表达式中的<code>a</code>的值替换为<code>5</code>，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5 AND b &gt; a</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;就可以被转换为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5 AND b &gt; 5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：为什么用OR连接起来的表达式就不能进行常量传递呢？自己想想～</span><br></pre></td></tr></table></figure><h3 id="等值传递（equality-propagation）"><a href="#等值传递（equality-propagation）" class="headerlink" title="等值传递（equality_propagation）"></a>等值传递（equality_propagation）</h3><p>&amp;emsp;&amp;emsp;有时候多个列之间存在等值匹配的关系，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b and b = c and c = 5</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个表达式可以被简化为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5 and b = 5 and c = 5</span><br></pre></td></tr></table></figure><h3 id="移除没用的条件（trivial-condition-removal）"><a href="#移除没用的条件（trivial-condition-removal）" class="headerlink" title="移除没用的条件（trivial_condition_removal）"></a>移除没用的条件（trivial_condition_removal）</h3><p>&amp;emsp;&amp;emsp;对于一些明显永远为<code>TRUE</code>或者<code>FALSE</code>的表达式，优化器会移除掉它们，比如这个表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a &lt; 1 and b = b) OR (a = 6 OR 5 != 5)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;很明显，<code>b = b</code>这个表达式永远为<code>TRUE</code>，<code>5 != 5</code>这个表达式永远为<code>FALSE</code>，所以简化后的表达式就是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a &lt; 1 and TRUE) OR (a = 6 OR FALSE)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以继续被简化为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &lt; 1 OR a = 6</span><br></pre></td></tr></table></figure><h3 id="表达式计算"><a href="#表达式计算" class="headerlink" title="表达式计算"></a>表达式计算</h3><p>&amp;emsp;&amp;emsp;在查询开始执行之前，如果表达式中只包含常量的话，它的值会被先计算出来，比如这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5 + 1</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;因为<code>5 + 1</code>这个表达式只包含常量，所以就会被化简成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 6</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;但是这里需要注意的是，如果某个列并不是以单独的形式作为表达式的操作数时，比如出现在函数中，出现在某个更复杂表达式中，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABS(a) &gt; 5</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a &lt; -8</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;<span style="color:red">优化器是不会尝试对这些表达式进行化简的</span>。我们前面说过只有搜索条件中索引列和常数使用某些运算符连接起来才可能使用到索引，所以如果可以的话，<span style="color:red">最好让索引列以单独的形式出现在表达式中</span>。</p><h3 id="HAVING子句和WHERE子句的合并"><a href="#HAVING子句和WHERE子句的合并" class="headerlink" title="HAVING子句和WHERE子句的合并"></a>HAVING子句和WHERE子句的合并</h3><p>&amp;emsp;&amp;emsp;如果查询语句中没有出现诸如<code>SUM</code>、<code>MAX</code>等等的聚集函数以及<code>GROUP BY</code>子句，优化器就把<code>HAVING</code>子句和<code>WHERE</code>子句合并起来。</p><h3 id="常量表检测"><a href="#常量表检测" class="headerlink" title="常量表检测"></a>常量表检测</h3><p>&amp;emsp;&amp;emsp;设计<code>MySQL</code>的大佬觉得下面这两种查询运行的特别快：</p><ul><li><p>查询的表中一条记录没有，或者只有一条记录。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：大家有没有觉得这一条有点儿不对劲，我还没开始查表呢咋就知道这表里边有几条记录呢？这个其实依靠的是统计数据。不过我们说过InnoDB的统计数据数据不准确，所以这一条不能用于使用InnoDB作为存储引擎的表，只能适用于使用Memory或者MyISAM存储引擎的表。</span><br></pre></td></tr></table></figure></li><li><p>使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表。</p></li></ul><p>&amp;emsp;&amp;emsp;设计<code>MySQL</code>的大佬觉得这两种查询花费的时间特别少，少到可以忽略，所以也把通过这两种方式查询的表称之为<code>常量表</code>（英文名：<code>constant tables</code>）。优化器在分析一个查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本，比方说这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table1 INNER JOIN table2</span><br><span class="line">    ON table1.column1 = table2.column2 </span><br><span class="line">    WHERE table1.primary_key = 1;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;很明显，这个查询可以使用主键和常量值的等值匹配来查询<code>table1</code>表，也就是在这个查询中<code>table1</code>表相当于<code>常量表</code>，在分析对<code>table2</code>表的查询成本之前，就会执行对<code>table1</code>表的查询，并把查询中涉及<code>table1</code>表的条件都替换掉，也就是上面的语句会被转换成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT table1表记录的各个字段的常量值, table2.* FROM table1 INNER JOIN table2 </span><br><span class="line">    ON table1表column1列的常量值 = table2.column2;</span><br></pre></td></tr></table></figure><h2 id="外连接消除"><a href="#外连接消除" class="headerlink" title="外连接消除"></a>外连接消除</h2><p>&amp;emsp;&amp;emsp;我们前面说过，<code>内连接</code>的驱动表和被驱动表的位置可以相互转换，而<code>左（外）连接</code>和<code>右（外）连接</code>的驱动表和被驱动表是固定的。这就导致<code>内连接</code>可能通过优化表的连接顺序来降低整体的查询成本，而<code>外连接</code>却无法优化表的连接顺序。为了故事的顺利发展，我们还是把之前介绍连接原理时用过的<code>t1</code>和<code>t2</code>表请出来，为了防止大家早就忘掉了，我们再看一下这两个表的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t1 (</span><br><span class="line">    m1 int, </span><br><span class="line">    n1 char(1)</span><br><span class="line">) Engine=InnoDB, CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE t2 (</span><br><span class="line">    m2 int, </span><br><span class="line">    n2 char(1)</span><br><span class="line">) Engine=InnoDB, CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;为了唤醒大家的记忆，我们再把这两个表中的数据给展示一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1;</span><br><span class="line">+------+------+</span><br><span class="line">| m1   | n1   |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | a    |</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    3 | c    |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM t2;</span><br><span class="line">+------+------+</span><br><span class="line">| m2   | n2   |</span><br><span class="line">+------+------+</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    3 | c    |</span><br><span class="line">|    4 | d    |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们之前说过，<span style="color:red">外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃</span>。查询效果就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">|    1 | a    | NULL | NULL |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;对于上面例子中的（左）外连接来说，由于驱动表<code>t1</code>中<code>m1=1, n1=&#39;a&#39;</code>的记录无法在被驱动表<code>t2</code>中找到符合<code>ON</code>子句条件<code>t1.m1 = t2.m2</code>的记录，所以就直接把这条记录加入到结果集，对应的<code>t2</code>表的<code>m2</code>和<code>n2</code>列的值都设置为<code>NULL</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：右（外）连接和左（外）连接其实只在驱动表的选取方式上是不同的，其余方面都是一样的，所以优化器会首先把右（外）连接查询转换成左（外）连接查询。我们后边就不再介绍右（外）连接了。</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们知道<code>WHERE</code>子句的杀伤力比较大，<span style="color:red">凡是不符合WHERE子句中条件的记录都不会参与连接</span>。只要我们在搜索条件中指定关于被驱动表相关列的值不为<code>NULL</code>，那么外连接中在被驱动表中找不到符合<code>ON</code>子句条件的驱动表记录也就被排除出最后的结果集了，也就是说：<span style="color:red">在这种情况下：外连接和内连接也就没有什么区别了</span>！比方说这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.n2 IS NOT NULL;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;由于指定了被驱动表<code>t2</code>的<code>n2</code>列不允许为<code>NULL</code>，所以上面的<code>t1</code>和<code>t2</code>表的左（外）连接查询和内连接查询是一样一样的。当然，我们也可以不用显式的指定被驱动表的某个列<code>IS NOT NULL</code>，只要隐含的有这个意思就行了，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;在这个例子中，我们在<code>WHERE</code>子句中指定了被驱动表<code>t2</code>的<code>m2</code>列等于<code>2</code>，也就相当于间接的指定了<code>m2</code>列不为<code>NULL</code>值，所以上面的这个左（外）连接查询其实和下面这个内连接查询是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们把这种在外连接查询中，指定的<code>WHERE</code>子句中包含被驱动表中的列不为<code>NULL</code>值的条件称之为<code>空值拒绝</code>（英文名：<code>reject-NULL</code>）。<span style="color:red">在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换</span>。这种转换带来的好处就是<span style="color:red">查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询</span>。</p><h2 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h2><p>&amp;emsp;&amp;emsp;我们的主题本来是介绍<code>MySQL</code>查询优化器是如何处理子查询的，但是我还是有一万个担心好多同学连子查询的语法都没掌握全，所以我们就先介绍介绍什么是个子查询（当然不会面面俱到啦，只是说个大概），然后再介绍关于子查询优化的事儿。</p><h3 id="子查询语法"><a href="#子查询语法" class="headerlink" title="子查询语法"></a>子查询语法</h3><p>&amp;emsp;&amp;emsp;想必大家都是妈妈生下来的吧，连孙猴子都有妈妈——<span style="color:red">石头人</span>。怀孕妈妈肚子里的那个东东就是她的孩子，类似的，在一个查询语句里的某个位置也可以有另一个查询语句，这个出现在某个查询语句的某个位置中的查询就被称为<code>子查询</code>（我们也可以称它为宝宝查询），那个充当“妈妈”角色的查询也被称之为<code>外层查询</code>。不像人们怀孕时宝宝们都只在肚子里，子查询可以在一个外层查询的各种位置出现，比如：</p><ul><li><p><code>SELECT</code>子句中</p><p>  &amp;emsp;&amp;emsp;也就是我们平时说的查询列表中，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT (SELECT m1 FROM t1 LIMIT 1);</span><br><span class="line">+-----------------------------+</span><br><span class="line">| (SELECT m1 FROM t1 LIMIT 1) |</span><br><span class="line">+-----------------------------+</span><br><span class="line">|                           1 |</span><br><span class="line">+-----------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;其中的<code>(SELECT m1 FROM t1 LIMIT 1)</code>就是我们介绍的所谓的<code>子查询</code>。</p></li><li><p><code>FROM</code>子句中</p><p>  &amp;emsp;&amp;emsp;比如：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT m, n FROM (SELECT m2 + 1 AS m, n2 AS n FROM t2 WHERE m2 &gt; 2) AS t;</span><br><span class="line">+------+------+</span><br><span class="line">| m    | n    |</span><br><span class="line">+------+------+</span><br><span class="line">|    4 | c    |</span><br><span class="line">|    5 | d    |</span><br><span class="line">+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这个例子中的子查询是：<code>(SELECT m2 + 1 AS m, n2 AS n FROM t2 WHERE m2 &gt; 2)</code>，很特别的地方是它出现在了<code>FROM</code>子句中。<code>FROM</code>子句里边儿不是存放我们要查询的表的名称么，这里放进来一个子查询是个什么鬼？其实这里我们可以把子查询的查询结果当作是一个表，子查询后边的<code>AS t</code>表明这个子查询的结果就相当于一个名称为<code>t</code>的表，这个名叫<code>t</code>的表的列就是子查询结果中的列，比如例子中表<code>t</code>就有两个列：<code>m</code>列和<code>n</code>列。这个放在<code>FROM</code>子句中的子查询本质上相当于一个<code>表</code>，但又和我们平常使用的表有点儿不一样，设计<code>MySQL</code>的大佬把这种由子查询结果集组成的表称之为<code>派生表</code>。</p></li><li><p><code>WHERE</code>或<code>ON</code>子句中</p><p>  &amp;emsp;&amp;emsp;把子查询放在外层查询的<code>WHERE</code>子句或者<code>ON</code>子句中可能是我们最常用的一种使用子查询的方式了，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);</span><br><span class="line">+------+------+</span><br><span class="line">| m1   | n1   |</span><br><span class="line">+------+------+</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    3 | c    |</span><br><span class="line">+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这个查询表明我们想要将<code>(SELECT m2 FROM t2)</code>这个子查询的结果作为外层查询的<code>IN</code>语句参数，整个查询语句的意思就是我们想找<code>t1</code>表中的某些记录，这些记录的<code>m1</code>列的值能在<code>t2</code>表的<code>m2</code>列找到匹配的值。</p></li><li><p><code>ORDER BY</code>子句中</p><p>  &amp;emsp;&amp;emsp;虽然语法支持，但没什么子意义，不介绍这种情况了。</p></li><li><p><code>GROUP BY</code>子句中</p><p>  &amp;emsp;&amp;emsp;同上～</p></li></ul><h4 id="按返回的结果集区分子查询"><a href="#按返回的结果集区分子查询" class="headerlink" title="按返回的结果集区分子查询"></a>按返回的结果集区分子查询</h4><p>&amp;emsp;&amp;emsp;因为子查询本身也算是一个查询，所以可以按照它们返回的不同结果集类型而把这些子查询分为不同的类型：</p><ul><li><p>标量子查询</p><p>  &amp;emsp;&amp;emsp;那些只返回一个单一值的子查询称之为<code>标量子查询</code>，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT (SELECT m1 FROM t1 LIMIT 1);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;或者这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 = (SELECT MIN(m2) FROM t2);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这两个查询语句中的子查询都返回一个单一的值，也就是一个<code>标量</code>。这些标量子查询可以作为一个单一值或者表达式的一部分出现在查询语句的各个地方。</p></li><li><p>行子查询</p><p>  &amp;emsp;&amp;emsp;顾名思义，就是返回一条记录的子查询，不过这条记录需要包含多个列（只包含一个列就成了标量子查询了）。比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE (m1, n1) = (SELECT m2, n2 FROM t2 LIMIT 1);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;其中的<code>(SELECT m2, n2 FROM t2 LIMIT 1)</code>就是一个行子查询，整条语句的含义就是要从<code>t1</code>表中找一些记录，这些记录的<code>m1</code>和<code>n2</code>列分别等于子查询结果中的<code>m2</code>和<code>n2</code>列。</p></li><li><p>列子查询</p><p>  &amp;emsp;&amp;emsp;列子查询自然就是查询出一个列的数据喽，不过这个列的数据需要包含多条记录（只包含一条记录就成了标量子查询了）。比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;其中的<code>(SELECT m2 FROM t2)</code>就是一个列子查询，表明查询出<code>t2</code>表的<code>m2</code>列的值作为外层查询<code>IN</code>语句的参数。</p></li><li><p>表子查询</p><p>  &amp;emsp;&amp;emsp;顾名思义，就是子查询的结果既包含很多条记录，又包含很多个列，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;其中的<code>(SELECT m2, n2 FROM t2)</code>就是一个表子查询，这里需要和行子查询对比一下，行子查询中我们用了<code>LIMIT 1</code>来保证子查询的结果只有一条记录，表子查询中不需要这个限制。</p></li></ul><h4 id="按与外层查询关系来区分子查询"><a href="#按与外层查询关系来区分子查询" class="headerlink" title="按与外层查询关系来区分子查询"></a>按与外层查询关系来区分子查询</h4><ul><li><p>不相关子查询</p><p>  &amp;emsp;&amp;emsp;如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为<code>不相关子查询</code>。我们前面介绍的那些子查询全部都可以看作不相关子查询，所以也就不举例子了。</p></li><li><p>相关子查询</p><p>  &amp;emsp;&amp;emsp;如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为<code>相关子查询</code>。比如：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2 WHERE n1 = n2);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;例子中的子查询是<code>(SELECT m2 FROM t2 WHERE n1 = n2)</code>，可是这个查询中有一个搜索条件是<code>n1 = n2</code>，别忘了<code>n1</code>是表<code>t1</code>的列，也就是外层查询的列，也就是说子查询的执行需要依赖于外层查询的值，所以这个子查询就是一个<code>相关子查询</code>。</p></li></ul><h4 id="子查询在布尔表达式中的使用"><a href="#子查询在布尔表达式中的使用" class="headerlink" title="子查询在布尔表达式中的使用"></a>子查询在布尔表达式中的使用</h4><p>&amp;emsp;&amp;emsp;你说写下面这样的子查询有什么意义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT (SELECT m1 FROM t1 LIMIT 1);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;貌似没什么意义～ 我们平时用子查询最多的地方就是把它作为布尔表达式的一部分来作为搜索条件用在<code>WHERE</code>子句或者<code>ON</code>子句里。所以我们这里来总结一下子查询在布尔表达式中的使用场景。</p><ul><li><p>使用<code>=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>&lt;&gt;</code>、<code>!=</code>、<code>&lt;=&gt;</code>作为布尔表达式的操作符</p><p>  &amp;emsp;&amp;emsp;这些操作符具体是什么意思就不用我多介绍了吧，如果你不知道的话，那我真的很佩服你是靠着什么勇气一口气看到这里的～ 为了方便，我们就把这些操作符称为<code>comparison_operator</code>吧，所以子查询组成的布尔表达式就长这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 comparison_operator (子查询)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这里的<code>操作数</code>可以是某个列名，或者是一个常量，或者是一个更复杂的表达式，甚至可以是另一个子查询。但是需要注意的是，<span style="color:red">这里的子查询只能是标量子查询或者行子查询，也就是子查询的结果只能返回一个单一的值或者只能是一条记录</span>。比如这样（标量子查询）：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 &lt; (SELECT MIN(m2) FROM t2);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;或者这样（行子查询）：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE (m1, n1) = (SELECT m2, n2 FROM t2 LIMIT 1);</span><br></pre></td></tr></table></figure></li><li><p>[NOT] IN&#x2F;ANY&#x2F;SOME&#x2F;ALL子查询</p><p>  &amp;emsp;&amp;emsp;对于列子查询和表子查询来说，它们的结果集中包含很多条记录，这些记录相当于是一个集合，所以就不能单纯的和另外一个操作数使用<code>comparison_operator</code>来组成布尔表达式了，<code>MySQL</code>通过下面的语法来支持某个操作数和一个集合组成一个布尔表达式：</p><ul><li><p><code>IN</code>或者<code>NOT IN</code></p><p>  &amp;emsp;&amp;emsp;具体的语法形式如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 [NOT] IN (子查询)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这个布尔表达式的意思是用来判断某个操作数在不在由子查询结果集组成的集合中，比如下面的查询的意思是找出<code>t1</code>表中的某些记录，这些记录存在于子查询的结果集中：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE (m1, n2) IN (SELECT m2, n2 FROM t2);</span><br></pre></td></tr></table></figure></li><li><p><code>ANY/SOME</code>（<code>ANY</code>和<code>SOME</code>是同义词）</p><p>  &amp;emsp;&amp;emsp;具体的语法形式如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 comparison_operator ANY/SOME(子查询)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这个布尔表达式的意思是只要子查询结果集中存在某个值和给定的操作数做<code>comparison_operator</code>比较结果为<code>TRUE</code>，那么整个表达式的结果就为<code>TRUE</code>，否则整个表达式的结果就为<code>FALSE</code>。比方说下面这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 &gt; ANY(SELECT m2 FROM t2);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这个查询的意思就是对于<code>t1</code>表的某条记录的<code>m1</code>列的值来说，如果子查询<code>(SELECT m2 FROM t2)</code>的结果集中存在一个小于<code>m1</code>列的值，那么整个布尔表达式的值就是<code>TRUE</code>，否则为<code>FALSE</code>，也就是说只要<code>m1</code>列的值大于子查询结果集中最小的值，整个表达式的结果就是<code>TRUE</code>，所以上面的查询本质上等价于这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 &gt; (SELECT MIN(m2) FROM t2);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;另外，<span style="color:red">&#x3D;ANY相当于判断子查询结果集中是否存在某个值和给定的操作数相等，它的含义和IN是相同的</span>。</p></li><li><p><code>ALL</code></p><p>  &amp;emsp;&amp;emsp;具体的语法形式如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 comparison_operator ALL(子查询)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这个布尔表达式的意思是子查询结果集中所有的值和给定的操作数做<code>comparison_operator</code>比较结果为<code>TRUE</code>，那么整个表达式的结果就为<code>TRUE</code>，否则整个表达式的结果就为<code>FALSE</code>。比方说下面这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 &gt; ALL(SELECT m2 FROM t2);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这个查询的意思就是对于<code>t1</code>表的某条记录的<code>m1</code>列的值来说，如果子查询<code>(SELECT m2 FROM t2)</code>的结果集中的所有值都小于<code>m1</code>列的值，那么整个布尔表达式的值就是<code>TRUE</code>，否则为<code>FALSE</code>，也就是说只要<code>m1</code>列的值大于子查询结果集中最大的值，整个表达式的结果就是<code>TRUE</code>，所以上面的查询本质上等价于这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 &gt; (SELECT MAX(m2) FROM t2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：觉得ANY和ALL有点晕的同学多看两遍。</span><br></pre></td></tr></table></figure></li></ul></li><li><p>EXISTS子查询</p><p>  &amp;emsp;&amp;emsp;有的时候我们仅仅需要判断子查询的结果集中是否有记录，而不在乎它的记录具体是什么，可以使用把<code>EXISTS</code>或者<code>NOT EXISTS</code>放在子查询语句前面，就像这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NOT] EXISTS (子查询)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;我们举一个例子啊：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE EXISTS (SELECT 1 FROM t2);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;对于子查询<code>(SELECT 1 FROM t2)</code>来说，我们并不关心这个子查询最后到底查询出的结果是什么，所以查询列表里填<code>*</code>、某个列名，或者其他什么东西都无所谓，我们真正关心的是子查询的结果集中是否存在记录。也就是说只要<code>(SELECT 1 FROM t2)</code>这个查询中有记录，那么整个<code>EXISTS</code>表达式的结果就为<code>TRUE</code>。</p></li></ul><h4 id="子查询语法注意事项"><a href="#子查询语法注意事项" class="headerlink" title="子查询语法注意事项"></a>子查询语法注意事项</h4><ul><li><p>子查询必须用小括号扩起来。</p><p>  &amp;emsp;&amp;emsp;不扩起来的子查询是非法的，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SELECT m1 FROM t1;</span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;SELECT m1 FROM t1&#x27; at line 1</span><br></pre></td></tr></table></figure></li><li><p>在<code>SELECT</code>子句中的子查询必须是标量子查询。</p><p>  &amp;emsp;&amp;emsp;如果子查询结果集中有多个列或者多个行，都不允许放在<code>SELECT</code>子句中，也就是查询列表中，比如这样就是非法的：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT (SELECT m1, n1 FROM t1);</span><br><span class="line"></span><br><span class="line">ERROR 1241 (21000): Operand should contain 1 column(s)</span><br></pre></td></tr></table></figure></li><li><p>在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用<code>LIMIT 1</code>语句来限制记录数量。</p></li><li><p>对于<code>[NOT] IN/ANY/SOME/ALL</code>子查询来说，子查询中不允许有<code>LIMIT</code>语句。</p><p>  &amp;emsp;&amp;emsp;比如这样是非法的：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 WHERE m1 IN (SELECT * FROM t2 LIMIT 2);</span><br><span class="line"></span><br><span class="line">ERROR 1235 (42000): This version of MySQL doesn&#x27;t yet support &#x27;LIMIT &amp; IN/ALL/ANY/SOME subquery&#x27;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;为什么不合法？人家就这么规定的，不解释～ 可能以后的版本会支持吧。正因为<code>[NOT] IN/ANY/SOME/ALL</code>子查询不支持<code>LIMIT</code>语句，所以子查询中的这些语句也就是多余的了：</p><ul><li><p><code>ORDER BY</code>子句</p><p>  &amp;emsp;&amp;emsp;子查询的结果其实就相当于一个集合，集合里的值排不排序一点儿都不重要，比如下面这个语句中的<code>ORDER BY</code>子句简直就是画蛇添足：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2 ORDER BY m2);</span><br></pre></td></tr></table></figure></li><li><p><code>DISTINCT</code>语句</p><p>  &amp;emsp;&amp;emsp;集合里的值去不去重也没什么意义，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 IN (SELECT DISTINCT m2 FROM t2);</span><br></pre></td></tr></table></figure></li><li><p>没有聚集函数以及<code>HAVING</code>子句的<code>GROUP BY</code>子句。</p><p>  &amp;emsp;&amp;emsp;在没有聚集函数以及<code>HAVING</code>子句时，<code>GROUP BY</code>子句就是个摆设，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2 GROUP BY m2);</span><br></pre></td></tr></table></figure></li></ul><p>  &amp;emsp;&amp;emsp;对于这些冗余的语句，<span style="color:red">查询优化器在一开始就把它们给干掉了</span>。  </p></li><li><p>不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。</p><p>  &amp;emsp;&amp;emsp;比方说这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM t1 WHERE m1 &lt; (SELECT MAX(m1) FROM t1);</span><br><span class="line"></span><br><span class="line">ERROR 1093 (HY000): You can&#x27;t specify target table &#x27;t1&#x27; for update in FROM clause</span><br></pre></td></tr></table></figure></li></ul><h3 id="子查询在MySQL中是怎么执行的"><a href="#子查询在MySQL中是怎么执行的" class="headerlink" title="子查询在MySQL中是怎么执行的"></a>子查询在MySQL中是怎么执行的</h3><p>&amp;emsp;&amp;emsp;好了，关于子查询的基础语法我们用最快的速度温习了一遍，如果想了解更多语法细节，大家可以去查看一下<code>MySQL</code>的文档，现在我们就假设各位都懂了什么是个子查询了喔，接下来就要介绍具体某种类型的子查询在<code>MySQL</code>中是怎么执行的了，想想就有点儿小激动呢～ 当然，为了故事的顺利发展，我们的例子也需要跟随形势鸟枪换炮，还是要祭出我们用了n遍的<code>single_table</code>表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE single_table (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    UNIQUE KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;为了方便，我们假设有两个表<code>s1</code>、<code>s2</code>与这个<code>single_table</code>表的构造是相同的，而且这两个表里边儿有10000条记录，除id列外其余的列都插入随机值。下面正式开始我们的表演。</p><h4 id="小白们眼中子查询的执行方式"><a href="#小白们眼中子查询的执行方式" class="headerlink" title="小白们眼中子查询的执行方式"></a>小白们眼中子查询的执行方式</h4><p>&amp;emsp;&amp;emsp;在我还是一个单纯无知的少年时，觉得子查询的执行方式是这样的：</p><ul><li><p>如果该子查询是不相关子查询，比如下面这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;我年少时觉得这个查询是的执行方式是这样的：</p><ul><li>先单独执行<code>(SELECT common_field FROM s2)</code>这个子查询。</li><li>然后在将上一步子查询得到的结果当作外层查询的参数再执行外层查询<code>SELECT * FROM s1 WHERE key1 IN (...)</code>。</li></ul></li><li><p>如果该子查询是相关子查询，比如下面这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE s1.key2 = s2.key2);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这个查询中的子查询中出现了<code>s1.key2 = s2.key2</code>这样的条件，意味着该子查询的执行依赖着外层查询的值，所以我年少时觉得这个查询的执行方式是这样的：</p><ul><li>先从外层查询中获取一条记录，本例中也就是先从<code>s1</code>表中获取一条记录。</li><li>然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，本例中就是从<code>s1</code>表中获取的那条记录中找出<code>s1.key2</code>列的值，然后执行子查询。</li><li>最后根据子查询的查询结果来检测外层查询<code>WHERE</code>子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。</li><li>再次执行第一步，获取第二条外层查询中的记录，依次类推～</li></ul></li></ul><p>&amp;emsp;&amp;emsp;告诉我不只是我一个人是这样认为的，这样认为的同学请举起你们的双手～～～ 哇唔，还真不少～ </p><p>&amp;emsp;&amp;emsp;其实设计<code>MySQL</code>的大佬想了一系列的办法来优化子查询的执行，大部分情况下这些优化措施其实挺有效的，但是保不齐有的时候马失前蹄，下面我们详细介绍各种不同类型的子查询具体是怎么执行的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：我们下面即将介绍的关于MySQL优化子查询的执行方式的事儿都是基于MySQL5.7这个版本的，以后版本可能有更新的优化策略！</span><br></pre></td></tr></table></figure><h4 id="标量子查询、行子查询的执行方式"><a href="#标量子查询、行子查询的执行方式" class="headerlink" title="标量子查询、行子查询的执行方式"></a>标量子查询、行子查询的执行方式</h4><p>&amp;emsp;&amp;emsp;我们经常在下面两个场景中使用到标量子查询或者行子查询：</p><ul><li><p><code>SELECT</code>子句中，我们前面说过的在查询列表中的子查询必须是标量子查询。</p></li><li><p>子查询使用<code>=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>&lt;&gt;</code>、<code>!=</code>、<code>&lt;=&gt;</code>等操作符和某个操作数组成一个布尔表达式，这样的子查询必须是标量子查询或者行子查询。</p></li></ul><p>&amp;emsp;&amp;emsp;对于上述两种场景中的<span style="color:red">不相关</span>标量子查询或者行子查询来说，它们的执行方式是简单的，比方说下面这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 = (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27; LIMIT 1);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;它的执行方式和年少的我想的一样：</p><ul><li><p>先单独执行<code>(SELECT common_field FROM s2 WHERE key3 = &#39;a&#39; LIMIT 1)</code>这个子查询。</p></li><li><p>然后在将上一步子查询得到的结果当作外层查询的参数再执行外层查询<code>SELECT * FROM s1 WHERE key1 = ...</code>。</p></li></ul><p>&amp;emsp;&amp;emsp;也就是说，<span style="color:red">对于包含不相关的标量子查询或者行子查询的查询语句来说，MySQL会分别独立的执行外层查询和子查询，就当作两个单表查询就好了</span>。</p><p>&amp;emsp;&amp;emsp;对于<span style="color:red">相关</span>的标量子查询或者行子查询来说，比如下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE </span><br><span class="line">    key1 = (SELECT common_field FROM s2 WHERE s1.key3 = s2.key3 LIMIT 1);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;事情也和年少的我想的一样，它的执行方式就是这样的：</p><ul><li>先从外层查询中获取一条记录，本例中也就是先从<code>s1</code>表中获取一条记录。</li><li>然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，本例中就是从<code>s1</code>表中获取的那条记录中找出<code>s1.key3</code>列的值，然后执行子查询。</li><li>最后根据子查询的查询结果来检测外层查询<code>WHERE</code>子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。</li><li>再次执行第一步，获取第二条外层查询中的记录，依次类推～</li></ul><p>&amp;emsp;&amp;emsp;也就是说对于一开始介绍的两种使用标量子查询以及行子查询的场景中，<code>MySQL</code>优化器的执行方式并没有什么新鲜的。</p><h4 id="IN子查询优化"><a href="#IN子查询优化" class="headerlink" title="IN子查询优化"></a>IN子查询优化</h4><h5 id="物化表的提出"><a href="#物化表的提出" class="headerlink" title="物化表的提出"></a>物化表的提出</h5><p>&amp;emsp;&amp;emsp;对于不相关的<code>IN</code>子查询，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们最开始的感觉就是这种不相关的<code>IN</code>子查询和不相关的标量子查询或者行子查询是一样一样的，都是把外层查询和子查询当作两个独立的单表查询来对待，可是很遗憾的是设计<code>MySQL</code>的大佬为了优化<code>IN</code>子查询倾注了太多心血（毕竟<code>IN</code>子查询是我们日常生活中最常用的子查询类型），所以整个执行过程并不像我们想象的那么简单(&gt;_&lt;)。</p><p>&amp;emsp;&amp;emsp;其实说句老实话，对于不相关的<code>IN</code>子查询来说，如果子查询的结果集中的记录条数很少，那么把子查询和外层查询分别看成两个单独的单表查询效率还是蛮高的，但是如果单独执行子查询后的结果集太多的话，就会导致这些问题：</p><ul><li><p>结果集太多，可能内存中都放不下～</p></li><li><p>对于外层查询来说，如果子查询的结果集太多，那就意味着<code>IN</code>子句中的参数特别多，这就导致：</p><ul><li><p>无法有效的使用索引，只能对外层查询进行全表扫描。</p></li><li><p>在对外层查询执行全表扫描时，由于<code>IN</code>子句中的参数太多，这会导致检测一条记录是否符合和<code>IN</code>子句中的参数匹配花费的时间太长。</p><p>  &amp;emsp;&amp;emsp;比如说<code>IN</code>子句中的参数只有两个：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE column IN (a, b);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这样相当于需要对<code>tbl_name</code>表中的每条记录判断一下它的<code>column</code>列是否符合<code>column = a OR column = b</code>。在<code>IN</code>子句中的参数比较少时这并不是什么问题，如果<code>IN</code>子句中的参数比较多时，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE column IN (a, b, c ..., ...);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;那么这样每条记录需要判断一下它的<code>column</code>列是否符合<code>column = a OR column = b OR column = c OR ...</code>，这样性能耗费可就多了。</p></li></ul></li></ul><p>&amp;emsp;&amp;emsp;于是乎设计<code>MySQL</code>的大佬想了一个招：<span style="color:red">不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表里</span>。写入临时表的过程是这样的：</p><ul><li><p>该临时表的列就是子查询结果集中的列。</p></li><li><p>写入临时表的记录会被去重。</p><p>  &amp;emsp;&amp;emsp;我们说<code>IN</code>语句是判断某个操作数在不在某个集合中，集合中的值重不重复对整个<code>IN</code>语句的结果并没有什么子关系，所以我们在将结果集写入临时表时对记录进行去重可以让临时表变得更小，更省地方～</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：临时表如何对记录进行去重？这不是小意思嘛，临时表也是个表，只要为表中记录的所有列建立主键或者唯一索引就好了嘛～</span><br></pre></td></tr></table></figure></li><li><p>一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用<code>Memory</code>存储引擎的临时表，而且会为该表建立希索引。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小贴士：IN语句的本质就是判断某个操作数在不在某个集合里，如果集合中的数据建立了哈希索引，那么这个匹配的过程就是超级快的。  </span><br><span class="line">有同学不知道哈希索引是什么？我这里就不展开了，自己上网找找吧，不会了再来问我～</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;如果子查询的结果集非常大，超过了系统变量<code>tmp_table_size</code>或者<code>max_heap_table_size</code>，临时表会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也对应转变为<code>B+</code>树索引。</p></li></ul><p>&amp;emsp;&amp;emsp;设计<code>MySQL</code>的大佬把这个将子查询结果集中的记录保存到临时表的过程称之为<code>物化</code>（英文名：<code>Materialize</code>）。为了方便起见，我们就把那个存储子查询结果集的临时表称之为<code>物化表</code>。正因为物化表中的记录都建立了索引（基于内存的物化表有哈希索引，基于磁盘的有B+树索引），通过索引执行<code>IN</code>语句判断某个操作数在不在子查询结果集中变得非常快，从而提升了子查询语句的性能。</p><h5 id="物化表转连接"><a href="#物化表转连接" class="headerlink" title="物化表转连接"></a>物化表转连接</h5><p>&amp;emsp;&amp;emsp;事情到这就完了？我们还得重新审视一下最开始的那个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;当我们把子查询进行物化之后，假设子查询物化表的名称为<code>materialized_table</code>，该物化表存储的子查询结果集的列为<code>m_val</code>，那么这个查询其实可以从下面两种角度来看待：</p><ul><li><p>从表<code>s1</code>的角度来看待，整个查询的意思其实是：对于<code>s1</code>表中的每条记录来说，如果该记录的<code>key1</code>列的值在子查询对应的物化表中，则该记录会被加入最终的结果集。画个图表示一下就是这样：</p><p>  <img src="/../images/14-01.png"></p></li><li><p>从子查询物化表的角度来看待，整个查询的意思其实是：对于子查询物化表的每个值来说，如果能在<code>s1</code>表中找到对应的<code>key1</code>列的值与该值相等的记录，那么就把这些记录加入到最终的结果集。画个图表示一下就是这样：</p><p>  <img src="/../images/14-02.png"></p></li></ul><p>&amp;emsp;&amp;emsp;也就是说其实上面的查询就相当于表<code>s1</code>和子查询物化表<code>materialized_table</code>进行内连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.* FROM s1 INNER JOIN materialized_table ON key1 = m_val;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;转化成内连接之后就有意思了，查询优化器可以评估不同连接顺序需要的成本是多少，选取成本最低的那种查询方式执行查询。我们分析一下上述查询中使用外层查询的表<code>s1</code>和物化表<code>materialized_table</code>进行内连接的成本都是由哪几部分组成的：</p><ul><li><p>如果使用<code>s1</code>表作为驱动表的话，总查询成本由下面几个部分组成：</p><ul><li>物化子查询时需要的成本</li><li>扫描<code>s1</code>表时的成本</li><li>s1表中的记录数量 × 通过<code>m_val = xxx</code>对<code>materialized_table</code>表进行单表访问的成本（我们前面说过物化表中的记录是不重复的，并且为物化表中的列建立了索引，所以这个步骤显然是非常快的）。</li></ul></li><li><p>如果使用<code>materialized_table</code>表作为驱动表的话，总查询成本由下面几个部分组成：</p><ul><li>物化子查询时需要的成本</li><li>扫描物化表时的成本</li><li>物化表中的记录数量 × 通过<code>key1 = xxx</code>对<code>s1</code>表进行单表访问的成本（非常庆幸<code>key1</code>列上建立了索引，所以这个步骤是非常快的）。</li></ul></li></ul><p>&amp;emsp;&amp;emsp;<code>MySQL</code>查询优化器会通过运算来选择上述成本更低的方案来执行查询。</p><h5 id="将子查询转换为semi-join"><a href="#将子查询转换为semi-join" class="headerlink" title="将子查询转换为semi-join"></a>将子查询转换为semi-join</h5><p>&amp;emsp;&amp;emsp;虽然将子查询进行物化之后再执行查询都会有建立临时表的成本，但是不管怎么说，我们见识到了将子查询转换为连接的强大作用，设计<code>MySQL</code>的大佬继续开脑洞：能不能不进行物化操作直接把子查询转换为连接呢？让我们重新审视一下上面的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们可以把这个查询理解成：对于<code>s1</code>表中的某条记录，如果我们能在<code>s2</code>表（准确的说是执行完<code>WHERE s2.key3 = &#39;a&#39;</code>之后的结果集）中找到一条或多条记录，这些记录的<code>common_field</code>的值等于<code>s1</code>表记录的<code>key1</code>列的值，那么该条<code>s1</code>表的记录就会被加入到最终的结果集。这个过程其实和把<code>s1</code>和<code>s2</code>两个表连接起来的效果很像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.* FROM s1 INNER JOIN s2 </span><br><span class="line">    ON s1.key1 = s2.common_field </span><br><span class="line">    WHERE s2.key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;只不过我们不能保证对于<code>s1</code>表的某条记录来说，在<code>s2</code>表（准确的说是执行完<code>WHERE s2.key3 = &#39;a&#39;</code>之后的结果集）中有多少条记录满足<code>s1.key1 = s2.common_field</code>这个条件，不过我们可以分三种情况讨论：</p><ul><li>情况一：对于<code>s1</code>表的某条记录来说，<code>s2</code>表中<span style="color:red">没有</span>任何记录满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录自然也不会加入到最后的结果集。</li><li>情况二：对于<code>s1</code>表的某条记录来说，<code>s2</code>表中<span style="color:red">有且只有</span>记录满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录会被加入最终的结果集。</li><li>情况三：对于<code>s1</code>表的某条记录来说，<code>s2</code>表中<span style="color:red">至少有2条</span>记录满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录会被<span style="color:red">多次</span>加入最终的结果集。</li></ul><p>&amp;emsp;&amp;emsp;对于<code>s1</code>表的某条记录来说，由于我们只关心<code>s2</code>表中<span style="color:red">是否存在</span>记录满足<code>s1.key1 = s2.common_field</code>这个条件，而<span style="color:red">不关心具体有多少条记录与之匹配</span>，又因为有<code>情况三</code>的存在，我们上面所说的<code>IN</code>子查询和两表连接之间并不完全等价。但是将子查询转换为连接又真的可以充分发挥优化器的作用，所以设计<code>MySQL</code>的大佬在这里提出了一个新概念 — <code>半连接</code>（英文名：<code>semi-join</code>）。将<code>s1</code>表和<code>s2</code>表进行半连接的意思就是：<span style="color:red">对于<code>s1</code>表的某条记录来说，我们只关心在<code>s2</code>表中是否存在与之匹配的记录是否存在，而不关心具体有多少条记录与之匹配，最终的结果集中只保留<code>s1</code>表的记录</span>。为了让大家有更直观的感受，我们假设MySQL内部是这么改写上面的子查询的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.* FROM s1 SEMI JOIN s2</span><br><span class="line">    ON s1.key1 = s2.common_field</span><br><span class="line">    WHERE key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：semi-join只是在MySQL内部采用的一种执行子查询的方式，MySQL并没有提供面向用户的semi-join语法，所以我们不需要，也不能尝试把上面这个语句放到黑框框里运行，我只是想说明一下上面的子查询在MySQL内部会被转换为类似上面语句的半连接～</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;概念是有了，怎么实现这种所谓的<code>半连接</code>呢？设计<code>MySQL</code>的大佬准备了好几种办法。</p><ul><li><p>Table pullout （子查询中的表上拉）</p><p>  &amp;emsp;&amp;emsp;当<span style="color:red">子查询的查询列表处只有主键或者唯一索引列</span>时，可以直接把子查询中的表<code>上拉</code>到外层查询的<code>FROM</code>子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中，比如这个</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key2 IN (SELECT key2 FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;由于<code>key2</code>列是<code>s2</code>表的唯一二级索引列，所以我们可以直接把<code>s2</code>表上拉到外层查询的<code>FROM</code>子句中，并且把子查询中的搜索条件合并到外层查询的搜索条件中，上拉之后的查询就是这样的：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.* FROM s1 INNER JOIN s2 </span><br><span class="line">    ON s1.key2 = s2.key2 </span><br><span class="line">    WHERE s2.key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;为什么当子查询的查询列表处只有主键或者唯一索引列时，就可以直接将子查询转换为连接查询呢？哎呀，主键或者唯一索引列中的数据本身就是不重复的嘛！所以对于同一条<code>s1</code>表中的记录，你不可能找到两条以上的符合<code>s1.key2 = s2.key2</code>的记录呀～</p></li><li><p>DuplicateWeedout execution strategy （重复值消除）</p><p>  &amp;emsp;&amp;emsp;对于这个查询来说：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;转换为半连接查询后，<code>s1</code>表中的某条记录可能在<code>s2</code>表中有多条匹配的记录，所以该条记录可能多次被添加到最后的结果集中，为了消除重复，我们可以建立一个临时表，比方说这个临时表长这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tmp (</span><br><span class="line">    id PRIMARY KEY</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这样在执行连接查询的过程中，每当某条<code>s1</code>表中的记录要加入结果集时，就首先把这条记录的<code>id</code>值加入到这个临时表里，如果添加成功，说明之前这条<code>s1</code>表中的记录并没有加入最终的结果集，现在把该记录添加到最终的结果集；如果添加失败，说明这条之前这条<code>s1</code>表中的记录已经加入过最终的结果集，这里直接把它丢弃就好了，这种使用临时表消除<code>semi-join</code>结果集中的重复值的方式称之为<code>DuplicateWeedout</code>。</p></li><li><p>LooseScan execution strategy （松散索引扫描）</p><p>  &amp;emsp;&amp;emsp;大家看这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key3 IN (SELECT key1 FROM s2 WHERE key1 &gt; &#x27;a&#x27; AND key1 &lt; &#x27;b&#x27;);</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;在子查询中，对于<code>s2</code>表的访问可以使用到<code>key1</code>列的索引，而恰好子查询的查询列表处就是<code>key1</code>列，这样在将该查询转换为半连接查询后，如果将<code>s2</code>作为驱动表执行查询的话，那么执行过程就是这样：</p><p>  <img src="/../images/14-03.png"></p><p>  &amp;emsp;&amp;emsp;如图所示，在<code>s2</code>表的<code>idx_key1</code>索引中，值为<code>&#39;aa&#39;</code>的二级索引记录一共有3条，那么只需要取第一条的值到<code>s1</code>表中查找<code>s1.key3 = &#39;aa&#39;</code>的记录，如果能在<code>s1</code>表中找到对应的记录，那么就把对应的记录加入到结果集。依此类推，其他值相同的二级索引记录，也只需要取第一条记录的值到<code>s1</code>表中找匹配的记录，这种虽然是扫描索引，但只取值相同的记录的第一条去做匹配操作的方式称之为<code>松散索引扫描</code>。</p></li><li><p>Semi-join Materialization execution strategy</p><p>  &amp;emsp;&amp;emsp;我们之前介绍的先把外层查询的<code>IN</code>子句中的不相关子查询进行物化，然后再进行外层查询的表和物化表的连接本质上也算是一种<code>semi-join</code>，只不过由于物化表中没有重复的记录，所以可以直接将子查询转为连接查询。</p></li><li><p>FirstMatch execution strategy （首次匹配）</p><p>  &amp;emsp;&amp;emsp;<code>FirstMatch</code>是一种最原始的半连接执行方式，跟我们年少时认为的相关子查询的执行方式是一样一样的，就是说先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录，如果能找到一条，则将该外层查询的记录放入最终的结果集并且停止查找更多匹配的记录，如果找不到则把该外层查询的记录丢弃掉；然后再开始取下一条外层查询中的记录，重复上面这个过程。</p></li></ul><p>&amp;emsp;&amp;emsp;对于某些使用<code>IN</code>语句的<span style="color:red">相关</span>子查询，比方这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE s1.key3 = s2.key3);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;它也可以很方便的转为半连接，转换后的语句类似这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.* FROM s1 SEMI JOIN s2 </span><br><span class="line">    ON s1.key1 = s2.common_field AND s1.key3 = s2.key3;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;然后就可以使用我们上面介绍过的<code>DuplicateWeedout</code>、<code>LooseScan</code>、<code>FirstMatch</code>等半连接执行策略来执行查询，当然，如果子查询的查询列表处只有主键或者唯一二级索引列，还可以直接使用<code>table pullout</code>的策略来执行查询，但是需要大家注意的是，<span style="color:red">由于相关子查询并不是一个独立的查询，所以不能转换为物化表来执行查询</span>。</p><h5 id="semi-join的适用条件"><a href="#semi-join的适用条件" class="headerlink" title="semi-join的适用条件"></a>semi-join的适用条件</h5><p>&amp;emsp;&amp;emsp;当然，并不是所有包含<code>IN</code>子查询的查询语句都可以转换为<code>semi-join</code>，只有形如这样的查询才可以被转换为<code>semi-join</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM outer_tables </span><br><span class="line">    WHERE expr IN (SELECT ... FROM inner_tables ...) AND ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;或者这样的形式也可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM outer_tables </span><br><span class="line">    WHERE (oe1, oe2, ...) IN (SELECT ie1, ie2, ... FROM inner_tables ...) AND ...</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;用文字总结一下，只有符合下面这些条件的子查询才可以被转换为<code>semi-join</code>：</p><ul><li>该子查询必须是和<code>IN</code>语句组成的布尔表达式，并且在外层查询的<code>WHERE</code>或者<code>ON</code>子句中出现。</li><li>外层查询也可以有其他的搜索条件，只不过和<code>IN</code>子查询的搜索条件必须使用<code>AND</code>连接起来。</li><li>该子查询必须是一个单一的查询，不能是由若干查询由<code>UNION</code>连接起来的形式。</li><li>该子查询不能包含<code>GROUP BY</code>或者<code>HAVING</code>语句或者聚集函数。</li><li>… 还有一些条件比较少见，就不介绍啦～</li></ul><h5 id="不适用于semi-join的情况"><a href="#不适用于semi-join的情况" class="headerlink" title="不适用于semi-join的情况"></a>不适用于semi-join的情况</h5><p>&amp;emsp;&amp;emsp;对于一些不能将子查询转位<code>semi-join</code>的情况，典型的比如下面这几种：</p><ul><li><p>外层查询的WHERE条件中有其他搜索条件与IN子查询组成的布尔表达式使用<code>OR</code>连接起来</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;)</span><br><span class="line">        OR key2 &gt; 100;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>NOT IN</code>而不是<code>IN</code>的情况</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 NOT IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;)</span><br></pre></td></tr></table></figure></li><li><p>在<code>SELECT</code>子句中的IN子查询的情况</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;) FROM s1 ;</span><br></pre></td></tr></table></figure></li><li><p>子查询中包含<code>GROUP BY</code>、<code>HAVING</code>或者聚集函数的情况</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key2 IN (SELECT COUNT(*) FROM s2 GROUP BY key1);</span><br></pre></td></tr></table></figure></li><li><p>子查询中包含<code>UNION</code>的情况</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 IN (</span><br><span class="line">    SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27; </span><br><span class="line">    UNION</span><br><span class="line">    SELECT common_field FROM s2 WHERE key3 = &#x27;b&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;<code>MySQL</code>仍然留了两手绝活来优化不能转为<code>semi-join</code>查询的子查询，那就是：</p><ul><li><p>对于不相关子查询来说，可以尝试把它们物化之后再参与查询</p><p>  &amp;emsp;&amp;emsp;比如我们上面提到的这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 NOT IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;先将子查询物化，然后再判断<code>key1</code>是否在物化表的结果集中可以加快查询执行的速度。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：请注意这里将子查询物化之后不能转为和外层查询的表的连接，只能是先扫描s1表，然后对s1表的某条记录来说，判断该记录的key1值在不在物化表中。</span><br></pre></td></tr></table></figure></li><li><p>不管子查询是相关的还是不相关的，都可以把<code>IN</code>子查询尝试专为<code>EXISTS</code>子查询    </p><p>  &amp;emsp;&amp;emsp;其实对于任意一个IN子查询来说，都可以被转为<code>EXISTS</code>子查询，通用的例子如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outer_expr IN (SELECT inner_expr FROM ... WHERE subquery_where)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;可以被转换为：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS (SELECT inner_expr FROM ... WHERE subquery_where AND outer_expr=inner_expr)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;当然这个过程中有一些特殊情况，比如在<code>outer_expr</code>或者<code>inner_expr</code>值为<code>NULL</code>的情况下就比较特殊。因为有<code>NULL</code>值作为操作数的表达式结果往往是<code>NULL</code>，比方说：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT NULL IN (1, 2, 3);</span><br><span class="line">+-------------------+</span><br><span class="line">| NULL IN (1, 2, 3) |</span><br><span class="line">+-------------------+</span><br><span class="line">|              NULL |</span><br><span class="line">+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT 1 IN (1, 2, 3);</span><br><span class="line">+----------------+</span><br><span class="line">| 1 IN (1, 2, 3) |</span><br><span class="line">+----------------+</span><br><span class="line">|              1 |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT NULL IN (NULL);</span><br><span class="line">+----------------+</span><br><span class="line">| NULL IN (NULL) |</span><br><span class="line">+----------------+</span><br><span class="line">|           NULL |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;而<code>EXISTS</code>子查询的结果肯定是<code>TRUE</code>或者<code>FASLE</code>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT EXISTS (SELECT 1 FROM s1 WHERE NULL = 1);</span><br><span class="line">+------------------------------------------+</span><br><span class="line">| EXISTS (SELECT 1 FROM s1 WHERE NULL = 1) |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">|                                        0 |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT EXISTS (SELECT 1 FROM s1 WHERE 1 = NULL);</span><br><span class="line">+------------------------------------------+</span><br><span class="line">| EXISTS (SELECT 1 FROM s1 WHERE 1 = NULL) |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">|                                        0 |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT EXISTS (SELECT 1 FROM s1 WHERE NULL = NULL);</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">| EXISTS (SELECT 1 FROM s1 WHERE NULL = NULL) |</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">|                                           0 |</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;但是幸运的是，我们大部分使用<code>IN</code>子查询的场景是把它放在<code>WHERE</code>或者<code>ON</code>子句中，而<code>WHERE</code>或者<code>ON</code>子句是不区分<code>NULL</code>和<code>FALSE</code>的，比方说：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 1 FROM s1 WHERE NULL;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT 1 FROM s1 WHERE FALSE;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;所以只要我们的<code>IN</code>子查询是放在<code>WHERE</code>或者<code>ON</code>子句中的，那么<code>IN -&gt; EXISTS</code>的转换就是没问题的。说了这么多，为什么要转换呢？这是因为不转换的话可能用不到索引，比方说下面这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1</span><br><span class="line">    WHERE key1 IN (SELECT key3 FROM s2 where s1.common_field = s2.common_field) </span><br><span class="line">        OR key2 &gt; 1000;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这个查询中的子查询是一个相关子查询，而且子查询执行的时候不能使用到索引，但是将它转为<code>EXISTS</code>子查询后却可以使用到索引：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1</span><br><span class="line">    WHERE EXISTS (SELECT 1 FROM s2 where s1.common_field = s2.common_field AND s2.key3 = s1.key1) </span><br><span class="line">        OR key2 &gt; 1000;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;转为<code>EXISTS</code>子查询时便可以使用到<code>s2</code>表的<code>idx_key3</code>索引了。</p><p>  &amp;emsp;&amp;emsp;需要注意的是，如果<code>IN</code>子查询不满足转换为<code>semi-join</code>的条件，又不能转换为物化表或者转换为物化表的成本太大，那么它就会被转换为<code>EXISTS</code>查询。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：在MySQL5.5以及之前的版本没有引进semi-join和物化的方式优化子查询时，优化器都会把IN子查询转换为EXISTS子查询，好多同学就惊呼我明明写的是一个不相关子查询，为什么要按照执行相关子查询的方式来执行呢？所以当时好多声音都是建议大家把子查询转为连接，不过随着MySQL的发展，最近的版本中引入了非常多的子查询优化策略，大家可以稍微放心的使用子查询了，内部的转换工作优化器会为大家自动实现。</span><br></pre></td></tr></table></figure></li></ul><h5 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h5><ul><li><p>如果<code>IN</code>子查询符合转换为<code>semi-join</code>的条件，查询优化器会优先把该子查询为<code>semi-join</code>，然后再考虑下面5种执行半连接的策略中哪个成本最低：</p><ul><li>Table pullout</li><li>DuplicateWeedout</li><li>LooseScan</li><li>Materialization</li><li>FirstMatch</li></ul><p>  选择成本最低的那种执行策略来执行子查询。  </p></li><li><p>如果<code>IN</code>子查询不符合转换为<code>semi-join</code>的条件，那么查询优化器会从下面两种策略中找出一种成本更低的方式执行子查询：</p><ul><li>先将子查询物化之后再执行查询</li><li>执行<code>IN to EXISTS</code>转换。</li></ul></li></ul><h4 id="ANY-x2F-ALL子查询优化"><a href="#ANY-x2F-ALL子查询优化" class="headerlink" title="ANY&#x2F;ALL子查询优化"></a>ANY&#x2F;ALL子查询优化</h4><p>&amp;emsp;&amp;emsp;如果ANY&#x2F;ALL子查询是不相关子查询的话，它们在很多场合都能转换成我们熟悉的方式去执行，比方说：</p><table><thead><tr><th align="center">原始表达式</th><th align="center">转换为</th></tr></thead><tbody><tr><td align="center">&lt; ANY (SELECT inner_expr …)</td><td align="center">&lt; (SELECT MAX(inner_expr) …)</td></tr><tr><td align="center">&gt; ANY (SELECT inner_expr …)</td><td align="center">&gt; (SELECT MIN(inner_expr) …)</td></tr><tr><td align="center">&lt; ALL (SELECT inner_expr …)</td><td align="center">&lt; (SELECT MIN(inner_expr) …)</td></tr><tr><td align="center">&gt; ALL (SELECT inner_expr …)</td><td align="center">&gt; (SELECT MAX(inner_expr) …)</td></tr></tbody></table><h4 id="NOT-EXISTS子查询的执行"><a href="#NOT-EXISTS子查询的执行" class="headerlink" title="[NOT] EXISTS子查询的执行"></a>[NOT] EXISTS子查询的执行</h4><p>&amp;emsp;&amp;emsp;如果<code>[NOT] EXISTS</code>子查询是不相关子查询，可以先执行子查询，得出该<code>[NOT] EXISTS</code>子查询的结果是<code>TRUE</code>还是<code>FALSE</code>，并重写原先的查询语句，比如对这个查询来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE EXISTS (SELECT 1 FROM s2 WHERE key1 = &#x27;a&#x27;) </span><br><span class="line">        OR key2 &gt; 100;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;因为这个语句里的子查询是不相关子查询，所以优化器会首先执行该子查询，假设该EXISTS子查询的结果为<code>TRUE</code>，那么接着优化器会重写查询为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE TRUE OR key2 &gt; 100;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;进一步简化后就变成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE TRUE;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;对于相关的<code>[NOT] EXISTS</code>子查询来说，比如这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE EXISTS (SELECT 1 FROM s2 WHERE s1.common_field = s2.common_field);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;很不幸，这个查询只能按照我们年少时的那种执行相关子查询的方式来执行。不过如果<code>[NOT] EXISTS</code>子查询中如果可以使用索引的话，那查询速度也会加快不少，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE EXISTS (SELECT 1 FROM s2 WHERE s1.common_field = s2.key1);</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;上面这个<code>EXISTS</code>子查询中可以使用<code>idx_key1</code>来加快查询速度。</p><h4 id="对于派生表的优化"><a href="#对于派生表的优化" class="headerlink" title="对于派生表的优化"></a>对于派生表的优化</h4><p>&amp;emsp;&amp;emsp;我们前面说过把子查询放在外层查询的<code>FROM</code>子句后，那么这个子查询的结果相当于一个<code>派生表</code>，比如下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM  (</span><br><span class="line">        SELECT id AS d_id,  key3 AS d_key3 FROM s2 WHERE key1 = &#x27;a&#x27;</span><br><span class="line">    ) AS derived_s1 WHERE d_key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;子查询<code>( SELECT id AS d_id,  key3 AS d_key3 FROM s2 WHERE key1 = &#39;a&#39;)</code>的结果就相当于一个派生表，这个表的名称是<code>derived_s1</code>，该表有两个列，分别是<code>d_id</code>和<code>d_key3</code>。</p><p>&amp;emsp;&amp;emsp;对于含有<code>派生表</code>的查询，<code>MySQL</code>提供了两种执行策略：</p><ul><li><p>最容易想到的就是把派生表物化。</p><p>  &amp;emsp;&amp;emsp;我们可以将派生表的结果集写到一个内部的临时表中，然后就把这个物化表当作普通表一样参与查询。当然，在对派生表进行物化时，设计<code>MySQL</code>的大佬使用了一种称为<code>延迟物化</code>的策略，也就是在查询中真正使用到派生表时才回去尝试物化派生表，而不是还没开始执行查询呢就把派生表物化掉。比方说对于下面这个含有派生表的查询来说：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM (</span><br><span class="line">        SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;</span><br><span class="line">    ) AS derived_s1 INNER JOIN s2</span><br><span class="line">    ON derived_s1.key1 = s2.key1</span><br><span class="line">    WHERE s2.key2 = 1;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;如果采用物化派生表的方式来执行这个查询的话，那么执行时首先会到<code>s1</code>表中找出满足<code>s1.key2 = 1</code>的记录，如果压根儿找不到，说明参与连接的<code>s1</code>表记录就是空的，所以整个查询的结果集就是空的，所以也就没有必要去物化查询中的派生表了。</p></li><li><p>将派生表和外层的表合并，也就是将查询重写为没有派生表的形式</p><p>  &amp;emsp;&amp;emsp;我们来看这个贼简单的包含派生表的查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM (SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;) AS derived_s1;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这个查询本质上就是想查看<code>s1</code>表中满足<code>key1 = &#39;a&#39;</code>条件的的全部记录，所以和下面这个语句是等价的：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;对于一些稍微复杂的包含派生表的语句，比如我们上面提到的那个：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM (</span><br><span class="line">        SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;</span><br><span class="line">    ) AS derived_s1 INNER JOIN s2</span><br><span class="line">    ON derived_s1.key1 = s2.key1</span><br><span class="line">    WHERE s2.key2 = 1;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;我们可以将派生表与外层查询的表合并，然后将派生表中的搜索条件放到外层查询的搜索条件中，就像这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 INNER JOIN s2 </span><br><span class="line">    ON s1.key1 = s2.key1</span><br><span class="line">    WHERE s1.key1 = &#x27;a&#x27; AND s2.key2 = 1;</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这样通过将外层查询和派生表合并的方式成功的消除了派生表，也就意味着我们没必要再付出创建和访问临时表的成本了。可是并不是所有带有派生表的查询都能被成功的和外层查询合并，当派生表中有这些语句就不可以和外层查询合并：</p><ul><li>聚集函数，比如MAX()、MIN()、SUM()什么的</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>LIMIT</li><li>UNION 或者 UNION ALL</li><li>派生表对应的子查询的<code>SELECT</code>子句中含有另一个子查询</li><li>… 还有些不常用的情况就不多说了～</li></ul></li></ul><p>&amp;emsp;&amp;emsp;所以<code>MySQL</code>在执行带有派生表的时候，优先尝试把派生表和外层查询合并掉，如果不行的话，再把派生表物化掉执行查询。</p><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/10/31/model-mysql/mysql/15-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2022/10/31/model-mysql/mysql/15-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="第15章-查询优化的百科全书-Explain详解（上）"><a href="#第15章-查询优化的百科全书-Explain详解（上）" class="headerlink" title="第15章 查询优化的百科全书-Explain详解（上）"></a>第15章 查询优化的百科全书-Explain详解（上）</h1><p>&amp;emsp;&amp;emsp;一条查询语句在经过<code>MySQL</code>查询优化器的各种基于成本和规则的优化会后生成一个所谓的<code>执行计划</code>，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。设计<code>MySQL</code>的大佬贴心的为我们提供了<code>EXPLAIN</code>语句来帮助我们查看某个查询语句的具体执行计划，本章的内容就是为了帮助大家看懂<code>EXPLAIN</code>语句的各个输出项都是干嘛使的，从而可以有针对性的提升我们查询语句的性能。</p><p>&amp;emsp;&amp;emsp;如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前面加一个<code>EXPLAIN</code>，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT 1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;然后这输出的一大坨东西就是所谓的<code>执行计划</code>，我的任务就是带领大家看懂这一大坨东西里边的每个列都是干什么用的，以及在这个<code>执行计划</code>的辅助下，我们应该怎样改进自己的查询语句以使查询执行起来更高效。其实除了以<code>SELECT</code>开头的查询语句，其余的<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code>以及<code>UPDATE </code>语句前面都可以加上<code>EXPLAIN</code>这个词儿，用来查看这些语句的执行计划，不过我们这里对<code>SELECT</code>语句更感兴趣，所以后边只会以<code>SELECT</code>语句为例来描述<code>EXPLAIN</code>语句的用法。为了让大家先有一个感性的认识，我们把<code>EXPLAIN</code>语句输出的各个列的作用先大致罗列一下：</p><table><thead><tr><th align="center">列名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>id</code></td><td align="left">在一个大的查询语句中每个<code>SELECT</code>关键字都对应一个唯一的<code>id</code></td></tr><tr><td align="center"><code>select_type</code></td><td align="left"><code>SELECT</code>关键字对应的那个查询的类型</td></tr><tr><td align="center"><code>table</code></td><td align="left">表名</td></tr><tr><td align="center"><code>partitions</code></td><td align="left">匹配的分区信息</td></tr><tr><td align="center"><code>type</code></td><td align="left">针对单表的访问方法</td></tr><tr><td align="center"><code>possible_keys</code></td><td align="left">可能用到的索引</td></tr><tr><td align="center"><code>key</code></td><td align="left">实际上使用的索引</td></tr><tr><td align="center"><code>key_len</code></td><td align="left">实际使用到的索引长度</td></tr><tr><td align="center"><code>ref</code></td><td align="left">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td align="center"><code>rows</code></td><td align="left">预估的需要读取的记录条数</td></tr><tr><td align="center"><code>filtered</code></td><td align="left">某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td align="center"><code>Extra</code></td><td align="left">一些额外的信息</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;需要注意的是，<span style="color:red">大家如果看不懂上面输出列含义，那是正常的，千万不要纠结～</span>。我在这里把它们都列出来只是为了描述一个轮廓，让大家有一个大致的印象，下面会细细道来，等会儿说完了不信你不会～ 为了故事的顺利发展，我们还是要请出我们前面已经用了n遍的<code>single_table</code>表，为了防止大家忘了，再把它的结构描述一遍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE single_table (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    UNIQUE KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们仍然假设有两个和<code>single_table</code>表构造一模一样的<code>s1</code>、<code>s2</code>表，而且这两个表里边儿有10000条记录，除id列外其余的列都插入随机值。为了让大家有比较好的阅读体验，我们下面并不准备严格按照<code>EXPLAIN</code>输出列的顺序来介绍这些列分别是干嘛的，大家注意一下就好了。</p><h2 id="执行计划输出中各列详解"><a href="#执行计划输出中各列详解" class="headerlink" title="执行计划输出中各列详解"></a>执行计划输出中各列详解</h2><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>&amp;emsp;&amp;emsp;不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行单表访问的，所以设计<code>MySQL</code>的大佬规定<span style="color:red">EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名</span>。所以我们看一条比较简单的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个查询语句只涉及对<code>s1</code>表的单表查询，所以<code>EXPLAIN</code>输出中只有一条记录，其中的<code>table</code>列的值是<code>s1</code>，表明这条记录是用来说明对<code>s1</code>表的单表访问方法的。</p><p>&amp;emsp;&amp;emsp;下面我们看一下一个连接查询的执行计划：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL                                  |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到这个连接查询的执行计划中有两条记录，这两条记录的<code>table</code>列分别是<code>s1</code>和<code>s2</code>，这两条记录用来分别说明对<code>s1</code>表和<code>s2</code>表的访问方法是什么。</p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>&amp;emsp;&amp;emsp;我们知道我们写的查询语句一般都以<code>SELECT</code>关键字开头，比较简单的查询语句里只有一个<code>SELECT</code>关键字，比如下面这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;稍微复杂一点的连接查询中也只有一个<code>SELECT</code>关键字，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 INNER JOIN s2</span><br><span class="line">    ON s1.key1 = s2.key1</span><br><span class="line">    WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;但是下面两种情况下在一条查询语句中会出现多个<code>SELECT</code>关键字：</p><ul><li><p>查询中包含子查询的情况</p><p>  &amp;emsp;&amp;emsp;比如下面这个查询语句中就包含2个<code>SELECT</code>关键字：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT * FROM s2);</span><br></pre></td></tr></table></figure></li><li><p>查询中包含<code>UNION</code>语句的情况</p><p>  &amp;emsp;&amp;emsp;比如下面这个查询语句中也包含2个<code>SELECT</code>关键字：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1  UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;查询语句中每出现一个<code>SELECT</code>关键字，设计<code>MySQL</code>的大佬就会为它分配一个唯一的<code>id</code>值。这个<code>id</code>值就是<code>EXPLAIN</code>语句的第一个列，比如下面这个查询中只有一个<code>SELECT</code>关键字，所以<code>EXPLAIN</code>的结果中也就只有一条<code>id</code>列为<code>1</code>的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;对于连接查询来说，一个<code>SELECT</code>关键字后边的<code>FROM</code>子句中可以跟随多个表，所以在连接查询的执行计划中，<span style="color:red">每个表都会对应一条记录，但是这些记录的id值都是相同的</span>，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL                                  |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到，上述连接查询中参与连接的<code>s1</code>和<code>s2</code>表分别对应一条记录，但是这两条记录对应的<code>id</code>值都是<code>1</code>。这里需要大家记住的是，<span style="color:red">在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前面的表表示驱动表，出现在后边的表表示被驱动表</span>。所以从上面的<code>EXPLAIN</code>输出中我们可以看出，查询优化器准备让<code>s1</code>表作为驱动表，让<code>s2</code>表作为被驱动表来执行查询。</p><p>&amp;emsp;&amp;emsp;对于包含子查询的查询语句来说，就可能涉及多个<code>SELECT</code>关键字，所以在包含子查询的查询语句的执行计划中，每个<code>SELECT</code>关键字都会对应一个唯一的<code>id</code>值，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9688 |   100.00 | Using where |</span><br><span class="line">|  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9954 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;从输出结果中我们可以看到，<code>s1</code>表在外层查询中，外层查询有一个独立的<code>SELECT</code>关键字，所以第一条记录的<code>id</code>值就是<code>1</code>，<code>s2</code>表在子查询中，子查询有一个独立的<code>SELECT</code>关键字，所以第二条记录的<code>id</code>值就是<code>2</code>。</p><p>&amp;emsp;&amp;emsp;但是这里大家需要特别注意，<span style="color:red">查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询</span>。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = &#x27;a&#x27;);</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra                        |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL              | 9954 |    10.00 | Using where; Start temporary |</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s2.key3 |    1 |   100.00 | End temporary                |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到，虽然我们的查询语句是一个子查询，但是执行计划中<code>s1</code>和<code>s2</code>表对应的记录的<code>id</code>值全部是<code>1</code>，这就表明了<span style="color:red">查询优化器将子查询转换为了连接查询</span>。</p><p>&amp;emsp;&amp;emsp;对于包含<code>UNION</code>子句的查询语句来说，每个<code>SELECT</code>关键字对应一个<code>id</code>值也是没错的，不过还是有点儿特别的东西，比方说下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1  UNION SELECT * FROM s2;</span><br><span class="line">+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL            |</span><br><span class="line">|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | NULL            |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |</span><br><span class="line">+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">3 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个语句的执行计划的第三条记录是个什么鬼？为毛<code>id</code>值是<code>NULL</code>，而且<code>table</code>列长的也怪怪的？大家别忘了<code>UNION</code>子句是干嘛用的，它会把多个查询的结果集合并起来并对结果集中的记录进行去重，怎么去重呢？<code>MySQL</code>使用的是内部的临时表。正如上面的查询计划中所示，<code>UNION</code>子句是为了把<code>id</code>为<code>1</code>的查询和<code>id</code>为<code>2</code>的查询的结果集合并起来并去重，所以在内部创建了一个名为<code>&lt;union1, 2&gt;</code>的临时表（就是执行计划第三条记录的<code>table</code>列的名称），<code>id</code>为<code>NULL</code>表明这个临时表是为了合并两个查询的结果集而创建的。</p><p>&amp;emsp;&amp;emsp;跟<code>UNION</code>对比起来，<code>UNION ALL</code>就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含<code>UNION ALL</code>子句的查询的执行计划中，就没有那个<code>id</code>为<code>NULL</code>的记录，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1  UNION ALL SELECT * FROM s2;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | PRIMARY     | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL  |</span><br><span class="line">|  2 | UNION       | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>&amp;emsp;&amp;emsp;通过上面的内容我们知道，一条大的查询语句里边可以包含若干个<code>SELECT</code>关键字，每个<code>SELECT</code>关键字代表着一个小的查询语句，而每个<code>SELECT</code>关键字的<code>FROM</code>子句中都可以包含若干张表（这些表用来做连接查询），每一张表都对应着执行计划输出中的一条记录，对于在同一个<code>SELECT</code>关键字中的表来说，它们的<code>id</code>值是相同的。</p><p>&amp;emsp;&amp;emsp;设计<code>MySQL</code>的大佬为每一个<code>SELECT</code>关键字代表的小查询都定义了一个称之为<code>select_type</code>的属性，意思是我们只要知道了某个小查询的<code>select_type</code>属性，就知道了这个小查询在整个大查询中扮演了一个什么角色，口说无凭，我们还是先来见识见识这个<code>select_type</code>都能取哪些值（为了精确起见，我们直接使用文档中的英文做简要描述，随后会进行详细解释的）：</p><table><thead><tr><th align="center">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>SIMPLE</code></td><td align="left">Simple SELECT (not using UNION or subqueries)</td></tr><tr><td align="center"><code>PRIMARY</code></td><td align="left">Outermost SELECT</td></tr><tr><td align="center"><code>UNION</code></td><td align="left">Second or later SELECT statement in a UNION</td></tr><tr><td align="center"><code>UNION RESULT</code></td><td align="left">Result of a UNION</td></tr><tr><td align="center"><code>SUBQUERY</code></td><td align="left">First SELECT in subquery</td></tr><tr><td align="center"><code>DEPENDENT SUBQUERY</code></td><td align="left">First SELECT in subquery, dependent on outer query</td></tr><tr><td align="center"><code>DEPENDENT UNION</code></td><td align="left">Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td align="center"><code>DERIVED</code></td><td align="left">Derived table</td></tr><tr><td align="center"><code>MATERIALIZED</code></td><td align="left">Materialized subquery</td></tr><tr><td align="center"><code>UNCACHEABLE SUBQUERY</code></td><td align="left">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td align="center"><code>UNCACHEABLE UNION</code></td><td align="left">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><p>&amp;emsp;&amp;emsp;英文描述太简单，不知道说了什么？来详细看看里边儿的每个值都是干什么吃的：</p><ul><li><p><code>SIMPLE</code></p><p>  &amp;emsp;&amp;emsp;查询语句中不包含<code>UNION</code>或者子查询的查询都算作是<code>SIMPLE</code>类型，比方说下面这个单表查询的<code>select_type</code>的值就是<code>SIMPLE</code>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;当然，连接查询也算是<code>SIMPLE</code>类型，比如：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL                                  |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p><code>PRIMARY</code>    </p><p>  &amp;emsp;&amp;emsp;对于包含<code>UNION</code>、<code>UNION ALL</code>或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的<code>select_type</code>值就是<code>PRIMARY</code>，比方说：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br><span class="line">+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL            |</span><br><span class="line">|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | NULL            |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |</span><br><span class="line">+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">3 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;从结果中可以看到，最左边的小查询<code>SELECT * FROM s1</code>对应的是执行计划中的第一条记录，它的<code>select_type</code>值就是<code>PRIMARY</code>。</p></li><li><p><code>UNION</code></p><p>  &amp;emsp;&amp;emsp;对于包含<code>UNION</code>或者<code>UNION ALL</code>的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的<code>select_type</code>值就是<code>UNION</code>，可以对比上一个例子的效果，这就不多举例子了。</p></li><li><p><code>UNION RESULT</code></p><p>  &amp;emsp;&amp;emsp;<code>MySQL</code>选择使用临时表来完成<code>UNION</code>查询的去重工作，针对该临时表的查询的<code>select_type</code>就是<code>UNION RESULT</code>，例子上面有，就不赘述了。</p></li><li><p><code>SUBQUERY</code></p><p>  &amp;emsp;&amp;emsp;如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>SUBQUERY</code>，比如下面这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9688 |   100.00 | Using where |</span><br><span class="line">|  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9954 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;可以看到，外层查询的<code>select_type</code>就是<code>PRIMARY</code>，子查询的<code>select_type</code>就是<code>SUBQUERY</code>。需要大家注意的是，<span style="color:red">由于select_type为SUBQUERY的子查询由于会被物化，所以只需要执行一遍</span>。</p></li><li><p><code>DEPENDENT SUBQUERY</code></p><p>  &amp;emsp;&amp;emsp;如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是相关子查询，则该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>DEPENDENT SUBQUERY</code>，比如下面这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = &#x27;a&#x27;;</span><br><span class="line">+----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+</span><br><span class="line">| id | select_type        | table | partitions | type | possible_keys     | key      | key_len | ref               | rows | filtered | Extra       |</span><br><span class="line">+----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY            | s1    | NULL       | ALL  | idx_key3          | NULL     | NULL    | NULL              | 9688 |   100.00 | Using where |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | s2    | NULL       | ref  | idx_key2,idx_key1 | idx_key2 | 5       | xiaohaizi.s1.key2 |    1 |    10.00 | Using where |</span><br><span class="line">+----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+</span><br><span class="line">2 rows in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;需要大家注意的是，<span style="color:red">select_type为DEPENDENT SUBQUERY的查询可能会被执行多次</span>。</p></li><li><p><code>DEPENDENT UNION</code>    </p><p>  &amp;emsp;&amp;emsp;在包含<code>UNION</code>或者<code>UNION ALL</code>的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的<code>select_type</code>的值就是<code>DEPENDENT UNION</code>。说的有些绕，比方说下面这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = &#x27;a&#x27; UNION SELECT key1 FROM s1 WHERE key1 = &#x27;b&#x27;);</span><br><span class="line">+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">| id | select_type        | table      | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra                    |</span><br><span class="line">+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">|  1 | PRIMARY            | s1         | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | 9688 |   100.00 | Using where              |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | s2         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |   12 |   100.00 | Using where; Using index |</span><br><span class="line">|  3 | DEPENDENT UNION    | s1         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | Using where; Using index |</span><br><span class="line">| NULL | UNION RESULT       | &lt;union2,3&gt; | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | NULL |     NULL | Using temporary          |</span><br><span class="line">+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">4 rows in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;这个查询比较复杂啊，大查询里包含了一个子查询，子查询里又是由<code>UNION</code>连起来的两个小查询。从执行计划中可以看出来，<code>SELECT key1 FROM s2 WHERE key1 = &#39;a&#39;</code>这个小查询由于是子查询中第一个查询，所以它的<code>select_type</code>是<code>DEPENDENT SUBQUERY</code>，而<code>SELECT key1 FROM s1 WHERE key1 = &#39;b&#39;</code>这个查询的<code>select_type</code>就是<code>DEPENDENT UNION</code>。</p></li><li><p><code>DERIVED</code></p><p>  &amp;emsp;&amp;emsp;对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的<code>select_type</code>就是<code>DERIVED</code>，比方说下面这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c &gt; 1;</span><br><span class="line">+----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table      | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | NULL       | ALL   | NULL          | NULL     | NULL    | NULL | 9688 |    33.33 | Using where |</span><br><span class="line">|  2 | DERIVED     | s1         | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9688 |   100.00 | Using index |</span><br><span class="line">+----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;从执行计划中可以看出，<code>id</code>为<code>2</code>的记录就代表子查询的执行方式，它的<code>select_type</code>是<code>DERIVED</code>，说明该子查询是以物化的方式执行的。<code>id</code>为<code>1</code>的记录代表外层查询，大家注意看它的<code>table</code>列显示的是<code>&lt;derived2&gt;</code>，表示该查询是针对将派生表物化之后的表进行查询的。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：如果派生表可以通过和外层查询合并的方式执行的话，执行计划又是另一番景象，大家可以试试～</span><br></pre></td></tr></table></figure></li><li><p><code>MATERIALIZED</code></p><p>  &amp;emsp;&amp;emsp;当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的<code>select_type</code>属性就是<code>MATERIALIZED</code>，比如下面这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);</span><br><span class="line">+----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">| id | select_type  | table       | partitions | type   | possible_keys | key        | key_len | ref               | rows | filtered | Extra       |</span><br><span class="line">+----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE       | s1          | NULL       | ALL    | idx_key1      | NULL       | NULL    | NULL              | 9688 |   100.00 | Using where |</span><br><span class="line">|  1 | SIMPLE       | &lt;subquery2&gt; | NULL       | eq_ref | &lt;auto_key&gt;    | &lt;auto_key&gt; | 303     | xiaohaizi.s1.key1 |    1 |   100.00 | NULL        |</span><br><span class="line">|  2 | MATERIALIZED | s2          | NULL       | index  | idx_key1      | idx_key1   | 303     | NULL              | 9954 |   100.00 | Using index |</span><br><span class="line">+----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">3 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;执行计划的第三条记录的<code>id</code>值为<code>2</code>，说明该条记录对应的是一个单表查询，从它的<code>select_type</code>值为<code>MATERIALIZED</code>可以看出，查询优化器是要把子查询先转换成物化表。然后看执行计划的前两条记录的<code>id</code>值都为<code>1</code>，说明这两条记录对应的表进行连接查询，需要注意的是第二条记录的<code>table</code>列的值是<code>&lt;subquery2&gt;</code>，说明该表其实就是<code>id</code>为<code>2</code>对应的子查询执行之后产生的物化表，然后将<code>s1</code>和该物化表进行连接查询。</p></li><li><p><code>UNCACHEABLE SUBQUERY</code></p><p>  不常用，就不多介绍了。</p></li><li><p><code>UNCACHEABLE UNION</code></p><p>  不常用，就不多介绍了。</p></li></ul><h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>&amp;emsp;&amp;emsp;由于我们压根儿就没介绍过分区是什么，所以这个输出列我们也就不说了，一般情况下我们的查询语句的执行计划的<code>partitions</code>列的值都是<code>NULL</code>。</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>&amp;emsp;&amp;emsp;我们前面说过执行计划的一条记录就代表着<code>MySQL</code>对某个表的执行查询时的访问方法，其中的<code>type</code>列就表明了这个访问方法是什么，比方说下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.04 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到<code>type</code>列的值是<code>ref</code>，表明<code>MySQL</code>即将使用<code>ref</code>访问方法来执行对<code>s1</code>表的查询。但是我们之前只介绍过对使用<code>InnoDB</code>存储引擎的表进行单表访问的一些访问方法，完整的访问方法如下：<code>system</code>，<code>const</code>，<code>eq_ref</code>，<code>ref</code>，<code>fulltext</code>，<code>ref_or_null</code>，<code>index_merge</code>，<code>unique_subquery</code>，<code>index_subquery</code>，<code>range</code>，<code>index</code>，<code>ALL</code>。当然我们还要详细介绍一下：</p><ul><li><p><code>system</code></p><p>  &amp;emsp;&amp;emsp;当表中只有一条记录并且<span style="color:red">该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory</span>，那么对该表的访问方法就是<code>system</code>。比方说我们新建一个<code>MyISAM</code>表，并为其插入一条记录：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t(i int) Engine=MyISAM;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO t VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;然后我们看一下查询这个表的执行计划：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM t;</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | system | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;可以看到<code>type</code>列的值就是<code>system</code>了。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：你可以把表改成使用InnoDB存储引擎，试试看执行计划的type列是什么。</span><br></pre></td></tr></table></figure></li><li><p><code>const</code></p><p>  &amp;emsp;&amp;emsp;这个我们前面介绍过，就是当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是<code>const</code>，比如：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE id = 5;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p><code>eq_ref</code></p><p>  &amp;emsp;&amp;emsp;在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是<code>eq_ref</code>，比方说：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref             | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL            | 9688 |   100.00 | NULL  |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xiaohaizi.s1.id |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;从执行计划的结果中可以看出，<code>MySQL</code>打算将<code>s1</code>作为驱动表，<code>s2</code>作为被驱动表，重点关注<code>s2</code>的访问方法是<code>eq_ref</code>，表明在访问<code>s2</code>表的时候可以通过主键的等值匹配来进行访问。</p></li><li><p><code>ref</code></p><p>  &amp;emsp;&amp;emsp;当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就<span style="color:red">可能</span>是<code>ref</code>，最开始举过例子了，就不重复举例了。</p></li><li><p><code>fulltext</code></p><p>  &amp;emsp;&amp;emsp;全文索引，我们没有细讲过，跳过～</p></li><li><p><code>ref_or_null</code></p><p>  &amp;emsp;&amp;emsp;当对普通二级索引进行等值匹配查询，该索引列的值也可以是<code>NULL</code>值时，那么对该表的访问方法就<span style="color:red">可能</span>是<code>ref_or_null</code>，比如说：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key1 IS NULL;</span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type        | possible_keys | key      | key_len | ref   | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref_or_null | idx_key1      | idx_key1 | 303     | const |    9 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p><code>index_merge</code></p><p>  &amp;emsp;&amp;emsp;一般情况下对于某个表的查询只能使用到一个索引，但我们介绍单表访问方法时特意强调了在某些场景下可以使用<code>Intersection</code>、<code>Union</code>、<code>Sort-Union</code>这三种索引合并的方式来执行查询，忘掉的回去补一下，我们看一下执行计划中是怎么体现<code>MySQL</code>使用索引合并的方式来对某个表执行查询的：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key3 = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                       |</span><br><span class="line">+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL |   14 |   100.00 | Using union(idx_key1,idx_key3); Using where |</span><br><span class="line">+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;从执行计划的<code>type</code>列的值是<code>index_merge</code>就可以看出，<code>MySQL</code>打算使用索引合并的方式来执行对<code>s1</code>表的查询。</p></li><li><p><code>unique_subquery</code></p><p>  &amp;emsp;&amp;emsp;类似于两表连接中被驱动表的<code>eq_ref</code>访问方法，<code>unique_subquery</code>是针对在一些包含<code>IN</code>子查询的查询语句中，如果查询优化器决定将<code>IN</code>子查询转换为<code>EXISTS</code>子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的<code>type</code>列的值就是<code>unique_subquery</code>，比如下面的这个查询语句：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;</span><br><span class="line">+----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type        | table | partitions | type            | possible_keys    | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY            | s1    | NULL       | ALL             | idx_key3         | NULL    | NULL    | NULL | 9688 |   100.00 | Using where |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | s2    | NULL       | unique_subquery | PRIMARY,idx_key1 | PRIMARY | 4       | func |    1 |    10.00 | Using where |</span><br><span class="line">+----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;可以看到执行计划的第二条记录的<code>type</code>值就是<code>unique_subquery</code>，说明在执行子查询时会使用到<code>id</code>列的索引。</p></li><li><p><code>index_subquery</code></p><p>  &amp;emsp;&amp;emsp;<code>index_subquery</code>与<code>unique_subquery</code>类似，只不过访问子查询中的表时使用的是普通的索引，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;</span><br><span class="line">+----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type        | table | partitions | type           | possible_keys     | key      | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY            | s1    | NULL       | ALL            | idx_key3          | NULL     | NULL    | NULL | 9688 |   100.00 | Using where |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | s2    | NULL       | index_subquery | idx_key1,idx_key3 | idx_key3 | 303     | func |    1 |    10.00 | Using where |</span><br><span class="line">+----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set, 2 warnings (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p><code>range</code></p><p>  &amp;emsp;&amp;emsp;如果使用索引获取某些<code>范围区间</code>的记录，那么就<span style="color:red">可能</span>使用到<code>range</code>访问方法，比如下面的这个查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |   27 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;或者：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;a&#x27; AND key1 &lt; &#x27;b&#x27;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |  294 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p><code>index</code></p><p>  &amp;emsp;&amp;emsp;当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是<code>index</code>，比如这样：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key_part | 909     | NULL | 9688 |    10.00 | Using where; Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>  &amp;emsp;&amp;emsp;上述查询中的搜索列表中只有<code>key_part2</code>一个列，而且搜索条件中也只有<code>key_part3</code>一个列，这两个列又恰好包含在<code>idx_key_part</code>这个索引中，可是搜索条件<code>key_part3</code>不能直接使用该索引进行<code>ref</code>或者<code>range</code>方式的访问，只能扫描整个<code>idx_key_part</code>索引的记录，所以查询计划的<code>type</code>列的值就是<code>index</code>。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小贴士：再一次强调，对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</span><br></pre></td></tr></table></figure></li><li><p><code>ALL</code></p><p>  &amp;emsp;&amp;emsp;最熟悉的全表扫描，就不多介绍了，直接看例子：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p>&amp;emsp;&amp;emsp;一般来说，这些访问方法按照我们介绍它们的顺序性能依次变差。其中除了<code>All</code>这个访问方法外，其余的访问方法都能用到索引，除了<code>index_merge</code>访问方法外，其余的访问方法都最多只能用到一个索引。</p><h3 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h3><p>&amp;emsp;&amp;emsp;在<code>EXPLAIN</code>语句输出的执行计划中，<code>possible_keys</code>列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，<code>key</code>列表示实际用到的索引有哪些，比方说下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key3 = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys     | key      | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1,idx_key3 | idx_key3 | 303     | const |    6 |     2.75 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;上述执行计划的<code>possible_keys</code>列的值是<code>idx_key1,idx_key3</code>，表示该查询可能使用到<code>idx_key1,idx_key3</code>两个索引，然后<code>key</code>列的值是<code>idx_key3</code>，表示经过查询优化器计算使用不同索引的成本后，最后决定使用<code>idx_key3</code>来执行查询比较划算。</p><p>&amp;emsp;&amp;emsp;不过有一点比较特别，就是在使用<code>index</code>访问方法来查询某个表时，<code>possible_keys</code>列是空的，而<code>key</code>列展示的是实际使用到的索引，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key_part | 909     | NULL | 9688 |    10.00 | Using where; Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;另外需要注意的一点是，<span style="color:red">possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引</span>。</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>&amp;emsp;&amp;emsp;<code>key_len</code>列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：</p><ul><li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是<code>VARCHAR(100)</code>，使用的字符集是<code>utf8</code>，那么该列实际占用的最大存储空间就是<code>100 × 3 = 300</code>个字节。</li><li>如果该索引列可以存储<code>NULL</code>值，则<code>key_len</code>比不可以存储<code>NULL</code>值时多1个字节。</li><li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li></ul><p>&amp;emsp;&amp;emsp;比如下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE id = 5;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;由于<code>id</code>列的类型是<code>INT</code>，并且不可以存储<code>NULL</code>值，所以在使用该列的索引时<code>key_len</code>大小就是<code>4</code>。当索引列可以存储<code>NULL</code>值时，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 = 5;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | const | idx_key2      | idx_key2 | 5       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到<code>key_len</code>列就变成了<code>5</code>，比使用<code>id</code>列的索引时多了<code>1</code>。</p><p>&amp;emsp;&amp;emsp;对于可变长度的索引列来说，比如下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;由于<code>key1</code>列的类型是<code>VARCHAR(100)</code>，所以该列实际最多占用的存储空间就是<code>300</code>字节，又因为该列允许存储<code>NULL</code>值，所以<code>key_len</code>需要加<code>1</code>，又因为该列是可变长度列，所以<code>key_len</code>需要加<code>2</code>，所以最后<code>ken_len</code>的值就是<code>303</code>。</p><p>&amp;emsp;&amp;emsp;有的同学可能有疑问：你在前面介绍<code>InnoDB</code>行格式的时候不是说，存储变长字段的实际长度不是可能占用1个字节或者2个字节么？为什么现在不管三七二十一都用了<code>2</code>个字节？这里需要强调的一点是，执行计划的生成是在<code>MySQL server</code>层中的功能，并不是针对具体某个存储引擎的功能，设计<code>MySQL</code>的大佬在执行计划中输出<code>key_len</code>列主要是为了让我们区分某个使用联合索引的查询具体用了几个索引列，而不是为了准确的说明针对某个具体存储引擎存储变长字段的实际长度占用的空间到底是占用1个字节还是2个字节。比方说下面这个使用到联合索引<code>idx_key_part</code>的查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key_part  | idx_key_part | 303     | const |   12 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们可以从执行计划的<code>key_len</code>列中看到值是<code>303</code>，这意味着<code>MySQL</code>在执行上述查询中只能用到<code>idx_key_part</code>索引的一个索引列，而下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key          | key_len | ref         | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key_part  | idx_key_part | 606     | const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这个查询的执行计划的<code>ken_len</code>列的值是<code>606</code>，说明执行这个查询的时候可以用到联合索引<code>idx_key_part</code>的两个索引列。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>&amp;emsp;&amp;emsp;当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是<code>const</code>、<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>、<code>unique_subquery</code>、<code>index_subquery</code>其中之一时，<code>ref</code>列展示的就是与索引列作等值匹配的东东是什么，比如只是一个常数或者是某个列。大家看下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到<code>ref</code>列的值是<code>const</code>，表明在使用<code>idx_key1</code>索引执行查询时，与<code>key1</code>列作等值匹配的对象是一个常数，当然有时候更复杂一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref             | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL            | 9688 |   100.00 | NULL  |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xiaohaizi.s1.id |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;可以看到对被驱动表<code>s2</code>的访问方法是<code>eq_ref</code>，而对应的<code>ref</code>列的值是<code>xiaohaizi.s1.id</code>，这说明在对被驱动表进行访问时会用到<code>PRIMARY</code>索引，也就是聚簇索引与一个列进行等值匹配的条件，于<code>s2</code>表的<code>id</code>作等值匹配的对象就是<code>xiaohaizi.s1.id</code>列（注意这里把数据库名也写出来了）。</p><p>&amp;emsp;&amp;emsp;有的时候与索引列进行等值匹配的对象是一个函数，比方说下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL | 9688 |   100.00 | NULL                  |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | func |    1 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们看执行计划的第二条记录，可以看到对<code>s2</code>表采用<code>ref</code>访问方法执行查询，然后在查询计划的<code>ref</code>列里输出的是<code>func</code>，说明与<code>s2</code>表的<code>key1</code>列进行等值匹配的对象是一个函数。</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>&amp;emsp;&amp;emsp;如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的<code>rows</code>列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的<code>rows</code>列就代表预计扫描的索引记录行数。比如下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |  266 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;我们看到执行计划的<code>rows</code>列的值是<code>266</code>，这意味着查询优化器在经过分析使用<code>idx_key1</code>进行查询的成本之后，觉得满足<code>key1 &gt; &#39;z&#39;</code>这个条件的记录只有<code>266</code>条。</p><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>&amp;emsp;&amp;emsp;之前在分析连接查询的成本时提出过一个<code>condition filtering</code>的概念，就是<code>MySQL</code>在计算驱动表扇出时采用的一个策略：</p><ul><li>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。</li><li>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</li></ul><p>&amp;emsp;&amp;emsp;比方说下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND common_field = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                              |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |  266 |    10.00 | Using index condition; Using where |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;从执行计划的<code>key</code>列中可以看出来，该查询使用<code>idx_key1</code>索引来执行查询，从<code>rows</code>列可以看出满足<code>key1 &gt; &#39;z&#39;</code>的记录有<code>266</code>条。执行计划的<code>filtered</code>列就代表查询优化器预测在这<code>266</code>条记录中，有多少条记录满足其余的搜索条件，也就是<code>common_field = &#39;a&#39;</code>这个条件的百分比。此处<code>filtered</code>列的值是<code>10.00</code>，说明查询优化器预测在<code>266</code>条记录中有<code>10.00%</code>的记录满足<code>common_field = &#39;a&#39;</code>这个条件。</p><p>&amp;emsp;&amp;emsp;对于单表查询来说，这个<code>filtered</code>列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的<code>filtered</code>值，比方说下面这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL              | 9688 |    10.00 | Using where |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s1.key1 |    1 |   100.00 | NULL        |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;从执行计划中可以看出来，查询优化器打算把<code>s1</code>当作驱动表，<code>s2</code>当作被驱动表。我们可以看到驱动表<code>s1</code>表的执行计划的<code>rows</code>列为<code>9688</code>， <code>filtered</code>列为<code>10.00</code>，这意味着驱动表<code>s1</code>的扇出值就是<code>9688 × 10.00% = 968.8</code>，这说明还要对被驱动表执行大约<code>968</code>次查询。</p><div style="page-break-after: always;"></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试准备--MySQL</title>
      <link href="/2022/10/31/mysql-2022-10-31/"/>
      <url>/2022/10/31/mysql-2022-10-31/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><a href="./model-mysql/mysql/01-%E8%A3%85%E4%BD%9C%E8%87%AA%E5%B7%B1%E6%98%AF%E4%B8%AA%E5%B0%8F%E7%99%BD-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86MySQL.md">01-装作自己是个小白-重新认识MySQL</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://relph1119.github.io/mysql-learning-notes/#/">《MySQL 是怎样运行的：从根儿上理解 MySQL》</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国共产党第二十次全国代表大会闭幕会(文字实录)</title>
      <link href="/2022/10/22/news-2022-10-22/"/>
      <url>/2022/10/22/news-2022-10-22/</url>
      
        <content type="html"><![CDATA[<h1 id="中国共产党第二十次全国代表大会在京闭幕-习近平主持大会并发表重要讲话"><a href="#中国共产党第二十次全国代表大会在京闭幕-习近平主持大会并发表重要讲话" class="headerlink" title="中国共产党第二十次全国代表大会在京闭幕 习近平主持大会并发表重要讲话"></a>中国共产党第二十次全国代表大会在京闭幕 习近平主持大会并发表重要讲话</h1><p><img src="https://s2.loli.net/2022/10/22/Xey7fdVRPmhK5tq.png" alt="avatar"></p><p><font color="red" size="3"> <center>中国共产党第二十次全国代表大会在京闭幕</center></font></p><p><font color="red" size="3"> <center>选举产生新一届中央委员会和中央纪律检查委员会</center></font></p><p><font color="red" size="3"> <center>通过关于十九届中央委员会报告的决议、关于十九届中央纪律检查委员会工作报告的决议、关于《中国共产党章程（修正案）》的决议</center></font></p><p><font color="red" size="3"> <center>习近平主持大会并发表重要讲话</center></font></p><p>　　中国共产党第二十次全国代表大会在选举产生新一届中央委员会和中央纪律检查委员会，通过关于十九届中央委员会报告的决议、关于十九届中央纪律检查委员会工作报告的决议、关于《中国共产党章程（修正案）》的决议后，22日上午在人民大会堂胜利闭幕。</p><p>　　大会号召，全党全军全国各族人民紧密团结在以习近平同志为核心的党中央周围，牢记空谈误国、实干兴邦，坚定信心、同心同德，埋头苦干、奋勇前进，为全面建设社会主义现代化国家、全面推进中华民族伟大复兴而团结奋斗。</p><p>　　习近平同志主持大会。</p><p>　　习近平、李克强、栗战书、汪洋、王沪宁、赵乐际、韩正、王岐山、丁薛祥、王晨、刘鹤、许其亮、孙春兰、李希、李强、李鸿忠、杨洁篪、杨晓渡、张又侠、陈希、陈全国、陈敏尔、胡春华、郭声琨、黄坤明、蔡奇、胡锦涛、李瑞环、温家宝、贾庆林、张德江、俞正声、宋平、李岚清、曾庆红、吴官正、李长春、贺国强、刘云山、张高丽、尤权、张庆黎等大会主席团常务委员会成员在主席台前排就座。</p><p>　　上午9时，闭幕会开始。</p><p>　　今天大会应到代表和特邀代表2378人，实到2338人。实到代表超过应到代表的半数，符合大会选举办法的规定。</p><p>　　会议首先通过了2名总监票人和36名监票人名单。</p><p>　　在总监票人和监票人监督下，到会的代表和特邀代表以无记名投票方式，选举出由205名委员、171名候补委员组成的二十届中央委员会，选举出二十届中央纪律检查委员会委员133名。</p><p>　　11时09分，习近平宣布，第二十届中央委员会和中央纪律检查委员会，已经党的第二十次全国代表大会选举产生。全场响起长时间的热烈掌声。</p><p>　　随后，大会通过了关于十九届中央委员会报告的决议。大会批准习近平同志代表十九届中央委员会所作的报告。决议指出，大会通过的十九届中央委员会的报告，是党和人民智慧的结晶，是党团结带领全国各族人民夺取中国特色社会主义新胜利的政治宣言和行动纲领，是马克思主义的纲领性文献。</p><p>　　大会认为，报告阐明的大会主题是大会的灵魂，是党和国家事业发展的总纲。全党要高举中国特色社会主义伟大旗帜，深刻领悟”两个确立”的决定性意义，坚决维护习近平同志党中央的核心、全党的核心地位，全面贯彻习近平新时代中国特色社会主义思想，弘扬伟大建党精神，自信自强、守正创新，踔厉奋发、勇毅前行，为全面建设社会主义现代化国家、全面推进中华民族伟大复兴而团结奋斗。</p><p>　　大会高度评价十九届中央委员会的工作。党的十九大以来的五年，是极不寻常、极不平凡的五年。五年来，以习近平同志为核心的党中央审时度势、守正创新，敢于斗争、善于斗争，团结带领全党全军全国各族人民有效应对严峻复杂的国际形势和接踵而至的巨大风险挑战，以奋发有为的精神把新时代中国特色社会主义不断推向前进，攻克了许多长期没有解决的难题，办成了许多事关长远的大事要事，推动党和国家事业取得举世瞩目的重大成就。</p><p>　　大会强调，党的十八大召开十年来，我们经历了对党和人民事业具有重大现实意义和深远历史意义的三件大事：一是迎来中国共产党成立一百周年，二是中国特色社会主义进入新时代，三是完成脱贫攻坚、全面建成小康社会的历史任务，实现第一个百年奋斗目标。新时代十年的伟大变革，在党史、新中国史、改革开放史、社会主义发展史、中华民族发展史上具有里程碑意义。中国共产党在革命性锻造中更加坚强有力，中国人民焕发出更为强烈的历史自觉和主动精神，实现中华民族伟大复兴进入了不可逆转的历史进程，科学社会主义在二十一世纪的中国焕发出新的蓬勃生机。</p><p>　　大会强调，新时代十年的伟大变革，是在以习近平同志为核心的党中央坚强领导下、在习近平新时代中国特色社会主义思想指引下全党全国各族人民团结奋斗取得的。党确立习近平同志党中央的核心、全党的核心地位，确立习近平新时代中国特色社会主义思想的指导地位，反映了全党全军全国各族人民共同心愿，对新时代党和国家事业发展、对推进中华民族伟大复兴历史进程具有决定性意义。新时代新征程上把中国特色社会主义事业推向前进，最紧要的是深刻领悟”两个确立”的决定性意义，增强”四个意识”、坚定”四个自信”、做到”两个维护”，自觉在思想上政治上行动上同以习近平同志为核心的党中央保持高度一致。</p><p>　　大会强调，党的十八大以来，我们党勇于进行理论探索和创新，以全新的视野深化对共产党执政规律、社会主义建设规律、人类社会发展规律的认识，取得重大理论创新成果，集中体现为习近平新时代中国特色社会主义思想。党的十九大、十九届六中全会提出的”十个明确”、”十四个坚持”、”十三个方面成就”概括了这一思想的主要内容，必须长期坚持并不断丰富发展。</p><p>　　大会提出，从现在起，中国共产党的中心任务就是团结带领全国各族人民全面建成社会主义现代化强国、实现第二个百年奋斗目标，以中国式现代化全面推进中华民族伟大复兴。</p><p>　　大会指出，中国式现代化，是中国共产党领导的社会主义现代化，既有各国现代化的共同特征，更有基于自己国情的中国特色。中国式现代化是人口规模巨大的现代化、全体人民共同富裕的现代化、物质文明和精神文明相协调的现代化、人与自然和谐共生的现代化、走和平发展道路的现代化。中国式现代化的本质要求是：坚持中国共产党领导，坚持中国特色社会主义，实现高质量发展，发展全过程人民民主，丰富人民精神世界，实现全体人民共同富裕，促进人与自然和谐共生，推动构建人类命运共同体，创造人类文明新形态。</p><p>　　大会指出，全面建成社会主义现代化强国，总的战略安排是分两步走：从二〇二〇年到二〇三五年基本实现社会主义现代化；从二〇三五年到本世纪中叶把我国建成富强民主文明和谐美丽的社会主义现代化强国。未来五年是全面建设社会主义现代化国家开局起步的关键时期。</p><p>　　大会强调，前进道路上，必须牢牢把握以下重大原则：坚持和加强党的全面领导，坚持中国特色社会主义道路，坚持以人民为中心的发展思想，坚持深化改革开放，坚持发扬斗争精神。</p><p>　　大会同意报告对未来一个时期党和国家事业发展作出的战略部署。</p><p>　　大会强调，必须坚定不移贯彻总体国家安全观，把维护国家安全贯穿党和国家工作各方面全过程，健全国家安全体系，增强维护国家安全能力，提高公共安全治理水平，完善社会治理体系，确保国家安全和社会稳定。</p><p>　　大会强调，如期实现建军一百年奋斗目标，加快把人民军队建成世界一流军队，是全面建设社会主义现代化国家的战略要求。必须贯彻习近平强军思想，贯彻新时代军事战略方针，有效履行新时代人民军队使命任务。</p><p>　　大会强调，”一国两制”是中国特色社会主义的伟大创举，是香港、澳门回归后保持长期繁荣稳定的最佳制度安排，必须长期坚持。要坚持一个中国原则和”九二共识”，坚持贯彻新时代党解决台湾问题的总体方略，坚定反”独”促统，牢牢把握两岸关系主导权和主动权，坚定不移推进祖国统一大业。</p><p>　　大会同意报告对国际形势的分析和外交工作的部署。</p><p>　　大会强调，全面建设社会主义现代化国家、全面推进中华民族伟大复兴，关键在党。必须持之以恒推进全面从严治党，深入推进新时代党的建设新的伟大工程，以党的自我革命引领社会革命，落实新时代党的建设总要求，健全全面从严治党体系，全面推进党的自我净化、自我完善、自我革新、自我提高，坚持和加强党中央集中统一领导，坚持不懈用习近平新时代中国特色社会主义思想凝心铸魂，完善党的自我革命制度规范体系，建设堪当民族复兴重任的高素质干部队伍，增强党组织政治功能和组织功能，坚持以严的基调强化正风肃纪，坚决打赢反腐败斗争攻坚战持久战。</p><p>　　大会通过了关于十九届中央纪律检查委员会工作报告的决议。大会充分肯定十九届中央纪律检查委员会的工作。</p><p>　　大会通过了关于《中国共产党章程（修正案）》的决议，决定这一修正案自通过之日起生效。</p><p>　　大会认为，党的十九大以来，以习近平同志为核心的党中央坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，提出一系列治国理政新理念新思想新战略，不断丰富和发展习近平新时代中国特色社会主义思想，开辟了马克思主义中国化时代化新境界。习近平新时代中国特色社会主义思想是当代中国马克思主义、二十一世纪马克思主义，是中华文化和中国精神的时代精华。大会一致同意，把党的十九大以来习近平新时代中国特色社会主义思想新发展写入党章，以更好反映以习近平同志为核心的党中央推进党的理论创新、实践创新、制度创新成果。</p><p>　　大会认为，在百年奋斗历程中，党始终践行党的初心使命，团结带领全国各族人民书写了中华民族几千年历史上最恢宏的史诗，创造了一系列伟大成就，积累了宝贵历史经验。大会同意把党的初心使命、党的百年奋斗重大成就和历史经验的内容写入党章。敢于斗争、敢于胜利，是党和人民不可战胜的强大精神力量。党和人民取得的一切成就，都是通过斗争取得的。大会同意把发扬斗争精神、增强斗争本领的内容写入党章。</p><p>　　大会认为，习近平同志在庆祝中国共产党成立一百周年大会上代表党和人民作出实现了第一个百年奋斗目标、全面建成了小康社会、正在向着全面建成社会主义现代化强国的第二个百年奋斗目标迈进的庄严宣告，党章据此作出相应修改。</p><p>　　大会认为，党的二十大提出以中国式现代化全面推进中华民族伟大复兴，并将此确定为新时代新征程中国共产党的中心任务。公有制为主体、多种所有制经济共同发展，按劳分配为主体、多种分配方式并存，社会主义市场经济体制等社会主义基本经济制度，是中国特色社会主义制度的重要支柱。大会同意把上述内容写入党章，同意把逐步实现全体人民共同富裕，把握新发展阶段，贯彻创新、协调、绿色、开放、共享的新发展理念，加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局，推动高质量发展，充分发挥人才作为第一资源的作用，促进国民经济更高质量、更有效率、更加公平、更可持续、更为安全发展等内容写入党章。</p><p>　　大会认为，全面建设社会主义现代化国家，是一项伟大而艰巨的事业，前途光明，任重道远。全面建成社会主义现代化强国，总的战略安排是分两步走：从二〇二〇年到二〇三五年基本实现社会主义现代化；从二〇三五年到本世纪中叶把我国建成富强民主文明和谐美丽的社会主义现代化强国。党章据此作出相应修改。</p><p>　　大会同意，把走中国特色社会主义法治道路，发展更加广泛、更加充分、更加健全的全过程人民民主，建立健全民主选举、民主协商、民主决策、民主管理、民主监督的制度和程序，统筹发展和安全等内容写入党章。</p><p>　　大会同意，把坚持政治建军、改革强军、科技强军、人才强军、依法治军，把人民军队建设成为世界一流军队；全面准确、坚定不移贯彻”一个国家、两种制度”的方针，坚决反对和遏制”台独”；弘扬和平、发展、公平、正义、民主、自由的全人类共同价值，推动建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界等内容写入党章。</p><p>　　大会同意，把弘扬坚持真理、坚守理想，践行初心、担当使命，不怕牺牲、英勇斗争，对党忠诚、不负人民的伟大建党精神，以伟大自我革命引领伟大社会革命等要求写入党章；把必须提高政治判断力、政治领悟力、政治执行力，增强贯彻落实党的理论和路线方针政策的自觉性和坚定性，推进马克思主义中国化时代化，党的自我革命永远在路上，不断健全党内法规体系，强化全面从严治党主体责任和监督责任，一体推进不敢腐、不能腐、不想腐等内容写入党章；把坚持新时代党的组织路线作为党的建设的基本要求之一写入党章。</p><p>　　大会认为，中国共产党是领导我们事业的核心力量，党的领导是实现中华民族伟大复兴的根本保证。大会同意把党是最高政治领导力量，坚持和加强党的全面领导等内容写入党章。</p><p>　　大会认为，总结吸收党的十九大以来党的工作和党的建设的成功经验，并同总纲部分修改相衔接，对党章部分条文作适当修改很有必要。</p><p>　　大会认为，进入新时代，党和国家面临的形势之复杂、斗争之严峻、改革发展稳定任务之艰巨世所罕见、史所罕见，正是因为确立了习近平同志党中央的核心、全党的核心地位，确立了习近平新时代中国特色社会主义思想的指导地位，党才有力解决了影响党长期执政、国家长治久安、人民幸福安康的突出矛盾和问题，消除了党、国家、军队内部存在的严重隐患，从根本上确保实现中华民族伟大复兴进入了不可逆转的历史进程。”两个确立”是党在新时代取得的重大政治成果，是推动党和国家事业取得历史性成就、发生历史性变革的决定性因素。全党必须深刻领悟”两个确立”的决定性意义，更加自觉地维护习近平同志党中央的核心、全党的核心地位，更加自觉地维护以习近平同志为核心的党中央权威和集中统一领导，全面贯彻习近平新时代中国特色社会主义思想，坚定不移在思想上政治上行动上同以习近平同志为核心的党中央保持高度一致。</p><p>　　大会完成各项议程后，习近平在热烈的掌声中发表了重要讲话。他表示，在全体代表共同努力下，大会取得了圆满成功，达到了统一思想、坚定信心、明确方向、鼓舞斗志的目的。这是一次高举旗帜、凝聚力量、团结奋进的大会。大会通过的十九届中央委员会的报告，高举中国特色社会主义伟大旗帜，坚持马克思列宁主义、毛泽东思想、邓小平理论、”三个代表”重要思想、科学发展观，全面贯彻新时代中国特色社会主义思想，分析了国际国内形势，提出了党的二十大主题，回顾总结了过去五年的工作和新时代十年的伟大变革，阐述了开辟马克思主义中国化时代化新境界、中国式现代化的中国特色和本质要求等重大问题，对全面建设社会主义现代化国家、全面推进中华民族伟大复兴进行了战略谋划，对统筹推进”五位一体”总体布局、协调推进”四个全面”战略布局作出了全面部署，为新时代新征程党和国家事业发展、实现第二个百年奋斗目标指明了前进方向、确立了行动指南。这个报告，是党和人民智慧的结晶，是党团结带领全国各族人民夺取中国特色社会主义新胜利的政治宣言和行动纲领，是马克思主义的纲领性文献。大会通过的十九届中央纪律检查委员会工作报告，总结了党的十九大以来在党中央坚强领导下，各级纪律检查委员会推进全面从严治党的实践探索和重要成效，阐明了深化全面从严治党、深入推进新时代党的建设新的伟大工程对全面建设社会主义现代化国家、全面推进中华民族伟大复兴的极端重要性，揭示了以党的自我革命引领社会革命的重大意义，宣示了党以永远在路上的清醒和坚定推进党风廉政建设和反腐败斗争的坚强决心。大会通过的党章修正案，体现了党的十九大以来党的理论创新、实践创新、制度创新成果，对坚持和加强党的全面领导、坚定不移推进全面从严治党、坚持和完善党的建设、推进党的自我革命提出了明确要求。大会选举产生的新一届中央委员会，集中了各地区各部门、各条战线、各个行业党的执政骨干和优秀代表，素质优良、分布均衡、结构合理，符合党中央要求和干部群众期待，符合领导班子和干部队伍实际，一定能够担负起团结带领全党全国各族人民全面建设社会主义现代化国家、全面推进中华民族伟大复兴的历史重任。大会还选举产生了新一届中央纪律检查委员会。我们相信，党的二十大作出的各项决策部署、取得的各项成果，必将对全面建设社会主义现代化国家、全面推进中华民族伟大复兴，对夺取中国特色社会主义新胜利发挥十分重要的指导和保证作用。</p><p>　　习近平强调，我们作为党的全国代表大会代表，使命光荣，责任重大，一定要牢记党的初心使命，坚定理想信念，弘扬伟大建党精神，认真学习领会党的理论和路线方针政策，贯彻落实党中央关于全面建设社会主义现代化国家、全面推进中华民族伟大复兴的战略部署，更加自觉地学习党章、遵守党章、贯彻党章、维护党章，在思想上政治上行动上同党中央保持高度一致；一定要牢记江山就是人民、人民就是江山，践行全心全意为人民服务的根本宗旨，保持同人民群众的血肉联系，始终同人民站在一起、想在一起、干在一起，积极反映广大党员和人民群众呼声，正确履行代表职责，自觉接受党和人民监督；一定要牢记”国之大者”，提高政治判断力、政治领悟力、政治执行力，带头维护党中央权威和集中统一领导，带头遵守政治纪律和政治规矩，带头提高党性修养、提升素质能力，为党和人民事业贡献自己的全部智慧和力量，为全体党员作出表率，不辜负广大党员信任。</p><p>　　习近平表示，大会期间，各民主党派中央、全国工商联和各族各界人士向大会表示祝贺，广大人民群众通过各种方式向大会表示祝贺，许多国家政党和组织来电来函对大会表示祝贺，大会主席团谨向他们表示衷心的感谢。</p><p>　　习近平强调，中国共产党走过了百年奋斗历程，又踏上了新的赶考之路。一百年来，党团结带领全国各族人民取得了新民主主义革命、社会主义革命和建设、改革开放和社会主义现代化建设的伟大胜利，开创了中国特色社会主义新时代。百年成就无比辉煌，百年大党风华正茂。我们完全有信心有能力在新时代新征程创造令世人刮目相看的新的更大奇迹。全党要紧密团结在党中央周围，高举中国特色社会主义伟大旗帜，坚定历史自信，增强历史主动，敢于斗争、敢于胜利，埋头苦干、锐意进取，团结带领全国各族人民为实现党的二十大确定的目标任务而奋斗。</p><p>　　大会选举后，现任和曾任全国人大常委会副委员长、全国政协副主席的党外人士，在京各民主党派中央、全国工商联副主席，无党派代表人士，宗教界代表人士，在京全国人大、全国政协常委中的民主党派、无党派和民族宗教界人士作为来宾列席会议。党内有关负责同志也列席了会议。</p><p>　　大会在雄壮的《国际歌》声中圆满结束。</p><p>来源：新华社</p><p>责编：张明宇 姚润萍 郝多 冯文雅</p><p>编审：陈卫平 陈竞超</p>]]></content>
      
      
      <categories>
          
          <category> 新闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时政 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试准备--SpringCloud</title>
      <link href="/2022/10/20/interview-springCloud-001/"/>
      <url>/2022/10/20/interview-springCloud-001/</url>
      
        <content type="html"><![CDATA[<h2 id="问题简答"><a href="#问题简答" class="headerlink" title="问题简答"></a>问题简答</h2><h3 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a><code>什么是微服务？</code></h3><p>单个轻量级服务一般为一个单独微服务，微服务讲究的是 专注某个功能的实现，比如登录系统只专注于用户登录方面功能的实现，讲究的是职责单一，开箱即用，可以独立运行。微服务架构系统是一个分布式的系统，按照业务进行划分服务单元模块，解决单个系统的不足，满足越来越复杂的业务需求。</p><p>马丁福勒（Martin Fowler）：就目前而言，对于微服务业界并没有一个统一的、标准的定义。但通常而言，微服务架构是一种架构模式或者说是架构风格，它提倡将单一应用程序划分成一组小的服务。每个服务运行在其独立的自己的进程中服务之间相互配合、相互协调，为用户提供最终价值。服务之间采用轻量级通信。每个服务都围绕具体业务进行构建，并能够独立部署到生产环境等。另外应尽量避免统一的、集中的服务管理机制。</p><h3 id="通俗的来讲："><a href="#通俗的来讲：" class="headerlink" title="通俗的来讲："></a><code>通俗的来讲：</code></h3><p>微服务就是一个独立的职责单一的服务应用程序。在 intellij idea 工具里面就是用maven开发的一个个独立的module，具体就是使用springboot 开发的一个小的模块，处理单一专业的业务逻辑，一个模块只做一个事情。</p><p>微服务强调的是服务大小，关注的是某一个点，具体解决某一个问题&#x2F;落地对应的一个服务应用，可以看做是idea 里面一个 module。</p><p>比如你去医院：你的牙齿不舒服，那么你就去牙科。你的头疼，那么你就去脑科。一个个的科室，就是一个微服务，一个功能就是一个服务。</p><h3 id="微服务的优缺点是什么？"><a href="#微服务的优缺点是什么？" class="headerlink" title="微服务的优缺点是什么？"></a><code>微服务的优缺点是什么？</code></h3><ul><li><p><strong>优点</strong>： 松耦合，聚焦单一业务功能，无关开发语言，团队规模降低。在开发中，不需要了解多有业务，只专注于当前功能，便利集中，功能小而精。微服务一个功能受损，对其他功能影响并不是太大，可以快速定位问题。微服务只专注于当前业务逻辑代码，不会和 html、css 或其他界面进行混合。可以灵活搭配技术，独立性比较舒服。</p></li><li><p><strong>缺点</strong>： 随着服务数量增加，管理复杂，部署复杂，服务器需要增多，服务通信和调用压力增大，运维工程师压力增大，人力资源增多，系统依赖增强，数据一致性，性能监控</p></li></ul><h3 id="什么是微服务架构？"><a href="#什么是微服务架构？" class="headerlink" title="什么是微服务架构？"></a><code>什么是微服务架构？</code></h3><p>微服务架构 就是 对微服务进行管理整合应用的。微服务架构 依赖于 微服务，是在微服务基础之上的。</p><p>例如：上面已经列举了什么是微服务。在医院里，每一个科室都是一个独立的微服务，那么 这个医院 就是 一个大型的微服务架构，就类似 院长 可以 对下面的 科室进行管理。微服务架构主要就是这种功能。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大白话中台系统</title>
      <link href="/2022/10/19/zhongTai-sys-20221019/"/>
      <url>/2022/10/19/zhongTai-sys-20221019/</url>
      
        <content type="html"><![CDATA[<p>什么是中台系统？它是如何诞生的？它长什么模样？我们为什么需要它？一串串的问题不禁浮现在我们的脑海，今天我们就带着这些问题，一起走进中台。</p><p>　<strong>1、中台诞生</strong></p><p>　　任何一个软件系统都是通过帮助客户解决问题来实现价值的。针对不同的需求会建立不同的软件项目。</p><p>　　这些软件项目包含客户端的应用和后台管理配置的应用。久而久之就形成了固定的”前台”和”后台”系统，而且大家都在乐此不疲地开发着类似的业务系统。</p><p>　　但是，时间一长大家就发现了，这些系统中有一些部分大同小异，在做第二个项目的时候并不用将所有的功能重写，可以把之前项目中那些共有的模块拿出来，稍作修改就可以在新项目中应用了。这就是中台的雏形。</p><p>　　<strong>转动的齿轮</strong></p><p>　　抽象和解耦是软件开发铁律，同样也适用于中台系统。中台系统就是将”后台”系统中那些针对技术，业务，组织的通用”模块&#x2F;服务”从原来固定的项目中抽离出来，并且使之能够成为一个自治的服务提供给更多的”前台”使用。</p><p>　　中台就是”前台”和”后台”之间联动的齿轮，也是：</p><p>　　调节器：前台业务变化快，后台系统相对比较稳定，中台就是他们中间的速度调节器。</p><p>　　加速器：新业务上马，接入中台即刻享受服务，不用 0 开始。</p><p>　　稳定器：前台业务多如牛毛，后台数据排山倒海，而中台提供各式各样的接口对接两者使用户享受稳定可靠的服务。</p><p>　　</p><p><img src="/2022/10/19/zhongTai-sys-20221019/1.png" alt="图片"></p><p>　　“中台系统”犹如齿轮，带动”前，后台系统”飞速转动</p><p>　<strong>2、中台的分类</strong></p><p>　　中台是一种能力的抽象，这种能力可以是业务能力，技术能力，数据能力甚至是组织能力。我们可以从不同的维度对其进行分类。</p><p>　　<br><img src="/2022/10/19/zhongTai-sys-20221019/2.png" alt="图片"></p><p>　　中台分为如下几类：</p><p>　　业务中台</p><p>　　技术中台</p><p>　　数据中台</p><p>　　组织中台</p><p>　<strong>①业务中台</strong></p><p>　　业务是根本，特别是用户的核心业务。对于中台来说需要针对业务进行颗粒度划分。例如：客户服务，结算中心，订单中心。</p><p>　　如果业务发生变化需要对上述服务进行拆解，例如：将结算中心拆解成支付服务和核销服务。</p><p>　　这样的分类和拆解是为了更好的支持前台，给前台业务提供更多的可能性，从而为用户组合出更多的使用场景。</p><p>　　这类平台的提供者一般在某一个行业深耕多年，积累大量的行业知识。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/3.png" alt="图片"></p><p>　　业务中台：根据业务对服务进行划分</p><p>　　<strong>②技术中台</strong></p><p>　　作为技术人员接触过最多的就是技术中台，通常我们会将服务进行拆解通过微服务的方式重新组织。</p><p>　　每个微服务都是自我治理的，通过服务注册，服务网关，服务跟踪的方式让他们形成一个整体。</p><p>　　技术中台的划分通常分为两个维度，第一个是基础服务，这些服务针对整个系统来说相对通用，如：日志服务，安全服务等等。</p><p>　　第二个就是业务服务，这些服务都针对每个业务模块做划分，通常这些服务会根据业务的变化或者增量进行更新或者横向扩展。</p><p>　　这类平台的提供者，一般都是科技型企业，涉及过多个行业，对基础组件和模块的应用得心应手，往往他们设计出来的中台架构性能和可靠性方面比较优秀。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/4.png" alt="图片"></p><p>　　技术中台：利用微服务，DevOps 给前台提供支撑</p><p>　<strong>③数据中台</strong></p><p>　　数据的获取通常需要经过数据采集，数据清洗&#x2F;过滤，数据存储，数据归档几个步骤，最后才能通过数据服务的形式展现给用户。</p><p>　　特别是针对客户端来说，同时通过数据中台提供的服务来获取数据的。数据中台会根据不同的业务场景，生成不同的数据服务，满足客户的需要。</p><p>　　提供类似平台的企业进入 IT<br>信息化的时间比较早，积累了一大批数据，通过对数据的整合和分析可以助力业务发展。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/5.png" alt="图片"></p><p>　　数据中台：让前端不用关心数据处理过程，只专注于”数据服务”</p><p>　　<strong>④组织中台</strong></p><p>　　中台是需要人来实现的，如何组织好这些人就显得尤为重要了。如果要谈谈组织中台，那么就要先说说下面几种组织结构。</p><p>　　职能型：每个部门各司其职，虽然都是一个老板管，但是部门之间的界限明确。</p><p>　　每次有了项目就从各个部门抽调人员，当项目完成以后人员都回到各自的部门当中。</p><p>　　如果再有新的项目就再次抽调。这种方式沟通成本高，责权不清，出现问题以后容易踢皮球，对用户需求的反应相对较慢。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/6.png" alt="图片"></p><p>　　职能型：根据职能对组织进行划分</p><p>　　矩阵型：随着互联网的兴起，矩阵型的组织结构也悄然兴起。把人员从原来的部门中完全剥离出来成立专门的项目，并且指定项目经理。</p><p>　　人员汇报的线路也从原来的部门经理换成了项目经理。而项目经理又对 CTO<br>直接负责，这样的结构相对简单，实用性较强，避开了职能型组织结构的一些缺点。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/7.png" alt="图片"></p><p>　　矩阵型：从职能部门中抽取合适的人形成独立的组织</p><p>　　产品型：随着产品意识的不断提升，人们不再拘泥于之前的矩阵型组织结构了，于是加入了产品和产品经理，更重要的是把客户也纳入到组织当中。</p><p>　　让客户参与产品决策，验收测试，增加用户的参与感，做到产品为客户所用。用户自己设计，测试出来的产品他想说不好都难。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/8.png" alt="图片"></p><p>　　产品型：在职能型的基础上，让组织围绕产品和用户工作</p><p>　　随着组织中台的不断发展，我们的组织结构也慢慢从职能型向矩阵型，产品型进行过渡。</p><p>　　<strong>3、中台的生命周期</strong></p><p>　　任何事物都有自身的运转规律，中台系统也不例外。首先我们需要满足使用者在某种场景中的需求，通过对需求的转化我们知道需要通过哪些功能或者系统来实现。</p><p>　　这些功能或者系统是否已经在中台系统中存在？如果存在是否需要进行优化或者拆分，如果不存在是否做成可以有通用性的模块？</p><p>　　在定义了以上几点以后，再进行设计，编码调试，集成测试。最后，发布给客户去验证业务的可行性。</p><p>　　如果发现问题再回到需求的原点重新走一次上面的过程，周而复始，直到满足客户的需求为止。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/9.png" alt="图片"></p><p>　　“需求”，”实施”，”验证”不断循环，直到满足用户的需求</p><p>　<strong>4、中台的作用</strong></p><p>　　大家既然对中台有了一定的了解，那我们再从两个维度来看看中台的作用。虽然上面已经介绍了很多关乎作用的例子，但是我们还是希望从两个维度来归纳总结一下。</p><p><strong>①快速切入市场</strong></p><p>　　在中台出现之前，我们进入每个行业是比较困难的。在了解业务的基础上需要搭建基础的业务模块。</p><p>　　现在不需要了，有了中台策略的加持即使对一些行业不太了解也能够从容应对。</p><p>　　在 BAT<br>中已经有染指汽车制造，航空航天等专业性很强的行业了，靠的就是中台能力的输出。<br>      <strong>②专业人员融入系统</strong></p><p>　　有了中台系统，那么就离不开行业中的专业人员。行业中的专业人员，协助中台系统打磨各个业务模块，通过<br>PASS 平台打造行业自身的应用。让业务和技术更好的融合，产生化学作用。</p><p>　　<strong>③定义平台规则</strong></p><p>　　现在阿里的钉钉就把用户，服务提供商，经销商都拉到了一个平台上了。通过阿里平台的能力，将钉钉打造成企业服务的中台，让多方从中受益。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/10.png" alt="图片"></p><p>　　业务方面：通过满足市场需求，提高专业化程度，打造平台战略，逐步升级</p><p><strong>5、技术方面的作用</strong><br><strong>①服务重用</strong></p><p>　　不要重复造轮子是我们始终面对的问题，中台的初衷就是抽离通用的部分，让更多人能够享受他们。</p><p>　　<strong>②服务进化</strong><br>技术会跟随业务的进化而进化，每一次进化都是一次技术的沉淀。以前这些技术进化是不可见的，现在新的项目也可以通过中台系统享受这些技术的进化。</p><p>　　<strong>③快速响应</strong><br>由于中台系统针对服务进行颗粒化处理，让每个服务都有独立性，可以针对业务的需求对服务进行横向扩展，从而提高服务的响应时间。</p><p>　<strong>④数据积累</strong></p><p>　　长年累月的数据积累，特别是对业务数据的积累，能够帮助我们带来商业价值。</p><p>　　<strong>⑤提高效率</strong></p><p>　　不用从无到有去搭建整个项目架构，也大大缩短了给用户的交付时间，高效的组织结构也促进了交付质量，提高了用户的满意度。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/11.png" alt="图片"></p><p>　　技术方面：服务重用，服务进化，快速响应，数据积累，提高效率相辅相成</p><p><strong>6、如何建立自己公司的中台</strong></p><p>　　不管是阿里的”中台，前台”战略，还是华为的”平台炮火支撑精兵作战”战略，仿佛都离我们很远。</p><p>　　有人说：”中台系统就是大公司的事情，我们做好自己手上的项目就好了。”这话对也不对！</p><p>　　中台系统确实需要具备一定规模以后才能产生，只有项目足够多，行业足够丰富，资源充足的情况下可以实行。</p><p>　　这些都是中小公司无法做到的，但是，作为我们可以利用中台策略的思维来优化我们的开发，产品，项目甚至是组织。</p><p>　　从业务方面，我们是否能够把自己专精行业的业务进行一个模块划分，让用户可以自由选择需要的业务模块，提高我们业务适配的灵活性。</p><p>　　从技术方面，我们是否能够总结一下哪些模块，服务可以从系统中解耦出来成为单独的服务，甚至可以单独部署做到真正的自治。以后搭建技术框架的时候就好像搭积木一样方便可靠。</p><p>　　从组织方面，由康威定理可以得出什么样的组织结构直接影响这个组织结构生产的软件。</p><p>　　我们是否还在遵循传统的职能型的方式在推进项目。是否可以考虑以客户为中心的开发模式，让开发人员更加贴近客户，为客户创造价值。</p><p>　　中台对于个体来说意味着什么？</p><p>　　前面提到了中台的定义，中台的作用以及对中小公司的思考。那么对于我们个人而言中台又意味着什么呢？我们可以在其中做些什么呢？这里我分享一下自己的想法。</p><p>　　如果说淘宝网整个就看成一个大中台来说，它提供了各式各样的服务，接口，数据，为商家和消费者创造交易的环境。那么我们把淘宝网可以看成一个”面”。</p><p>　　那么对于商家来说，他需要利用一些营销工具，聘请一些模特拍照，利用一些物流信息为自己送货。商家可以看成一条”线”。</p><p>　　那些提供营销工具，拍照服务，物流服务的供应商就可以看成”点”。</p><p>　　对于我们而言，可能无法成为”面”，但是可以通过”面”的支持去做”线”和”点”。</p><p>　　再把眼界扩大一点，到微信小程序，支付宝小程序，钉钉应用，都是有发挥空间的。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/12.png" alt="图片"></p><p>　　供应商，商家，平台，构成”点”，”线”，”面”的有机整体</p><p><strong>7、总结</strong></p><p>　　中台是 IT<br>信息化过程中经验总结的产物，他是前人归纳总结出来的方法论，也是解决问题的思路。</p><p>　　它把这些经验和方法从具体的场景中抽离出来，为的是服务于更多的场景。</p><p>　　我们可以从业务，技术，数据，组织多个维度来看待它。它不仅仅可以应用到企业，对个人的发展也是有帮助的。</p><hr><p>转载说明：本文转载自：51CTO、架构师技术联盟等，如有侵权请联系相关工作人员。<br>来源:<a href="https://blog.csdn.net/jiangjiang_jian/article/details/103006494">https://blog.csdn.net/jiangjiang_jian/article/details/103006494</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国共产党第二十次全国代表大会开幕会文字实录</title>
      <link href="/2022/10/18/news-2022-10-16/"/>
      <url>/2022/10/18/news-2022-10-16/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/10/18/news-2022-10-16/1.jpg" alt="图片"></p><p>10月16日，中国共产党第二十次全国代表大会在北京人民大会堂开幕。这是习近平、李克强、栗战书、汪洋、王沪宁、赵乐际、韩正、胡锦涛在主席台上。</p><p>以下为文字实录：</p><p>同志们：现在，我代表第十九届中央委员会向大会作报告。</p><p>中国共产党第二十次全国代表大会，是在全党全国各族人民迈上全面建设社会主义现代化国家新征程、向第二个百年奋斗目标进军的关键时刻召开的一次十分重要的大会。</p><p>大会的主题是：高举中国特色社会主义伟大旗帜，全面贯彻新时代中国特色社会主义思想，弘扬伟大建党精神，自信自强、守正创新，踔厉奋发、勇毅前行，为全面建设社会主义现代化国家、全面推进中华民族伟大复兴而团结奋斗。</p><p>中国共产党已走过百年奋斗历程。我们党立志于中华民族千秋伟业，致力于人类和平与发展崇高事业，责任无比重大，使命无上光荣。全党同志务必不忘初心、牢记使命，务必谦虚谨慎、艰苦奋斗，务必敢于斗争、善于斗争，坚定历史自信，增强历史主动，谱写新时代中国特色社会主义更加绚丽的华章。</p><p><code>一、过去五年的工作和新时代十年的伟大变革</code></p><p>十九大以来的五年，是极不寻常、极不平凡的五年。党中央统筹中华民族伟大复兴战略全局和世界百年未有之大变局，就党和国家事业发展作出重大战略部署，团结带领全党全军全国各族人民有效应对严峻复杂的国际形势和接踵而至的巨大风险挑战，以奋发有为的精神把新时代中国特色社会主义不断推向前进。</p><p>五年来，我们坚持加强党的全面领导和党中央集中统一领导，全力推进全面建成小康社会进程，完整、准确、全面贯彻新发展理念，着力推动高质量发展，主动构建新发展格局，蹄疾步稳推进改革，扎实推进全过程人民民主，全面推进依法治国，积极发展社会主义先进文化，突出保障和改善民生，集中力量实施脱贫攻坚战，大力推进生态文明建设，坚决维护国家安全，防范化解重大风险，保持社会大局稳定，大力度推进国防和军队现代化建设，全方位开展中国特色大国外交，全面推进党的建设新的伟大工程。我们隆重庆祝中国共产党成立一百周年、中华人民共和国成立七十周年，制定第三个历史决议，在全党开展党史学习教育，号召全党学习和践行伟大建党精神。特别是面对突如其来的新冠肺炎疫情，我们坚持人民至上、生命至上，坚持动态清零不动摇，开展抗击疫情人民战争、总体战、阻击战，最大限度保护了人民生命安全和身体健康，统筹疫情防控和经济社会发展取得重大积极成果。面对香港局势动荡变化，我们依照宪法和基本法有效实施对特别行政区的全面管治权，落实”爱国者治港”原则，香港局势实现由乱到治的重大转折。面对”台独”势力分裂活动和外部势力干涉台湾事务的严重挑衅，我们坚决开展反分裂、反干涉重大斗争，展示了我们维护国家主权和领土完整、反对”台独”的坚强决心和强大能力。面对国际局势急剧变化，我们保持战略定力，发扬斗争精神，在斗争中维护国家尊严和核心利益，牢牢掌握了我国发展和安全主动权。五年来，我们党团结带领人民，攻克了许多长期没有解决的难题，办成了许多事关长远的大事要事，推动党和国家事业取得举世瞩目的重大成就。</p><p>同志们！十八大召开至今已经十年了。十年来，我们经历了对党和人民事业具有重大现实意义和深远历史意义的三件大事：一是迎来中国共产党成立一百周年，二是中国特色社会主义进入新时代，三是完成脱贫攻坚、全面建成小康社会的历史任务，实现第一个百年奋斗目标。这是中国共产党和中国人民团结奋斗赢得的历史性胜利，是彪炳中华民族发展史册的历史性胜利，也是对世界具有深远影响的历史性胜利。</p><p>十年前，我们面对的形势是，改革开放和社会主义现代化建设取得巨大成就，党的建设新的伟大工程取得显著成效，为我们继续前进奠定了坚实基础、创造了良好条件、提供了重要保障，同时一系列长期积累及新出现的突出矛盾和问题亟待解决。面对这些影响党长期执政、国家长治久安、人民幸福安康的突出矛盾和问题，党中央审时度势、果敢抉择，锐意进取、攻坚克难，团结带领全党全军全国各族人民撸起袖子加油干、风雨无阻向前行，义无反顾进行具有许多新的历史特点的伟大斗争。</p><p>十年来，我们坚持马克思列宁主义、毛泽东思想、邓小平理论、”三个代表”重要思想、科学发展观，全面贯彻新时代中国特色社会主义思想，全面贯彻党的基本路线、基本方略，采取一系列战略性举措，推进一系列变革性实践，实现一系列突破性进展，取得一系列标志性成果，经受住了来自政治、经济、意识形态、自然界等方面的风险挑战考验，党和国家事业取得历史性成就、发生历史性变革，推动我国迈上全面建设社会主义现代化国家新征程。</p><ul><li><p>我们创立了新时代中国特色社会主义思想，明确坚持和发展中国特色社会主义的基本方略，提出一系列治国理政新理念新思想新战略，实现了马克思主义中国化时代化新的飞跃。</p></li><li><p>我们全面加强党的领导，确保党中央权威和集中统一领导，确保党发挥总揽全局、协调各方的领导核心作用，我们这个拥有九千六百多万名党员的马克思主义政党更加团结统一。</p></li><li><p>我们经过接续奋斗，实现了小康这个中华民族的千年梦想，打赢了人类历史上规模最大的脱贫攻坚战，历史性地解决了绝对贫困问题，为全球减贫事业作出了重大贡献。</p></li><li><p>我们对新时代党和国家事业发展作出科学完整的战略部署，提出实现中华民族伟大复兴的中国梦，统揽伟大斗争、伟大工程、伟大事业、伟大梦想，明确”五位一体”总体布局和”四个全面”战略布局，确定稳中求进工作总基调，统筹发展和安全，明确我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，并紧紧围绕这个社会主要矛盾推进各项工作，不断丰富和发展人类文明新形态。</p></li><li><p>我们提出并贯彻新发展理念，着力推进高质量发展，推动构建新发展格局，实施供给侧结构性改革，制定一系列具有全局性意义的区域重大战略，我国经济实力实现历史性跃升，国内生产总值从五十四万亿元增长到一百一十四万亿元，我国经济总量占世界经济的比重达百分之十八点五，提高七点二个百分点，稳居世界第二位；人均国内生产总值从三万九千八百元增加到八万一千元。谷物总产量稳居世界首位，制造业规模、外汇储备稳居世界第一。一些关键核心技术实现突破，战略性新兴产业发展壮大，载人航天、探月探火、深海深地探测、超级计算机、卫星导航、量子信息、核电技术、大飞机制造、生物医药等取得重大成果，进入创新型国家行列。</p></li><li><p>我们以巨大的政治勇气全面深化改革，许多领域实现历史性变革、系统性重塑、整体性重构，中国特色社会主义制度更加成熟更加定型，国家治理体系和治理能力现代化水平明显提高。</p></li><li><p>我们实行更加积极主动的开放战略，共建”一带一路”成为深受欢迎的国际公共产品和国际合作平台，我国成为一百四十多个国家和地区的主要贸易伙伴，货物贸易总额居世界第一，吸引外资和对外投资居世界前列，形成更大范围、更宽领域、更深层次对外开放格局。</p></li><li><p>我们坚持走中国特色社会主义政治发展道路，全面发展全过程人民民主，社会主义民主政治制度化、规范化、程序化全面推进，人民当家作主更为扎实，全面依法治国总体格局基本形成。</p></li><li><p>我们确立和坚持马克思主义在意识形态领域指导地位的根本制度，社会主义核心价值观广泛传播，中华优秀传统文化得到创造性转化、创新性发展，文化事业日益繁荣，网络生态持续向好，意识形态领域形势发生全局性、根本性转变。</p></li><li><p>我们深入贯彻以人民为中心的发展思想，在幼有所育、学有所教、劳有所得、病有所医、老有所养、住有所居、弱有所扶上持续用力，建成世界上规模最大的教育体系、社会保障体系、医疗卫生体系，人民群众获得感、幸福感、安全感更加充实、更有保障、更可持续，共同富裕取得新成效。</p></li><li><p>我们坚持绿水青山就是金山银山的理念，坚持山水林田湖草沙一体化保护和系统治理，生态文明制度体系更加健全，生态环境保护发生历史性、转折性、全局性变化，我们的祖国天更蓝、山更绿、水更清。</p></li><li><p>我们贯彻总体国家安全观，以坚定的意志品质维护国家主权、安全、发展利益，国家安全得到全面加强，扫黑除恶专项斗争取得阶段性成果，有力应对一系列重大自然灾害，平安中国建设迈向更高水平。</p></li><li><p>我们确立党在新时代的强军目标，贯彻新时代党的强军思想，贯彻新时代军事战略方针，坚持党对人民军队的绝对领导，统筹加强各方向各领域军事斗争，大刀阔斧深化国防和军队改革，人民军队体制一新、结构一新、格局一新、面貌一新。</p></li><li><p>我们全面准确推进”一国两制”实践，坚持”一国两制”、”港人治港”、”澳人治澳”、高度自治的方针，推动香港进入由乱到治走向由治及兴的新阶段，香港、澳门保持长期稳定发展良好态势。我们提出新时代解决台湾问题的总体方略，促进两岸交流合作，坚决反对”台独”分裂行径，坚决反对外部势力干涉，牢牢把握两岸关系主导权和主动权。</p></li><li><p>我们全面推进中国特色大国外交，推动构建人类命运共同体，坚定维护国际公平正义，倡导践行真正的多边主义，旗帜鲜明反对一切霸权主义和强权政治，毫不动摇反对任何单边主义、保护主义、霸凌行径。我们推动构建新型国际关系，积极参与全球治理体系改革和建设，全面开展抗击新冠肺炎疫情国际合作，赢得广泛国际赞誉，我国国际影响力、感召力、塑造力显著提升。</p></li><li><p>我们深入推进全面从严治党，坚持打铁必须自身硬，提出和落实新时代党的建设总要求，以党的政治建设统领党的建设各项工作。我们以钉钉子精神纠治”四风”，反对特权思想和特权现象，刹住了一些长期没有刹住的歪风，纠治了一些多年未除的顽瘴痼疾。我们开展了史无前例的反腐败斗争，以”得罪千百人、不负十四亿”的使命担当祛疴治乱，”打虎”、”拍蝇”、”猎狐”多管齐下，反腐败斗争取得压倒性胜利并全面巩固，消除了党、国家、军队内部存在的严重隐患。经过不懈努力，党找到了自我革命这一跳出治乱兴衰历史周期率的第二个答案，确保党永远不变质、不变色、不变味。</p></li></ul><p>在充分肯定党和国家事业取得举世瞩目成就的同时，必须清醒看到，我们的工作还存在一些不足，面临不少困难和问题。对这些问题，我们已经采取一系列措施加以解决，今后必须加大工作力度。</p><p>同志们！新时代的伟大成就是党和人民一道拼出来、干出来、奋斗出来的！在这里，我代表中共中央，向全体中国共产党员，向全国各族人民，向各民主党派、各人民团体和各界爱国人士，向香港特别行政区同胞、澳门特别行政区同胞和台湾同胞以及广大侨胞，向关心和支持中国现代化建设的各国朋友，表示衷心的感谢！</p><p>新时代十年的伟大变革，在党史、新中国史、改革开放史、社会主义发展史、中华民族发展史上具有里程碑意义。走过百年奋斗历程的中国共产党在革命性锻造中更加坚强有力，在坚持和发展中国特色社会主义的历史进程中始终成为坚强领导核心。中国人民的前进动力更加强大、奋斗精神更加昂扬、必胜信念更加坚定，中国共产党和中国人民正信心百倍推进中华民族从站起来、富起来到强起来的伟大飞跃。改革开放和社会主义现代化建设深入推进，实现中华民族伟大复兴进入了不可逆转的历史进程。科学社会主义在二十一世纪的中国焕发出新的蓬勃生机，中国式现代化为人类实现现代化提供了新的选择，中国共产党和中国人民为解决人类面临的共同问题提供更多更好的中国智慧、中国方案、中国力量，为人类和平与发展崇高事业作出新的更大的贡献！</p><p><code>二、开辟马克思主义中国化时代化新境界</code></p><p>马克思主义是我们立党立国、兴党兴国的根本指导思想。实践告诉我们，中国共产党为什么能，中国特色社会主义为什么好，归根到底是马克思主义行，是中国化时代化的马克思主义行。拥有马克思主义科学理论指导是我们党坚定信仰信念、把握历史主动的根本所在。</p><p>十八大以来，我们党勇于进行理论探索和创新，以全新的视野深化对共产党执政规律、社会主义建设规律、人类社会发展规律的认识，取得重大理论创新成果，集中体现为新时代中国特色社会主义思想。十九大、十九届六中全会提出的”十个明确”、”十四个坚持”、”十三个方面成就”概括了这一思想的主要内容，必须长期坚持并不断丰富发展。</p><p>中国共产党人深刻认识到，只有把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，坚持运用辩证唯物主义和历史唯物主义，才能正确回答时代和实践提出的重大问题，才能始终保持马克思主义的蓬勃生机和旺盛活力。</p><p>实践没有止境，理论创新也没有止境。不断谱写马克思主义中国化时代化新篇章，是当代中国共产党人的庄严历史责任。继续推进实践基础上的理论创新，首先要把握好新时代中国特色社会主义思想的世界观和方法论，坚持好、运用好贯穿其中的立场观点方法。必须坚持人民至上，坚持自信自立，坚持守正创新，坚持问题导向，坚持系统观念，坚持胸怀天下，站稳人民立场、把握人民愿望、尊重人民创造、集中人民智慧，坚持对马克思主义的坚定信仰、对中国特色社会主义的坚定信念，坚定道路自信、理论自信、制度自信、文化自信，不断提出真正解决问题的新理念新思路新办法，为前瞻性思考、全局性谋划、整体性推进党和国家各项事业提供科学思想方法。</p><p><code>三、新时代新征程中国共产党的使命任务</code></p><p>从现在起，中国共产党的中心任务就是团结带领全国各族人民全面建成社会主义现代化强国、实现第二个百年奋斗目标，以中国式现代化全面推进中华民族伟大复兴。</p><p>中国式现代化，是中国共产党领导的社会主义现代化，既有各国现代化的共同特征，更有基于自己国情的中国特色。中国式现代化是人口规模巨大的现代化，是全体人民共同富裕的现代化，是物质文明和精神文明相协调的现代化，是人与自然和谐共生的现代化，是走和平发展道路的现代化。</p><p>中国式现代化的本质要求是：坚持中国共产党领导，坚持中国特色社会主义，实现高质量发展，发展全过程人民民主，丰富人民精神世界，实现全体人民共同富裕，促进人与自然和谐共生，推动构建人类命运共同体，创造人类文明新形态。</p><p>全面建成社会主义现代化强国，总的战略安排是分两步走：从二〇二〇年到二〇三五年基本实现社会主义现代化；从二〇三五年到本世纪中叶把我国建成富强民主文明和谐美丽的社会主义现代化强国。未来五年是全面建设社会主义现代化国家开局起步的关键时期。</p><p>全面建设社会主义现代化国家，是一项伟大而艰巨的事业，前途光明，任重道远。我们必须增强忧患意识，坚持底线思维，做到居安思危、未雨绸缪，准备经受风高浪急甚至惊涛骇浪的重大考验。前进道路上，必须牢牢把握以下重大原则：坚持和加强党的全面领导，坚持中国特色社会主义道路，坚持以人民为中心的发展思想，坚持深化改革开放，坚持发扬斗争精神。要增强全党全国各族人民的志气、骨气、底气，不信邪、不怕鬼、不怕压，知难而进、迎难而上，统筹发展和安全，全力战胜前进道路上各种困难和挑战，依靠顽强斗争打开事业发展新天地。</p><p><code>四、加快构建新发展格局，着力推动高质量发展</code></p><p>高质量发展是全面建设社会主义现代化国家的首要任务。发展是党执政兴国的第一要务。没有坚实的物质技术基础，就不可能全面建成社会主义现代化强国。必须完整、准确、全面贯彻新发展理念，坚持社会主义市场经济改革方向，坚持高水平对外开放，加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局。</p><p>我们要坚持以推动高质量发展为主题，把实施扩大内需战略同深化供给侧结构性改革有机结合起来，增强国内大循环内生动力和可靠性，提升国际循环质量和水平，加快建设现代化经济体系，着力提高全要素生产率，着力提升产业链供应链韧性和安全水平，着力推进城乡融合和区域协调发展，推动经济实现质的有效提升和量的合理增长。</p><p>我们要构建高水平社会主义市场经济体制，坚持和完善社会主义基本经济制度，毫不动摇巩固和发展公有制经济，毫不动摇鼓励、支持、引导非公有制经济发展，充分发挥市场在资源配置中的决定性作用，更好发挥政府作用。建设现代化产业体系，坚持把发展经济的着力点放在实体经济上，推进新型工业化，加快建设制造强国、质量强国、航天强国、交通强国、网络强国、数字中国。全面推进乡村振兴，坚持农业农村优先发展，巩固拓展脱贫攻坚成果，加快建设农业强国，扎实推动乡村产业、人才、文化、生态、组织振兴，全方位夯实粮食安全根基，牢牢守住十八亿亩耕地红线，确保中国人的饭碗牢牢端在自己手中。促进区域协调发展，深入实施区域协调发展战略、区域重大战略、主体功能区战略、新型城镇化战略，优化重大生产力布局，构建优势互补、高质量发展的区域经济布局和国土空间体系。推进高水平对外开放，稳步扩大规则、规制、管理、标准等制度型开放，加快建设贸易强国，推动共建”一带一路”高质量发展，维护多元稳定的国际经济格局和经贸关系。</p><p><code>五、实施科教兴国战略，强化现代化建设人才支撑</code></p><p>教育、科技、人才是全面建设社会主义现代化国家的基础性、战略性支撑。必须坚持科技是第一生产力、人才是第一资源、创新是第一动力，深入实施科教兴国战略、人才强国战略、创新驱动发展战略，开辟发展新领域新赛道，不断塑造发展新动能新优势。</p><p>我们要坚持教育优先发展、科技自立自强、人才引领驱动，加快建设教育强国、科技强国、人才强国，坚持为党育人、为国育才，全面提高人才自主培养质量，着力造就拔尖创新人才，聚天下英才而用之。</p><p>我们要办好人民满意的教育，全面贯彻党的教育方针，落实立德树人根本任务，培养德智体美劳全面发展的社会主义建设者和接班人，加快建设高质量教育体系，发展素质教育，促进教育公平。完善科技创新体系，坚持创新在我国现代化建设全局中的核心地位，健全新型举国体制，强化国家战略科技力量，提升国家创新体系整体效能，形成具有全球竞争力的开放创新生态。加快实施创新驱动发展战略，加快实现高水平科技自立自强，以国家战略需求为导向，集聚力量进行原创性引领性科技攻关，坚决打赢关键核心技术攻坚战，加快实施一批具有战略性全局性前瞻性的国家重大科技项目，增强自主创新能力。深入实施人才强国战略，坚持尊重劳动、尊重知识、尊重人才、尊重创造，完善人才战略布局，加快建设世界重要人才中心和创新高地，着力形成人才国际竞争的比较优势，把各方面优秀人才集聚到党和人民事业中来。</p><p><code>六、发展全过程人民民主，保障人民当家作主</code></p><p>我国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家，国家一切权力属于人民。人民民主是社会主义的生命，是全面建设社会主义现代化国家的应有之义。全过程人民民主是社会主义民主政治的本质属性，是最广泛、最真实、最管用的民主。必须坚定不移走中国特色社会主义政治发展道路，坚持党的领导、人民当家作主、依法治国有机统一，坚持人民主体地位，充分体现人民意志、保障人民权益、激发人民创造活力。</p><p>我们要健全人民当家作主制度体系，扩大人民有序政治参与，保证人民依法实行民主选举、民主协商、民主决策、民主管理、民主监督，发挥人民群众积极性、主动性、创造性，巩固和发展生动活泼、安定团结的政治局面。</p><p>我们要加强人民当家作主制度保障，坚持和完善我国根本政治制度、基本政治制度、重要政治制度，拓展民主渠道，丰富民主形式，支持和保证人民通过人民代表大会行使国家权力。深化工会、共青团、妇联等群团组织改革和建设，有效发挥桥梁纽带作用。坚持走中国人权发展道路，推动人权事业全面发展。全面发展协商民主，推进协商民主广泛多层制度化发展，坚持和完善中国共产党领导的多党合作和政治协商制度，完善人民政协民主监督和委员联系界别群众制度机制。积极发展基层民主，健全基层党组织领导的基层群众自治机制，完善基层直接民主制度体系和工作体系。全心全意依靠工人阶级，维护职工合法权益。巩固和发展最广泛的爱国统一战线，完善大统战工作格局，坚持大团结大联合，动员全体中华儿女围绕实现中华民族伟大复兴中国梦一起来想、一起来干。加强同民主党派和无党派人士的团结合作。以铸牢中华民族共同体意识为主线，加强和改进党的民族工作。坚持我国宗教中国化方向，积极引导宗教与社会主义社会相适应。加强和改进侨务工作，形成共同致力民族复兴的强大力量。</p><p><code>七、坚持全面依法治国，推进法治中国建设</code></p><p>全面依法治国是国家治理的一场深刻革命，关系党执政兴国，关系人民幸福安康，关系党和国家长治久安。必须更好发挥法治固根本、稳预期、利长远的保障作用，在法治轨道上全面建设社会主义现代化国家。</p><p>我们要坚持走中国特色社会主义法治道路，建设中国特色社会主义法治体系、建设社会主义法治国家，围绕保障和促进社会公平正义，坚持依法治国、依法执政、依法行政共同推进，坚持法治国家、法治政府、法治社会一体建设，全面推进科学立法、严格执法、公正司法、全民守法，全面推进国家各方面工作法治化。</p><p>我们要完善以宪法为核心的中国特色社会主义法律体系，加强宪法实施和监督，加强重点领域、新兴领域、涉外领域立法，推进科学立法、民主立法、依法立法。扎实推进依法行政，转变政府职能，优化政府职责体系和组织结构，提高行政效率和公信力，全面推进严格规范公正文明执法。严格公正司法，深化司法体制综合配套改革，全面准确落实司法责任制，加快建设公正高效权威的社会主义司法制度，努力让人民群众在每一个司法案件中感受到公平正义。加快建设法治社会，弘扬社会主义法治精神，传承中华优秀传统法律文化，引导全体人民做社会主义法治的忠实崇尚者、自觉遵守者、坚定捍卫者，努力使尊法学法守法用法在全社会蔚然成风。</p><p><code>八、推进文化自信自强，铸就社会主义文化新辉煌</code></p><p>全面建设社会主义现代化国家，必须坚持中国特色社会主义文化发展道路，增强文化自信，围绕举旗帜、聚民心、育新人、兴文化、展形象建设社会主义文化强国，发展面向现代化、面向世界、面向未来的，民族的科学的大众的社会主义文化，激发全民族文化创新创造活力，增强实现中华民族伟大复兴的精神力量。</p><p>我们要坚持马克思主义在意识形态领域指导地位的根本制度，坚持为人民服务、为社会主义服务，坚持百花齐放、百家争鸣，坚持创造性转化、创新性发展，以社会主义核心价值观为引领，发展社会主义先进文化，弘扬革命文化，传承中华优秀传统文化，满足人民日益增长的精神文化需求，巩固全党全国各族人民团结奋斗的共同思想基础，不断提升国家文化软实力和中华文化影响力。</p><p>我们要建设具有强大凝聚力和引领力的社会主义意识形态，牢牢掌握党对意识形态工作领导权，全面落实意识形态工作责任制，巩固壮大奋进新时代的主流思想舆论，加强全媒体传播体系建设，推动形成良好网络生态。广泛践行社会主义核心价值观，弘扬以伟大建党精神为源头的中国共产党人精神谱系，深入开展社会主义核心价值观宣传教育，深化爱国主义、集体主义、社会主义教育，着力培养担当民族复兴大任的时代新人。提高全社会文明程度，实施公民道德建设工程，弘扬中华传统美德，加强家庭家教家风建设，推动明大德、守公德、严私德，提高人民道德水准和文明素养，在全社会弘扬劳动精神、奋斗精神、奉献精神、创造精神、勤俭节约精神。繁荣发展文化事业和文化产业，坚持以人民为中心的创作导向，推出更多增强人民精神力量的优秀作品，健全现代公共文化服务体系，实施重大文化产业项目带动战略。促进群众体育和竞技体育全面发展，加快建设体育强国。增强中华文明传播力影响力，坚守中华文化立场，讲好中国故事、传播好中国声音，展现可信、可爱、可敬的中国形象，推动中华文化更好走向世界。</p><p><code>九、增进民生福祉，提高人民生活品质</code></p><p>江山就是人民，人民就是江山。中国共产党领导人民打江山、守江山，守的是人民的心。治国有常，利民为本。为民造福是立党为公、执政为民的本质要求。必须坚持在发展中保障和改善民生，鼓励共同奋斗创造美好生活，不断实现人民对美好生活的向往。</p><p>我们要实现好、维护好、发展好最广大人民根本利益，紧紧抓住人民最关心最直接最现实的利益问题，坚持尽力而为、量力而行，深入群众、深入基层，采取更多惠民生、暖民心举措，着力解决好人民群众急难愁盼问题，健全基本公共服务体系，提高公共服务水平，增强均衡性和可及性，扎实推进共同富裕。</p><p>我们要完善分配制度，坚持按劳分配为主体、多种分配方式并存，坚持多劳多得，鼓励勤劳致富，促进机会公平，增加低收入者收入，扩大中等收入群体，规范收入分配秩序，规范财富积累机制。实施就业优先战略，强化就业优先政策，健全就业公共服务体系，加强困难群体就业兜底帮扶，消除影响平等就业的不合理限制和就业歧视，使人人都有通过勤奋劳动实现自身发展的机会。健全社会保障体系，健全覆盖全民、统筹城乡、公平统一、安全规范、可持续的多层次社会保障体系，扩大社会保险覆盖面。坚持男女平等基本国策，保障妇女儿童合法权益。促进残疾人事业全面发展。加快建立多主体供给、多渠道保障、租购并举的住房制度。推进健康中国建设，把保障人民健康放在优先发展的战略位置，建立生育支持政策体系，实施积极应对人口老龄化国家战略，促进中医药传承创新发展，健全公共卫生体系，加强重大疫情防控救治体系和应急能力建设，有效遏制重大传染性疾病传播。</p><p><code>十、推动绿色发展，促进人与自然和谐共生</code></p><p>大自然是人类赖以生存发展的基本条件。尊重自然、顺应自然、保护自然，是全面建设社会主义现代化国家的内在要求。必须牢固树立和践行绿水青山就是金山银山的理念，站在人与自然和谐共生的高度谋划发展。</p><p>我们要推进美丽中国建设，坚持山水林田湖草沙一体化保护和系统治理，统筹产业结构调整、污染治理、生态保护、应对气候变化，协同推进降碳、减污、扩绿、增长，推进生态优先、节约集约、绿色低碳发展。</p><p>我们要加快发展方式绿色转型，实施全面节约战略，发展绿色低碳产业，倡导绿色消费，推动形成绿色低碳的生产方式和生活方式。深入推进环境污染防治，持续深入打好蓝天、碧水、净土保卫战，基本消除重污染天气，基本消除城市黑臭水体，加强土壤污染源头防控，提升环境基础设施建设水平，推进城乡人居环境整治。提升生态系统多样性、稳定性、持续性，加快实施重要生态系统保护和修复重大工程，实施生物多样性保护重大工程，推行草原森林河流湖泊湿地休养生息，实施好长江十年禁渔，健全耕地休耕轮作制度，防治外来物种侵害。积极稳妥推进碳达峰碳中和，立足我国能源资源禀赋，坚持先立后破，有计划分步骤实施碳达峰行动，深入推进能源革命，加强煤炭清洁高效利用，加快规划建设新型能源体系，积极参与应对气候变化全球治理。</p><p><code>十一、推进国家安全体系和能力现代化，坚决维护国家安全和社会稳定</code></p><p>国家安全是民族复兴的根基，社会稳定是国家强盛的前提。必须坚定不移贯彻总体国家安全观，把维护国家安全贯穿党和国家工作各方面全过程，确保国家安全和社会稳定。</p><p>我们要坚持以人民安全为宗旨、以政治安全为根本、以经济安全为基础、以军事科技文化社会安全为保障、以促进国际安全为依托，统筹外部安全和内部安全、国土安全和国民安全、传统安全和非传统安全、自身安全和共同安全，统筹维护和塑造国家安全，夯实国家安全和社会稳定基层基础，完善参与全球安全治理机制，建设更高水平的平安中国，以新安全格局保障新发展格局。</p><p>我们要健全国家安全体系，完善高效权威的国家安全领导体制，完善国家安全法治体系、战略体系、政策体系、风险监测预警体系、国家应急管理体系，构建全域联动、立体高效的国家安全防护体系。增强维护国家安全能力，坚定维护国家政权安全、制度安全、意识形态安全，确保粮食、能源资源、重要产业链供应链安全，维护我国公民、法人在海外合法权益，筑牢国家安全人民防线。提高公共安全治理水平，坚持安全第一、预防为主，完善公共安全体系，提高防灾减灾救灾和急难险重突发公共事件处置保障能力，加强个人信息保护。完善社会治理体系，健全共建共治共享的社会治理制度，提升社会治理效能，畅通和规范群众诉求表达、利益协调、权益保障通道，建设人人有责、人人尽责、人人享有的社会治理共同体。</p><p><code>十二、实现建军一百年奋斗目标，开创国防和军队现代化新局面</code></p><p>如期实现建军一百年奋斗目标，加快把人民军队建成世界一流军队，是全面建设社会主义现代化国家的战略要求。必须贯彻新时代党的强军思想，贯彻新时代军事战略方针，坚持党对人民军队的绝对领导，坚持政治建军、改革强军、科技强军、人才强军、依法治军，加快军事理论现代化、军队组织形态现代化、军事人员现代化、武器装备现代化，提高捍卫国家主权、安全、发展利益战略能力，有效履行新时代人民军队使命任务。</p><p>全面加强人民军队党的建设，确保枪杆子永远听党指挥。健全贯彻军委主席负责制体制机制。建强人民军队党的组织体系，推进政治整训常态化制度化，持之以恒正风肃纪反腐。</p><p>我们要全面加强练兵备战，提高人民军队打赢能力，创新军事战略指导，发展人民战争战略战术，打造强大战略威慑力量体系，增加新域新质作战力量比重，深入推进实战化军事训练。全面加强军事治理，巩固拓展国防和军队改革成果，完善军事力量结构编成，体系优化军事政策制度，实施国防科技和武器装备重大工程，建强新型军事人才培养体系，加强依法治军机制建设和战略规划。巩固提高一体化国家战略体系和能力，加强国防科技工业能力建设，加强国防动员和后备力量建设，做好退役军人服务保障工作，巩固发展军政军民团结。</p><p><code>十三、坚持和完善&quot;一国两制&quot;，推进祖国统一</code></p><p>“一国两制”是中国特色社会主义的伟大创举，是香港、澳门回归后保持长期繁荣稳定的最佳制度安排，必须长期坚持。</p><p>全面准确、坚定不移贯彻”一国两制”、”港人治港”、”澳人治澳”、高度自治的方针，坚持依法治港治澳，落实中央全面管治权，落实”爱国者治港”、”爱国者治澳”原则，支持香港、澳门发展经济、改善民生、破解经济社会发展中的深层次矛盾和问题，促进香港、澳门长期繁荣稳定，支持香港、澳门更好融入国家发展大局，为实现中华民族伟大复兴更好发挥作用。</p><p>坚持贯彻新时代党解决台湾问题的总体方略，坚定不移推进祖国统一大业。我们始终尊重、关爱、造福台湾同胞，继续致力于促进两岸经济文化交流合作，推动两岸共同弘扬中华文化，促进两岸同胞心灵契合。解决台湾问题是中国人自己的事，要由中国人来决定。我们坚持以最大诚意、尽最大努力争取和平统一的前景，但决不承诺放弃使用武力，保留采取一切必要措施的选项，这针对的是外部势力干涉和极少数”台独”分裂分子及其分裂活动，绝非针对广大台湾同胞。国家统一、民族复兴的历史车轮滚滚向前，祖国完全统一一定要实现，也一定能够实现！</p><p><code>十四、促进世界和平与发展，推动构建人类命运共同体</code></p><p>当前，世界之变、时代之变、历史之变正以前所未有的方式展开，人类社会面临前所未有的挑战。世界又一次站在历史的十字路口，何去何从取决于各国人民的抉择。</p><p>中国始终坚持维护世界和平、促进共同发展的外交政策宗旨，致力于推动构建人类命运共同体。</p><p>中国坚定奉行独立自主的和平外交政策，始终根据事情本身的是非曲直决定自己的立场和政策，维护国际关系基本准则，维护国际公平正义，坚决反对一切形式的霸权主义和强权政治，反对冷战思维，反对干涉别国内政，反对搞双重标准。中国永远不称霸、永远不搞扩张。</p><p>中国坚持在和平共处五项原则基础上同各国发展友好合作，推动构建新型国际关系，深化拓展平等、开放、合作的全球伙伴关系，致力于扩大同各国利益的汇合点。秉持真实亲诚理念和正确义利观加强同发展中国家团结合作，维护发展中国家共同利益。</p><p>中国坚持对外开放的基本国策，坚定奉行互利共赢的开放战略，不断以中国新发展为世界提供新机遇，推动建设开放型世界经济，更好惠及各国人民。中国坚持经济全球化正确方向，共同营造有利于发展的国际环境，共同培育全球发展新动能。中国积极参与全球治理体系改革和建设，坚持真正的多边主义，推进国际关系民主化，推动全球治理朝着更加公正合理的方向发展。</p><p>中国提出了全球发展倡议、全球安全倡议，愿同国际社会一道努力落实。我们真诚呼吁，世界各国弘扬和平、发展、公平、正义、民主、自由的全人类共同价值，促进各国人民相知相亲，共同应对各种全球性挑战。中国人民愿同世界人民携手开创人类更加美好的未来！</p><p><code>十五、坚定不移全面从严治党，深入推进新时代党的建设新的伟大工程</code></p><p>全面建设社会主义现代化国家、全面推进中华民族伟大复兴，关键在党。我们党作为世界上最大的马克思主义执政党，要始终赢得人民拥护、巩固长期执政地位，必须时刻保持解决大党独有难题的清醒和坚定。全党必须牢记，全面从严治党永远在路上，党的自我革命永远在路上，决不能有松劲歇脚、疲劳厌战的情绪，必须持之以恒推进全面从严治党，深入推进新时代党的建设新的伟大工程，以党的自我革命引领社会革命。</p><p>我们要落实新时代党的建设总要求，健全全面从严治党体系，全面推进党的自我净化、自我完善、自我革新、自我提高，使我们党坚守初心使命，始终成为中国特色社会主义事业的坚强领导核心。</p><p>我们要坚持和加强党中央集中统一领导，健全总揽全局、协调各方的党的领导制度体系，完善党中央重大决策部署落实机制，确保全党在政治立场、政治方向、政治原则、政治道路上同党中央保持高度一致，确保党的团结统一。坚持不懈用新时代中国特色社会主义思想凝心铸魂，全面加强党的思想建设，加强理想信念教育，引导全党牢记党的宗旨，自觉做共产主义远大理想和中国特色社会主义共同理想的坚定信仰者和忠实实践者。完善党的自我革命制度规范体系，坚持制度治党、依规治党，健全党统一领导、全面覆盖、权威高效的监督体系，发挥政治巡视利剑作用，落实全面从严治党政治责任，用好问责利器。建设堪当民族复兴重任的高素质干部队伍，坚持德才兼备、以德为先、五湖四海、任人唯贤，树立选人用人正确导向，选拔忠诚干净担当的高素质专业化干部，选优配强各级领导班子，加强干部斗争精神和斗争本领养成，激励干部敢于担当、积极作为。增强党组织政治功能和组织功能，坚持大抓基层的鲜明导向，把基层党组织建设成为有效实现党的领导的坚强战斗堡垒，激励党员发挥先锋模范作用，保持党员队伍先进性和纯洁性。坚持以严的基调强化正风肃纪，锲而不舍落实中央八项规定精神，持续深化纠治”四风”，重点纠治形式主义、官僚主义，坚决破除特权思想和特权行为。坚决打赢反腐败斗争攻坚战持久战，腐败是危害党的生命力和战斗力的最大毒瘤，反腐败是最彻底的自我革命。只要存在腐败问题产生的土壤和条件，反腐败斗争就一刻不能停，必须永远吹冲锋号，坚持不敢腐、不能腐、不想腐一体推进，以零容忍态度反腐惩恶，决不姑息。</p><p>同志们！时代呼唤着我们，人民期待着我们，唯有矢志不渝、笃行不怠，方能不负时代、不负人民。全党必须牢记，坚持党的全面领导是坚持和发展中国特色社会主义的必由之路，中国特色社会主义是实现中华民族伟大复兴的必由之路，团结奋斗是中国人民创造历史伟业的必由之路，贯彻新发展理念是新时代我国发展壮大的必由之路，全面从严治党是党永葆生机活力、走好新的赶考之路的必由之路。这是我们在长期实践中得出的至关紧要的规律性认识，必须倍加珍惜、始终坚持，咬定青山不放松，引领和保障中国特色社会主义巍巍巨轮乘风破浪、行稳致远。</p><p>团结就是力量，团结才能胜利。全面建设社会主义现代化国家，必须充分发挥亿万人民的创造伟力。全党要坚持全心全意为人民服务的根本宗旨，树牢群众观点，贯彻群众路线，尊重人民首创精神，坚持一切为了人民、一切依靠人民，从群众中来、到群众中去，始终保持同人民群众的血肉联系，始终接受人民批评和监督，始终同人民同呼吸、共命运、心连心，不断巩固全国各族人民大团结，加强海内外中华儿女大团结，形成同心共圆中国梦的强大合力。</p><p>青年强，则国家强。当代中国青年生逢其时，施展才干的舞台无比广阔，实现梦想的前景无比光明。全党要把青年工作作为战略性工作来抓，用党的科学理论武装青年，用党的初心使命感召青年，做青年朋友的知心人、青年工作的热心人、青年群众的引路人。广大青年要坚定不移听党话、跟党走，怀抱梦想又脚踏实地，敢想敢为又善作善成，立志做有理想、敢担当、能吃苦、肯奋斗的新时代好青年，让青春在全面建设社会主义现代化国家的火热实践中绽放绚丽之花。</p><p>同志们！党用伟大奋斗创造了百年伟业，也一定能用新的伟大奋斗创造新的伟业。全党全军全国各族人民要紧密团结在党中央周围，牢记空谈误国、实干兴邦，坚定信心、同心同德，埋头苦干、奋勇前进，为全面建设社会主义现代化国家、全面推进中华民族伟大复兴而团结奋斗！</p><p>来源：新华网图文实录</p>]]></content>
      
      
      <categories>
          
          <category> 新闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时政 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot--自动配置原理</title>
      <link href="/2022/09/22/springboot-start-20220922/"/>
      <url>/2022/09/22/springboot-start-20220922/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>不论在工作中，亦或是求职面试，SpringBoot已经成为我们必知必会的技能项。除了某些老旧的政府项目或金融项目持有观望态度外，如今的各行各业都在飞速的拥抱这个已经不是很新的Spring启动框架。</p><p>当然，作为SpringBoot的精髓，自动配置原理的工作过程往往只有在”面试”的时候才能用得上，但是如果在工作中你能够深入的理解SpringBoot的自动配置原理，将无往不利。</p><p>SpringBoot的出现，得益于”习惯优于配置”的理念，没有繁琐的配置、难以集成的内容（大多数流行第三方技术都被集成），这是基于Spring4.x提供的按条件配置Bean的能力。</p><h2 id="Spring-Boot的配置文件"><a href="#Spring-Boot的配置文件" class="headerlink" title="Spring Boot的配置文件"></a>Spring Boot的配置文件</h2><p>初识Spring Boot时我们就知道，SpringBoot有一个全局配置文件：<code>application.properties</code>或<code>application.yml</code>。</p><p>我们的各种属性都可以在这个文件中进行配置，最常配置的比如：<code>server.port</code>、<code>logging.level.*</code> 等等，然而我们实际用到的往往只是很少的一部分，那么这些属性是否有据可依呢？答案当然是肯定的，这些属性都可以在官方文档中查找到：</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle//#common-application-properties">https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/\#common-application-properties</a></p></blockquote><p><img src="/2022/09/22/springboot-start-20220922/640(1).png" alt="图片"></p><p>（所以，话又说回来，找资料还得是官方文档，百度出来一大堆，还是稍显业余了一些）</p><p>除了官方文档为我们提供了大量的属性解释，我们也可以使用IDE的相关提示功能，比如IDEA的自动提示，和Eclipse的YEdit插件，都可以很好的对你需要配置的属性进行提示，下图是使用Eclipse的YEdit插件的效果，Eclipse的版本是：STS4。</p><p><img src="/2022/09/22/springboot-start-20220922/640(2).png" alt="图片"></p><p>以上，是Spring Boot的配置文件的大致使用方法，其实都是些题外话。</p><p>那么问题来了：<strong>这些配置是如何在SpringBoot项目中生效的呢？</strong> 那么接下来，就需要聚焦本篇博客的主题：自动配置工作原理或者叫实现方式。</p><h2 id="工作原理剖析"><a href="#工作原理剖析" class="headerlink" title="工作原理剖析"></a>工作原理剖析</h2><p>Spring Boot关于自动配置的源码在spring-boot-autoconfigure-x.x.x.x.jar中：</p><p><img src="/2022/09/22/springboot-start-20220922/640(3).png" alt="图片"></p><p>当然，自动配置原理的相关描述，官方文档貌似是没有提及。不过我们不难猜出，SpringBoot的启动类上有一个@SpringBootApplication注解，这个注解是SpringBoot项目必不可少的注解。那么自动配置原理一定和这个注解有着千丝万缕的联系！</p><h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><p><img src="/2022/09/22/springboot-start-20220922/640(4).png" alt="图片"></p><p>@SpringBootApplication是一个复合注解或派生注解，在@SpringBootApplication中有一个注解@EnableAutoConfiguration，翻译成人话就是开启自动配置，其定义如下：</p><p><img src="/2022/09/22/springboot-start-20220922/640(5).png" alt="图片"></p><p>而这个注解也是一个派生注解，其中的关键功能由@Import提供，其导入的AutoConfigurationImportSelector的selectImports()方法通过SpringFactoriesLoader.loadFactoryNames()扫描所有具有<strong>META-INF&#x2F;spring.factories</strong> 的jar包。<br>spring-boot-autoconfigure-x.x.x.x.jar里就有一个这样的spring.factories文件。<br>这个spring.factories文件也是一组一组的key&#x3D;value的形式，其中一个key是EnableAutoConfiguration类的全类名，而它的value是一个xxxxAutoConfiguration的类名的列表，这些类名以逗号分隔，如下图所示：</p><p><img src="/2022/09/22/springboot-start-20220922/640(6).png" alt="图片"></p><p>这个@EnableAutoConfiguration注解通过@SpringBootApplication被间接的标记在了SpringBoot的启动类上.在<code>&quot;SpringApplication.run(\...)&quot;</code>的内部就会执行selectImports()方法，找到所有JavaConfig自动配置类的全限定名对应的class，然后将所有自动配置类加载到Spring容器中。</p><h2 id="自动配置生效"><a href="#自动配置生效" class="headerlink" title="自动配置生效"></a>自动配置生效</h2><p>每一个XxxxAutoConfiguration自动配置类都是在某些条件之下才会生效的，这些条件的限制在Spring<br>Boot中以注解的形式体现，常见的条件注解有如下几项：</p><ul><li><p>@ConditionalOnBean：当容器里有指定的bean的条件下。</p></li><li><p>@ConditionalOnMissingBean：当容器里不存在指定bean的条件下。</p></li><li><p>@ConditionalOnClass：当类路径下有指定类的条件下。</p></li><li><p>@ConditionalOnMissingClass：当类路径下不存在指定类的条件下。</p></li><li><p>@ConditionalOnProperty：指定的属性是否有指定的值，比如@ConditionalOnProperties(prefix&#x3D;”xxx.xxx”,<br>value&#x3D;”enable”,<br>matchIfMissing&#x3D;true)，代表当xxx.xxx为enable时条件的布尔值为true，如果没有设置的情况下也为true。</p></li></ul><p>以ServletWebServerFactoryAutoConfiguration配置类为例，解释一下全局配置文件中的属性如何生效，比如：server.port&#x3D;8081，是如何生效的（当然不配置也会有默认值，这个默认值来自于org.apache.catalina.startup.Tomcat）。</p><p><img src="/2022/09/22/springboot-start-20220922/640(7).png" alt="图片"></p><p>在ServletWebServerFactoryAutoConfiguration类上，有一个@EnableConfigurationProperties注解：开启配置属性，而它后面的参数是一个ServerProperties类，这就是习惯优于配置的最终落地点。</p><p><img src="/2022/09/22/springboot-start-20220922/640(8).png" alt="图片"></p><p>在这个类上，我们看到了一个非常熟悉的注解：@ConfigurationProperties，它的作用就是从配置文件中绑定属性到对应的bean上，而@EnableConfigurationProperties负责导入这个已经绑定了属性的bean到spring容器中（见上面截图）。那么所有其他的和这个类相关的属性都可以在全局配置文件中定义，也就是说，真正”限制”我们可以在全局配置文件中配置哪些属性的类就是这些XxxxProperties类，它与配置文件中定义的prefix关键字开头的一组属性是唯一对应的。</p><p>至此，我们大致可以了解。在全局配置的属性如：server.port等，通过@ConfigurationProperties注解，绑定到对应的XxxxProperties配置实体类上封装为一个bean，然后再通过@EnableConfigurationProperties注解导入到Spring容器中。</p><p>而诸多的XxxxAutoConfiguration自动配置类，就是Spring容器的JavaConfig形式，作用就是为Spring<br>容器导入bean，而所有导入的bean所需要的属性都通过xxxxProperties的bean来获得。</p><p>可能到目前为止还是有所疑惑，但面试的时候，其实远远不需要回答的这么具体，你只需要这样回答：</p><blockquote><p>SpringBoot启动的时候会通过@EnableAutoConfiguration注解找到META-INF&#x2F;spring.factories配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性如：server.port，而XxxxProperties类是通过@ConfigurationProperties注解与全局配置文件中对应的属性进行绑定的。</p></blockquote><p>通过一张图标来理解一下这一繁复的流程：</p><p><img src="/2022/09/22/springboot-start-20220922/640(9).png" alt="图片"></p><p>图片来自于王福强老师的博客：<a href="https://afoo.me/posts/2015-07-09-how-spring-boot-works.html">https://afoo.me/posts/2015-07-09-how-spring-boot-works.html</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上是对自动配置原理的讲解。当然，在浏览源码的时候一定要记得不要太过拘泥与代码的实现，而是应该抓住重点脉络。</p><p>一定要记得XxxxProperties类的含义是：封装配置文件中相关属性；XxxxAutoConfiguration类的含义是：自动配置类，目的是给容器中添加组件。</p><p>而其他的主方法启动，则是为了加载这些五花八门的XxxxAutoConfiguration类。</p><p><em>来源：blog.csdn.net&#x2F;u014745069&#x2F;article&#x2F;details&#x2F;83820511</em></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学位英语--翻译001</title>
      <link href="/2022/09/21/learn-en-translate-20220921/"/>
      <url>/2022/09/21/learn-en-translate-20220921/</url>
      
        <content type="html"><![CDATA[<p>翻译题 </p><blockquote><p>34(2分) Four score and seven years ago our fathers brought forth on this continent a new nation</p></blockquote><p>A、87年前，我们的父亲们在这块大陆上创建了一个新的国家</p><p>B、87年前，我们的先辈在这块大陆上创建了一个新的国家</p><p>C、在历经4个20年和1个7年之后，我们的父亲们在这块大陆上创建了一个新的国家</p><p>参考答案： A：70%； B：100%； C：30%；</p><p>解析：</p><p>英语中的计量词，如score, dozen,decade等在汉语中没有相应的表达方式，应加以转换。B译文将”Four score and seven years”转换为”87年前”，符合汉语的表达习惯。A译文中对于”our fathers”翻译不够精确，此处应指”先辈，前辈”之意。C译文除了以上的错误，对于计量词的翻译也不够恰当。</p><blockquote><p>35(2分) It was William who defended him against a tyrant at the school where they were</p></blockquote><p>A、 他们学校里有一个恶霸欺负他，幸而有威廉的保护着才没有吃亏</p><p>B、 正是有了威廉的保护才使他免受他们学校里的一个小恶霸的欺负</p><p>C、 基于威廉的保护，他才避免受学校本来存在的恶棍的欺负</p><p>参考答案： A：70%； B：100%； C：30%；</p><p>解析：</p><p>It is …who…引导的是个强调句型。tyrant意思是”专制统治者，暴君；（古希腊的）僭主；专横的人”，这里指”专横的人，恶霸”。比较来看，选项B译意准确，表达自然。选项A只是将原句的基本意思译出了，没有译出强调句型的特点。选项C的译意出入较大。综合考虑：答案从优到劣的排序为B-A-C。</p><blockquote><p>36(2分) Pressure in liquids become rapidly greater with increasing depth as any one knows who has swum even a few feet below the surface of a lake</p></blockquote><p>A、 谁都知道，入液越深，液压就迅速增强，凡是在湖面以下几英尺游过泳的人都知道这一点</p><p>B、 入液越深，液压就迅速增强；凡是在湖面以下几英尺游过泳的人都知道这一点</p><p>C、 越往下潜，液体的压力就迅速增强，湖面以下游上一游的人都知道这一点</p><p>参考答案： A：70%； B：100%； C：30%；</p><p>解析：</p><p>句中的as是代词，意思是”这一点”。如As is well known, 众所周知。who 引导的是定语从句，修饰any one。比较来看，选项B为首选，翻译准确到位。选项A多了个”谁都知道”。选项C后半句的译意与原句不符。综合考虑：答案从优到劣的排序为B-A-C。</p><blockquote><p>37(2分) We cannot ignore our neighbors; only at our peril can we ignore their distress</p></blockquote><p> A、 我们不能不顾忌我们的邻国；只有在我们处于自身难保的时候才顾不了它们的安危</p><p> B、 我们不能不顾及我们的邻邦；我们如果不顾忌它们的安危，就只能陷入自身难保的境地</p><p> C、 我们不能忽视我们的邻居；只有我们自己在自身难保的时候才能忽视他们的安危</p><p>参考答案： A：70%； B：100%； C：30%；</p><p>解析：</p><p>原文后半句意思为”If we ignore their distress, then we will be only at our peril.”B译文意思准确。A译文后半句处理不当，颠倒了逻辑关系。 C译文不仅颠倒了逻辑关系，将”neighbors”译为”邻居”也是不准确的。</p><blockquote><p>38(2分) If they get the feeling you really care，they&#39;ll respond to that.They&#39;ll actually become reluctant not to buy from you</p></blockquote><p>A、 如果顾客觉得你很关心他们，他们便会作出反应，就不会不愿意从你手上买鞋</p><p>B、 假如顾客感觉到你确实关心他们，他们就不会无动于衷，就不会不买你的鞋而一走了之</p><p>C、 如果顾客有你真的关心他们的感觉，他们对此将会反应出来。实际上，他们将从你那里买鞋的</p><p>参考答案： A：70%； B：100%； C：30%；</p><blockquote><p>39(2分) My maternal grandfather was cut off in the flower of his youth</p></blockquote><p>A、 我的外祖父割掉了他的年轻的花朵</p><p>B、 我的外祖父年轻的时候就如花一样凋谢了</p><p>C、 我外祖父在风华正茂的年龄就去世了</p><p>参考答案： A：30%； B：70%； C：100%；</p><blockquote><p>40(2分) The university students in Britain are usually under pressure because their academic performance will affect their future careers</p></blockquote><p>A、 英国大学生通常压力较大，因为他们的学业成绩将会影响到未来的职业</p><p>B、 大学里的英国学生通常压力较大，因为他们在学术上的表现对未来将要从事的职业会有影响</p><p>C、 英国大学生通常课业负担较重，因为他们的学业成绩对未来的职业生涯会有影响</p><p>参考答案： A：100%； B：30%； C：70%；</p><p>解析：</p><p>A译文忠于原文，用词简洁。 C译文前半句将”under pressure”增译为”课业负担较重”，不够忠实原文，且译文不够简练。B译文用词拖沓，稍显啰嗦，且前半句不够通顺。</p><blockquote><p>41(2分) The inside of each tent depended on the personality of its occupant</p></blockquote><p>A、 每个帐篷的内部取决于各个使用者的性格</p><p>B、 每个帐篷内部怎么布置，这就要看各个使用者的性格了</p><p>C、 每个帐篷的里面依赖于每个使用者的个性</p><p>参考答案： A：70%； B：100%； C：30%；</p><p>解析：</p><p>为了让句子通顺，有时会采用单词分译的方法，将一个单词译成一个句子。原文中名词”inside”若仅译为”内部”，则会产生歧义。译成”内部怎么布置”，句意一目了然，因此B译文最佳。A译文次之。其次，C译文将”depend on”译为依”依赖”，不符合语境。</p><blockquote><p>42(2分) If the United States betrays the millions of people who have relied on us in Vietnam，the President of the United States，whoever he is，will not deserve nor receive the respect…</p></blockquote><p>A、 如果美国背叛了信赖我们的千百万越南人民，那么，不论谁担任美国总统，都无权享受尊敬，也得不到尊敬…</p><p>B、 如果美国背叛数百万在越南信任我们的人们，那么，不管谁是美国总统，都不值得也得不到尊敬…</p><p>C、 如果美国背叛了千百万在越南问题上信赖我们的人，那么，不论谁当美国总统，他都不值得尊敬，也得不到尊敬 …</p><p>参考答案： A：70%； B：30%； C：100%；</p><p>解析：</p><p>rely on意思是：”信赖; 依赖; 依靠; 信任”； who引导的是定语从句; whoever 引导的是让步状语从句。选择的焦点主要集中在if从句所表达的意思。比较来看，选项C为首选。综合考虑：答案从优到劣的排序为C-A-B。</p><blockquote><p>43(2分) The oxygen atom is nearly 16 times as heavy as hydrogen atom</p></blockquote><p>A、 氧原子的重量几乎是氢原子的16倍</p><p>B、 氧原子重量的16倍和氢原子的重量差不多</p><p>C、 一个氧原子的重量和16个氢原子的重量一样</p><p>参考答案： A：100%； B：30%； C：70%；</p><p>解析：</p><p>“倍数+as…as”译为”是…的几倍”或者”几倍于…”。 A 译文倍数翻译准确，译文简练。C译文倍数解释正确，但语句啰嗦，且”nearly”（几乎）不等于”一样”。B译文倍数关系错误。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty系列--进击的NIO！Reactor模式！</title>
      <link href="/2022/09/19/netty-nio-002/"/>
      <url>/2022/09/19/netty-nio-002/</url>
      
        <content type="html"><![CDATA[<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="/2022/09/19/netty-nio-002/640" alt="640"></p><h1 id="一、Reactor模式介绍"><a href="#一、Reactor模式介绍" class="headerlink" title="一、Reactor模式介绍"></a>一、Reactor模式介绍</h1><p>本文主要参考Doug Lea(大神)的《<strong>Scalable IO in Java</strong>》中讲述的Reactor模式。</p><p>原文地址：<a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p><p>有兴趣的可以看看这本书，受益匪浅！</p><h2 id="1-1-什么是Reactor模式"><a href="#1-1-什么是Reactor模式" class="headerlink" title="1.1 什么是Reactor模式"></a>1.1 什么是Reactor模式</h2><p>Reactor模式一般翻译成&quot;<strong>反应器模式</strong>&quot;，也有人称为&quot;<strong>分发者模式</strong>&quot;。它是将客户端请求提交到一个或者多个服务处理程序的设计模式。工作原理是由<strong>一个线程来接收所有的请求</strong>，然后<strong>派发这些请求到相关的工作线程中</strong>。</p><h2 id="1-2-为什么使用Reactor模式"><a href="#1-2-为什么使用Reactor模式" class="headerlink" title="1.2 为什么使用Reactor模式"></a>1.2 为什么使用Reactor模式</h2><p>在java中，没有NIO出现之前都是使用socket编程。socket的接收请求是阻塞的，需要处理完一个请求才能处理下一个请求，所以在面对高并发的服务请求时，性能就会很差。</p><p>那有人就会说使用多线程（如下图所示）。接收到一个请求，就创建一个线程处理，这样就不会阻塞了。实际上这样的确是可以在提升性能上起到一定的作用，<strong>但是当请求很多的时候，就会创建大量的线程，维护线程需要资源的消耗，线程之间的切换也需要消耗性能</strong>。而且系统创建线程的数量也是有限的，所以当高并发时，会直接把系统拖垮。</p><p><img src="/2022/09/19/netty-nio-002/640(1)" alt="640(1)"></p><p>由于以上的问题，提出了Reactor模式。</p><p>基于Java，Doug Lea（Java并发包作者）提出了三种形式，<strong>单Reactor单线程，单Reactor多线程和多Reactor多线程</strong>。</p><h1 id="二、Reactor模式的演进过程"><a href="#二、Reactor模式的演进过程" class="headerlink" title="二、Reactor模式的演进过程"></a>二、Reactor模式的演进过程</h1><p>在介绍三种Reactor模式前，先简单地说明三个角色：</p><blockquote><p><code>Reactor</code>：负责响应事件，将事件分发到绑定了对应事件的Handler，如果是连接事件，则分发到Acceptor。<code>Handler</code>：事件处理器。负责执行对应事件对应的业务逻辑。<code>Acceptor</code>：绑定了connect 事件，当客户端发起connect请求时，Reactor会将accept事件分发给Acceptor处理。</p></blockquote><h2 id="2-1-单Reactor单线程"><a href="#2-1-单Reactor单线程" class="headerlink" title="2.1 单Reactor单线程"></a>2.1 单Reactor单线程</h2><p><img src="/2022/09/19/netty-nio-002/640(2)" alt="640(2)"></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p>只有一个<code>select</code>循环接收请求，客户端（client）注册进来由<code>Reactor</code>接收注册事件，然后再由reactor分发（dispatch）出去，由下面的处理器（Handler）去处理。</p></blockquote><h3 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>一个餐厅里只有一个既是前台也是服务员的人，负责接待客人，也负责把客人点的菜下达给厨师。</p><h3 id="单Reactor单线程的特点"><a href="#单Reactor单线程的特点" class="headerlink" title="单Reactor单线程的特点"></a>单Reactor单线程的特点</h3><p>单线程的问题实际上是很明显的。只要其中一个Handler方法阻塞了，那就会导致所有的client的Handler都被阻塞了，也会导致注册事件也无法处理，无法接收新的请求。所以这种模式用的比较少，因为不能充分利用到多核的资源。</p><p>这种模式仅仅只能处理Handler比较快速完成的场景。</p><h2 id="2-2-单Reactor多线程"><a href="#2-2-单Reactor多线程" class="headerlink" title="2.2 单Reactor多线程"></a>2.2 单Reactor多线程</h2><p><img src="/2022/09/19/netty-nio-002/640(3)" alt="640(3)"></p><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p>在<strong>多线程Reactor</strong>中，注册接收事件都是由<code>Reactor</code>来做，其它的计算，编解码由一个线程池来做。从图中可以看出工作线程是多线程的，监听注册事件的<code>Reactor</code>还是单线程。</p></blockquote><h3 id="通俗解释-1"><a href="#通俗解释-1" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>相当于餐厅里有一个前台，多个服务员。前台只负责接待客人，服务员只负责服务客人。</p><h3 id="单Reactor多线程的特点"><a href="#单Reactor多线程的特点" class="headerlink" title="单Reactor多线程的特点"></a>单Reactor多线程的特点</h3><p>对比<strong>单线程Reactor</strong>模型，多线程Reactor模式在Handler读写处理时，交给工作线程池处理，不会导致Reactor无法执行，因为Reactor分发和Handler处理是分开的，能充分地利用资源。从而提升应用的性能。</p><p>缺点：Reactor只在主线程中运行，承担所有事件的监听和响应，如果短时间的高并发场景下，依然会造成性能瓶颈。</p><h2 id="2-3-多Reactor多线程"><a href="#2-3-多Reactor多线程" class="headerlink" title="2.3 多Reactor多线程"></a>2.3 多Reactor多线程</h2><p><img src="/2022/09/19/netty-nio-002/640(4)" alt="640(4)"></p><h3 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p>1、mainReactor负责监听客户端请求，专门处理新连接的建立，将建立好的连接注册到subReactor。</p></blockquote><blockquote><p>2、subReactor将分配的连接加入到队列进行监听，当有新的事件发生时，会调用连接相对应的Handler进行处理。</p></blockquote><h3 id="通俗解释-2"><a href="#通俗解释-2" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>相当于餐厅里有多个前台和多个服务员，前台只负责接待客人，服务员只负责服务客人。</p><h3 id="多Reactor多线程的特点"><a href="#多Reactor多线程的特点" class="headerlink" title="多Reactor多线程的特点"></a>多Reactor多线程的特点</h3><p>mainReactor主要是用来处理客户端请求连接建立的操作。subReactor主要做和建立起来的连接做数据交互和事件业务处理操作，每个subReactor一个线程来处理。</p><blockquote><p>这样的模型使得每个模块更加专一，耦合度更低，能支持更高的并发量。许多框架也使用这种模式，比如接下来要讲的Netty框架就采用了这种模式。</p></blockquote><h1 id="三、在Netty中的应用"><a href="#三、在Netty中的应用" class="headerlink" title="三、在Netty中的应用"></a>三、在Netty中的应用</h1><p>Netty可谓是框架中精品中的极品，要用一张图或者一段话来总结概括不太可能，所以下面我仅分析一下Netty框架的架构模型。在下一篇文章再继续深入探究Netty。</p><p><img src="/2022/09/19/netty-nio-002/640(5)" alt="640(5)"></p><p>这个架构实际上跟多Reactor多线程模型比较像。</p><blockquote><p>1、BossGroup相当于mainReactor，负责建立连接并且把连接注册到WorkGroup中。WorkGroup负责处理连接对应的读写事件。</p><p>2、BossGroup和WorkGroup是两个线程池，里面有多个NioEventGroup(实际上是线程)，默认BossGroup和WorkGroup里的线程数是cpu核数的两倍（源码中有体现）。</p><p>3、每一个NioEventGroup都是一个无限循环，负责监听相对应的事件。4、Pipeline(通道)里包含多个ChannelHandler(业务处理)，按顺序执行。</p></blockquote><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>其实上面的这些模型都只是一种思想，很多人可能觉得学习思想不是很重要。实际上要学习一门技术，要先有天上飞的理论才有落地的产品。世界上的事物大多都是如此。</p><p>最后借用大神<strong>Doug Lea</strong>的名言：</p><blockquote><p>分享知识和分享苹果是不一样的，苹果会越分越少，而自己的知识并不会因为给了别人就减少了，知识的分享更能激荡出不一样的火花。</p></blockquote><hr><p><strong>免责声明：</strong></p><p>本公博客部分分享的资料来自网络收集和整理，所有文字和图片版权归属于原作者所有，且仅代表作者个人观点，与<strong>本博客</strong>无关，文章仅供读者学习交流使用，并请自行核实相关内容，如文章内容涉及侵权，请联系后台管理员删除。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学位英语--完型填空001</title>
      <link href="/2022/09/16/learn-en-cf-20220916/"/>
      <url>/2022/09/16/learn-en-cf-20220916/</url>
      
        <content type="html"><![CDATA[<p>  When I first went to Hong Kong a number of years ago，I had no idea about the Chinese language  <u> <code>1</code></u> the Chinese culture.Shortly after my arrival，I went to the bank on my way to school.I was  <u> <code>2</code></u>  surprised when the bank clerk asked me  <u> <code>3</code></u>  I had had my lunch .In British culture，this question would be regarded as an indirect invitation to lunch，and between unmarried young people it indicates a young man’s interest in dating a girl.  <u> <code>4</code></u>  he was a complete stranger，I was quite taken aback.1 proceeded to school and was even more surprised when one of the teachers asked me the  <u> <code>5</code></u>  question .By now I realized that it could not be an  <u> <code>6</code></u>  ，but I was puzzled as to why they kept asking it .In the following days， as I was asked the question again and again，I came to the conclusion  <u> <code>7</code></u>  people must be concerned about my health.I was somewhat underweight，and I assumed they must be worried that I was not eating properly.Only later， did I find out that the question had   <u> <code>8</code></u>  real significance at all，it was merely a greeting.</p><p>   English people have a very strong sense of privacy.They are easily offended by comments which seem to invade their personal lives，so the Chinese greeting“Where are you going?”is uncomfortable to them.They regard it as a request for information and  <u> <code>9</code></u>   an invasion of their privacy .In fact，many foreign teachers in China have complained that their room attendants are spies  <u> <code>10</code></u>  the attendants have greeted them with“Where are you going? ”</p><p>1)、(单选题)</p><p>A、and     </p><p>B、than</p><p>C、otherwise</p><p>D、or</p><p>2)、(单选题)</p><p>A、slowly</p><p>B、extremely</p><p>C、quietly</p><p>D、suddenly</p><p>3)、(单选题)</p><p>A、what </p><p>B、where</p><p>C、when</p><p>D、if</p><p>4)、(单选题)</p><p>A、Since        </p><p>B、Although </p><p>C、Even</p><p>D、Though </p><p>5)、(单选题)</p><p>A、easy         </p><p>B、different</p><p>C、same</p><p>D、complex</p><p>6)、(单选题)</p><p>A、question     </p><p>B、invitation  </p><p>C、concern </p><p>D、invasion </p><p>7)、(单选题)</p><p>A、that  </p><p>B、which</p><p>C、when</p><p>D、whether</p><p>8)、(单选题)</p><p>A、little   </p><p>B、some</p><p>C、any</p><p>D、no</p><p>9)、(单选题)</p><p>A、in        </p><p>B、to</p><p>C、as</p><p>D、for</p><p>10)、(单选题)</p><p>A、because       </p><p>B、when</p><p>C、though</p><p>D、some people</p><p><code>参考答案：</code></p><blockquote><ol><li>D； 2) B； 3) D； 4) A； 5) C； 6) B； 7) A； 8) D； 9) C； 10) A；</li></ol></blockquote><p><code>解析：</code></p><ul><li><p>1.D  这里表达的是并列关系，否定句，故选or。</p></li><li><p>2.B  此处是表示非常惊讶。</p></li><li><p>3.D  这里根据文意，应选择表示“是否”之意的if作宾语从句的引导词。</p></li><li><p>4.A  根据上文语境，这里对上述现象进行解释说明。</p></li><li><p>5.C  此处作者想表达的是当被问及同样问题时，更加惊讶，故选same。</p></li><li><p>6.B  根据上文语境判断，选invitation，邀请，招待。</p></li><li><p>7.A  “that ” 引导同位语从句。</p></li><li><p>8.D  “not&#x2F; no…at all”为固定短语，意为“一点也没有”。</p></li><li><p>9.C  “regard … as”，固定搭配“把……看作”。</p></li><li><p>10.A  这里说明原因,故选A.because。</p></li></ul><p><code>原文</code></p><p>When I first went to Hong Kong a number of years ago，I had no idea about the Chinese language or the Chinese culture.Shortly after my arrival，I went to the bank on my way to school.I was extremely surprised when the bank clerk asked me if I had had my lunch.In British culture，this question would be regarded as an indirect invitation to lunch，and between unmarried young people it indicates a young man’s interest in dating a girl. Since he was a complete stranger，I was quite taken aback.1 proceeded to school and was even more surprised when one of the teachers asked me the same question.By now I realized that it could not be an invitation ，but I was puzzled as to why they kept asking it.In the following days， as I was asked the question again and again，I came to the conclusion that people must be concerned about my health.I was somewhat underweight，and I assumed they must be worried that I was not eating properly.Only later， did I find out that the question had no real significance at all，it was merely a greeting.</p><p>English people have a very strong sense of privacy.They are easily offended by comments which seem to invade their personal lives，so the Chinese greeting“Where are you going?”is uncomfortable to them.They regard it as a request for information and as an invasion of their privacy.In fact，many foreign teachers in China have complained that their room attendants are spies because the attendants have greeted them with“Where are you going? ”</p><p><code>翻译;</code></p><p>几年前我第一次去香港的时候，我对中国语言和中国文化一无所知。到达后不久，我在上学的路上去了银行。当银行职员问我是否吃过午饭时，我非常惊讶。在英国文化中，这个问题会被视为是对午餐的间接邀请，在未婚年轻人之间，它表明年轻人对约会女孩的兴趣。由于他是一个完全陌生的人，我大吃一惊。我继续上学，当一位老师问我同样的问题时，我更加惊讶。现在我意识到这不可能是一个邀请，但我不明白为什么他们一直问我。在接下来的几天里，当我一次又一次被问到这个问题时，我得出结论，人们必须关心我的健康。我有点体重不足，我想他们一定担心我吃得不好。直到后来，我才发现这个问题根本没有真正的意义，只是一个问候而已。<br>英国人有很强的隐私意识。他们很容易被那些似乎侵犯了他们个人生活的评论所冒犯，所以中国人的问候语“你要去哪里？”对他们来说是不舒服的。他们认为这是对信息的请求，是对他们隐私的侵犯。事实上，许多在中国的外籍教师抱怨说，他们的客房服务员是间谍，因为服务员用“你要去哪里？”</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty系列--NIO从入门到踹门</title>
      <link href="/2022/09/15/netty-nio-001/"/>
      <url>/2022/09/15/netty-nio-001/</url>
      
        <content type="html"><![CDATA[<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="/2022/09/15/netty-nio-001/640" alt="640"></p><blockquote><p>学如逆水行舟，不进则退</p></blockquote><h1 id="NIO概述"><a href="#NIO概述" class="headerlink" title="NIO概述"></a>NIO概述</h1><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong>java.nio</strong>全称<strong>java non-blocking IO</strong>，是指<strong>JDK1.4及以上</strong>版本里提供的新api（New IO），为所有的原始类型（boolean类型除外）提供<strong>缓存支持的数据容器</strong>，使用它可以提供<strong>非阻塞式</strong>的高伸缩性网络(来源于百度百科)。</p><h3 id="1-2-为什么使用NIO"><a href="#1-2-为什么使用NIO" class="headerlink" title="1.2 为什么使用NIO"></a>1.2 为什么使用NIO</h3><p>在上面的描述中提到，是在JDK1.4以上的版本才提供NIO，那在之前使用的是什么呢？答案很简单，就是<strong>BIO</strong>(阻塞式IO)，也就是我们常用的IO流。</p><p>BIO的问题其实不用多说了，因为在使用BIO时，主线程会进入阻塞状态，这就非常影响程序的性能，<strong>不能充分利用机器资源</strong>。但是这样就会有人提出疑问了，那我<strong>使用多线程</strong>不就可以了吗？</p><p>但是在高并发的情况下，会创建很多线程，线程会占用内存，线程之间的切换也会浪费资源开销。</p><p>而NIO<strong>只有在连接&#x2F;通道真正有读写事件</strong>发生时(<strong>事件驱动</strong>)，<strong>才会进行读写</strong>，就大大地减少了系统的开销。不必为每一个连接都创建一个线程，也不必去维护多个线程。</p><p><strong>避免了多个线程之间的上下文切换</strong>，导致资源的浪费。</p><h3 id="2-NIO的三大核心"><a href="#2-NIO的三大核心" class="headerlink" title="2 NIO的三大核心"></a>2 NIO的三大核心</h3><table><thead><tr><th>NIO的核心</th><th>对应的类或接口</th><th>应用</th><th>作用</th></tr></thead><tbody><tr><td>缓冲区</td><td>Buffer</td><td>文件IO&#x2F;网络IO</td><td>存储数据</td></tr><tr><td>通道</td><td>Channel</td><td>文件IO&#x2F;网络IO</td><td>运输</td></tr><tr><td>选择器</td><td>Selector</td><td>网络IO</td><td>控制器</td></tr></tbody></table><h3 id="2-1-1-什么是缓冲区"><a href="#2-1-1-什么是缓冲区" class="headerlink" title="2.1.1 什么是缓冲区"></a>2.1.1 什么是缓冲区</h3><p>我们先看以下这张类图，可以看到<code>Buffer</code>有七种类型。</p><p><img src="/2022/09/15/netty-nio-001/640(1)" alt="640(1)"></p><p><code>Buffer</code>是一个内存块。在<code>NIO</code>中，所有的数据都是用<code>Buffer</code>处理，有读写两种模式。所以NIO和传统的IO的区别就体现在这里。传统IO是面向<code>Stream</code>流，<code>NIO</code>而是面向缓冲区(<code>Buffer</code>)。</p><h3 id="2-1-2-常用的类型ByteBuffer"><a href="#2-1-2-常用的类型ByteBuffer" class="headerlink" title="2.1.2 常用的类型ByteBuffer"></a>2.1.2 常用的类型ByteBuffer</h3><p>一般我们常用的类型是<code>ByteBuffer</code>，把数据转成字节进行处理。实质上是一个<code>byte[]</code>数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ByteBuffer</span> <span class="keyword">extends</span> <span class="title class_">Buffer</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;ByteBuffer&gt;&#123;</span><br><span class="line">    <span class="comment">//存储数据的数组</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">byte</span>[] hb;</span><br><span class="line">    <span class="comment">//构造器方法</span></span><br><span class="line">    ByteBuffer(<span class="type">int</span> mark, <span class="type">int</span> pos, <span class="type">int</span> lim, <span class="type">int</span> cap, <span class="type">byte</span>[] hb, <span class="type">int</span> offset) &#123;</span><br><span class="line">        <span class="built_in">super</span>(mark, pos, lim, cap);</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="built_in">this</span>.hb = hb;</span><br><span class="line">        <span class="built_in">this</span>.offset = offset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-3-创建Buffer的方式"><a href="#2-1-3-创建Buffer的方式" class="headerlink" title="2.1.3 创建Buffer的方式"></a>2.1.3 创建Buffer的方式</h3><p>主要分成两种：JVM堆内内存块Buffer、堆外内存块Buffer。</p><p>创建堆内内存块(非直接缓冲区)的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建堆内内存块HeapByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;java技术爱好者&quot;</span>;</span><br><span class="line"><span class="comment">//包装一个byte[]数组获得一个Buffer，实际类型是HeapByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer2</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br></pre></td></tr></table></figure><p>创建堆外内存块(直接缓冲区)的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建堆外内存块DirectByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer3</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><h3 id="2-1-3-1"><a href="#2-1-3-1" class="headerlink" title="2.1.3.1"></a>2.1.3.1</h3><h3 id="HeapByteBuffer与DirectByteBuffer"><a href="#HeapByteBuffer与DirectByteBuffer" class="headerlink" title="HeapByteBuffer与DirectByteBuffer"></a>HeapByteBuffer与DirectByteBuffer</h3><p>其实根据类名就可以看出，<code>HeapByteBuffer</code>所创建的字节缓冲区就是在JVM堆中的，即JVM内部所维护的字节数组。而<code>DirectByteBuffer</code>是<strong>直接操作操作系统本地代码</strong>创建的<strong>内存缓冲数组</strong>。</p><p><code>DirectByteBuffer</code>的使用场景：</p><ol><li><p>java程序与本地磁盘、socket传输数据</p></li><li><p>大文件对象，可以使用。不会受到堆内存大小的限制。</p></li><li><p>不需要频繁创建，生命周期较长的情况，能重复使用的情况。</p></li></ol><p><code>HeapByteBuffer</code>的使用场景：</p><p>除了以上的场景外，其他情况还是建议使用<code>HeapByteBuffer</code>，没有达到一定的量级，实际上使用<code>DirectByteBuffer</code>是体现不出优势的。</p><h3 id="2-1-3-2-Buffer的初体验"><a href="#2-1-3-2-Buffer的初体验" class="headerlink" title="2.1.3.2 Buffer的初体验"></a>2.1.3.2 Buffer的初体验</h3><p>接下来，使用<code>ByteBuffer</code>做一个小例子，熟悉一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;java技术爱好者，起飞！&quot;</span>;</span><br><span class="line">            <span class="comment">//创建一个固定大小的buffer(返回的是HeapByteBuffer)</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">byte</span>[] bytes = msg.getBytes();</span><br><span class="line">            <span class="comment">//写入数据到Buffer中</span></span><br><span class="line">            byteBuffer.put(bytes);</span><br><span class="line">            <span class="comment">//切换成读模式，关键一步</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="comment">//创建一个临时数组，用于存储获取到的数据</span></span><br><span class="line">            <span class="type">byte</span>[] tempByte = <span class="keyword">new</span> <span class="title class_">byte</span>[bytes.length];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//如果还有数据，就循环。循环判断条件</span></span><br><span class="line">            <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">//获取byteBuffer中的数据</span></span><br><span class="line">                <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> byteBuffer.get();</span><br><span class="line">                <span class="comment">//放到临时数组中</span></span><br><span class="line">                tempByte[i] = b;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印结果</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(tempByte));<span class="comment">//java技术爱好者，起飞！</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这上面有一个<code>flip()</code>方法是很重要的。意思是切换到读模式。上面已经提到<strong>缓存区是双向的</strong>，<strong>既可以往缓冲区写入数据，也可以从缓冲区读取数据</strong>。但是不能同时进行，需要切换。那么这个切换模式的本质是什么呢？</p><h3 id="2-1-4-三个重要参数"><a href="#2-1-4-三个重要参数" class="headerlink" title="2.1.4 三个重要参数"></a>2.1.4 三个重要参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//位置，默认是从第一个开始</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//限制，不能读取或者写入的位置索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line"><span class="comment">//容量，缓冲区所包含的元素的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> capacity;</span><br></pre></td></tr></table></figure><p>那么我们以上面的例子，一句一句代码进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;java技术爱好者，起飞！&quot;</span>;</span><br><span class="line"><span class="comment">//创建一个固定大小的buffer(返回的是HeapByteBuffer)</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>当创建一个缓冲区时，参数的值是这样的：</p><p><img src="/2022/09/15/netty-nio-001/640(2)" alt="640(2)"></p><p><img src="/2022/09/15/netty-nio-001/640(3)" alt="640(3)"></p><p>当执行到<code>byteBuffer.put(bytes)</code>，当<code>put()</code>进入多少数据，position就会增加多少，参数就会发生变化：</p><p><img src="/2022/09/15/netty-nio-001/640(4)" alt="640(4)"></p><p><img src="/2022/09/15/netty-nio-001/640(5)" alt="640(5)"></p><p>接下来关键一步<code>byteBuffer.flip()</code>，会发生如下变化：</p><p><img src="/2022/09/15/netty-nio-001/640(6)" alt="640(6)"></p><p><img src="/2022/09/15/netty-nio-001/640(7)" alt="640(7)"></p><p><code>flip()</code>方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">            limit = position;</span><br><span class="line">            position = <span class="number">0</span>;</span><br><span class="line">            mark = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>为什么要这样赋值呢？因为下面有一句循环条件判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byteBuffer.hasRemaining();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasRemaining</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//判断position的索引是否小于limit。</span></span><br><span class="line">    <span class="comment">//所以可以看出limit的作用就是记录写入数据的位置，那么当读取数据时，就知道读到哪个位置</span></span><br><span class="line">    <span class="keyword">return</span> position &lt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是在<code>while</code>循环中<code>get()</code>读取数据，读取完之后。</p><p><img src="/2022/09/15/netty-nio-001/640(8)" alt="640(8)"></p><p><img src="/2022/09/15/netty-nio-001/640(9)" alt="640(9)"></p><p>最后当<code>position</code>等于<code>limit</code>时，循环判断条件不成立，就跳出循环，读取完毕。</p><p>所以可以看出实质上<code>capacity</code>容量大小是不变的，实际上是通过控制<code>position</code>和<code>limit</code>的值来控制读写的数据。</p><h3 id="2-2-管道-Channel"><a href="#2-2-管道-Channel" class="headerlink" title="2.2 管道(Channel)"></a>2.2 管道(Channel)</h3><p>首先我们看一下Channel有哪些子类：</p><p><img src="/2022/09/15/netty-nio-001/640(10)" alt="640(10)"></p><p>常用的Channel有这四种：</p><blockquote><p>FileChannel，读写文件中的数据。<br>SocketChannel，通过TCP读写网络中的数据。<br>ServerSockectChannel，监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。<br>DatagramChannel，通过UDP读写网络中的数据。</p></blockquote><p><strong>Channel本身并不存储数据，只是负责数据的运输</strong>。必须要和<code>Buffer</code>一起使用。</p><h3 id="2-2-1-1-FileChannel"><a href="#2-2-1-1-FileChannel" class="headerlink" title="2.2.1.1 FileChannel"></a>2.2.1.1 FileChannel</h3><p>FileChannel的获取方式，下面举个文件复制拷贝的例子进行说明：</p><p><img src="/2022/09/15/netty-nio-001/640(11)" alt="640(11)"></p><p>首先准备一个&quot;1.txt&quot;放在项目的根目录下，然后编写一个main方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//获取文件输入流</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="comment">//从文件输入流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">inputStreamChannel</span> <span class="operator">=</span> inputStream.getChannel();</span><br><span class="line">            <span class="comment">//获取文件输出流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;2.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//从文件输出流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">outputStreamChannel</span> <span class="operator">=</span> outputStream.getChannel();</span><br><span class="line">            <span class="comment">//创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>)file.length());</span><br><span class="line">            <span class="comment">//把输入流通道的数据读取到缓冲区</span></span><br><span class="line">            inputStreamChannel.read(byteBuffer);</span><br><span class="line">            <span class="comment">//切换成读模式</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="comment">//把数据从缓冲区写入到输出流通道</span></span><br><span class="line">            outputStreamChannel.write(byteBuffer);</span><br><span class="line">            <span class="comment">//关闭通道</span></span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            outputStreamChannel.close();</span><br><span class="line">            inputStreamChannel.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>执行后，我们就获得一个&quot;2.txt&quot;。执行成功。</p><p><img src="/2022/09/15/netty-nio-001/640(12)" alt="640(12)"></p><p>以上的例子，可以用一张示意图表示，是这样的：</p><p><img src="/2022/09/15/netty-nio-001/640(13)" alt="640(13)"></p><h3 id="2-2-1-2-SocketChannel"><a href="#2-2-1-2-SocketChannel" class="headerlink" title="2.2.1.2 SocketChannel"></a>2.2.1.2 SocketChannel</h3><p>接下来我们学习获取<code>SocketChannel</code>的方式。</p><p>还是一样，我们通过一个例子来快速上手：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//获取ServerSocketChannel</span></span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">            <span class="comment">//绑定地址，端口号</span></span><br><span class="line">            serverSocketChannel.bind(address);</span><br><span class="line">            <span class="comment">//创建一个缓冲区</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//获取SocketChannel</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                <span class="keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//打印结果</span></span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array()));</span><br><span class="line">                    <span class="comment">//清空缓冲区</span></span><br><span class="line">                    byteBuffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后运行main()方法，我们可以通过<code>telnet</code>命令进行连接测试：</p><p><img src="/2022/09/15/netty-nio-001/640(14)" alt="640(14)"></p><p>通过上面的例子可以知道，通过<code>ServerSocketChannel.open()</code>方法可以获取服务器的通道，然后绑定一个地址端口号，接着<code>accept()</code>方法可获得一个<code>SocketChannel</code>通道，也就是客户端的连接通道。</p><p>最后配合使用<code>Buffer</code>进行读写即可。</p><p>这就是一个简单的例子，实际上上面的例子是阻塞式的。要做到非阻塞还需要使用选择器<code>Selector</code>。</p><h3 id="2-3-选择器-Selector"><a href="#2-3-选择器-Selector" class="headerlink" title="2.3 选择器(Selector)"></a>2.3 选择器(Selector)</h3><p><code>Selector</code>翻译成<strong>选择器</strong>，有些人也会翻译成<strong>多路复用器</strong>，实际上指的是同一样东西。</p><p>只有网络IO才会使用选择器，文件IO是不需要使用的。</p><p>选择器可以说是NIO的核心组件，它可以监听通道的状态，来实现异步非阻塞的IO。换句话说，也就是事件驱动。以此实现<strong>单线程管理多个Channel</strong>的目的。</p><p><img src="/2022/09/15/netty-nio-001/640(15)" alt="640(15)"></p><h3 id="2-3-1-核心API"><a href="#2-3-1-核心API" class="headerlink" title="2.3.1 核心API"></a>2.3.1 核心API</h3><table><thead><tr><th>API方法名</th><th>作用</th></tr></thead><tbody><tr><td>Selector.open()</td><td>打开一个选择器。</td></tr><tr><td>select()</td><td>选择一组键，其相应的通道已为 I&#x2F;O 操作准备就绪。</td></tr><tr><td>selectedKeys()</td><td>返回此选择器的已选择键集。</td></tr></tbody></table><p>以上的API会在后面的例子用到，先有个印象。</p><h1 id="NIO快速入门"><a href="#NIO快速入门" class="headerlink" title="NIO快速入门"></a>NIO快速入门</h1><h3 id="3-1-1-通道间的数据传输"><a href="#3-1-1-通道间的数据传输" class="headerlink" title="3.1.1 通道间的数据传输"></a>3.1.1 通道间的数据传输</h3><p>这里主要介绍两个通道与通道之间数据传输的方式：</p><p><code>transferTo()</code>：把源通道的数据传输到目的通道中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//获取文件输入流</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="comment">//从文件输入流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">inputStreamChannel</span> <span class="operator">=</span> inputStream.getChannel();</span><br><span class="line">            <span class="comment">//获取文件输出流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;2.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//从文件输出流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">outputStreamChannel</span> <span class="operator">=</span> outputStream.getChannel();</span><br><span class="line">            <span class="comment">//创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>) file.length());</span><br><span class="line">            <span class="comment">//把输入流通道的数据读取到输出流的通道</span></span><br><span class="line">            inputStreamChannel.transferTo(<span class="number">0</span>, byteBuffer.limit(), outputStreamChannel);</span><br><span class="line">            <span class="comment">//关闭通道</span></span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            outputStreamChannel.close();</span><br><span class="line">            inputStreamChannel.close();</span><br><span class="line">        &#125;    </span><br></pre></td></tr></table></figure><p><code>transferFrom()</code>：把来自源通道的数据传输到目的通道。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//获取文件输入流</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="comment">//从文件输入流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">inputStreamChannel</span> <span class="operator">=</span> inputStream.getChannel();</span><br><span class="line">            <span class="comment">//获取文件输出流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;2.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//从文件输出流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">outputStreamChannel</span> <span class="operator">=</span> outputStream.getChannel();</span><br><span class="line">            <span class="comment">//创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>) file.length());</span><br><span class="line">            <span class="comment">//把输入流通道的数据读取到输出流的通道</span></span><br><span class="line">            outputStreamChannel.transferFrom(inputStreamChannel,<span class="number">0</span>,byteBuffer.limit());</span><br><span class="line">            <span class="comment">//关闭通道</span></span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            outputStreamChannel.close();</span><br><span class="line">            inputStreamChannel.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-分散读取和聚合写入"><a href="#3-1-2-分散读取和聚合写入" class="headerlink" title="3.1.2 分散读取和聚合写入"></a>3.1.2 分散读取和聚合写入</h3><p>我们先看一下FileChannel的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FileChannel</span> <span class="keyword">extends</span> <span class="title class_">AbstractInterruptibleChannel</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">SeekableByteChannel</span>, GatheringByteChannel, ScatteringByteChannel &#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出实现了GatheringByteChannel,ScatteringByteChannel接口。也就是支持分散读取和聚合写入的操作。怎么使用呢，请看以下例子：</p><p>我们写一个main方法来实现复制1.txt文件，文件内容是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcdefghijklmnopqrstuvwxyz//26个字母</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//获取文件输入流</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="comment">//从文件输入流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">inputStreamChannel</span> <span class="operator">=</span> inputStream.getChannel();</span><br><span class="line">            <span class="comment">//获取文件输出流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;2.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//从文件输出流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">outputStreamChannel</span> <span class="operator">=</span> outputStream.getChannel();</span><br><span class="line">            <span class="comment">//创建三个缓冲区，分别都是5</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">            <span class="comment">//创建一个缓冲区数组</span></span><br><span class="line">            ByteBuffer[] buffers = <span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;byteBuffer1, byteBuffer2, byteBuffer3&#125;;</span><br><span class="line">            <span class="comment">//循环写入到buffers缓冲区数组中，分散读取</span></span><br><span class="line">            <span class="type">long</span> read;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sumLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((read = inputStreamChannel.read(buffers)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                sumLength += read;</span><br><span class="line">                Arrays.stream(buffers)</span><br><span class="line">                        .map(buffer -&gt; <span class="string">&quot;posstion=&quot;</span> + buffer.position() + <span class="string">&quot;,limit=&quot;</span> + buffer.limit())</span><br><span class="line">                        .forEach(System.out::println);</span><br><span class="line">                <span class="comment">//切换模式</span></span><br><span class="line">                Arrays.stream(buffers).forEach(Buffer::flip);</span><br><span class="line">                <span class="comment">//聚合写入到文件输出通道</span></span><br><span class="line">                outputStreamChannel.write(buffers);</span><br><span class="line">                <span class="comment">//清空缓冲区</span></span><br><span class="line">                Arrays.stream(buffers).forEach(Buffer::clear);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;总长度:&quot;</span> + sumLength);</span><br><span class="line">            <span class="comment">//关闭通道</span></span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            outputStreamChannel.close();</span><br><span class="line">            inputStreamChannel.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">posstion=5,limit=5</span><br><span class="line">posstion=5,limit=5</span><br><span class="line">posstion=5,limit=5</span><br><span class="line"></span><br><span class="line">posstion=5,limit=5</span><br><span class="line">posstion=5,limit=5</span><br><span class="line">posstion=1,limit=5</span><br><span class="line"></span><br><span class="line">总长度:26</span><br></pre></td></tr></table></figure><p>可以看到循环了两次。第一次循环时，三个缓冲区都读取了5个字节，总共读取了15，也就是读满了。还剩下11个字节，于是第二次循环时，前两个缓冲区分配了5个字节，最后一个缓冲区给他分配了1个字节，刚好读完。总共就是26个字节。</p><p>这就是分散读取，聚合写入的过程。</p><p>使用场景就是可以<strong>使用一个缓冲区数组，自动地根据需要去分配缓冲区的大小。可以减少内存消耗</strong>。网络IO也可以使用，这里就不写例子演示了。</p><h3 id="3-1-3-非直接-x2F-直接缓冲区"><a href="#3-1-3-非直接-x2F-直接缓冲区" class="headerlink" title="3.1.3 非直接&#x2F;直接缓冲区"></a>3.1.3 非直接&#x2F;直接缓冲区</h3><p>非直接缓冲区的创建方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static ByteBuffer allocate(int capacity)</span><br></pre></td></tr></table></figure><p>直接缓冲区的创建方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static ByteBuffer allocateDirect(int capacity)</span><br></pre></td></tr></table></figure><p>非直接&#x2F;直接缓冲区的区别示意图：</p><p><img src="/2022/09/15/netty-nio-001/640(16)" alt="640(16)"></p><p><img src="/2022/09/15/netty-nio-001/640(17)" alt="640(17)"></p><p>从示意图中我们可以发现，最大的不同在于直接缓冲区不需要再把文件内容copy到物理内存中。这就大大地提高了性能。其实在介绍Buffer时，我们就有接触到这个概念。直接缓冲区是堆外内存，在本地文件IO效率会更高一点。</p><p>接下来我们来对比一下效率，以一个136 MB的视频文件为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">starTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//获取文件输入流</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\小电影.mp4&quot;</span>);<span class="comment">//文件大小136 MB</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">    <span class="comment">//从文件输入流获取通道</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">inputStreamChannel</span> <span class="operator">=</span> inputStream.getChannel();</span><br><span class="line">    <span class="comment">//获取文件输出流</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test.mp4&quot;</span>));</span><br><span class="line">    <span class="comment">//从文件输出流获取通道</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">outputStreamChannel</span> <span class="operator">=</span> outputStream.getChannel();</span><br><span class="line">    <span class="comment">//创建一个直接缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//创建一个非直接缓冲区</span></span><br><span class="line">    <span class="comment">//ByteBuffer byteBuffer = ByteBuffer.allocate(5 * 1024 * 1024);</span></span><br><span class="line">    <span class="comment">//写入到缓冲区</span></span><br><span class="line">    <span class="keyword">while</span> (inputStreamChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//切换读模式</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        outputStreamChannel.write(byteBuffer);</span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭通道</span></span><br><span class="line">    outputStream.close();</span><br><span class="line">    inputStream.close();</span><br><span class="line">    outputStreamChannel.close();</span><br><span class="line">    inputStreamChannel.close();</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;消耗时间：&quot;</span> + (endTime - starTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>直接缓冲区的消耗时间：283毫秒</p><p>非直接缓冲区的消耗时间：487毫秒</p><h3 id="3-2-网络IO"><a href="#3-2-网络IO" class="headerlink" title="3.2 网络IO"></a>3.2 网络IO</h3><p>其实NIO的主要用途是网络IO，在NIO之前java要使用网络编程就只有用<code>Socket</code>。而<code>Socket</code>是阻塞的，显然对于高并发的场景是不适用的。所以NIO的出现就是解决了这个痛点。</p><p>主要思想是把Channel通道注册到Selector中，通过Selector去监听Channel中的事件状态，这样就不需要阻塞等待客户端的连接，从主动等待客户端的连接，变成了通过事件驱动。没有监听的事件，服务器可以做自己的事情。</p><h3 id="3-2-1-使用Selector的小例子"><a href="#3-2-1-使用Selector的小例子" class="headerlink" title="3.2.1 使用Selector的小例子"></a>3.2.1 使用Selector的小例子</h3><p>接下来趁热打铁，我们来做一个服务器接受客户端消息的例子：</p><p>首先服务端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//打开一个ServerSocketChannel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//绑定地址</span></span><br><span class="line">        serverSocketChannel.bind(address);</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//打开一个选择器</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">//serverSocketChannel注册到选择器中,监听连接事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">//循环等待客户端的连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//等待3秒，（返回0相当于没有事件）如果没有事件，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (selector.select(<span class="number">3000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器等待3秒，没有连接&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有事件selector.select(3000)&gt;0的情况,获取事件</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//获取迭代器遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//获取到事件</span></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> it.next();</span><br><span class="line">                <span class="comment">//判断如果是连接事件</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">//服务器与客户端建立连接，获取socketChannel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    <span class="comment">//设置成非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">//把socketChannel注册到selector中，监听读事件，并绑定一个缓冲区</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果是读事件</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">//获取通道</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">//获取关联的ByteBuffer</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) selectionKey.attachment();</span><br><span class="line">                    <span class="comment">//打印从客户端获取到的数据</span></span><br><span class="line">                    socketChannel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;from 客户端：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从事件集合中删除已处理的事件，防止重复处理</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">connect</span> <span class="operator">=</span> socketChannel.connect(address);</span><br><span class="line">        <span class="comment">//判断是否连接成功</span></span><br><span class="line">        <span class="keyword">if</span>(!connect)&#123;</span><br><span class="line">            <span class="comment">//等待连接的过程中</span></span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接服务器需要时间，期间可以做其他事情...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello java技术爱好者！&quot;</span>;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">        <span class="comment">//把byteBuffer数据写入到通道中</span></span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">        <span class="comment">//让程序卡在这个位置，不关闭连接</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来启动服务端，然后再启动客户端，我们可以看到控制台打印以下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务器等待3秒，没有连接</span><br><span class="line">服务器等待3秒，没有连接</span><br><span class="line">from 客户端：hello java技术爱好者！                       </span><br><span class="line">服务器等待3秒，没有连接</span><br><span class="line">服务器等待3秒，没有连接</span><br></pre></td></tr></table></figure><p>通过这个例子我们引出以下知识点。</p><h3 id="3-2-2-SelectionKey"><a href="#3-2-2-SelectionKey" class="headerlink" title="3.2.2 SelectionKey"></a>3.2.2 SelectionKey</h3><p>在<code>SelectionKey</code>类中有四个常量表示四种事件，来看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SelectionKey</span> &#123;</span><br><span class="line">    <span class="comment">//读事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">//2^0=1</span></span><br><span class="line">    <span class="comment">//写事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>; <span class="comment">// 2^2=4</span></span><br><span class="line">    <span class="comment">//连接操作,Client端支持的一种操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_CONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">// 2^3=8</span></span><br><span class="line">    <span class="comment">//连接可接受操作,仅ServerSocketChannel支持</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_ACCEPT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 2^4=16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附加的对象(可选)，把通道注册到选择器中时可以附加一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops, Object att)</span></span><br></pre></td></tr></table></figure><p>从<code>selectionKey</code>中获取附件对象可以使用<code>attachment()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">attachment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> attachment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用NIO实现多人聊天室"><a href="#4-使用NIO实现多人聊天室" class="headerlink" title="4 使用NIO实现多人聊天室"></a>4 使用NIO实现多人聊天室</h3><p>接下来进行一个实战例子，用NIO实现一个多人运动版本的聊天室。</p><p>服务端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器初始化成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//打开一个选择器</span></span><br><span class="line">            <span class="built_in">this</span>.selector = Selector.open();</span><br><span class="line">            <span class="comment">//打开serverSocketChannel</span></span><br><span class="line">            <span class="built_in">this</span>.serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定地址，端口号</span></span><br><span class="line">            <span class="built_in">this</span>.serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, PORT));</span><br><span class="line">            <span class="comment">//设置为非阻塞</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//把通道注册到选择器中</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听，并且接受客户端消息，转发到其他客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//获取监听的事件总数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    <span class="comment">//获取SelectionKey集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">                        <span class="comment">//如果是获取连接事件</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                            <span class="comment">//设置为非阻塞</span></span><br><span class="line">                            socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            <span class="comment">//注册到选择器中</span></span><br><span class="line">                            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                            System.out.println(socketChannel.getRemoteAddress() + <span class="string">&quot;上线了~&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果是读就绪事件</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="comment">//读取消息，并且转发到其他客户端</span></span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        it.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取客户端发送过来的消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readData</span><span class="params">(SelectionKey selectionKey)</span> &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从selectionKey中获取channel</span></span><br><span class="line">            socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//创建一个缓冲区</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">//把通道的数据写入到缓冲区</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> socketChannel.read(byteBuffer);</span><br><span class="line">            <span class="comment">//判断返回的count是否大于0，大于0表示读取到了数据</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//把缓冲区的byte[]转成字符串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array());</span><br><span class="line">                <span class="comment">//输出该消息到控制台</span></span><br><span class="line">                System.out.println(<span class="string">&quot;from 客户端：&quot;</span> + msg);</span><br><span class="line">                <span class="comment">//转发到其他客户端</span></span><br><span class="line">                notifyAllClient(msg, socketChannel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//打印离线的通知</span></span><br><span class="line">                System.out.println(socketChannel.getRemoteAddress() + <span class="string">&quot;离线了...&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                selectionKey.cancel();</span><br><span class="line">                <span class="comment">//关闭流</span></span><br><span class="line">                socketChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转发消息到其他客户端</span></span><br><span class="line"><span class="comment">     * msg 消息</span></span><br><span class="line"><span class="comment">     * noNotifyChannel 不需要通知的Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyAllClient</span><span class="params">(String msg, SocketChannel noNotifyChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息~&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (SelectionKey selectionKey : selector.keys()) &#123;</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> selectionKey.channel();</span><br><span class="line">            <span class="comment">//channel的类型实际类型是SocketChannel，并且排除不需要通知的通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; channel != noNotifyChannel) &#123;</span><br><span class="line">                <span class="comment">//强转成SocketChannel类型</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) channel;</span><br><span class="line">                <span class="comment">//通过消息，包裹获取一个缓冲区</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                socketChannel.write(byteBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">GroupChatServer</span> <span class="variable">chatServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatServer</span>();</span><br><span class="line">        <span class="comment">//启动服务器，监听</span></span><br><span class="line">        chatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClinet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatClinet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//打开选择器</span></span><br><span class="line">            <span class="built_in">this</span>.selector = Selector.open();</span><br><span class="line">            <span class="comment">//连接服务器</span></span><br><span class="line">            socketChannel = SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, GroupChatServer.PORT));</span><br><span class="line">            <span class="comment">//设置为非阻塞</span></span><br><span class="line">            socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//注册到选择器中</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            <span class="comment">//获取用户名</span></span><br><span class="line">            userName = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">            System.out.println(userName + <span class="string">&quot; is ok~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息到服务端</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        msg = userName + <span class="string">&quot;说：&quot;</span> + msg;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(msg.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取服务端发送过来的消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    <span class="comment">//判断是读就绪事件</span></span><br><span class="line">                    <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">                        <span class="comment">//创建一个缓冲区</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//从服务器的通道中读取数据到缓冲区</span></span><br><span class="line">                        channel.read(byteBuffer);</span><br><span class="line">                        <span class="comment">//缓冲区的数据，转成字符串，并打印</span></span><br><span class="line">                        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">GroupChatClinet</span> <span class="variable">chatClinet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatClinet</span>();</span><br><span class="line">        <span class="comment">//启动线程，读取服务器转发过来的消息</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                chatClinet.readMsg();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//主线程发送消息到服务器</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            chatClinet.sendMsg(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动服务端的main方法，再启动两个客户端的main方法：</p><p><img src="/2022/09/15/netty-nio-001/640(18)" alt="640(18)"></p><p>然后使用两个客户端开始聊天了~</p><p><img src="/2022/09/15/netty-nio-001/640(19)" alt="640(19)"></p><p><img src="/2022/09/15/netty-nio-001/640(20)" alt="640(20)"></p><p>以上就是使用NIO<strong>实现多人聊天室</strong>的例子，同学们可以看着我这个例子自己完成一下。要多写代码才好理解这些概念。</p><hr><p><strong>免责声明：</strong></p><p>本公博客部分分享的资料来自网络收集和整理，所有文字和图片版权归属于原作者所有，且仅代表作者个人观点，与<strong>本博客</strong>无关，文章仅供读者学习交流使用，并请自行核实相关内容，如文章内容涉及侵权，请联系后台管理员删除。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Quartz，更优雅地管理你的定时任务</title>
      <link href="/2022/09/14/quartz20220914/"/>
      <url>/2022/09/14/quartz20220914/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><p>初识Quartz</p></li><li><p>Quartz基础使用</p><ul><li><p>基于时间间隔的定时任务</p></li><li><p>基于Cron表达式的定时任务</p></li></ul></li><li><p>Quartz解读</p><ul><li><p>Job</p></li><li><p>Trigger</p></li><li><p>Scheduler</p></li></ul></li><li><p>Quartz进阶使用</p><ul><li><p>多触发器的定时任务</p></li><li><p>Job中注入Bean</p></li><li><p>Quartz的持久化</p></li></ul></li></ul><p>最近在工作遇到了定时任务场景，因此特地对定时任务相关知识进行了调研，记录在此，后文中使用的代码已经上传到Github：<a href="https://github.com/ThinkMugz/springboot-demo-major%EF%BC%8C%E9%9C%80%E8%A6%81%E7%9A%84%E4%BC%99%E4%BC%B4%E5%84%BF%E8%87%AA%E5%8F%96%E3%80%82">https://github.com/ThinkMugz/springboot-demo-major，需要的伙伴儿自取。</a></p><p>本文主要有以下内容：</p><ul><li><p>Quartz的基本认知和源码初探</p></li><li><p>Quartz的基本使用</p></li><li><p>Quartz的进阶使用，包括Job中注入Mapper层、Quartz的持久化</p></li></ul><p>在Java领域，有很多定时任务框架，这里简单对比一下目前比较流行的三款：</p><p><img src="/2022/09/14/quartz20220914/saved_resource" alt="saved_resource"></p><ul><li><p>Quartz文档：<a href="https://www.w3cschool.cn/quartz/_doc/">https://www.w3cschool.cn/quartz\_doc/</a></p></li><li><p>xxl-job博客：<a href="https://www.cnblogs.com/xuxueli/p/5021979.html">https://www.cnblogs.com/xuxueli/p/5021979.html</a></p></li></ul><h2 id="一-初识Quartz"><a href="#一-初识Quartz" class="headerlink" title="一 . 初识Quartz"></a>一 . 初识Quartz</h2><p>如果你的定时任务没有分布式需求，但需要对任务有一定的动态管理，例如任务的启动、暂停、恢复、停止和触发时间修改，那么Quartz非常适合你。</p><p>Quartz是Java定时任务领域一个非常优秀的框架，由OpenSymphony（一个开源组织）开发，这个框架进行了优良地解耦设计，整个模块可以分为三大部分：</p><ul><li><p><strong>Job</strong>：顾名思义，指待定时执行的具体工作内容；</p></li><li><p><strong>Trigger</strong>：触发器，指定运行参数，包括运行次数、运行开始时间和技术时间、运行时长等；</p></li><li><p><strong>Scheduler</strong>：调度器，将Job和Trigger组装起来，使定时任务被真正执行；</p></li></ul><p><img src="/2022/09/14/quartz20220914/saved_resource(1)" alt="saved_resource(1)"><br>下面这个图简略地描述了三者之间的关系：</p><ul><li><p>一个JobDetail（Job的实现类）可以绑定多个Trigger，但一个Trigger只能绑定一个JobDetail；</p></li><li><p>每个JobDetail和Trigger通过group和name来标识唯一性；</p></li><li><p>一个Scheduler可以调度多组JobDetail和Trigger。</p></li></ul><p><img src="/2022/09/14/quartz20220914/saved_resource(2)" alt="saved_resource(2)"></p><p>为了便于理解和记忆，可以把这套设计机制与工厂车间相关联：</p><ul><li><p><strong>Job</strong>：把Job比作车间要生产的一类产品，例如汽车、电脑等。</p></li><li><p><strong>Trigger</strong>：trigger可以理解为一条生产线，一条生产线只能生产一类产品，但一类产品可以由多条生产线生产。</p></li><li><p><strong>Scheduler</strong>：Scheduler则可以理解为车间主任，指挥调度着车间内的生产任务（Scheduler内置线程池，线程池内的工作线程即为车间工人，每个工人承担着一组任务的真正执行）。</p></li></ul><p><img src="/2022/09/14/quartz20220914/saved_resource(3)" alt="saved_resource(3)"></p><h2 id="二-Quartz基础使用"><a href="#二-Quartz基础使用" class="headerlink" title="二. Quartz基础使用"></a>二. Quartz基础使用</h2><p><code>Quartz提供了丰富的API，下面我们在Springboot中使用Quartz完成一些简单的demo。</code></p><h3 id="基于时间间隔的定时任务"><a href="#基于时间间隔的定时任务" class="headerlink" title="基于时间间隔的定时任务"></a>基于时间间隔的定时任务</h3><p>基于时间间隔和时间长度实现定时任务，借助SimpleTrigger，例如这个场景——每隔2s在控制台输出线程名和当前时间，持续30s。</p><h4 id="a-导入依赖："><a href="#a-导入依赖：" class="headerlink" title="a.导入依赖："></a>a.导入依赖：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- quartz任务--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="b-新建Job，实现我们想要定时执行的任务："><a href="#b-新建Job，实现我们想要定时执行的任务：" class="headerlink" title="b.新建Job，实现我们想要定时执行的任务："></a>b.新建Job，实现我们想要定时执行的任务：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/9/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个事件，下面仅创建一个输出语句作演示</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&quot;</span></span><br><span class="line">                + DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(LocalDateTime.now()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c-创建Scheduler和Trigger，执行定时任务："><a href="#c-创建Scheduler和Trigger，执行定时任务：" class="headerlink" title="c.创建Scheduler和Trigger，执行定时任务："></a>c.创建Scheduler和Trigger，执行定时任务：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/9/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleQuartzTest</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 基于时间间隔的定时任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleTest</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1、创建Scheduler（调度器）</span></span><br><span class="line">        <span class="type">SchedulerFactory</span> <span class="variable">schedulerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> schedulerFactory.getScheduler();</span><br><span class="line">        <span class="comment">// 2、创建JobDetail实例，并与SimpleJob类绑定(Job执行内容)</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(SimpleJob.class)</span><br><span class="line">                .withIdentity(<span class="string">&quot;job1&quot;</span>, <span class="string">&quot;group1&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 3、构建Trigger（触发器），定义执行频率和时长</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                <span class="comment">// 指定group和name，这是唯一身份标识</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;trigger-1&quot;</span>, <span class="string">&quot;trigger-group&quot;</span>)</span><br><span class="line">                .startNow()  <span class="comment">//立即生效</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">2</span>) <span class="comment">//每隔2s执行一次</span></span><br><span class="line">                        .repeatForever())  <span class="comment">// 永久执行</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//4、将Job和Trigger交给Scheduler调度</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">        <span class="comment">// 5、启动Scheduler</span></span><br><span class="line">        scheduler.start();</span><br><span class="line">        <span class="comment">// 休眠，决定调度器运行时间，这里设置30s</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 关闭Scheduler</span></span><br><span class="line">        scheduler.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动测试方法后，控制台观察现象即可。注意到这么一句日志：Using threadpool ‘org.quartz.simpl.SimpleThreadPool&#39; - with 10 threads.，这说明Scheduler确实是内置了10个线程的线程池，通过打印线程名也印证了这一点。</p><p>另外要尤其注意的是，我们之所以通过TimeUnit.SECONDS.sleep(30);设置休眠，是因为定时任务是交由线程池异步执行的，而测试方法运行结束，主线程随之结束导致定时任务也不再执行了，所以需要设置休眠hold住主线程。在真实项目中，项目的进程是一直存活的，因此不需要设置休眠时间。</p><p>这其中的区别可以参考</p><p><code> https://github.com/ThinkMugz/springboot-demo-major。</code></p><h3 id="基于Cron表达式的定时任务"><a href="#基于Cron表达式的定时任务" class="headerlink" title="基于Cron表达式的定时任务"></a>基于Cron表达式的定时任务</h3><p>基于Cron表达式的定时任务demo如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 基于cron表达式的定时任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cronTest</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1、创建Scheduler（调度器）</span></span><br><span class="line">        <span class="type">SchedulerFactory</span> <span class="variable">schedulerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> schedulerFactory.getScheduler();</span><br><span class="line">        <span class="comment">// 2、创建JobDetail实例，并与SimpleJob类绑定</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(SimpleJob.class)</span><br><span class="line">                .withIdentity(<span class="string">&quot;job-1&quot;</span>, <span class="string">&quot;job-group&quot;</span>).build();</span><br><span class="line">        <span class="comment">// 3、构建Trigger（触发器），定义执行频率和时长</span></span><br><span class="line">        <span class="type">CronTrigger</span> <span class="variable">cronTrigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;trigger-1&quot;</span>, <span class="string">&quot;trigger-group&quot;</span>)</span><br><span class="line">                .startNow()  <span class="comment">//立即生效</span></span><br><span class="line">                .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">&quot;* 30 10 ? * 1/5 *&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、执行</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, cronTrigger);</span><br><span class="line">        scheduler.start();</span><br><span class="line">        <span class="comment">// 休眠，决定调度器运行时间，这里设置30s</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 关闭Scheduler</span></span><br><span class="line">        scheduler.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="三-Quartz解读"><a href="#三-Quartz解读" class="headerlink" title="三 .  Quartz解读"></a>三 .  Quartz解读</h2><p>整个Quartz体系涉及的类及之间的关系如下图所示：</p><p><img src="/2022/09/14/quartz20220914/saved_resource(4)" alt="saved_resource(4)"></p><ul><li><p><strong>JobDetail</strong>：Job接口的实现类，由JobBuilder将具体定义任务的类包装而成。</p></li><li><p><strong>Trigger</strong>：触发器，定义定时任务的触发规则，包括执行间隔、时长等，使用    TriggerBuilder创建，JobDetail和Trigger可以一对多，反之不可。触发器可以拥有多种状态。</p></li><li><p><strong>Scheduler</strong>：调度器，将Job和Trigger组装起来，使定时任务被真正执行；是Quartz的核心，提供了大量API。</p></li><li><p><strong>JobDataMap</strong>：集成Map，通过键值对为JobDetail存储一些额外信息。</p></li><li><p><strong>JobStore</strong>：用来存储任务和触发器相关的信息，例如任务名称、数量、状态等等。Quartz<br>中有两种存储任务的方式，一种在在内存（RAMJobStore），一种是在数据库（JDBCJobStore）。</p></li></ul><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>Job是一个接口，只有一个方法execute()，我们创建具体的任务类时要继承Job并重写execute()方法，使用JobBuilder将具体任务类包装成一个JobDetail（使用了建造者模式）交给Scheduler管理。每个JobDetail由name和group作为其唯一身份标识。</p><ul><li><p>JobDataMap中可以包含不限量的（序列化的）数据对象，在job实例执行的时候，可以使用其中的数据。</p></li><li><p>JobDataMap继承Map，可通过键值对为JobDetail存储一些额外信息。</p></li></ul><h3 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h3><p>Trigger有四类实现，分别如下：</p><ul><li><p><strong>SimpleTrigger</strong>：简单触发器，支持定义任务执行的间隔时间，执行次数的规则有两种，一是定义重复次数，二是定义开始时间和结束时间。如果同时设置了结束时间与重复次数，先结束的会覆盖后结束的，以先结束的为准。</p></li><li><p><strong>CronTrigger</strong>：基于Cron表达式的触发器。</p></li><li><p><strong>CalendarIntervalTrigger</strong>：基于日历的触发器，比简单触发器更多时间单位，且能智能区分大小月和平闰年。</p></li><li><p><strong>DailyTimeIntervalTrigger</strong>：基于日期的触发器，如每天的某个时间段。</p></li></ul><p>Trigger是有状态的：NONE,NORMAL,PAUSED,COMPLETE,ERROR,BLOCKED，状态之间转换关系：</p><p><img src="/2022/09/14/quartz20220914/saved_resource(5)" alt="saved_resource(5)"><br>COMPLETE状态比较特殊，我在实际操作中发现，当Trigger长时间暂停后（具体时长不太确定）再恢复，状态就会变为COMPLETE，这种状态下无法再次启动该触发器。</p><h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>调度器，是 Quartz的指挥官，由StdSchedulerFactory产生，它是单例的。Scheduler中提供了Quartz中最重要的API，默认是实现类是StdScheduler。</p><p>Scheduler中主要的API大概分为三种：</p><ul><li><p><strong>操作Scheduler本身</strong>：例如start、shutdown等；</p></li><li><p><strong>操作Job</strong>：例如：addJob、pauseJob、pauseJobs、resumeJob、resumeJobs、getJobKeys、getJobDetail等</p></li><li><p><strong>操作Trigger</strong>：例如pauseTrigger、resumeTrigger等</p></li></ul><p>这些API使用非常简单，源码中也有完善的注释，这里不再赘述。</p><h2 id="四-Quartz进阶使用"><a href="#四-Quartz进阶使用" class="headerlink" title="四 . Quartz进阶使用"></a>四 . Quartz进阶使用</h2><p>除了基本使用外，Quartz还有一些较为复杂的应用场景。</p><h3 id="多触发器的定时任务"><a href="#多触发器的定时任务" class="headerlink" title="多触发器的定时任务"></a>多触发器的定时任务</h3><p>前文提过，一个JobDetail可以绑定多个触发器，这种场景还是有一些注意点的：</p><ul><li><p>首先，要通过storeDurably()方法将JobDetail设置为孤立后保存存储（没有触发器指向该作业的情况）；</p></li><li><p>Scheduler通过addJob()将给定的作业添加到计划程序中-没有关联的触发器。作业将处于”休眠”状态，直到使用触发器或调度程序对其进行调度；</p></li><li><p>触发器通过forJob(JobDetail jobDetail)指定要绑定的JobDetail，scheduleJob()方法只传入触发器，触发后将自动执行addJob过的绑定JobDetail。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.quartz.demo.schedule.SimpleJob;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiQuartzTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multiJobTest</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1、创建Scheduler（调度器）</span></span><br><span class="line">        <span class="type">SchedulerFactory</span> <span class="variable">schedulerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> schedulerFactory.getScheduler();</span><br><span class="line">        <span class="comment">// 2、创建JobDetail实例，与执行内容类SimpleJob绑定，注意要设置 .storeDurably()，否则报错</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(SimpleJob.class)</span><br><span class="line">                .withIdentity(<span class="string">&quot;job1&quot;</span>, <span class="string">&quot;job-group&quot;</span>)</span><br><span class="line">                .storeDurably()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、分别构建Trigger实例</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger().withIdentity(<span class="string">&quot;trigger1&quot;</span>, <span class="string">&quot;trigger-group&quot;</span>)</span><br><span class="line">                .startNow()<span class="comment">//立即生效</span></span><br><span class="line">                .forJob(jobDetail)</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder</span><br><span class="line">                        .simpleSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">2</span>) <span class="comment">//每隔3s执行一次</span></span><br><span class="line">                        .repeatForever()) <span class="comment">// 永久循环</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger2</span> <span class="operator">=</span> TriggerBuilder.newTrigger().withIdentity(<span class="string">&quot;trigger2&quot;</span>, <span class="string">&quot;trigger-group&quot;</span>)</span><br><span class="line">                .startNow()<span class="comment">//立即生效</span></span><br><span class="line">                .forJob(jobDetail)</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">3</span>) <span class="comment">//每隔5s执行一次</span></span><br><span class="line">                        .repeatForever()).build(); <span class="comment">// 永久循环</span></span><br><span class="line">        <span class="comment">//4、调度器中添加job</span></span><br><span class="line">        scheduler.addJob(jobDetail, <span class="literal">false</span>);</span><br><span class="line">        scheduler.scheduleJob(trigger);</span><br><span class="line">        scheduler.scheduleJob(trigger2);</span><br><span class="line">        <span class="comment">// 启动调度器</span></span><br><span class="line">        scheduler.start();</span><br><span class="line">        <span class="comment">// 休眠任务执行时长</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        scheduler.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Job中注入Bean"><a href="#Job中注入Bean" class="headerlink" title="Job中注入Bean"></a>Job中注入Bean</h3><p>有时候，我们要在定时任务中操作数据库，但Job中无法直接注入数据层，解决这种问题，有两种解决方案。</p><h4 id="方案一：借助JobDataMap"><a href="#方案一：借助JobDataMap" class="headerlink" title="方案一：借助JobDataMap"></a>方案一：借助JobDataMap</h4><p>在构建JobDetail时，可以将数据放入JobDataMap，基本类型的数据通过usingJobData方法直接放入，mapper这种类型数据手动put进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建定时任务</span></span><br><span class="line"><span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(MajorJob.class)</span><br><span class="line">        .withIdentity(jobName, jobGroupName)</span><br><span class="line">        .usingJobData(<span class="string">&quot;jobName&quot;</span>, <span class="string">&quot;QuartzDemo&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">// 将mapper放入jobDetail的jobDataMap中</span></span><br><span class="line">jobDetail.getJobDataMap().put(<span class="string">&quot;personMapper&quot;</span>, personMapper);</span><br></pre></td></tr></table></figure><p>在job的执行过程中，可以从JobDataMap中取出数据，如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.quartz.demo.entity.Person;</span><br><span class="line"><span class="keyword">import</span> com.quartz.demo.mapper.PersonMapper;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobDataMap;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MajorJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> &#123;</span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">dataMap</span> <span class="operator">=</span> jobExecutionContext.getJobDetail().getJobDataMap();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jobName</span> <span class="operator">=</span> dataMap.getString(<span class="string">&quot;jobName&quot;</span>);</span><br><span class="line">        <span class="type">PersonMapper</span> <span class="variable">personMapper</span> <span class="operator">=</span> (PersonMapper) dataMap.get(<span class="string">&quot;personMapper&quot;</span>);</span><br><span class="line">        <span class="comment">// 这样就可以执行mapper层方法了</span></span><br><span class="line">        List&lt;Person&gt; personList = personMapper.queryList();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&quot;</span></span><br><span class="line">                + DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(LocalDateTime.now()) + <span class="string">&quot;--&quot;</span></span><br><span class="line">                + jobName + <span class="string">&quot;--&quot;</span> + personList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方案相对简单，但在持久化中会遇到mapper的序列化问题：</p><blockquote><p>java.io.NotSerializableException: Unable to serialize JobDataMap for insertion into database because the value of property ‘personMapper’ is not serializable: org.mybatis.spring.SqlSessionTemplate</p></blockquote><h4 id="方案二：静态工具类"><a href="#方案二：静态工具类" class="headerlink" title="方案二：静态工具类"></a>方案二：静态工具类</h4><ul><li>创建工具类SpringContextJobUtil，实现ApplicationContextAware接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringContextJobUtil</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;static-access&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext contex)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = contex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据name获取bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bean对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> context.getBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMessage</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> context.getMessage(key, <span class="literal">null</span>, Locale.getDefault());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>mapper类上打上@Service注解，并赋予其name：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;personMapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select id,name,age,sex,address,sect,skill,power,create_time createTime,modify_time modifyTime from mytest.persons&quot;)</span></span><br><span class="line">    List&lt;Person&gt; <span class="title function_">queryList</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Job中通过SpringContextJobUtil的getBean获取mapper的bean：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MajorJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> &#123;</span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">dataMap</span> <span class="operator">=</span> jobExecutionContext.getJobDetail().getJobDataMap();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jobName</span> <span class="operator">=</span> dataMap.getString(<span class="string">&quot;jobName&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PersonMapper</span> <span class="variable">personMapper</span> <span class="operator">=</span> (PersonMapper) SpringContextJobUtil.getBean(<span class="string">&quot;personMapper&quot;</span>);</span><br><span class="line">        List&lt;Person&gt; personList = personMapper.queryList();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&quot;</span></span><br><span class="line">                + DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(LocalDateTime.now()) + <span class="string">&quot;--&quot;</span></span><br><span class="line">                + jobName + <span class="string">&quot;--&quot;</span> + personList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>推荐使用这个方法。</li></ul><h3 id="Quartz的持久化"><a href="#Quartz的持久化" class="headerlink" title="Quartz的持久化"></a>Quartz的持久化</h3><p>定时任务的诸多要素，如任务名称、数量、状态、运行频率、运行时间等，是要存储起来的。JobStore，就是用来存储任务和触发器相关的信息的。</p><p>Quartz中有两种存储任务的方式，一种在在内存（RAMJobStore），一种是在数据库（JDBCJobStore）。</p><p>Quartz默认的JobStore是RAMJobstore，也就是把任务和触发器信息运行的信息存储在内存中，用到了HashMap、TreeSet、HashSet等等数据结构，如果程序崩溃或重启，所有存储在内存中的数据都会丢失。所以我们需要把这些数据持久化到磁盘。</p><p>实现Quartz的持久化并不困难，按下列步骤操作即可：</p><h4 id="添加相关依赖："><a href="#添加相关依赖：" class="headerlink" title="添加相关依赖："></a>添加相关依赖：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.mchange&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9.5.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="编写配置："><a href="#编写配置：" class="headerlink" title="编写配置："></a>编写配置：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.Scheduler;</span><br><span class="line"><span class="keyword">import</span> org.quartz.ee.servlet.QuartzInitializerListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.PropertiesFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.quartz.SchedulerFactoryBean;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> muguozheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2022/4/19 18:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> Quartz配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulerConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取quartz.properties,将值初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Properties</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException io</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Properties <span class="title function_">quartzProperties</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PropertiesFactoryBean</span> <span class="variable">propertiesFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertiesFactoryBean</span>();</span><br><span class="line">        propertiesFactoryBean.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;/quartz.properties&quot;</span>));</span><br><span class="line">        propertiesFactoryBean.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> propertiesFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将配置文件的数据加载到SchedulerFactoryBean中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SchedulerFactoryBean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException io</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SchedulerFactoryBean <span class="title function_">schedulerFactoryBean</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SchedulerFactoryBean</span> <span class="variable">schedulerFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchedulerFactoryBean</span>();</span><br><span class="line">        schedulerFactoryBean.setQuartzProperties(quartzProperties());</span><br><span class="line">        <span class="keyword">return</span> schedulerFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> QuartzInitializerListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> QuartzInitializerListener <span class="title function_">executorListener</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">QuartzInitializerListener</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得Scheduler对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Scheduler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException io</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Scheduler <span class="title function_">scheduler</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> schedulerFactoryBean().getScheduler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="创建quartz-properties配置文件"><a href="#创建quartz-properties配置文件" class="headerlink" title="创建quartz.properties配置文件"></a>创建quartz.properties配置文件</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化ThreadPool时，使用的线程类为SimpleThreadPool</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.class</span>=<span class="string">org.quartz.simpl.SimpleThreadPool</span></span><br><span class="line"><span class="comment"># 并发个数</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadCount</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 优先级</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadPriority</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.misfireThreshold</span>=<span class="string">5000</span></span><br><span class="line"><span class="comment"># 持久化使用的类</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.class</span>=<span class="string">org.quartz.impl.jdbcjobstore.JobStoreTX</span></span><br><span class="line"><span class="comment"># 数据库中表的前缀</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.tablePrefix</span>=<span class="string">QRTZ_</span></span><br><span class="line"><span class="comment"># 数据源命名</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.dataSource</span>=<span class="string">qzDS</span></span><br><span class="line"><span class="comment"># qzDS 数据源</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.qzDS.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.qzDS.URL</span>=<span class="string">jdbc:mysql://localhost:3306/mytest?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.qzDS.user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.qzDS.password</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.qzDS.maxConnections</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure><h4 id="创建Quartz持久化数据的表"><a href="#创建Quartz持久化数据的表" class="headerlink" title="创建Quartz持久化数据的表"></a>创建Quartz持久化数据的表</h4><p>数据表初始化sql放置在External Libraries的org&#x2F;quartz&#x2F;impl&#x2F;jdbcjobstore中，直接用其初始化相关表即可。要注意的是，用来放置这些表的库要与quartz.properties的库一致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># <span class="keyword">In</span> your Quartz properties file, you<span class="string">&#x27;ll need to set</span></span><br><span class="line"><span class="string"># org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># By: Ron Cordell - roncordell</span></span><br><span class="line"><span class="string">#  I didn&#x27;</span>t see this anywhere, so I thought I<span class="string">&#x27;d post it here. This is the script from Quartz to create the tables in a MySQL database, modified to use INNODB instead of MYISAM.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_FIRED_TRIGGERS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_PAUSED_TRIGGER_GRPS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_SCHEDULER_STATE;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_LOCKS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_SIMPLE_TRIGGERS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_SIMPROP_TRIGGERS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_CRON_TRIGGERS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_BLOB_TRIGGERS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_TRIGGERS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_JOB_DETAILS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_CALENDARS;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_JOB_DETAILS(</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">JOB_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">JOB_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">DESCRIPTION VARCHAR(250) NULL,</span></span><br><span class="line"><span class="string">JOB_CLASS_NAME VARCHAR(250) NOT NULL,</span></span><br><span class="line"><span class="string">IS_DURABLE VARCHAR(1) NOT NULL,</span></span><br><span class="line"><span class="string">IS_NONCONCURRENT VARCHAR(1) NOT NULL,</span></span><br><span class="line"><span class="string">IS_UPDATE_DATA VARCHAR(1) NOT NULL,</span></span><br><span class="line"><span class="string">REQUESTS_RECOVERY VARCHAR(1) NOT NULL,</span></span><br><span class="line"><span class="string">JOB_DATA BLOB NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_TRIGGERS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">JOB_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">JOB_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">DESCRIPTION VARCHAR(250) NULL,</span></span><br><span class="line"><span class="string">NEXT_FIRE_TIME BIGINT(13) NULL,</span></span><br><span class="line"><span class="string">PREV_FIRE_TIME BIGINT(13) NULL,</span></span><br><span class="line"><span class="string">PRIORITY INTEGER NULL,</span></span><br><span class="line"><span class="string">TRIGGER_STATE VARCHAR(16) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_TYPE VARCHAR(8) NOT NULL,</span></span><br><span class="line"><span class="string">START_TIME BIGINT(13) NOT NULL,</span></span><br><span class="line"><span class="string">END_TIME BIGINT(13) NULL,</span></span><br><span class="line"><span class="string">CALENDAR_NAME VARCHAR(190) NULL,</span></span><br><span class="line"><span class="string">MISFIRE_INSTR SMALLINT(2) NULL,</span></span><br><span class="line"><span class="string">JOB_DATA BLOB NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span></span><br><span class="line"><span class="string">FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)</span></span><br><span class="line"><span class="string">REFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_SIMPLE_TRIGGERS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">REPEAT_COUNT BIGINT(7) NOT NULL,</span></span><br><span class="line"><span class="string">REPEAT_INTERVAL BIGINT(12) NOT NULL,</span></span><br><span class="line"><span class="string">TIMES_TRIGGERED BIGINT(10) NOT NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span></span><br><span class="line"><span class="string">FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span></span><br><span class="line"><span class="string">REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_CRON_TRIGGERS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">CRON_EXPRESSION VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">TIME_ZONE_ID VARCHAR(80),</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span></span><br><span class="line"><span class="string">FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span></span><br><span class="line"><span class="string">REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_SIMPROP_TRIGGERS</span></span><br><span class="line"><span class="string">  (</span></span><br><span class="line"><span class="string">    SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">    TRIGGER_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">    TRIGGER_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">    STR_PROP_1 VARCHAR(512) NULL,</span></span><br><span class="line"><span class="string">    STR_PROP_2 VARCHAR(512) NULL,</span></span><br><span class="line"><span class="string">    STR_PROP_3 VARCHAR(512) NULL,</span></span><br><span class="line"><span class="string">    INT_PROP_1 INT NULL,</span></span><br><span class="line"><span class="string">    INT_PROP_2 INT NULL,</span></span><br><span class="line"><span class="string">    LONG_PROP_1 BIGINT NULL,</span></span><br><span class="line"><span class="string">    LONG_PROP_2 BIGINT NULL,</span></span><br><span class="line"><span class="string">    DEC_PROP_1 NUMERIC(13,4) NULL,</span></span><br><span class="line"><span class="string">    DEC_PROP_2 NUMERIC(13,4) NULL,</span></span><br><span class="line"><span class="string">    BOOL_PROP_1 VARCHAR(1) NULL,</span></span><br><span class="line"><span class="string">    BOOL_PROP_2 VARCHAR(1) NULL,</span></span><br><span class="line"><span class="string">    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span></span><br><span class="line"><span class="string">    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span></span><br><span class="line"><span class="string">    REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_BLOB_TRIGGERS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">BLOB_DATA BLOB NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span></span><br><span class="line"><span class="string">INDEX (SCHED_NAME,TRIGGER_NAME, TRIGGER_GROUP),</span></span><br><span class="line"><span class="string">FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span></span><br><span class="line"><span class="string">REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_CALENDARS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">CALENDAR_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">CALENDAR BLOB NOT NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,CALENDAR_NAME))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_FIRED_TRIGGERS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">ENTRY_ID VARCHAR(95) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">INSTANCE_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">FIRED_TIME BIGINT(13) NOT NULL,</span></span><br><span class="line"><span class="string">SCHED_TIME BIGINT(13) NOT NULL,</span></span><br><span class="line"><span class="string">PRIORITY INTEGER NOT NULL,</span></span><br><span class="line"><span class="string">STATE VARCHAR(16) NOT NULL,</span></span><br><span class="line"><span class="string">JOB_NAME VARCHAR(190) NULL,</span></span><br><span class="line"><span class="string">JOB_GROUP VARCHAR(190) NULL,</span></span><br><span class="line"><span class="string">IS_NONCONCURRENT VARCHAR(1) NULL,</span></span><br><span class="line"><span class="string">REQUESTS_RECOVERY VARCHAR(1) NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,ENTRY_ID))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_SCHEDULER_STATE (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">INSTANCE_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">LAST_CHECKIN_TIME BIGINT(13) NOT NULL,</span></span><br><span class="line"><span class="string">CHECKIN_INTERVAL BIGINT(13) NOT NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,INSTANCE_NAME))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_LOCKS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">LOCK_NAME VARCHAR(40) NOT NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,LOCK_NAME))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_J_REQ_RECOVERY ON QRTZ_JOB_DETAILS(SCHED_NAME,REQUESTS_RECOVERY);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_J_GRP ON QRTZ_JOB_DETAILS(SCHED_NAME,JOB_GROUP);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_J ON QRTZ_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_JG ON QRTZ_TRIGGERS(SCHED_NAME,JOB_GROUP);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_C ON QRTZ_TRIGGERS(SCHED_NAME,CALENDAR_NAME);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_G ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_N_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_STATE);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_N_G_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP,TRIGGER_STATE);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_NEXT_FIRE_TIME ON QRTZ_TRIGGERS(SCHED_NAME,NEXT_FIRE_TIME);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_NFT_ST ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE,NEXT_FIRE_TIME);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_NFT_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_STATE);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE_GRP ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_GROUP,TRIGGER_STATE);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_FT_TRIG_INST_NAME ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_FT_INST_JOB_REQ_RCVRY ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME,REQUESTS_RECOVERY);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_FT_J_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_FT_JG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_GROUP);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_FT_T_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_FT_TG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">commit;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><hr><p><strong>免责声明：</strong></p><p>本公博客部分分享的资料来自网络收集和整理，所有文字和图片版权归属于原作者所有，且仅代表作者个人观点，与<strong>本博客</strong>无关，文章仅供读者学习交流使用，并请自行核实相关内容，如文章内容涉及侵权，请联系后台管理员删除。</p><p>转载链接<a href="https://www.cnblogs.com/chch213/articles/16678448.html">点击这里</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> quartz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经济发展之内循环、外循环</title>
      <link href="/2022/09/14/economy20220814/"/>
      <url>/2022/09/14/economy20220814/</url>
      
        <content type="html"><![CDATA[<h2 id="经济发展之内循环、外循环"><a href="#经济发展之内循环、外循环" class="headerlink" title="经济发展之内循环、外循环"></a>经济发展之内循环、外循环</h2><h3 id="一、什么是”内循环”？"><a href="#一、什么是”内循环”？" class="headerlink" title="一、什么是”内循环”？"></a>一、什么是”内循环”？</h3><p>“内循环”不是什么新的理念，而是早就开始使用的一种发展经济的手段，但是最近几年效果正在减弱。</p><p>我个人认为从2002年至今，中国的经济发展可以划分为两个阶段：第一阶段是2002年至2009年，外循环+内循环的经济增长模式；第二阶段是2010年至今的内循环为主的经济增长模式。其中第一阶段也可是说是出口+投资的经济增长模式，第二阶段是负债+投资的经济增长模式。无论是外循环、内循环、外循环+内循环的模式都是凯恩斯主义的产物，最终都有潮水褪去的一天。</p><h3 id="二、第一阶段的经济发展"><a href="#二、第一阶段的经济发展" class="headerlink" title="二、第一阶段的经济发展"></a>二、第一阶段的经济发展</h3><p>一个产品被生产出来后，一般有两种结局，一是售出，二是再加工。在经济学中将”再加工”可以称为投资。售出因为购买的对象不同，再次被细分为消费和出口，其中消费是指本国消费者购买，出口是指外国消费者购买。那么该如何衡量一个国家的经济发展水平呢？——GDP。其实GDP就是指用货币来对消费、投资和净出口进行计量，可以简单理解为GDP&#x3D;消费+投资+净出口。</p><p>一个企业生产出的产品，国内消费者不购买，无法进行再加工，国外消费者也不购买，那这个企业就要出现危机了。将这个道理推广到一个国家也是一样的，一个国家的多个”产品”不能消费、出口或投资，那这个国家就要出现经济危机。因此经济危机大多数时候是因为产能过剩、消费力下降导致的。</p><p>中国1996年的时候开始出现了产能过剩，如果任由其发展，必然造成经济危机。解决经济危机的方法至今也只有一招，就是将过剩的产品销售出去。详细区分可以分为国内销售和出口国外，当时政府的办法是在1998年开启房改，提振国内消费需求，同时在2001年加入WTO，增加出口，在这两剂良药的作用下，我国1996年的经济危机成功的得到了延缓。</p><h3 id="三、外循环和内循环"><a href="#三、外循环和内循环" class="headerlink" title="三、外循环和内循环"></a>三、外循环和内循环</h3><p>外部循环中最重要的环节是出口。</p><p>我国将产品出口欧美，再用获得的外汇储备购买美债，让美国股市得到发展，美国股市的上涨，带来了经济的繁荣，美国人有钱了，然后开始购买中国产品，拉动中国经济增长。</p><p>内循环最重要的是消费和投资。</p><p>中国内循环最重要的投资方式是城镇化，最重要的消费方式是房地产。老百姓将钱存入银行，银行将这些钱通过土地开发、土地交易和房产交易三种方式贷款给房地产市场。因此老百姓通过存款支撑房地产市场，再通过贷款去消化房价的上涨。</p><p>在消费方面，出口导致需求增长，企业开始扩招，工人们有工资，然后银行存款增加，房地产市场得到更充分的支撑，房价开始不断上涨，同时城镇化的推进导致需求的进一步增强。因此，可以判断我国的消费是由出口和投资来引领的，并不是像欧美国家由消费引领出口和投资。<br>这两个循环开起来很美好，但是终究是”永动机”设想。如果想要两个循环能够不断的运行，就需要美国的股市和中国的房市永远上涨，绝不下跌。但是2008年美国爆发次贷危机，导致外循环熄火。</p><h3 id="四、内循环"><a href="#四、内循环" class="headerlink" title="四、内循环"></a>四、内循环</h3><p>2008年的时候，美国的次贷危机爆发了两年，欧美国家的经济发展受到阻碍，手里没有钱了，自然要减少购买或者赊购，中国的出口开始减少，最终很多企业因为资金链断裂破产。因此出口对中国GDP的贡献从之前的10%下降到2.7%，在2009年进一步降低为-42.9%，从此我国外汇开始减少。</p><p>企业不挣钱了，自然会开始缩减生产规模，进行裁员。记得在2009年的时候香港的电视台还拍摄过广州火车站春节返乡的纪录片，大规模的人员开始返乡，国家如果再不出手，经济问题就会转化为社会问题。</p><p>既然外循环不行了，那就只能想办法提升内循环了，因此4万亿的基建来了，中国的经济发展也开始正式步入内循环发展阶段，其中2008年和2009年两年是一个过渡期。在2010年至今，你会发现中国修公路、建高铁、搞农村基础设施、建保障房，在这个过程中一旦经济开始下滑就房款房地产贷款和购房政策，努力挖掘房地产市场潜力，通过投资和消费带动工业需求，最终盘活了中国的经济。</p><p>但是通过政府为主，银行为辅，企业借款的方式大规模开启基建的方式提振内循环，将会导致3个知名的缺点。</p><h3 id="五、我国内循环引发的三个主要问题"><a href="#五、我国内循环引发的三个主要问题" class="headerlink" title="五、我国内循环引发的三个主要问题"></a>五、我国内循环引发的三个主要问题</h3><ul><li><p>问题1：基建是有周期的，大规模的刺激导致企业不计后果的加杠杆进行生产扩能，最终出现更大规模的产能过剩。</p><blockquote><p>例如：进行高铁线路建设需要购买大量的钢材，这样消耗了当前过剩的钢材，并且产生了更大的钢材需求，但是高铁线路修完后呢？更大规模的产能过剩出现了，再修一条，继续推高产能过剩？即使这样，你要明白，高铁总有修完的一天，并且你修建的高铁如果不能盈利，会对国家的财政造成极大的负担（这就是为什么国家批准高铁公司上市）。这样就开始进入恶性循环，最终这个气球会有兜不住的一天，在违背所有人的期望下”嘭”的炸开（日本的泡沫破碎、美国的次贷危机）。</p></blockquote></li><li><p>问题2：所有的企业都害怕自己错过大放水，拼命的加杠杆，造成企业债台高筑。</p><p>  <code>这个问题中说的企业，狭义指城建，广义指所有房地产相关企业</code></p><blockquote><p>企业的钱从哪里来，当然是银行提供的，银行提供的贷款可不是白用的。正所谓欠债还钱天经地义，借的钱总是要还的，可是我国很多基建不能产生收益啊，一个小县城负债7个亿就不提了。北京的高速、地铁等很多项目都是赔钱的，更何况其它二三四五线城市的基建。城建没钱了，怎么办呢？一般是有三种办法，第一继续加大杠杆发行衍生品种（本系列的文章不讨论此方法）；第二借更多的钱，这就像吸毒，停不下来；第三直接搞破，说我破产了，钱不还了（政府信用破灭，会引发更加严重的危机）。城建只能越借越多，最后多到利息都还不上了，然后其它提供原材料的企业因为无法收款，导致资金链断裂，开始破产、裁员，情况又向糟糕的方向发展了。中国的企业债务有多少呢？这个没有明确的答案，人大在2015年的时候做过一次调查研究，最后得出的结论是98%发债企业的利润根本无法偿还债务利息，在中国买债券，你是在赌博。</p></blockquote></li><li><p>问题3：实体经济受到致命打击，经济开始脱离实际，向虚拟化发展。</p><blockquote><p>这个问题大家应该很清楚了，制造业产能过剩，利润大幅下滑，房地产业高歌猛进，银行越来越不愿意将钱借给制造业，特别喜欢将钱借给”房”，这样房地产业进一步繁荣，制造业被扼杀。所有人都在想着怎么买房，如何将钱弄到房地产业中。这就造成了更加严重的产能过剩、负债高企、脱实就虚，内循环是一剂可行的药方，但副作用很可怕。因此2018年国家提出供给侧改革，已经是到了不改不行的阶段，不改就要出现社会动荡了。</p></blockquote></li></ul><p>后面还有一章，谈谈目前中国经济的情况。</p><h3 id="六、当前的的经济情况"><a href="#六、当前的的经济情况" class="headerlink" title="六、当前的的经济情况"></a>六、当前的的经济情况</h3><p>目前中国的经济情况是：外需不振、内需萎靡、投资下滑。</p><p>目前中国经济面临的三个问题出现时，可以通过外循环+内循环或者内循环的方式来平滑或者过渡吗？带动经济开始新的增长。</p><p>先说答案：恐怕不行。</p><p>接下来详细分析一下目前中国经济的状况。首先中国的产能过剩到底严重到什么程度，为什么我们没有直观的感受到物价下滑反而感觉物价在上涨呢？</p><p>翻一翻统计的数据可以知道，从2016年12月至2020年6月，中国重化工业就不存在不过剩的行业。既然原材料过剩这么多，那么跟我们生活积极相关的行业又怎么样呢？从图1-1中可以看出也是严重过剩。</p><p><img src="/2022/09/14/economy20220814/%E4%BA%A7%E8%83%BD%E8%BF%87%E5%89%A9.jpg" alt="产能过剩"></p><center> 图1-1 轻工业产能过剩情况</center><p>产品过剩了怎么办？前文我们已经给出了解决方案。无非是消费、投资和出口（不知道看到这里，你是不是能明白为什么一带一路了）。但是本节开篇就说了目前中国的经济情况是外需不振、内需萎靡、投资下滑。</p><p>现在的经济是什么情况呢？外需萎靡，内需不振，投资下滑。</p><h3 id="七、出口、消费、投资"><a href="#七、出口、消费、投资" class="headerlink" title="七、出口、消费、投资"></a>七、出口、消费、投资</h3><p>出口对应的是外贸，消费对应的是内需，投资对应基建。</p><p>首先我们分析一下出口。</p><p>从2008年的全球金融危机开始，这几年国际上就动荡不断，美国刚稳定了，欧洲债务危机又开始了，好不容易发达的国家消停了，结果新兴市场开始作妖了，在2017年终于可以出口气了，结果中国要顶不住了。美国衰退、川普上台后的神操作，导致我国从2009年至今出口都很低迷，国家眼看外循环不行，开始不断的强调提振内需。可是回头一看，差点没吓死，房地产业这个脱缰的野马差点将整个中国带入万丈深渊。</p><p>其次我们分析一下投资。</p><p>收到投资就不得不讲基建、城镇化。2009年之后，我们开启了大搞基建的内循环拉动经济，城镇化的进程也进一步加快，每个人都长出了一口气，中国的经济危机过去了，经济又开始突飞猛进。可是就在大家都在欢庆的时候，却忘了内循环的三大问题</p><p>从统计局公布的数据，我们可以看出，全社会固定资产投资的70%以上是制造业投资、基建投资和房地产投资，因此这三个投资能够增长，中国的经济才可以平稳健康的发展。</p><p>2008年就面临产品过剩的经济危机，国家4万亿的放水，也只是掩盖了问题，造就了虚假的繁荣，从2001年开始，制造业投资增速开始转向，从30%开始逐渐降低到2019年的3.1%，从数据可以看出，制造业投资对经济的增长，作用越来越小了。</p><p>基建就不用多说了，相信大家都已经经过城投债的普及了，目前基建对经济的拉动作用也越来越小了。既然制造业、基建都不行了，那我们就搞房地产吧，继续推动炒房来带动经济增长。目前中国的城镇化已经快要结束，此外我国的抚养比（老龄化问题）开始快速增长，现在房屋价格已经是富人的游戏了，跟普通消费者关系不大了，并且从2019年开始我国房地产投资增速也突破10%，加上城镇化的减缓，接下来房地产对经济的增长的作用，也将越来越小。</p><p>在上述三种困境前，国家提出了新基建希望能够发现新的经济增长引擎。但是新基建的放水规模远大于08年，但是其规模体量太小了。新能源、医药和尖端科技的规模体量都远超制造业、基建和房地产，但是这三个行业不是短时间可以开启的，需要经年累月的研发和积累，目前我国还有太多的路要走，可以说这三个也是远水解不了近渴。</p><p>八、消费可以化解目前中国的经济困境吗？</p><p>有经济学家提出：欧美国家的消费开始转移到自己国家内，那么我国可以通过增加本国国民的消费来拉动经济增长。说起来容易，做起来千难万难。</p><p>前文讲过，我国的消费是被动的，不像欧美国家是主动的，所以我们拉动消费需要出口和投资，这样就进入了一个死循环。</p><p>其实从2015年开始我们的人均实际可支配收入就长时间低于人均实际GDP增长率。换句话说，就是工资在降低，失业人员增加，全社会可供消费的工资总量增速加速下滑（这里如果再考虑贫富差距，结果会更可怕），但是我国的房价和房租要么横盘，要么增长，进一步挤压消费。总的来说，就是我国消费萎靡，无法消耗过剩产能。</p><h3 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h3><p>大家都知道我国大量放水，但是我国的CPI为什么没有大幅增长？因为统计局将房子移出统计范围了。因为我国有200多万亿的超发货币（绝对的世界之最，即使美国的无线QE也没有超过中国）被圈在房地产市场里面，甚至有人将房地产称为人民币的锚。正是因为房地产留住了大量的钱，所以中国没有中产，社会才能保持稳定。从这个角度说政府最希望的是房地产横盘，所以房地产下跌到一定程度就放点水滋润一下房地产让其暴涨一波。这种方式也早就了房地产神话，让所有的人都相信中国的房子不会下跌，大家会想尽一切办法，加杠杆将资金投入房地产，这样投资和消费会进一步萎缩。</p><p>泡沫终有破灭的时候，到时我们面临的不但是经济增长的停滞，还有巨量的货币涌向市场导致的通货膨胀，从而导致中国的经济出现滞胀。</p><hr><p> 转载链接 <a href="https://zhuanlan.zhihu.com/p/434423560">知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 社科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ebooks</title>
      <link href="/2022/08/02/ebooks/"/>
      <url>/2022/08/02/ebooks/</url>
      
        <content type="html"><![CDATA[<h2 id="搜书网站"><a href="#搜书网站" class="headerlink" title="搜书网站"></a>搜书网站</h2><h3 id="https-sobooks-net-books-18957-html"><a href="#https-sobooks-net-books-18957-html" class="headerlink" title="https://sobooks.net/books/18957.html"></a><a href="https://sobooks.net/books/18957.html">https://sobooks.net/books/18957.html</a></h3>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用rabbitMQ实现聊天消息的转发</title>
      <link href="/2022/06/18/rabbitMQ/"/>
      <url>/2022/06/18/rabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><h2 id="项目结构图"><a href="#项目结构图" class="headerlink" title="项目结构图"></a>项目结构图</h2><p><img src="/2022/06/18/rabbitMQ/2022-06-20_pro.png" alt="2022-06-20_pro"></p><h2 id="父pom文件"><a href="#父pom文件" class="headerlink" title="父pom文件"></a>父pom文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.spt&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cloud_mq&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;mq_rabbit&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;mq_rabbit02&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;mq_rabbit03_spring&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;cloud_mq&lt;/name&gt;</span><br><span class="line">    &lt;!-- FIXME change it to the project&#x27;s website --&gt;</span><br><span class="line">    &lt;url&gt;http://www.example.com&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--  因为是总项目 所以用dependencyManagement来管理  因为其他的子项目就不会来管理版本了了 可以直接引用 --&gt;</span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;!-- springboot的依赖--&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="子模块结构图"><a href="#子模块结构图" class="headerlink" title="子模块结构图"></a>子模块结构图</h2><p><img src="/2022/06/18/rabbitMQ/2022-06-20_model.png" alt="2022-06-20_model"></p><h2 id="子模块pom文件"><a href="#子模块pom文件" class="headerlink" title="子模块pom文件"></a>子模块pom文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;artifactId&gt;cloud_mq&lt;/artifactId&gt;</span><br><span class="line">    &lt;groupId&gt;com.spt&lt;/groupId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">  &lt;artifactId&gt;mq_rabbit&lt;/artifactId&gt;</span><br><span class="line">  &lt;name&gt;mq_rabbit&lt;/name&gt;</span><br><span class="line">  &lt;!-- FIXME change it to the project&#x27;s website --&gt;</span><br><span class="line">  &lt;url&gt;http://www.example.com&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="子模块配置文件"><a href="#子模块配置文件" class="headerlink" title="子模块配置文件"></a>子模块配置文件</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spirng-boot-rabbitmq</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtualHost:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><h3 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h3><ul><li><strong>host</strong> : rabbitMQ服务的地址</li><li><strong>port</strong> : rabbitMQ服务的端口 (5672为mq应用访问端口,15672为web访问端口)</li><li><strong>password</strong> : 密码</li><li><strong>username</strong> : 用户名</li><li><strong>virtualHost</strong> : 虚拟消息服务器 (每个VirtualHost相当于一个相对独立的RabbitMQ服务器；每个VirtualHost之间是相互隔离的，exchange、queue、message不能互通。 )</li></ul><h3 id="RabbitMQ配置参数详解"><a href="#RabbitMQ配置参数详解" class="headerlink" title="RabbitMQ配置参数详解:"></a>RabbitMQ配置参数详解:</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基础信息</span></span><br><span class="line"><span class="attr">spring.rabbitmq.host</span>: <span class="string">默认localhost</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>: <span class="string">默认5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>: <span class="string">用户名</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>: <span class="string">密码</span></span><br><span class="line"><span class="attr">spring.rabbitmq.virtual-host</span>: <span class="string">连接到代理时用的虚拟主机</span></span><br><span class="line"><span class="attr">spring.rabbitmq.addresses</span>: <span class="string">连接到server的地址列表（以逗号分隔），先addresses后host </span></span><br><span class="line"><span class="attr">spring.rabbitmq.requested-heartbeat</span>: <span class="string">请求心跳超时时间，0为不指定，如果不指定时间单位默认为妙</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-confirms</span>: <span class="string">是否启用【发布确认】，默认false</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-returns</span>: <span class="string">是否启用【发布返回】，默认false</span></span><br><span class="line"><span class="attr">spring.rabbitmq.connection-timeout</span>: <span class="string">连接超时时间，单位毫秒，0表示永不超时 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#SSL</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.enabled</span>: <span class="string">是否支持ssl，默认false</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.key-store</span>: <span class="string">持有SSL certificate的key store的路径</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.key-store-password</span>: <span class="string">访问key store的密码</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.trust-store</span>: <span class="string">持有SSL certificates的Trust store</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.trust-store-password</span>: <span class="string">访问trust store的密码</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.trust-store-type</span>=<span class="string">JKS：Trust store 类型.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.algorithm</span>: <span class="string">ssl使用的算法，默认由rabiitClient配置</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.validate-server-certificate</span>=<span class="string">true：是否启用服务端证书验证</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.verify-hostname</span>=<span class="string">true 是否启用主机验证</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#缓存cache</span></span><br><span class="line"><span class="attr">spring.rabbitmq.cache.channel.size</span>: <span class="string">缓存中保持的channel数量</span></span><br><span class="line"><span class="attr">spring.rabbitmq.cache.channel.checkout-timeout</span>: <span class="string">当缓存数量被设置时，从缓存中获取一个channel的超时时间，单位毫秒；如果为0，则总是创建一个新channel</span></span><br><span class="line"><span class="attr">spring.rabbitmq.cache.connection.size</span>: <span class="string">缓存的channel数，只有是CONNECTION模式时生效</span></span><br><span class="line"><span class="attr">spring.rabbitmq.cache.connection.mode</span>=<span class="string">channel: 连接工厂缓存模式：channel 和 connection</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Listener</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.type</span>=<span class="string">simple: 容器类型.simple或direct</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.auto-startup</span>=<span class="string">true: 是否启动时自动启动容器</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.acknowledge-mode</span>: <span class="string">表示消息确认方式，其有三种配置方式，分别是none、manual和auto；默认auto</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.concurrency</span>: <span class="string">最小的消费者数量</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.max-concurrency</span>: <span class="string">最大的消费者数量</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.prefetch</span>: <span class="string">一个消费者最多可处理的nack消息数量，如果有事务的话，必须大于等于transaction数量.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.transaction-size</span>: <span class="string">当ack模式为auto时，一个事务（ack间）处理的消息数量，最好是小于等于prefetch的数量.若大于prefetch， 则prefetch将增加到这个值</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.default-requeue-rejected</span>: <span class="string">决定被拒绝的消息是否重新入队；默认是true（与参数acknowledge-mode有关系）</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.missing-queues-fatal</span>=<span class="string">true 若容器声明的队列在代理上不可用，是否失败； 或者运行时一个多多个队列被删除，是否停止容器</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.idle-event-interval</span>: <span class="string">发布空闲容器的时间间隔，单位毫秒</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.retry.enabled</span>=<span class="string">false: 监听重试是否可用</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.retry.max-attempts</span>=<span class="string">3: 最大重试次数</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.retry.max-interval</span>=<span class="string">10000ms: 最大重试时间间隔</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.retry.initial-interval</span>=<span class="string">1000ms:第一次和第二次尝试传递消息的时间间隔</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.retry.multiplier</span>=<span class="string">1: 应用于上一重试间隔的乘数</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.retry.stateless</span>=<span class="string">true: 重试时有状态or无状态</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.acknowledge-mode</span>= <span class="string">ack模式</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.auto-startup</span>=<span class="string">true 是否在启动时自动启动容器</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.consumers-per-queue</span>= <span class="string">每个队列消费者数量.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.default-requeue-rejected</span>= <span class="string">默认是否将拒绝传送的消息重新入队.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.idle-event-interval</span>= <span class="string">空闲容器事件发布时间间隔.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.missing-queues-fatal</span>=<span class="string">false若容器声明的队列在代理上不可用，是否失败.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.prefetch</span>= <span class="string">每个消费者可最大处理的nack消息数量.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.retry.enabled</span>=<span class="string">false  是否启用发布重试机制.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.retry.initial-interval</span>=<span class="string">1000ms # Duration between the first and second attempt to deliver a message.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.retry.max-attempts</span>=<span class="string">3 # Maximum number of attempts to deliver a message.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.retry.max-interval</span>=<span class="string">10000ms # Maximum duration between attempts.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.retry.multiplier</span>=<span class="string">1 # Multiplier to apply to the previous retry interval.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.retry.stateless</span>=<span class="string">true # Whether retries are stateless or stateful.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Template</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.mandatory</span>: <span class="string">启用强制信息；默认false</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.receive-timeout</span>: <span class="string">receive() 操作的超时时间</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.reply-timeout</span>: <span class="string">sendAndReceive() 操作的超时时间</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.retry.enabled</span>=<span class="string">false: 发送重试是否可用 </span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.retry.max-attempts</span>=<span class="string">3: 最大重试次数</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.retry.initial-interva</span>=<span class="string">1000msl: 第一次和第二次尝试发布或传递消息之间的间隔</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.retry.multiplier</span>=<span class="string">1: 应用于上一重试间隔的乘数</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.retry.max-interval</span>=<span class="string">10000: 最大重试时间间隔</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考:<br>1.<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#integration-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#integration-properties</a><br>2.<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/html/common-application-properties.html">https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/html/common-application-properties.html</a></p><h1 id="springBoot整合rabbitMQ"><a href="#springBoot整合rabbitMQ" class="headerlink" title="springBoot整合rabbitMQ"></a>springBoot整合rabbitMQ</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>父模块引入spring-boot-dependencies确定版本后,子模块不写版本号,会使用默认版本<br><img src="/2022/06/18/rabbitMQ/2022-06-20_model_mvn.png" alt="2022-06-20_model_mvn"><h2 id="配置MQ"><a href="#配置MQ" class="headerlink" title="配置MQ"></a>配置MQ</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">//fanout</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FANOUT_QUEUE1</span> <span class="operator">=</span> <span class="string">&quot;fanout.queue1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FANOUT_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;fanout.exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fanout模式</span></span><br><span class="line"><span class="comment">     * Fanout 就是我们熟悉的广播模式或者订阅模式，给Fanout交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(FANOUT_QUEUE1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(FANOUT_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">fanoutBinding1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>这里使用了rabbitMQ的fanout模式:<br><img src="/2022/06/18/rabbitMQ/2022-06-20_rabbit_fanout.png" alt="2022-06-20_rabbit_fanout"><blockquote><p><strong>Fanout</strong> :  这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的 所有队列中。系统中默认有些exchange 类型</p></blockquote><h2 id="发送者和接受者"><a href="#发送者和接受者" class="headerlink" title="发送者和接受者"></a>发送者和接受者</h2><h3 id="发送者代码"><a href="#发送者代码" class="headerlink" title="发送者代码:"></a>发送者代码:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutSender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String MSG_FROM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        MSG_FROM = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rabbitTemplate.convertAndSend(RabbitConfig.FANOUT_EXCHANGE, <span class="string">&quot;&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(MqMsgDto msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rabbitTemplate.convertAndSend(RabbitConfig.FANOUT_EXCHANGE, <span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收者代码"><a href="#接收者代码" class="headerlink" title="接收者代码:"></a>接收者代码:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutReceiver</span> &#123;</span><br><span class="line">    <span class="comment">// queues是指要监听的队列的名字</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = RabbitConfig.FANOUT_QUEUE1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveTopic1</span><span class="params">(MqMsgDto msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【项目A,receiveFanout监听到消息】&quot;</span> + msg);</span><br><span class="line">        <span class="keyword">if</span> (!MSG_FROM.equals(msg.getFrom())) &#123;</span><br><span class="line">            <span class="comment">//mq转发--RECEIVE_MESSAGE--</span></span><br><span class="line">            System.out.println(<span class="string">&quot;项目A,mq转发--RECEIVE_MESSAGE--&quot;</span> + msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>请注意 <strong>MSG_FROM</strong> 该静态变量是一个标识,标识消息从哪个应用发出,在接收消息时,判断消息是否为”自己”发出的,是:不转发,否:转发</li></ul><h2 id="具体业务类"><a href="#具体业务类" class="headerlink" title="具体业务类"></a>具体业务类</h2><h3 id="api"><a href="#api" class="headerlink" title="api :"></a>api :</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SendMsgEvent sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/msg/send&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">snedMsg</span><span class="params">(<span class="meta">@RequestBody</span> MsgDto msg)</span> &#123;</span><br><span class="line">        <span class="type">MqMsgDto</span> <span class="variable">mqMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MqMsgDto</span>(MSG_FROM, msg);</span><br><span class="line">        sender.setMsg(mqMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息数据类"><a href="#消息数据类" class="headerlink" title="消息数据类"></a>消息数据类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgDto</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MsgDto</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MsgDto</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MsgDto&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;msg=&#x27;&quot;</span> + msg + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MQ数据传输类"><a href="#MQ数据传输类" class="headerlink" title="MQ数据传输类"></a>MQ数据传输类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqMsgDto</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="keyword">private</span> MsgDto mag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFrom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFrom</span><span class="params">(String from)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.from = from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MsgDto <span class="title function_">getMag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMag</span><span class="params">(MsgDto mag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mag = mag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MqMsgDto</span><span class="params">(String from, com.spt.chat.entity.MsgDto mag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.from = from;</span><br><span class="line">        <span class="built_in">this</span>.mag = mag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MqMsgDto&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;from=&#x27;&quot;</span> + from + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, mag=&quot;</span> + mag +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMsgEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    FanoutSender msgSender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(MqMsgDto msg)</span>&#123;</span><br><span class="line">        <span class="comment">//转发RECEIVE_MESSAGE</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A项目转发--RECEIVE_MESSAGE--消息&quot;</span>+msg);</span><br><span class="line">        <span class="comment">//将消息发送只mq</span></span><br><span class="line">        msgSender.sendMsg(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此,springBoot整合MQ部分完毕</p><h1 id="运行-amp-结果"><a href="#运行-amp-结果" class="headerlink" title="运行&amp;结果"></a>运行&amp;结果</h1><blockquote><p>同样的方式,创建子模块:mq_rabbit02,mq_rabbit03  (记得修改yml文件哟~~)</p></blockquote><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p><img src="/2022/06/18/rabbitMQ/2022-06-20_run.png" alt="2022-06-20_run"></p><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p><img src="/2022/06/18/rabbitMQ/2022-06-20_req_postman.png" alt="2022-06-20_req_postman"></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="mq-rabbit01"><a href="#mq-rabbit01" class="headerlink" title="mq_rabbit01"></a>mq_rabbit01</h3><blockquote><p>localhost:8001&#x2F;msg&#x2F;send请求到服务mq_rabbit上,mq_rabbit发送消息,监听消息,判断是”自己”发的后,不转发</p></blockquote><p><img src="/2022/06/18/rabbitMQ/2022-06-20_22-01.png" alt="2022-06-20_22-01"></p><h3 id="mq-rabbit02"><a href="#mq-rabbit02" class="headerlink" title="mq_rabbit02"></a>mq_rabbit02</h3><blockquote><p>mq_rabbit02,监听消息,判断消息不是”自己”发的后,转发</p></blockquote><p><img src="/2022/06/18/rabbitMQ/2022-06-20_22-02.png" alt="2022-06-20_22-02"></p><h3 id="mq-rabbit03"><a href="#mq-rabbit03" class="headerlink" title="mq_rabbit03"></a>mq_rabbit03</h3><blockquote><p>mq_rabbit03,监听消息,判断消息不是”自己”发的后,转发</p></blockquote><p><img src="/2022/06/18/rabbitMQ/2022-06-20_22-03.png" alt="2022-06-20_22-03"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的一些货物清单</title>
      <link href="/2022/06/14/goods/"/>
      <url>/2022/06/14/goods/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于月底要搬新家了,就要告别自己租了一年的房子了,租的房子里自己的购买的一些家具,家电,桌桌椅椅,花花草草,要给他们找个新主人了,欢迎各位前来围观…</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我的联系方式</span><br><span class="line"> - 微信:start-spt</span><br><span class="line"> - 电话:15311997163</span><br></pre></td></tr></table></figure><table><thead><tr><th>物品名</th><th>价格(元)</th></tr></thead><tbody><tr><td><a href="#img1">图一</a>,餐桌</td><td>40</td></tr><tr><td><a href="#img2">图二</a>,床(宽150cm)</td><td>100</td></tr><tr><td><a href="#img2">图二</a>,柜子</td><td>随床赠送,单买50</td></tr><tr><td><a href="#img2">图二</a>,椅子</td><td>60</td></tr><tr><td><a href="#img2">图二</a>,桌子</td><td>随床赠送,单买30</td></tr><tr><td><a href="#img3">图三</a>,床(宽120cm)</td><td>80 (附赠桌子,类似图二桌子)</td></tr><tr><td><a href="#img4">图四</a>,油烟机(美的)</td><td>400</td></tr><tr><td><a href="#img4">图四</a>,燃气灶(美的)</td><td>300</td></tr><tr><td><a href="#img5">图五</a>,橱柜(大的长160cm,小的长120)</td><td>540</td></tr><tr><td><a href="#img6">图六</a>,热水器(海尔&#x2F;60升)</td><td>380</td></tr><tr><td><a href="#img7">图七</a>,床(宽150cm)</td><td>100(赠送床头柜)</td></tr><tr><td>以上电器均有发票,九成新质量好,附近邻居可来家查看</td><td></td></tr></tbody></table><p><a id="img1">图一</a><br><img src="/2022/06/14/goods/1.jpg" alt="image-1"><br><a id="img2">图二</a><br><img src="/2022/06/14/goods/2.jpg" alt="image-2"><br><a id="img3">图三</a><br><img src="/2022/06/14/goods/3.jpg" alt="image-3"><br><a id="img4">图四</a><br><img src="/2022/06/14/goods/4.jpg" alt="image-4"><br><a id="img5">图五</a><br><img src="/2022/06/14/goods/5.jpg" alt="image-5"><br><a id="img6">图六</a><br><img src="/2022/06/14/goods/6.jpg" alt="image-6"><br><a id="img7">图七</a><br><img src="/2022/06/14/goods/7.jpg" alt="image-7"></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> goods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Hexo中使用本地图片</title>
      <link href="/2022/06/13/hexo-local-image/"/>
      <url>/2022/06/13/hexo-local-image/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>使用Hexo编写博文时，根据Hexo的官方文档使用起来不方便（无法直观地在本地markdown语法显现）。引用站外图片或图床时则不方便本地化操作。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用 hexo-asset-image 插件（hexo5版本以上建议使用 hexo-asset-image-for-hexo5 ）可以解决问题。</p><blockquote><p>经测试，hexo-asset-image-for-hexo5 插件在使用 Hexo 的 6.0 版本中有效。</p></blockquote><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>① 在hexo主目录安装插件，在bash中输入：npm install hexo-asset-image-for-hexo5 –save<br>② 在主目录的_config.yml文件中查找并修改post_asset_folder值为true：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>③ 在md文件的同级目录里创建同名文件夹，例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├─article</span><br><span class="line">├──test.png</span><br><span class="line">└─article.md</span><br></pre></td></tr></table></figure><p>④ 写法：在文章里即可使用<code>![](./article/test.png)</code>在本地显示图片test.png，同时在静态网页中也可以正常显示。</p><blockquote><p>注意事项：</p></blockquote><ul><li>1、创建文件夹名称要和md文件名称保持一致；</li><li>2、设置post_asset_folder: true后，若使用 hexo new 命令创建新博文时会自动创建同名文件夹；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE总结</title>
      <link href="/2022/06/13/javaSE/"/>
      <url>/2022/06/13/javaSE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、java基础"><a href="#一、java基础" class="headerlink" title="一、java基础"></a>一、java基础</h1><p>java 语言的特点：<strong>跨平台性</strong>：<strong>一次编译,到处运行write once,run anywhere</strong>。java程序是运行在jvm中的，不能操作体统有着不同平台的jvm.</p><p>jdk 包含了jre+开发工具集</p><p>jre 包含了jvm +javaSE标准类库</p><p><img src="/2022/06/13/javaSE/image-20211007194902014.png" alt="image-20211007194902014"></p><p><img src="/2022/06/13/javaSE/image-20211007200033099.png" alt="image-20211007200033099"></p><p>API：Application Programming Interface,应用程序编程接口。</p><h2 id="1-1、基本语法"><a href="#1-1、基本语法" class="headerlink" title="1.1、基本语法"></a>1.1、基本语法</h2><p>应用程序 &#x3D; 算法 + 数据结构</p><p><img src="/2022/06/13/javaSE/image-20220515150842061.png" alt="image-20220515150842061"></p><h2 id="1-2、数组"><a href="#1-2、数组" class="headerlink" title="1.2、数组"></a>1.2、数组</h2><blockquote><p>数组的理解</p></blockquote><p>数组Array,是多个相同类型数据按一定顺序排列的集合。并使用一个名字命名，通过编号的方式对这些数据进行统一管理</p><blockquote><p>数组特点</p></blockquote><ul><li>数组是有序排列的</li><li>数组属于引用数据类型的变量，数组的元素可以是基本数据类型，也可以是引用数据类型</li><li>创建数组对象会在内存中开辟一整块连续的内存空间</li><li>数组长度一旦确定，就不能修改</li></ul><blockquote><p>数组的分类</p></blockquote><ul><li>按照维数：一维数组、二维数组……</li><li>按照数组元素类型：基本数据类型元素的数组、引用数据类型的数组</li></ul><blockquote><p>数据结构</p></blockquote><p>1、数据与数据之间的逻辑关系：集合、一对一、一对多（二叉树）、多对多（社交网络）</p><p>2、数据的存储结构：线性表（比如：数组）、链表、栈、队列、树形结构：二叉树</p><h3 id="1-2-1一维数组"><a href="#1-2-1一维数组" class="headerlink" title="1.2.1一维数组"></a>1.2.1一维数组</h3><p><strong>一维数组的声明和初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;<span class="comment">//声明</span></span><br><span class="line">num = <span class="number">10</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;<span class="comment">//声明 + 初始化</span></span><br><span class="line"><span class="type">int</span>[] ids;<span class="comment">//声明</span></span><br><span class="line"><span class="comment">//1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行</span></span><br><span class="line">ids = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>&#125;;</span><br><span class="line"><span class="comment">//1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>[] arr4 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//类型推断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误方式</span></span><br><span class="line"><span class="comment">//int[] arr1 = new int[];</span></span><br><span class="line"><span class="comment">//int[5] arr2 = new int[5];</span></span><br><span class="line"><span class="comment">//int[] arr3 = new int[3]&#123;1,2,3&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>一维数组元素的引用</strong></p><p>通过角标的方式调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组的角标（或索引从0开始的，到数组的长度-1结束。</span></span><br><span class="line">names[<span class="number">0</span>] = <span class="string">&quot;王铭&quot;</span>;</span><br><span class="line">names[<span class="number">1</span>] = <span class="string">&quot;王赫&quot;</span>;</span><br><span class="line">names[<span class="number">2</span>] = <span class="string">&quot;张学良&quot;</span>;</span><br><span class="line">names[<span class="number">3</span>] = <span class="string">&quot;孙居龙&quot;</span>;</span><br><span class="line">names[<span class="number">4</span>] = <span class="string">&quot;王宏志&quot;</span>;<span class="comment">//charAt(0)</span></span><br></pre></td></tr></table></figure><p><strong>数组的属性：length</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(names.length);<span class="comment">//5</span></span><br><span class="line">System.out.println(ids.length);</span><br></pre></td></tr></table></figure><blockquote><p>说明： 数组一旦初始化，其长度就是确定的。arr.length 数组长度一旦确定，就不可修改</p></blockquote><p><strong>一维数组遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; names.length;i++)&#123;</span><br><span class="line">System.out.println(names[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一维数组元素默认初始化值</strong></p><ul><li>数组元素是整型：0</li><li>数组元素是浮点型：0.0</li><li>数组元素是char型：0或’\u0000’，而非’0’</li><li>数组元素是boolean型：false</li><li>数组元素是引用数据类型：null</li></ul><p><strong>一维数组的内存结构</strong></p><p><img src="/2022/06/13/javaSE/image-20220515194449091.png" alt="image-20220515194449091"></p><h3 id="1-2-2、二维数组"><a href="#1-2-2、二维数组" class="headerlink" title="1.2.2、二维数组"></a>1.2.2、二维数组</h3><p>数组属于引用数据类型 数组的元素也可以是引用数据类型 一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组。</p><p><strong>二维数组的声明和初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//一维数组</span></span><br><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">int</span>[][] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//动态初始化1</span></span><br><span class="line">String[][] arr2 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//动态初始化2</span></span><br><span class="line">String[][] arr3 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="comment">//也是正确的写法：</span></span><br><span class="line"><span class="type">int</span>[] arr4[] = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span>[] arr5[] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;<span class="comment">//类型推断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误方式</span></span><br><span class="line"><span class="comment">//String[][] arr4 = new String[][4];</span></span><br><span class="line"><span class="comment">//String[4][3] arr5 = new String[][];</span></span><br><span class="line"><span class="comment">//int[][] arr6 = new int[4][3]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>调用二维数组元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数说明：0：第几个元素，1：该元素下标</span></span><br><span class="line">System.out.println(arr1[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">//2</span></span><br><span class="line">System.out.println(arr2[<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">arr3[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line">System.out.println(arr3[<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">//null</span></span><br><span class="line">System.out.println(arr3[<span class="number">0</span>]);<span class="comment">//null</span></span><br></pre></td></tr></table></figure><p><strong>遍历二维数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr4.length;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr4[i].length;j++)&#123;</span><br><span class="line">System.out.print(arr4[i][j] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二维数组元素的默认初始化值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* 规定：二维数组分为外层数组的元素，内层数组的元素</span><br><span class="line">* <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line">* 外层元素：arr[<span class="number">0</span>],arr[<span class="number">1</span>]等</span><br><span class="line">* 内层元素：arr[<span class="number">0</span>][<span class="number">0</span>],arr[<span class="number">1</span>][<span class="number">2</span>]等</span><br><span class="line">* </span><br><span class="line">*   ⑤ 数组元素的默认初始化值 </span><br><span class="line">*   针对于初始化方式一：比如：<span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line">*      外层元素的初始化值为：地址值</span><br><span class="line">*      内层元素的初始化值为：与一维数组初始化情况相同</span><br><span class="line">*      </span><br><span class="line">*   针对于初始化方式二：比如：<span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br><span class="line">*   外层元素的初始化值为：<span class="literal">null</span></span><br><span class="line">*      内层元素的初始化值为：不能调用，否则报错。</span><br></pre></td></tr></table></figure><p><strong>二维数组内存结构</strong></p><p><img src="/2022/06/13/javaSE/image-20220515204417549.png" alt="image-20220515204417549"> </p><h3 id="1-2-3、数组的常见算法"><a href="#1-2-3、数组的常见算法" class="headerlink" title="1.2.3、数组的常见算法"></a>1.2.3、数组的常见算法</h3><p>1、数组的创建于元素的赋值</p><p>杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。</p><blockquote><p>杨辉三角</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.新建二位数组，动态初始化</span></span><br><span class="line"><span class="type">int</span>[][] yangHui = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][];</span><br><span class="line"><span class="comment">// 2.为二维数组赋值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; yangHui.length; i++) &#123;</span><br><span class="line">    yangHui[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 2.1为首末元素赋值</span></span><br><span class="line">    yangHui[i][<span class="number">0</span>] = yangHui[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 2.2为其余元素赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; yangHui[i].length - <span class="number">1</span>; j++) &#123;<span class="comment">//</span></span><br><span class="line">        yangHui[i][j] = yangHui[i - <span class="number">1</span>][j - <span class="number">1</span>] + yangHui[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.打印输出二维数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; yangHui.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; yangHui[i].length; j++) &#123;<span class="comment">// 第0个位置没有元素</span></span><br><span class="line">        System.out.print(yangHui[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、对于数值型的数组</p><p>最大值、最小值、总和、平均数等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.找到数组中的最大值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxArr</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxArr &lt; arr[i]) &#123;</span><br><span class="line">        maxArr = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;数组中的最大值为：&quot;</span> + maxArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.找到数组中的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">minArr</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (minArr &gt; arr[i]) &#123;</span><br><span class="line">        minArr = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;数组中的最小值为：&quot;</span> + minArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.找到数组中的平均数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    num += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;数组的平均数为：&quot;</span> + (num / arr.length));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.求总和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    num1 += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;数组的总和为：&quot;</span> + num1);</span><br></pre></td></tr></table></figure><p>3、数组的赋值与复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] str = &#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line">      <span class="comment">// 1.数组的赋值</span></span><br><span class="line">      String[] str1 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">      str1 = str;</span><br><span class="line">      str1[<span class="number">2</span>] = <span class="string">&quot;AA&quot;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">          System.out.print(str[i] + <span class="string">&quot; &quot;</span>);<span class="comment">//aa bb AA</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>赋值</strong></p><p>将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体。</p><p><img src="/2022/06/13/javaSE/image-20220515221658500.png" alt="image-20220515221658500"> </p><p><strong>复制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1数组的复制</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">    str1[i] = str[i];</span><br><span class="line">    System.out.print(str1[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过new的方式，给array2在堆空间中新开辟了数组的空间。将array1数组中的元素值一个一个的赋值到array2数组中。</p><p><img src="/2022/06/13/javaSE/image-20220515221804241.png" alt="image-20220515221804241"> </p><p><strong>4、数组元素的反转</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length / <span class="number">2</span>;i++)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[arr.length - i -<span class="number">1</span>];</span><br><span class="line">    arr[arr.length - i -<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = arr.length - <span class="number">1</span>;i &lt; j;i++,j--)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、数组中指定元素的查找：</strong></p><p><strong>线性查找</strong></p><p>实现思路：通过遍历的方式，一个一个的数据进行比较、查找。 适用性：具有普遍适应性</p><p><strong>二分查找</strong></p><p>实现思路：每次比较中间值，折半的方式检索。 适用性：（前提：数组必须有序）</p><h3 id="1-2-4、排序算法"><a href="#1-2-4、排序算法" class="headerlink" title="1.2.4、排序算法"></a>1.2.4、排序算法</h3><blockquote><p>十大排序算法</p></blockquote><ul><li>选择排序：<ul><li>直接选择排序、堆排序</li></ul></li><li>交换排序：<ul><li>冒泡排序、快速排序</li></ul></li><li>插入排序：<ul><li>直接插入排序、折半插入排序、希尔排序</li></ul></li><li>归并排序</li><li>桶排序</li><li>基数排序</li></ul><p>理解：</p><p> 1）衡量排序算法的优劣：</p><p> 时间复杂度、空间复杂度、稳定性</p><p>2）排序的分类：内部排序 与 外部排序（需要借助磁盘）</p><p>3）不同排序算法的时间复杂度</p><p><img src="/2022/06/13/javaSE/image-20220515225242922.png" alt="image-20220515225242922"> </p><blockquote><p>冒泡排序的实现</p><p><strong>需经过n-1轮排序</strong></p></blockquote><p><img src="/2022/06/13/javaSE/image-20220515231845127.png" alt="image-20220515231845127"></p><p><img src="/2022/06/13/javaSE/image-20220515232010978.png" alt="image-20220515232010978"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">21</span>, <span class="number">43</span>, <span class="number">64</span>, <span class="number">76</span>, <span class="number">878</span>, <span class="number">432</span>, <span class="number">21</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i -<span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;<span class="comment">//对比前后值大小，满足条件后交换位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/06/13/javaSE/image-20220515231544873.png" alt="image-20220515231544873"></p><blockquote><p>选择排序</p><p>每一次从待排序的数据元素中选出最小的一个元素，存放在序列的起始位置，然后再从剩余未排序元素中寻找到最小元素，然后放到已排序序列的末尾，以此类推</p><p><strong>特点：</strong>在排序中每一轮比较会把最小的数移到最前，所以相互比较的次数每一轮都会比前一轮少一次。</p></blockquote><p><img src="/2022/06/13/javaSE/image-20220515232723049.png" alt="image-20220515232723049"></p><h3 id="1-2-5、数据结构"><a href="#1-2-5、数据结构" class="headerlink" title="1.2.5、数据结构"></a>1.2.5、数据结构</h3><h3 id="1-2-6、Arrays工具类的使用"><a href="#1-2-6、Arrays工具类的使用" class="headerlink" title="1.2.6、Arrays工具类的使用"></a>1.2.6、Arrays工具类的使用</h3><blockquote><p>① 定义在java.util包下。 ② Arrays:提供了很多操作数组的方法。</p></blockquote><blockquote><p>使用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">21</span>, <span class="number">43</span>, <span class="number">542</span>, <span class="number">432</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr2[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">32</span>, <span class="number">43</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">76</span>, <span class="number">54</span>, <span class="number">68</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.Arrays.equals(arr1, arr2):判断数组是否相等</span></span><br><span class="line">System.out.println(Arrays.equals(arr1, arr2));</span><br><span class="line"><span class="comment">// 2.Arrays.toString(arr1):输出数组信息</span></span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.Arrays.fill(arr1, 2):将指定值填充到数组中</span></span><br><span class="line">Arrays.fill(arr1, <span class="number">2</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"><span class="comment">// 4.Arrays.sort(arr2):对数组进行排序</span></span><br><span class="line">Arrays.sort(arr2);</span><br><span class="line">System.out.println(Arrays.toString(arr2));</span><br><span class="line"><span class="comment">// 5.Arrays.binarySearch(arr2, 1):堆排序好的数组用二分法检索指定值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr2, <span class="number">1</span>);</span><br><span class="line">System.out.println(index);</span><br></pre></td></tr></table></figure><h3 id="1-2-7、数组常见异常"><a href="#1-2-7、数组常见异常" class="headerlink" title="1.2.7、数组常见异常"></a>1.2.7、数组常见异常</h3><p><strong>1、数组角标越界异常：ArrayIndexOutOfBoundsException</strong></p><p><strong>2、空指针异常：NullPointerException</strong></p><h2 id="1-3、面向对象三大特征"><a href="#1-3、面向对象三大特征" class="headerlink" title="1.3、面向对象三大特征"></a>1.3、面向对象三大特征</h2><h4 id="1-3-1、封装"><a href="#1-3-1、封装" class="headerlink" title="1.3.1、封装"></a>1.3.1、封装</h4><p>我们程序设计追求“高内聚，低耦合”</p><ul><li>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</li><li>低耦合：仅对外暴露少量的方法用于使用。</li></ul><p><strong>隐藏对象内部的复杂性，只对外公开简单的接口。</strong>便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露岀来。这就是封装性的设计思想。</p><blockquote><p><strong>封装性思想具体代码的体现</strong></p><p>1、将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//private属性私有化</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRadius</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRadius</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、不对外暴露的私有的方法</p><p>3、单例模式（将构造器私有化）</p><p>4、如果不希望类在包外被调用，可以将类设置为缺省的。</p></blockquote><p><strong>Java规定的四种权限修饰符</strong></p><p>通过对不同的方法属性设置不同的权限修饰符来达到对类进行封装的目的。</p><ul><li>权限从小到大顺序为：private &lt; 缺省 &lt; protected &lt; public</li><li>具体的修饰范围：</li></ul><table><thead><tr><th align="left">修饰符</th><th>类内部</th><th>同一个包</th><th>不同包的子类</th><th align="left">同一个工程</th></tr></thead><tbody><tr><td align="left">private</td><td>Yes</td><td></td><td></td><td align="left"></td></tr><tr><td align="left">（缺省）</td><td>Yes</td><td>Yes</td><td></td><td align="left"></td></tr><tr><td align="left">protected</td><td>Yes</td><td>Yes</td><td>Yes</td><td align="left"></td></tr><tr><td align="left">public</td><td>Yes</td><td>Yes</td><td>Yes</td><td align="left">Yes</td></tr></tbody></table><p><img src="/2022/06/13/javaSE/image-20220517001319208.png" alt="image-20220517001319208"> </p><p><strong>权限修饰符可用来修饰的结构说明</strong>：</p><ul><li>4种权限都可以用来修饰<strong>类的内部结构</strong>：属性、方法、构造器、内部类</li><li><strong>修饰类</strong>，只能使用：缺省、public</li></ul><h4 id="1-3-2、继承"><a href="#1-3-2、继承" class="headerlink" title="1.3.2、继承"></a>1.3.2、继承</h4><blockquote><p>引入继承的好处：</p></blockquote><ul><li>减少了代码的冗余，提高了代码的复用性</li><li>便于功能的扩展</li><li>为之后多态性的使用，提供了前提</li></ul><p><img src="/2022/06/13/javaSE/image-20220517001655002.png" alt="image-20220517001655002"> </p><blockquote><p>继承性的格式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125;</span><br><span class="line"> *    A:子类、派生类、subclass</span><br><span class="line"> *    B:父类、超类、基类、superclass</span><br></pre></td></tr></table></figure><p>判断是否要进行继承：A is a B,若成立，则B继承A</p><blockquote><p>子类继承父类后有哪些不同</p></blockquote><ul><li><p>子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。</p></li><li><p>子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。</p></li></ul><blockquote><p>继承性说明</p></blockquote><ol><li>一个类可以被多个子类继承。</li><li>Java中类的单继承性：一个类只能有一个父类</li><li>子父类是相对的概念。</li><li>子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类</li><li>子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75580d6fd0a44c9d81a15a9efd937ea1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200331090341980"> </p><p><strong>Object类</strong></p><p>是Java中所有类的父类，类似于二叉树中的根节点，定义了一些通用的方法。</p><ol><li>如果我们没显式的声明一个类的父类的话，则此类继承于java.lang.Object类</li><li>所的java类（除java.lang.Object类之外都直接或间接的继承于java.lang.Object类</li><li>意味着，所的java类具有java.lang.Object类声明的功能。</li><li>java.lang.Object类中定义的一些方法</li></ol><p><img src="/2022/06/13/javaSE/image-20220517002424679.png" alt="image-20220517002424679"> </p><blockquote><p>java.lang.Object</p></blockquote><ol><li>Object类是所Java类的根父类</li><li>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类</li><li>Object类中的功能(属性、方法)就具通用性。</li></ol><ul><li><p>属性：无</p></li><li><p>方法：equals() &#x2F; toString() &#x2F; getClass() &#x2F;hashCode() &#x2F; clone() &#x2F; finalize()</p><p>wait() 、 notify()、notifyAll()</p></li></ul><ol><li>Object类只声明了一个空参的构造器</li><li>数组也作为 Object类的子类出现，可以调用 Object类中声明的方法</li></ol><blockquote><p>equals()</p></blockquote><ul><li>是一个方法，而非运算符</li><li>只能适用于引用数据类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>使用说明</strong></p><p>Object类中定义的equals()和&#x3D;&#x3D;的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p><p>像&#x3D;&#x3D;String、Date、File、包装类&#x3D;&#x3D;等都重写了Object类中的equals()方法。&#x3D;&#x3D;重写&#x3D;&#x3D;以后，比较的不是两个引用的地址是否相同，而是&#x3D;&#x3D;比较两个对象的”实体内容”是否相同&#x3D;&#x3D;。</p><p>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对Object类中的equals()进行重写.</p><p>重写的原则：比较两个对象的实体内容是否相同.</p><p><strong>&#x3D;&#x3D; ：运算符</strong></p><ol><li><p>可以使用在基本数据类型变量和引用数据类型变量中</p></li><li><p>如果比较的是基本数据类型变量：</p><p>比较两个变量保存的数据是否相等。（不一定类型要相同）</p></li><li><p>如果比较的是引用数据类型变量：</p><p>比较两个对象的地址值是否相同,即两个引用是否指向同一个对象实体</p></li></ol><blockquote><p>toString()方法</p></blockquote><p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()方法</p><p>Object类中toString()的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回”实体内容”信息。</p><p>自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Customer [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>子类对象实例化的全过程</p></blockquote><p><strong>从结果上看：继承性</strong></p><p>子类继承父类以后，就获取了父类中声明的属性或方法。 创建子类的对象，在堆空间中，就会加载所父类中声明的属性。</p><p><strong>从过程上看：</strong></p><p>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，…直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48a24b48169f428aa8328916508e7dba~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200331090544208"> </p><p><strong>强调说明：</strong></p><p>虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7579cbffeba4bb5aa7b689b1b91d6a4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200328171148983"> </p><h4 id="1-3-3、多态"><a href="#1-3-3、多态" class="headerlink" title="1.3.3、多态"></a>1.3.3、多态</h4><blockquote><p>多态性的理解</p></blockquote><p>可以理解为一个事物的多种形态。比如数据库的连接方式，我们定义好了数据库的连接，也规定了连接时的步骤，但是我们并不知道用户会采用什么数据库，在没有多态以前我们只能针对不同的数据库写不同的连接方法，而有了多态以后我们只需要定义好数据库的类并书写好连接方法，让所有的数据库继承数据库类并重写数据库连接方法。</p><p>这样我们在调用的时候只需要通过声明数据库类并指向数据库的子类的方式，<strong>（即数据库类的引用指向继承了数据库类的具体实现类的对象）</strong>就可以进行数据库连接。而不是需要针对不同的数据库书写不同的连接方式。</p><blockquote><p>何为多态</p></blockquote><p>对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</p><p>编译时和运行时类型不一致，产生了多态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure><blockquote><p>多态性的使用</p></blockquote><p>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</p><p>总结：编译，看左边；运行，看右边。</p><p>对象的多态：在Java中，子类的对象可以替代父类的对象使用</p><ul><li>一个变量只能有一种确定的数据类型</li><li>一个引用类型变量可能指向（引用）多种不同类型的对象</li></ul><blockquote><p>&#x3D;&#x3D;多态性的使用前提&#x3D;&#x3D;</p></blockquote><p>**① 类的继承关系 **</p><p><strong>② 方法的重写</strong></p><blockquote><p>多态应用举例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">举例一：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Animal animal)</span>&#123;<span class="comment">//Animal animal = new Dog();</span></span><br><span class="line">animal.eat();</span><br><span class="line">animal.shout();</span><br><span class="line">&#125;</span><br><span class="line">举例二：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">举例三：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Driver</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doData</span><span class="params">(Connection conn)</span>&#123;<span class="comment">//conn = new MySQlConnection(); / conn = new OracleConnection();</span></span><br><span class="line"><span class="comment">//规范的步骤去操作数据</span></span><br><span class="line"><span class="comment">//conn.method1();</span></span><br><span class="line"><span class="comment">//conn.method2();</span></span><br><span class="line"><span class="comment">//conn.method3();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多态性使用注意点</p></blockquote><ul><li>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</li><li>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就&#x3D;&#x3D;不能&#x3D;&#x3D;再访问子类中添加的属性和方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">User</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">manTest</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;man……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Man</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        man.testUser();</span><br><span class="line">        man.manTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就==不能==再访问子类中添加的属性和方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">man2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        man2.testUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多态使用总结</p></blockquote><ul><li><p>多态的作用：提高了代码的通用性，常称作接口重用</p></li><li><p>使用前提：①需要存在继承或者实现关系 ②有方法的重写</p></li><li><p>成员方法：</p><ul><li>编译时：要查看引用变量所声明的类中是否有所调用的方法</li><li>运行时：调用实际new的对象所属的类中的重写方法</li></ul></li><li><p>成员变量：不具备多态性，只看引用变量所声明的类</p></li></ul><blockquote><p>关于向上转型与向下转型</p></blockquote><p>向上转型：多态</p><p><strong>为什么使用向下转型</strong></p><p>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型。</p><p><strong>如何实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用强制类型转换符：()</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"></span><br><span class="line">Man m1=（Man）p2；<span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure><p><strong>使用时的注意点：</strong></p><p>① 使用强转时，可能出现ClassCastException的异常。</p><p>② 为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</p><p>③ 只有对象A是B的子类实例化对象或者在下层的子类，才能向下转型</p><p><strong>instanceof的使用</strong></p><p>① a instanceof A:&#x3D;&#x3D;判断对象a&#x3D;&#x3D;是否是&#x3D;&#x3D;类A的实例&#x3D;&#x3D;。如果是，返回true；如果不是，返回false。</p><p>② 如果 a instanceof A返回true,则 a instanceof B也返回true.其中，类B是类A的父类。</p><p>③ 要求a所属的类与类A必须是子类和父类的关系，否则编译错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        <span class="type">Man</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(man <span class="keyword">instanceof</span> Man);<span class="comment">//true</span></span><br><span class="line">        System.out.println(man <span class="keyword">instanceof</span> User);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//说明User是Man的父类</span></span><br></pre></td></tr></table></figure><h2 id="1-4、异常处理"><a href="#1-4、异常处理" class="headerlink" title="1.4、异常处理"></a>1.4、异常处理</h2><h3 id="1-4-1、异常的定义"><a href="#1-4-1、异常的定义" class="headerlink" title="1.4.1、异常的定义"></a>1.4.1、异常的定义</h3><p>在Java语言中，将程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错误不是异常）</p><blockquote><p>异常的体系结构</p></blockquote><p><code>Error</code>： Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：堆栈溢出 <code>StackOverflowError</code> 和OOM。一般不编写针对性的代码进行处理。</p><p><code>Exception</code>：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。如：</p><ul><li>空指针访问</li><li>试图读取不存在的文件</li><li>网络连接中断</li><li>数组角标越界</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">异常的体系结构</span><br><span class="line"> * java.lang.Throwable</span><br><span class="line"> * |-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line"> * |-----java.lang.Exception:可以进行异常的处理</span><br><span class="line"> * |------编译时异常(checked)不会生成字节码文件</span><br><span class="line"> * |-----IOException</span><br><span class="line"> * |-----FileNotFoundException</span><br><span class="line"> * |-----ClassNotFoundException</span><br><span class="line"> * |------运行时异常(unchecked,RuntimeException)</span><br><span class="line"> * |-----NullPointerException<span class="comment">//空指针异常</span></span><br><span class="line"> * |-----ArrayIndexOutOfBoundsException<span class="comment">//数组角标越界</span></span><br><span class="line"> * |-----ClassCastException<span class="comment">//类型转化异常</span></span><br><span class="line"> * |-----NumberFormatException<span class="comment">//编码格式异常</span></span><br><span class="line"> * |-----InputMismatchException<span class="comment">//输入不匹配</span></span><br><span class="line"> * |-----ArithmeticException<span class="comment">//算术异常</span></span><br></pre></td></tr></table></figure><p><strong>java中异常类的继承关系</strong></p><p><img src="/2022/06/13/javaSE/image-20220516011754023.png" alt="image-20220516011754023"> </p><blockquote><p>按照异常发生的时间可以分成两类</p></blockquote><ul><li><p>编译时异常：执行 <code>javac.exe</code> 命令时，可能出现的异常：</p><p>指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常对于这类异常，如果程序不处理，可能会带来意想不到的结果。</p></li><li><p>运行时异常：执行 <code>java.exe</code> 命令时，出现的异常：</p><p>指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。 <code>java. lang. Runtime Exception</code> 类及它的子类都是运行时异常。对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。</p></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9c094c49e1441e38d8ed870f94ac9ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200403162029470"> </p><blockquote><p>常见异常类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line"><span class="comment">//ArithmeticException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    System.out.println(a / b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputMismatchException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">    System.out.println(score);</span><br><span class="line"></span><br><span class="line">    scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NumberFormatException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ClassCastException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line">    <span class="comment">//int[] arr = new int[10];</span></span><br><span class="line">    <span class="comment">//System.out.println(arr[10]);</span></span><br><span class="line">    <span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NullPointerException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//int[] arr = null;</span></span><br><span class="line">    <span class="comment">//System.out.println(arr[3]);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    str = <span class="literal">null</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line">    <span class="comment">//FileInputStream fis = new FileInputStream(file);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//int data = fis.read();</span></span><br><span class="line">    <span class="comment">//while(data != -1)&#123;</span></span><br><span class="line">    <span class="comment">//System.out.print((char)data);</span></span><br><span class="line">    <span class="comment">//data = fis.read();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//fis.close();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2、异常的处理"><a href="#1-4-2、异常的处理" class="headerlink" title="1.4.2、异常的处理"></a>1.4.2、异常的处理</h3><p>**过程一：”抛”**程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。</p><p>关于异常对象的产生：</p><ul><li>系统自动生成的异常对象</li><li>手动的生成一个异常对象，并抛出（<code>throw</code>）</li></ul><p>**过程二：”抓”**可以理解为异常的处理方式：① <code>try-catch-finally</code> ② <code>throws</code></p><blockquote><p>2.异常处理方式一：try-catch-finally</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的代码</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式3</span></span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//一定会执行的代码</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>使用说明</strong></p><ul><li><p><code>finally</code> 是可选的。</p></li><li><p>使用 <code>try</code> 将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去 <code>catch</code> 中进行匹配</p></li><li><p>一旦 <code>try</code> 中的异常对象匹配到某一个 <code>catch</code> 时，就进入 <code>catch</code> 中进行异常的处理。一旦处理完成，就跳出当前的 <code>try-catch</code> 结构（在没写 <code>finally</code> 的情况。继续执行其后的代码）</p></li><li><p><code>catch</code>中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓；<code>catch</code>中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则会报错</p></li><li><p>常用的异常对象处理的方式： ① <code>String getMessage()</code> ② <code>printStackTrace()</code></p></li><li><p>在<code>try</code> 结构中声明的变量，再出了 <code>try</code> 结构以后，就不能再被调用</p></li><li><p><code>try-catch-finally</code> 结构可以嵌套</p></li></ul><p><strong>如何看待代码中的编译时异常和运行时异常？</strong></p><ul><li><p>使用 <code>try-catch-finally</code> 处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用 <code>try-catch-finally</code> 将一个编译时可能出现的异常，延迟到运行时出现。</p></li><li><p>开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写 <code>try-catch-finally</code> 了。但是针对于编译时异常，一定要考虑异常的处理。</p></li></ul><p><strong>finally的再说明：</strong></p><ul><li><p><code>finally</code> 是可选的</p></li><li><p><code>finally</code> 中声明的是一定会被执行的代码。即使catch中又出现异常了，<code>try</code> 中包含 <code>return</code> 语句，或者<code>catch</code>中 <code>return</code> 包含语句等情况，<code>finally</code> 中的代码也会被执行。</p></li><li><p>像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放的代码，就需要声明在 <code>finally</code> 中。</p></li></ul><blockquote><p>异常处理方式二</p></blockquote><p><code>throws + 异常类型</code> 写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。 一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足 <code>throws</code> 后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</p><blockquote><p>二者处理方式对比</p></blockquote><p><code>try-catch-finally</code> 真正的将异常给处理掉了。 <code>throws</code> 的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。</p><blockquote><p>开发中如何选择两种处理方式</p></blockquote><ul><li><p>如果父类中被重写的方法没 <code>throws</code> 方式处理异常，则子类重写的方法也不能使用 <code>throws</code>，意味着如果子类重写的方法中异常，必须使用 <code>try-catch-finally</code> 方式处理。</p></li><li><p>执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用<code>throws</code> 的方式进行处理。而执行的方法a可以考虑使用 <code>try-catch-finally</code> 方式进行处理。</p></li></ul><h3 id="1-4-3、手动抛出异常对象"><a href="#1-4-3、手动抛出异常对象" class="headerlink" title="1.4.3、手动抛出异常对象"></a>1.4.3、手动抛出异常对象</h3><blockquote><p>使用说明</p></blockquote><p>在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的 <code>throw</code> 一个异常类的对象。</p><blockquote><p>throw和throws的区别</p></blockquote><p><code>throw</code> 和 <code>throws</code>区别： <code>throw</code> 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。 <code>throws</code> 属于异常处理的一种方式，声明在方法的声明处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//手动抛出异常对象</span></span><br><span class="line">            <span class="comment">//throw new RuntimeException(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line">            <span class="comment">//throw new Exception(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;不能输入负数&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-4、自定义异常类"><a href="#1-4-4、自定义异常类" class="headerlink" title="1.4.4、自定义异常类"></a>1.4.4、自定义异常类</h3><blockquote><p>如何自定义异常类</p></blockquote><ul><li>继承于现的异常结构：<code>RuntimeException 、Exception</code></li><li>提供全局常量：<code>serialVersionUID</code>（对类的唯一标识）</li><li>提供重载的构造器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7034897193246939L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5、JAVA类"><a href="#1-5、JAVA类" class="headerlink" title="1.5、JAVA类"></a>1.5、JAVA类</h2><h3 id="1-5-1、类和对象"><a href="#1-5-1、类和对象" class="headerlink" title="1.5.1、类和对象"></a>1.5.1、类和对象</h3><p>类中主要包括五种结构：属性、方法、构造器、代码块、内部类</p><blockquote><p>1、面向对象与面向过程</p></blockquote><ul><li>面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。</li><li>面向过程：强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做。</li></ul><blockquote><p>2、类和对象的关系</p></blockquote><p>类：对一类事物的描述，是抽象的，概念上的定义</p><p>对象：是实际存在的该类事物的每个个体，因而也称为实例。</p><p><code>面向对象程序设计的重点是类的设计，设计类就是设计类的成员。 二者的关系：对象，是由类new出来的，派生出来的</code></p><blockquote><p>3、面向对象思想实现的规则</p></blockquote><ol><li>创建类，设计类的成员</li><li>创建类的对象</li><li>通过<code>对象.属性</code> 或 <code>对象.方法</code>调用对象的结构</li></ol><p><strong>补充：</strong></p><ul><li>属性 &#x3D; 成员变量 &#x3D; field &#x3D; 域、字段</li><li>方法 &#x3D; 成员方法 &#x3D; 函数 &#x3D; method</li><li>创建类的对象 &#x3D; 类的实例化 &#x3D; 实例化类</li></ul><blockquote><p>4、对象的创建与对象的内存解析</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> p1;<span class="comment">//没有新创建一个对象，共用一个堆空间中的对象实体。</span></span><br><span class="line"><span class="comment">/*说明：</span></span><br><span class="line"><span class="comment">*如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的）</span></span><br><span class="line"><span class="comment">*意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>素组对象内存解析</strong>：</p><p><img src="/2022/06/13/javaSE/image-20220517232036783.png" alt="image-20220517232036783"> </p><p><strong>对象内存解析</strong></p><p><img src="/2022/06/13/javaSE/image-20220517232119741.png" alt="image-20220517232119741"> </p><blockquote><p>5、JVM内存结构</p></blockquote><p>编译完源程序后，生成一个或多个字节码文件，我们使用JVM中类的加载器和解释器，对生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。</p><p><img src="/2022/06/13/javaSE/image-20220517232428996.png" alt="image-20220517232428996"></p><p>&#x3D;&#x3D;虚拟机栈&#x3D;&#x3D;：即为平时提到的栈结构。【我们将局部变量存储到栈结构中】</p><p>&#x3D;&#x3D;虚拟机堆&#x3D;&#x3D;：我们将new出来的结构【比如：数组，对象】加载到堆空间</p><p><strong>补充：</strong></p><p>对象的属性【非static的】加载在堆空间</p><p>方法区：类的加载信息、常量池、静态域</p><blockquote><p>6、匿名对象</p></blockquote><p>我们创建的对象，没有显示的赋给一个变量名，即为匿名对象</p><p><strong>特点：</strong>匿名对象只能调用一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().sendEmail();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().playGame();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().price = <span class="number">1999</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().showPrice();<span class="comment">//0.0</span></span><br></pre></td></tr></table></figure><p>适用场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PhoneMall</span> <span class="variable">mall</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneMall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象的使用</span></span><br><span class="line">mall.show(<span class="keyword">new</span> <span class="title class_">Phone</span>());</span><br><span class="line">其中，</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneMall</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Phone phone)</span>&#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">        phone.playGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>7、万物皆对象</p></blockquote><p>在Java语言范畴中，我们将功功能、结构等封装到类中，通过类的实例化，来调用具体功能的结构。</p><ul><li>Scanner,String等</li><li>文件：File</li><li>网络资源：URL</li></ul><p>涉及到Java语言与前端HTML,后端数据库交互时，前后端的结构在JAVA层面交互时，都体现为类、对象。</p><h3 id="1-5-2、类的结构之一：属性"><a href="#1-5-2、类的结构之一：属性" class="headerlink" title="1.5.2、类的结构之一：属性"></a>1.5.2、类的结构之一：属性</h3><blockquote><p>1、属性vs局部变量</p><blockquote><p>相同点</p></blockquote><ul><li>定义变量的格式：数据类型 变量名 &#x3D; 变量值</li><li>先声明，后使用</li><li>变量都其对应的作用域</li></ul><blockquote><p>不同点：</p></blockquote><p>1.2.1 在类中声明的位置的不同</p><ul><li>属性：直接定义在类的一对{}内</li><li>局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量。</li></ul><p>1.2.2 关于权限修饰符的不同</p><ul><li>属性：可以在声明属性时，指明其权限，使用权限修饰符。<ul><li>常用的权限修饰符：private、public、缺省、protected —&gt;封装性</li><li>目前，声明属性时，使用缺省就可以。</li></ul></li><li>局部变量：不可以使用权限修饰符。</li></ul><p>1.2.3 默认初始化值的情况：</p><ul><li><strong>属性</strong>：类的属性，根据其类型，都默认初始化值。<ul><li>整型（byte、short、int、long：0）</li><li>浮点型（float、double：0.0）</li><li>字符型（char：0 （或’\u0000’））</li><li>布尔型（boolean：false）</li><li>引用数据类型（类、数组、接口：null）</li></ul></li><li><strong>局部变量</strong>：没默认初始化值。<ul><li>意味着，我们在调用局部变量之前，一定要显式赋值。</li><li>特别地：形参在调用时，我们赋值即可。</li></ul></li></ul><p>1.2.4 在内存中加载的位置：</p><ul><li>属性：加载到堆空间中 （非static）</li><li>局部变量：加载到栈空间</li></ul></blockquote><hr><blockquote><p>变量的分类</p></blockquote><ul><li>方式一：按照数据类型<ul><li>基本数据类型</li><li>引用数据类型</li></ul></li></ul><p><img src="/2022/06/13/javaSE/image-20220517235950220.png" alt="image-20220517235950220"> </p><ul><li>方式二：按照在类中声明的位置<ul><li>成员变量</li><li>局部变量</li></ul></li></ul><p><img src="/2022/06/13/javaSE/image-20220518000118400.png" alt="image-20220518000118400"> </p><h3 id="1-5-3、类的结构之二：方法"><a href="#1-5-3、类的结构之二：方法" class="headerlink" title="1.5.3、类的结构之二：方法"></a>1.5.3、类的结构之二：方法</h3><p>定义：描述类应该具有的功能。</p><blockquote><p>1、方法举例</p></blockquote><p><strong>1.1 JDK中的方法：</strong></p><ul><li><p>Math类：<code>sqrt()</code> <code>random()</code> …</p></li><li><p>&#96;&#96;&#96;<br>Scanner类：<code>nextXxx()</code> …</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  Arrays类：`sort()`    `binarySearch()`    `toString()`     `equals()`   ...</span><br><span class="line">  </span><br><span class="line">  复制代码</span><br></pre></td></tr></table></figure></li></ul><p><strong>1.2 自定义的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.printly(<span class="string">&quot;我要吃饭！！！&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getNation</span><span class="params">(String nation)</span>&#123;</span><br><span class="line">     System.out.printly(<span class="string">&quot;当前地点为&quot;</span> + nation);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>1.3 方法的声明：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 返回值类型  方法名(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">方法体</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、方法的说明</p></blockquote><ul><li>返回值类型：</li></ul><p><strong>如果方法有返回值</strong>，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用return关键字来返回指定类型的变量或常量：<code>return 数据</code>。</p><p><strong>如果方法没返回值</strong>，则方法声明时，使用void来表示。通常，没返回值的方法中，就不需要使用return。如果使用的话，只能使用 <code>return;</code> 表示结束此方法的意思。</p><ul><li><p>命名规范</p><ul><li>属于标识符，遵循标识符的规则和规范，“见名知意”</li><li>方法名应遵循小驼峰命名 <code>aaaBbbCcc</code></li><li>方法名最好使用英文单词，不要使用拼音或者缩写</li><li>更多规范要求请参考《Java开发手册》</li></ul></li><li><p>形参列表</p><ul><li><p>方法可以声明0个，1个，或多个形参。</p><p>也可以使用可变形参，但可变形参必须放到最后，详细说明请查看本章第五部分。</p><p>格式：<code>数据类型1 形参1</code> <code>数据类型2 形参2</code> …..</p></li></ul></li><li><p>方法体</p></li></ul><p>是方法中功能的体现，通过循环分支、条件判断等语句完成复杂的逻辑关系。</p><p>方法中可以调用其他方法，同类中可以直接调用，不同类中通过类的实例化对象调用。</p><blockquote><p>3、方法的使用</p></blockquote><ul><li>同类中的方法可以直接调用当前类的属性或方法，不同类中通过类的实例化对象调用。</li><li>特殊的：方法A中又调用了自身—递归方法。（自身调用）</li></ul><blockquote><p>4、重载</p></blockquote><p><strong>概念</strong>：在同一个类中，允许存在一个以上的同名方法，只要它们的&#x3D;&#x3D;参数个数&#x3D;&#x3D;或者&#x3D;&#x3D;参数类型&#x3D;&#x3D;不同即可。</p><p><strong>构成重载实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举例一：Arrays类中重载的sort() / binarySearch()；PrintStream中的println()</span></span><br><span class="line"><span class="comment">// 举例二：</span></span><br><span class="line"><span class="comment">// 如下的4个方法构成了重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(<span class="type">double</span> d1,<span class="type">double</span> d2)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(String s ,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> i,String s)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;不&#x3D;&#x3D;构成重载实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如下的3个方法不能与上述4个方法构成重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重载方法判断</strong>：</p><p><strong>如何判断是否构成方法重载？</strong></p><p>严格按照定义判断：两同一不同。跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系！</p><p><strong>如何确定类中某一个方法的调用：</strong></p><p>①方法名 —&gt; ②参数列表</p><blockquote><p>5、可变个数形参方法</p></blockquote><p>JDK 5.0新增的内容</p><p>JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void test(int a， String[] books);</span><br></pre></td></tr></table></figure><p>JDK 5.0以后：采用可变个数形参来定义方法，传入多个同一类型变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void test(int a， String ... books);</span><br></pre></td></tr></table></figure><p>可变个数形参的格式：<code>数据类型 ... 变量名</code></p><p>当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，…..</p><p>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</p><p>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</p><p>可变个数形参在方法的形参中，<em><strong>必须声明在末尾。</strong></em></p><p>可变个数形参在方法的形参中***,最多只能声明一个可变形参***。</p><p><strong>举例说明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show(String)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String ... strs)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show(String ... strs)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不能与上一个方法同时存在</span></span><br><span class="line"><span class="comment">//  public void show(String[] strs)&#123;</span></span><br><span class="line"><span class="comment">//      </span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">// 调用时：可变形参与数组类似</span></span><br><span class="line">test.show(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">test.show(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">test.show();</span><br><span class="line"></span><br><span class="line">test.show(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>6、java值传递机制</p></blockquote><p><strong>针对&#x3D;&#x3D;方法内&#x3D;&#x3D;变量的赋值举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;***********基本数据类型：****************&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">n = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;***********引用数据类型：****************&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Order</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">o1.orderId = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Order</span> <span class="variable">o2</span> <span class="operator">=</span> o1;<span class="comment">//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;o1.orderId = &quot;</span> + o1.orderId + <span class="string">&quot;,o2.orderId = &quot;</span> +o2.orderId);</span><br><span class="line"></span><br><span class="line">o2.orderId = <span class="number">1002</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;o1.orderId = &quot;</span> + o1.orderId + <span class="string">&quot;,o2.orderId = &quot;</span> +o2.orderId);</span><br></pre></td></tr></table></figure><blockquote><p>说明：如果变量是基本数据类型，此时赋值的是变量所保存的数据值。 如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</p></blockquote><hr><p><strong>针对于&#x3D;&#x3D;方法&#x3D;&#x3D;的参数概念</strong></p><p>形参：<em><strong>方法定义时</strong></em>，声明的小括号内的参数 </p><p>实参：<em><strong>方法调用时</strong></em>，实际传递给形参的数据</p><hr><p><strong>Java中参数传递机制：值传递机制</strong></p><p><strong>规则：</strong></p><ul><li>如果参数是<em><strong>基本数据类型</strong></em>，此时实参赋给形参的是实参真实存储的数据值。</li><li>如果参数是<em><strong>引用数据类型</strong></em>，此时实参赋给形参的是实参存储数据的地址值。</li></ul><p><strong>推广：</strong></p><ul><li>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。</li><li>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</li></ul><hr><p><strong>内存解析</strong></p><ul><li>内存结构：栈（局部变量），&#x3D;&#x3D;堆【对象、数组、非static成员变量(属性)】&#x3D;&#x3D;</li><li>变量：成员变量（类变量，实例变量(不以static修饰)）vs 局部变量（方法体内，方法形参变量，构造器，构造器形参，代码块）</li></ul><p>举例一：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/552dc9d0c5284ded8c90d0d9eb1ea86e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>举例二： </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4bc865be8a340d396d95f43a71064b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"> </p><hr><blockquote><p>7、递归方法</p></blockquote><p>递归方法：一个方法体内调用它自身。</p><p>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。 <strong>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环</strong>。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1：计算1-n之间所自然数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2：计算1-n之间所自然数的乘积:n!</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * getSum1(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例3：已知一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),</span></span><br><span class="line"><span class="comment">//其中n是大于0的整数，求f(10)的值。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//          return f(n + 2) - 2 * f(n + 1);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例4：斐波那契数列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例5：汉诺塔问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例6：快排</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>8、方法的重写</p></blockquote><p><strong>什么是方法的重写(override 或 overwrite)？</strong>、</p><p>​子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.</p><p><strong>重写应用</strong>：</p><p>重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法</p><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;&#125;<span class="comment">//求面积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cylinder</span> <span class="keyword">extends</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;&#125;<span class="comment">//求表面积</span></span><br><span class="line">&#125;</span><br><span class="line">**********************************************</span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amt)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheckAccount</span> <span class="keyword">extends</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amt)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>重写规则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符  返回值类型  方法名(形参列表) <span class="keyword">throws</span> 异常的类型&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</p><ol><li>子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</li><li>子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</li></ol><p><strong>特殊情况</strong>：子类不能重写父类中声明为private权限的方法</p><ul><li><strong>返回值类型</strong>：<ul><li>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</li><li>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</li><li>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)</li></ul></li></ul><p><strong>补充：</strong>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p><p><strong>说明：</strong>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写)。</p><p>开发中一般保持子父类一致</p><hr><p><strong>区分方法的重写和重载？</strong></p><ol><li>二者的概念：</li></ol><ul><li>方法的<strong>重写</strong>：<strong>子类继承父类以后</strong>，可以对父类中&#x3D;&#x3D;同名同参数&#x3D;&#x3D;的方法，进行覆盖操作.</li><li>方法的<strong>重载</strong>：<strong>在同一个类中</strong>，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</li></ul><ol><li>重载和重写的具体规则：重载：两同一不同，重写</li><li>重载：不表现为多态性。 重写：表现为多态性。</li><li>从编译和运行的角度看：</li></ol><ul><li>重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</li><li>所以对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；</li><li>而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。</li></ul><hr><h3 id="1-5-4、类的结构之三：构造器"><a href="#1-5-4、类的结构之三：构造器" class="headerlink" title="1.5.4、类的结构之三：构造器"></a>1.5.4、类的结构之三：构造器</h3><blockquote><p>1、构造器（构造方法）：Constructor</p></blockquote><ul><li>构造器的作用：（只要造对象就得用到构造器）<ul><li>创建对象</li><li>初始化对象信息</li></ul></li></ul><hr><blockquote><p>2、使用说明</p></blockquote><ul><li><p>如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器</p></li><li><p>定义构造器的格式：<code>权限修饰符 类名(形参列表)&#123; &#125;</code></p></li><li><p>一个类中定义的<em><strong>多个构造器</strong></em>，彼此构成重载</p></li><li><p>一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</p></li><li><p>一个类中，<em><strong>至少会有一个构造器</strong></em>。</p></li></ul><hr><blockquote><p>3、构造器举例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器不等于方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Person().....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String n)</span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String n,<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    age = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造器默认权限和类的权限一致</li></ul><hr><blockquote><p>4、属性赋值顺序</p></blockquote><p>总结：属性赋值的先后顺序</p><p>① 默认初始化</p><p>② 显式初始化</p><p>③ 构造器中初始化</p><p>④ 通过”对象.方法” 或 “对象.属性”的方式，赋值</p><p>以上操作的先后顺序：① - ② - ③ - ④</p><hr><blockquote><p>5、JavaBean的概念</p></blockquote><p>所谓JavaBean，是指符合如下标准的Java类：</p><ul><li>类是公共的</li><li>一个<em><strong>无参</strong></em>的公共的构造器</li><li>属性，且对应的get、set方法</li></ul><hr><h3 id="1-5-5、类的结构之四：代码块"><a href="#1-5-5、类的结构之四：代码块" class="headerlink" title="1.5.5、类的结构之四：代码块"></a>1.5.5、类的结构之四：代码块</h3><p>代码块（初始化块）</p><blockquote><p>1、代码块的作用</p></blockquote><p>初始化类、对象的信息</p><blockquote><p>2、分类</p></blockquote><p>静态代码块 vs 非静态代码块</p><blockquote><p>3、区别</p></blockquote><p><strong>静态代码块：</strong></p><ul><li>内部可以输出语句</li><li>&#x3D;&#x3D;随着类的加载而执行,而且只执行一次&#x3D;&#x3D;</li><li>&#x3D;&#x3D;作用：初始化类的信息&#x3D;&#x3D;</li><li>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</li><li>静态代码块的执行要优先于非静态代码块的执行</li><li>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</li></ul><p><strong>非静态代码块：</strong></p><ul><li>内部可以输出语句</li><li>&#x3D;&#x3D;随着对象的创建而执行&#x3D;&#x3D;</li><li>&#x3D;&#x3D;每创建一个对象，就执行一次非静态代码块&#x3D;&#x3D;</li><li>&#x3D;&#x3D;作用：可以在创建对象时，对对象的属性等进行初始化&#x3D;&#x3D;</li><li>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</li><li>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</li></ul><p><strong>注意：</strong>实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：由父及子，静态先行。如下图</p><p><img src="/2022/06/13/javaSE/image-20220518015906900.png" alt="image-20220518015906900"> </p><hr><blockquote><p>属性的赋值顺序</p></blockquote><p>① 默认初始化</p><p>② 显式初始化&#x2F;⑤在代码块中赋值</p><p>③ 构造器中初始化</p><p>④ 有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值</p><p>执行的先后顺序：① - ② &#x2F; ⑤ - ③ - ④</p><hr><h3 id="1-5-6、类的结构之五：内部类"><a href="#1-5-6、类的结构之五：内部类" class="headerlink" title="1.5.6、类的结构之五：内部类"></a>1.5.6、类的结构之五：内部类</h3><blockquote><p>1、定义：</p></blockquote><p>Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类。</p><blockquote><p>2、分类：</p></blockquote><ul><li>成员内部类（静态、非静态）</li><li>局部内部类（方法内、代码块内、构造器内）</li></ul><blockquote><p>3、成员内部类的理解</p></blockquote><p><strong>一方面，作为外部类的&#x3D;&#x3D;成员&#x3D;&#x3D;：</strong></p><ul><li>调用外部类的结构</li><li>可以被static修饰</li><li>可以被4种不同的权限修饰</li></ul><p><strong>另一方面，作为一个&#x3D;&#x3D;类&#x3D;&#x3D;：</strong></p><ul><li>类内可以定义属性、方法、构造器等</li><li>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</li><li>可以被abstract修饰</li></ul><hr><blockquote><p>4、成员内部类</p></blockquote><p><strong>创建成员内部类对象</strong>(静态&amp;非静态)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建静态的Dog内部类的实例(静态的成员内部类):</span></span><br><span class="line">Person.<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建非静态的Bird内部类的实例(非静态的成员内部类):</span></span><br><span class="line"><span class="comment">// Person.Bird bird = new Person.Bird();//错误的</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">Person.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> p.<span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br></pre></td></tr></table></figure><p><strong>在成员内部类调用外部类结构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">            System.out.println(Person.<span class="built_in">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line">            <span class="comment">//Person.this.eat();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>局部内部类的使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line"><span class="keyword">public</span> Comparable <span class="title function_">getComparable</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line">    <span class="comment">//方式一：</span></span><br><span class="line">    <span class="comment">//      class MyComparable implements Comparable&#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//          @Override</span></span><br><span class="line">    <span class="comment">//          public int compareTo(Object o) &#123;</span></span><br><span class="line">    <span class="comment">//              return 0;</span></span><br><span class="line">    <span class="comment">//          &#125;</span></span><br><span class="line">    <span class="comment">//          </span></span><br><span class="line">    <span class="comment">//      &#125;</span></span><br><span class="line">    <span class="comment">//      </span></span><br><span class="line">    <span class="comment">//      return new MyComparable();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Comparable</span>()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>成员内部类和局部内部类，在编译以后，都会生成字节码文件。 格式：成员内部类：<code>外部类$内部类名.class</code> 局部内部类：<code>外部类$数字 内部类名.class</code></p><hr><h2 id="1-6、Java关键字的使用"><a href="#1-6、Java关键字的使用" class="headerlink" title="1.6、Java关键字的使用"></a>1.6、Java关键字的使用</h2><h3 id="1、return–跳出"><a href="#1、return–跳出" class="headerlink" title="1、return–跳出"></a>1、return–跳出</h3><ul><li><p>使用在方法体中，用于：① 结束方法② 针对于返回值类型的方法，使用”return 数据”方法返回所要的数据。</p></li><li><p>return关键字后面不可以声明执行语句。</p></li><li><p>在异常处理中try-catch-finally的结构中，如果try或catch中的结构中写了return，但是finally中的结构仍会执行。</p></li></ul><h3 id="2、this–本类的"><a href="#2、this–本类的" class="headerlink" title="2、this–本类的"></a>2、this–本类的</h3><blockquote><p><strong>概述：</strong></p></blockquote><p>this理解为：当前对象 或 当前正在创建的对象，可以调用的结构：<em><strong>属性、方法；构造器</strong></em></p><blockquote><p>使用</p></blockquote><p><strong>2.1 this调用属性、方法：</strong></p><ul><li>在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果<em><strong>方法的形参和类的属性同名时</strong></em>，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li><li>在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果<em><strong>构造器的形参和类的属性同名</strong></em>时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li></ul><p><strong>2.2 this调用构造器：</strong></p><p>① 我们在类的构造器中，可以显式的使用***”this(形参列表)”***方式，调用本类中指定的其他构造器</p><p>② 构造器中不能通过”this(形参列表)”方式调用自己</p><p>③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”</p><p>④ 规定：”this(形参列表)”<em><strong>必须声明在当前构造器的首行</strong></em></p><p>⑤ **构造器内部，最多只能声明一个”this(形参列表)”**，用来调用其他的构造器</p><h3 id="3、super–父类的"><a href="#3、super–父类的" class="headerlink" title="3、super–父类的"></a>3、super–父类的</h3><blockquote><p>概述</p></blockquote><p>super 关键字可以理解为：父类的，可以用来调用的结构：<em><strong>属性、方法、构造器</strong></em></p><ul><li>尤其当子父类出现同名成员时，可以用supe表明调用的是父类中的成员</li><li>super的追溯不仅限于直接父类</li><li>super和this的用法相像，this代表本类对象的引用， super代表父类的内存空间的标识</li></ul><blockquote><p>super使用</p></blockquote><p><strong>2.1super调用属性、方法：</strong></p><p>与this关键字使用方式相同，只不过调用的是父类的属性</p><p><strong>2.2 在子类的方法或构造器中使用</strong></p><p>通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”</p><p><strong>特殊情况</strong></p><ul><li>当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。</li><li>当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。</li></ul><p><strong>super调用构造器</strong></p><p>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</p><p>“super(形参列表)”的使用，必须声明在子类构造器的首行！</p><p>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现</p><p>在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()</p><p>在类的多个构造器中，至少一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</p><p><strong>this和super区别</strong></p><table><thead><tr><th>区别点</th><th>this</th><th>super</th></tr></thead><tbody><tr><td>访问属性</td><td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td><td>直接访问父类中的属性</td></tr><tr><td>调用方法</td><td>访问本类中的方法，如果本类没有此方法则从父类中继续查找</td><td>直接访问父类中的方法</td></tr><tr><td>调用构造器</td><td>调用本类构造器，必须放在构造器的首行</td><td>调用父类构造器，必须放在子类构造器的首行</td></tr></tbody></table><h3 id="4、package-x2F-import"><a href="#4、package-x2F-import" class="headerlink" title="4、package&#x2F;import"></a>4、package&#x2F;import</h3><blockquote><p>package</p><p>概述</p></blockquote><ol><li>为了更好的实现项目中类的管理，提供包的概念</li><li>使用package声明类或接口所属的包，声明在源文件的首行</li><li>包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”</li><li>每”.”一次，就代表一层文件目录</li></ol><blockquote><p>包结构应用举例</p></blockquote><p><strong>MVC设计模式：</strong></p><p><img src="/2022/06/13/javaSE/image-20220518210058219.png" alt="image-20220518210058219"> &#x3D;&#x3D;</p><blockquote><p>&#x3D;&#x3D;JDK中主要的包介绍&#x3D;&#x3D;</p></blockquote><ul><li><p>java. lang–包含一些Java语言的核心类，如 String、Math、 integer、 System和Thread，提供常用功能</p></li><li><p>java. net–包含执行与网络相关的操作的类和接口</p></li><li><p>java.io–包含能提供多种输入&#x2F;输出功能的类</p></li><li><p>java util–包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。</p></li><li><p>java. text–包含了一些java格式化相关的类</p></li><li><p>java.sql–包含了java进行JDBC数据库编程的相关类&#x2F;接口</p></li><li><p>java. awt–包含了构成抽象窗口工具集 (abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面GU）。 B&#x2F;S C&#x2F;S</p></li></ul><blockquote><p>import的使用</p></blockquote><p>在源文件中显式的使用import结构导入指定包下的类、接口</p><p>声明在包的声明和类的声明之间</p><p>如果需要导入多个结构，则并列写出即可</p><p>可以使用”xxx.*”的方式，表示可以导入xxx包下的所结构</p><p>如果使用的类或接口是java.lang包下定义的，则可以省略import结构</p><p>如果使用的类或接口是本包下定义的，则可以省略import结构</p><p>如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。</p><p>使用”xxx.*”方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入</p><p>import static:导入指定类或接口中的静态结构:属性或方法。</p><h3 id="5、static–静态的"><a href="#5、static–静态的" class="headerlink" title="5、static–静态的"></a>5、static–静态的</h3><blockquote><p>概述</p></blockquote><p>static主要用来修饰类的内部结构，如：属性、方法、代码块、内部类</p><blockquote><p>使用</p></blockquote><blockquote><p><strong>修饰属性：静态变量（类变量）</strong></p></blockquote><p>属性是否使用static修饰，可分为：静态属性 vs 非静态属性(实例变量)</p><ul><li>实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</li><li>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</li></ul><p><strong>static修饰属性的其他说明</strong></p><ul><li>&#x3D;&#x3D;静态变量随着类的加载而加载&#x3D;&#x3D;。可以通过”类.静态变量”的方式进行调用</li><li>静态变量的加载要早于对象的创建。</li><li>由于&#x3D;&#x3D;类只会加载一次&#x3D;&#x3D;，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</li></ul><p>静态属性举例：<code>System.out;Math.PI</code></p><p><strong>静态变量内存解析：</strong></p><p><img src="/2022/06/13/javaSE/image-20220519070741195.png" alt="image-20220519070741195"> </p><blockquote><p>修饰方法：静态方法、类方法</p></blockquote><ul><li>随着类的加载而加载，可以通过”类.静态方法”的方式进行调用</li><li>静态方法中，只能调用静态的方法或属性</li><li>非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</li></ul><p><strong>使用的注意点：</strong></p><ul><li>在静态的方法内，不能使用this关键字、super关键字</li><li>关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。</li></ul><blockquote><p>如何判定属性和方法应该使用static关键字</p></blockquote><p><strong>关于属性：</strong></p><ul><li>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</li><li>类中的常量也常常声明为static</li></ul><p><strong>关于方法：</strong></p><ul><li>操作静态属性的方法，通常设置为static的</li><li>工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</li></ul><p><strong>使用举例：</strong>记录创建的圆的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//自动赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">()</span>&#123;</span><br><span class="line">id = init++;</span><br><span class="line">total++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>();</span><br><span class="line"><span class="comment">//id = init++;</span></span><br><span class="line"><span class="comment">//total++;</span></span><br><span class="line"><span class="built_in">this</span>.radius = radius;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> total;<span class="comment">//记录创建的圆的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">init</span> <span class="operator">=</span> <span class="number">1001</span>;<span class="comment">//static声明的属性被所对象所共享</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRadius</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRadius</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getTotal</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>单例模式</p></blockquote><h4 id="设计模式的说明："><a href="#设计模式的说明：" class="headerlink" title="设计模式的说明："></a><strong>设计模式的说明：</strong></h4><p>设计模式是在大量的实践中总结和理论化之后优化的代码结构、编程风格、以及解决问题的思考方式</p><p><strong>常用设计模式</strong>–23种经典设计模式<strong>（标黄表示接触过的）</strong></p><ul><li>创建型模式，5种：工厂方法模式、抽象工厂模式、&#x3D;&#x3D;单例模式&#x3D;&#x3D;【饿汉+懒汉】、建造者模式、原型模式。</li><li>结构型模式，7种：适配器模式、装饰器模式、&#x3D;&#x3D;代理模式&#x3D;&#x3D;【AOP】、外观模式、桥接模式、组合模式、享元模式。</li><li>行为型模式，11种：策略模式、&#x3D;&#x3D;模板方法模式&#x3D;&#x3D;【抽象类,JDBCTemlate】、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><p><strong>单例模式：</strong></p><p>采取一定的方法保证在整个软件系统中，对某个类只能存在一个实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思想：(静态变量随着类的加载而加载，用static修饰属性，由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">饿汉式<span class="number">1</span>：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.内部创建类的对象</span></span><br><span class="line"><span class="comment">//4.要求此对象也必须声明为静态的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">饿汉式<span class="number">2</span>：使用了静态代码块</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line"><span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line"><span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>饿汉和懒汉方式的对比</strong></p><ul><li>饿汉式：上来就创建对象（对象创建在类中，类一加载则就会创建对象）<ul><li>坏处：对象加载时间过长。</li><li>好处：饿汉式是线程安全的</li></ul></li><li>懒汉式：什么时候用什么时候造对象（对象不初始化，定义为null先）<ul><li>好处：延迟对象的创建。</li><li>目前的写法坏处：线程不安全。—&gt;到多线程内容时，再修改</li></ul></li></ul><h3 id="6、final–最终的"><a href="#6、final–最终的" class="headerlink" title="6、final–最终的"></a>6、final–最终的</h3><p><strong>可以用来修饰：类、方法、变量</strong></p><ul><li><p>final 用来修饰一个类:此类不能被其他类所继承。</p><ul><li>比如：String类、System类、StringBuffer类</li></ul></li><li><p>final 用来修饰方法：表明此方法不可以被重写</p><ul><li>比如：Object类中getClass();</li></ul></li><li><p>final 用来修饰变量：此时的”变量”就称为是一个常量</p><ul><li>final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化</li><li>final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</li></ul></li><li><p>static final 用来修饰属性：全局常量</p></li></ul><h3 id="7、abstract–抽象的"><a href="#7、abstract–抽象的" class="headerlink" title="7、abstract–抽象的"></a>7、abstract–抽象的</h3><blockquote><p>abstract概述</p></blockquote><p>abstract: 抽象的，可以用来修饰：类、方法</p><blockquote><p>使用</p></blockquote><p><strong>abstract修饰类：抽象类</strong></p><ul><li>&#x3D;&#x3D;此类不能实例化&#x3D;&#x3D;</li><li>&#x3D;&#x3D;抽象类中一定有构造器&#x3D;&#x3D;，便于子类实例化时调用（涉及：子类对象实例化的全过程）</li><li>开发中，都会提供抽象类的子类，&#x3D;&#x3D;让子类对象实例化&#x3D;&#x3D;，完成相关的操作 —&gt;&#x3D;&#x3D;抽象的使用前提：继承性&#x3D;&#x3D;</li></ul><p> <strong>abstract修饰方法：抽象方法</strong></p><ul><li>抽象方法&#x3D;&#x3D;只有方法的声明，没方法体&#x3D;&#x3D;</li><li>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</li><li>若子类重写了父类中的所的抽象方法后，此子类方可实例化</li><li>若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</li></ul><blockquote><p><strong>注意点：</strong></p></blockquote><ul><li>abstract不能用来修饰：属性、构造器等结构</li><li>abstract不能用来修饰私有方法、静态方法（&#x3D;&#x3D;静态方法不能被重写，抽象方法不能调用&#x3D;&#x3D;）、final的方法、final的类</li><li>&#x3D;&#x3D;抽象方法权限修饰符不能为private&#x3D;&#x3D;</li></ul><p><strong>应用举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交通工具父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">()</span>;<span class="comment">//计算燃料效率的抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">()</span>;<span class="comment">//计算行驶距离的抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//卡车子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Truck</span> <span class="keyword">extends</span> <span class="title class_">Vehiclel</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">( )</span>&#123;<span class="comment">//写出计算卡车的燃料效率的具体方法&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">( )</span>&#123;<span class="comment">//写出计算卡车行驶距离的具体方法&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//驳船子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RiverBarge</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">( )</span>&#123;<span class="comment">//写出计算驳船的燃料效率的具体方法&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">( )</span>&#123;<span class="comment">//写出计算驳船行驶距离的具体方法&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GeometricObject</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">GeometricObject</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IO流中设计到的抽象类：InputStream&#x2F;OutputStream &#x2F; Reader &#x2F;Writer。在其内部定义了抽象的read()、write()方法。</p></blockquote><hr><blockquote><p>模板方法设计模式</p></blockquote><p><strong>解决的问题：</strong></p><p>在软件开发中，实现一个算法时，整体步骤固定、通用，这些步骤在父类已经写好了，但是某些部分易变，那么这些易变的部分就可以抽象出来，供不同子类实现。这就是一种模板模式。</p><p><strong>应用举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算某段代码执行所需要花费的时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">spendTime</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.code();<span class="comment">//不确定的部分、易变的部分</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubTemplate</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= Math.sqrt(i);j++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">isFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestTemplate</span> <span class="variable">testTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestTemplate</span>();</span><br><span class="line">        <span class="comment">//调用父类抽象类中的普通公用方法</span></span><br><span class="line">        testTemplate.spendTime();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>应用场景</p></blockquote><p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有</p><ul><li>数据库访问的封装</li><li>Junt单元测试</li><li>JavaWeb的 Servlet中关于 doGet&#x2F;doPost方法调用</li><li>Hibernate中模板程序</li><li>Spring中 JDBCTemlate、 Hibernate Template等</li></ul><hr><h3 id="8、interface–接口"><a href="#8、interface–接口" class="headerlink" title="8、interface–接口"></a>8、interface–接口</h3><blockquote><p>概述</p></blockquote><ul><li>接口使用Interface定义</li><li>Java中，接口和类是并列的两个结构</li></ul><blockquote><p>Interface关键字使用说明</p></blockquote><ul><li><p>如何定义接口：定义接口中的成员</p></li><li><p>接口中不能定义构造器的！意味着接口不可以实例化。</p></li><li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.</p><ul><li>如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化</li><li>如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</li></ul></li><li><p>&#x3D;&#x3D;Java类可以实现多个接口 —&gt;弥补了Java单继承性的局限性&#x3D;&#x3D;</p><ul><li>格式：class AA extends BB implements CC,DD,EE</li></ul></li><li><p>接口与接口之间可以继承，而且可以多继承</p></li><li><p>&#x3D;&#x3D;接口的具体使用，体现多态性&#x3D;&#x3D;【类的继承关系，方法的重写】</p></li><li><p>接口，实际上可以看做是一种规范</p></li></ul><p><strong>应用举例：</strong>不同的设备通过USB口接入电脑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferData</span><span class="params">(USB usb)</span>&#123;</span><br><span class="line">        <span class="comment">//USB usb = new Flash();</span></span><br><span class="line">        <span class="type">USB</span> <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">usb.start();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;具体传输数据的细节&quot;</span>);</span><br><span class="line"></span><br><span class="line">usb.stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"><span class="comment">//常量：定义了长、宽、最大最小的传输速度等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flash</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘开启工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机开启工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用总结</strong></p><ol><li>接口使用上也满足多态性</li><li>接口，实际上就是定义了一种规范</li><li>开发中，体会面向接口编程！</li></ol><blockquote><p>面向接口编程思想</p></blockquote><p><img src="/2022/06/13/javaSE/image-20220519103703021.png" alt="image-20220519103703021"> </p><p>面向接口编程：我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个 数据库厂商的API。</p><blockquote><p>Java8关于接口的新规范</p></blockquote><p>JDK7及以前：只能定义全局常量和抽象方法</p><ul><li>全局常量：public static final的，书写时可以省略不写</li><li>抽象方法：public abstract的</li></ul><p>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</p><ul><li><p>Java8中，可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。</p></li><li><p>静态方法：使用 static关键字修饰。</p><p>可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像 Collection&#x2F;co| ections或者Path&#x2F; Paths这样成对的接口和类。</p></li><li><p>默认方法：默认方法使用 default关键字修饰。</p></li><li><p>可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性比如：java8API中对 Collection、List、 Comparator等接口提供了丰富的默认方法。</p></li></ul><blockquote><p>总结</p></blockquote><p>知识点1：接口中定义的静态方法，只能通过接口来调用。</p><p>知识点2：通过实现类的对象，可以调用接口中的默认方法。</p><p>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</p><p>知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt;类优先原则</p><p>知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</p><p>那么在实现类没重写此方法的情况下，报错。–&gt;接口冲突。</p><p>这就需要我们必须在实现类中重写此方法</p><p>知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>&#123;</span><br><span class="line">method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line"><span class="built_in">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line"><span class="comment">//调用接口中的默认方法</span></span><br><span class="line">CompareA.<span class="built_in">super</span>.method3();</span><br><span class="line">CompareB.<span class="built_in">super</span>.method3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象类和接口的异同？</strong> </p><p>相同点：&#x3D;&#x3D;都不能实例化；都可以被继承；都可以包含抽象方法的。&#x3D;&#x3D;</p><p>不同点：</p><p>​抽象类：有构造器。接口：没有构造器</p><p>​1）把抽象类和接口(java7,java8,java9)的定义、内部结构解释说明</p><p>​2）类：单继承性；接口：多实现</p><blockquote><p>代理模式</p></blockquote><p>为其他对象提供一种代理，以控制对这个对象的访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> <span class="keyword">implements</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;真实的服务器访问网络&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyServer</span> <span class="keyword">implements</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> NetWork work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProxyServer</span><span class="params">(NetWork work)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.work = work;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;联网之前的检查工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span> &#123;</span><br><span class="line">check();</span><br><span class="line"></span><br><span class="line">work.browse();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyServer</span> <span class="variable">proxyServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyServer</span>(<span class="keyword">new</span> <span class="title class_">Server</span>());</span><br><span class="line">        proxyServer.browse();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong></p><ul><li>安全代理：屏蔽对真实角色的直接访问</li><li>远程代理：通过代理类处理远程方法调用（RM）</li><li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象 比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用 proxy来进行大图片的打开。</li></ul><p><strong>分类</strong></p><ul><li>静态代理（静态定义代理类）</li><li>动态代理（动态生成代理类）JDK自带的动态代理，需要反射等知识</li></ul><blockquote><p>工厂设计模式</p></blockquote><p><strong>解决的问题</strong></p><p>实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p><p><strong>具体模式：</strong></p><ul><li>简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</li><li>工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品)</li><li>抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)</li></ul><hr><h1 id="二、java高级"><a href="#二、java高级" class="headerlink" title="二、java高级"></a>二、java高级</h1><h2 id="2-1、枚举类-amp-注解"><a href="#2-1、枚举类-amp-注解" class="headerlink" title="2.1、枚举类&amp;注解"></a>2.1、枚举类&amp;注解</h2><h3 id="2-2-1、枚举类的使用"><a href="#2-2-1、枚举类的使用" class="headerlink" title="2.2.1、枚举类的使用"></a>2.2.1、枚举类的使用</h3><blockquote><p>枚举类说明</p></blockquote><ol><li><p>枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类</p></li><li><p>当需要定义一组常量时，强烈建议使用枚举类</p></li><li><p>枚举类的实现：</p><p>JDK 5.0以前需要自定义</p><p>JDK 5.0后新增enum关键字用于定义枚举类</p></li><li><p>如果枚举类中只一个对象，则可以作为单例模式的实现方式。</p></li><li><p>枚举类的属性：</p><p>枚举类对象的属性不应允许被改动，所以应该使用 private final修饰 枚举类的使用 private final修饰的属性应该在构造器中为其赋值 若枚举类显式的定义了带参数的构造器，则在列出枚举值时也必须对应的传入参数</p></li></ol><blockquote><p>自定义枚举类</p></blockquote><p><strong>步骤：</strong></p><ol><li>&#x3D;&#x3D;私有化构造器，保证<strong>不能在类的外部创建其对象</strong>&#x3D;&#x3D;；</li><li>在类的内部创建枚举类的示例。声明为：public static final；</li><li>对象如果有实例变量，应该声明为private final，并在构造器中初始化；</li></ol><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//1.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.其他诉求1：提供toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Test:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(SeasonEnum.SPRING);<span class="comment">//SeasonEnum&#123;seasonName=&#x27;春天&#x27;, seasonDesc=&#x27;春暖花开&#x27;&#125;</span></span><br><span class="line">        System.out.println(SeasonEnum.SPRING.getSeasonDesc());</span><br><span class="line">        System.out.println(SeasonEnum.SPRING.getSeasonName());</span><br><span class="line">        System.out.println(SeasonEnum2.AUTUMN.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JDK5.0新增使用enum定义枚举类</p></blockquote><p><strong>使用说明：</strong></p><ul><li>使用enum定义的枚举类默认继承了 <code>java.lang.Enum</code> 类，因此不能再继承其他类</li><li>枚举类的&#x3D;&#x3D;构造器只能使用private权限修饰符&#x3D;&#x3D;</li><li>枚举类的所有实例必须在枚举类中显式列出(<code>,</code> 分隔 <code>;</code> 结尾)。列出的实例系统会自动添加<code>public static final</code> 修饰</li><li>&#x3D;&#x3D;必须在枚举类的第一行声明枚举类对象&#x3D;&#x3D;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> &#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(SeasonEnum2.SPRING);</span><br><span class="line">        System.out.println(SeasonEnum2.AUTUMN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Enum类的常用方法</strong></p><p><code>values()</code>方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</p><p><code>valueOf(String str)</code>：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”.如不是，会有运行时异常 <code>IllegalArgumentException</code></p><p><code>toString()</code>：返回当前枚举类对象常量的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season1</span> <span class="variable">summer</span> <span class="operator">=</span> Season1.SUMMER;</span><br><span class="line"><span class="comment">//toString():返回枚举类对象的名称</span></span><br><span class="line">System.out.println(summer.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(Season1.class.getSuperclass());</span></span><br><span class="line">System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line"><span class="comment">//values():返回所的枚举类对象构成的数组</span></span><br><span class="line">Season1[] values = Season1.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">    System.out.println(values[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">Thread.State[] values1 = Thread.State.values();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values1.length; i++) &#123;</span><br><span class="line">    System.out.println(values1[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//valueOf(String objName):返回枚举类中对象名是objName的对象。</span></span><br><span class="line"><span class="type">Season1</span> <span class="variable">winter</span> <span class="operator">=</span> Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line"><span class="comment">//如果没objName的枚举类对象，则抛异常：IllegalArgumentException</span></span><br><span class="line"><span class="comment">//        Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);</span></span><br><span class="line">System.out.println(winter);</span><br></pre></td></tr></table></figure><p><strong>用Enum类定义的枚举类对象分别实现接口：</strong></p><ol><li>和普通Java类一样，&#x3D;&#x3D;枚举类可以实现一个或多个接口&#x3D;&#x3D;</li><li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</li><li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2、注解的使用"><a href="#2-2-2、注解的使用" class="headerlink" title="2.2.2、注解的使用"></a>2.2.2、注解的使用</h3><blockquote><p>注解的理解</p></blockquote><p>① jdk 5.0 新增的功能</p><p>② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation,程序员可以在不改变原逻辑的情况下, 在源文件中嵌入一些补充信息。</p><p>③ Annotation可以像修饰符一样使用，可以用来修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在Annotation的 <code>name = value</code> 对中。</p><p>④ 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE&#x2F;Android 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗 代码和XML配置等。</p><p>⑤&#x3D;&#x3D;框架 &#x3D; 注解 + 反射机制 + 设计模式&#x3D;&#x3D;</p><blockquote><p>注解的使用示例</p></blockquote><p>使用 Annotation时要在其前面增加 <code>@</code> 符号，并把该 Annotation当成个修饰符使用。用于修饰它支持的程序元素</p><p><strong>示例一：生成文档相关的注解</strong></p><ul><li><p><code>@author</code> 标明开发该类模块的作者，多个作者之间使用，分割 <code>@version</code> 标明该类模块的版本；</p></li><li><p><code>@see</code> 参考转向，也就是相关主题；</p></li><li><p><code>@since</code> 从哪个版本开始增加的；</p></li><li><p><code>@param</code> 对方法中某参数的说明，如果没有参数就不能写 <code> @return</code> 对方法返回值的说明，如果方法的返回值类型是 <code>void</code> 就不能写 <code>@exception</code> 对方法可能抛出的异常进行说明，如果方法没有用 <code>throws</code> 显式抛出的异常就不能写；</p></li><li><p>其中 <code>@param</code> 、 <code>@return</code> 和 <code>@exception</code> 这三个标记都是只用于方法的。</p></li><li><p><code>@param</code> 的格式要求：<code>@param</code> 形参名形参类型形参说明；</p></li><li><p><code>@return</code> 的格式要求：<code>@return</code> 返回值类型返回值说明；</p></li><li><p><code>@exception</code> 的格式要求：<code>@exception</code> 异常类型异常说明；</p></li><li><p><code>@param</code> 和 <code>@exception</code> 可以并列多个；</p></li></ul><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> bruce</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@project</span>_name JavaSenior</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span>_name com.bruce.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-04-26 10:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *程序的主方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 传入命令行参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求圆形面积</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> radius 所求面积的半径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 面积值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例二：在编译时进行格式检查(JDK内置的个基本注解)</strong></p><ul><li><code>@Override</code>: 限定重写父类方法, 该注解只能用于方法；</li><li><code>@Deprecated</code>: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的择；</li><li><code>@SuppressWarnings</code>: 抑制编译器警告；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mian</span> <span class="params">(String [] args)</span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarning(&quot;unused&quot;)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;过时的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;重写的toString方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例三：跟踪代码依赖性，实现替代配置文件功能</strong></p><p>在使用Spring框架时会大量用到注解驱动开发。</p><blockquote><p>自定义注解</p></blockquote><p><strong>参照 <code>@SuppressWarnings</code> 定义</strong></p><ol><li>注解声明为：<code>@interface</code></li><li>内部定义成员，通常使用value表示</li><li>可以指定成员的默认值，使用default定义</li><li>如果自定义注解没成员，表明是一个标识作用。</li></ol><p><strong>说明：</strong></p><ul><li>如果注解有成员，在使用注解时，需要指明成员的值。</li><li>自定义注解必须配上注解的信息处理流程(使用反射)才意义。</li><li>自定义注解通过都会指明两个元注解：<code>@Retention</code>、<code>@Target</code></li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>元注解</p></blockquote><p>对现有的注解进行解释说明的注解。</p><p>JDK 5.0 提供的4种元注解：</p><p><code>@Retention</code>：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为）\RUNTIME只有声明为RUNTIME生命周期的注解，才能通过反射获取。</p><p><code>@Target</code>:用于指定被修饰的 Annotation 能用于修饰哪些程序元素 </p><p><img src="/2022/06/13/javaSE/image-20220522140737579.png" alt="image-20220522140737579"> </p><p><code>@Documented</code>:表示所修饰的注解在被javadoc解析时，保留下来。</p><p><code>@Inherited</code>:被它修饰的 Annotation 将具继承性。</p><blockquote><p>获取注解信息</p></blockquote><p>通过发射来进行获取、调用。</p><p>前提：要求此注解的元注解Retention中声明的生命周期状态为：RUNTIME.</p><blockquote><p>JDK8.0中注解新特性</p></blockquote><p>可重复注解、类型注解</p><p><strong>可重复注解：</strong></p><p>① 在MyAnnotation上声明 <code>@Repeatable</code>，成员值为 <code>MyAnnotations.class</code></p><p>② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。</p><p><strong>类型注解：</strong></p><p><code>ElementType.TYPE_PARAMETER</code> 表示该注解能写在类型变量的声明语句中（如：泛型声明。）</p><p><code>ElementType.TYPE_USE</code> 表示该注解能写在使用类型的任何语句中。</p><h2 id="2-2、java集合"><a href="#2-2、java集合" class="headerlink" title="2.2、java集合"></a>2.2、java集合</h2><h3 id="2-2-1、集合与数组"><a href="#2-2-1、集合与数组" class="headerlink" title="2.2.1、集合与数组"></a>2.2.1、集合与数组</h3><blockquote><p>集合与数组存储数据概述</p></blockquote><p>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 说明：此时的存储，&#x3D;&#x3D;主要指的是<strong>内存层面的存储</strong>&#x3D;&#x3D;，&#x3D;&#x3D;不涉及到持久化的存储&#x3D;&#x3D;（.txt,.jpg,.avi，数据库中)</p><blockquote><p>数组的存储特点</p></blockquote><p>一旦初始化以后，其长度确定；数组一旦定义好后，其元素类型确定；<br>我们只能操作制定类型的数据。</p><p>例如：<code>String[] str</code>、<code>int[] arr</code>、<code>Object[] arr2</code></p><blockquote><p>数组存储的弊端</p></blockquote><ol><li>数组一旦初始化之后，长度不可修改</li><li>数组提供的方法有限，对于添加，删除，插入数据等操作，非常不便，且效率不高</li><li>获取数组中实际元素个数的需求，数组没有现成的方法可用</li><li>&#x3D;&#x3D;<strong>数组</strong>&#x3D;&#x3D;存储的特点：&#x3D;&#x3D;<strong>有序、可重复</strong>&#x3D;&#x3D;；对无序不可重复的需求不能满足。</li></ol><blockquote><p>集合存储优点</p></blockquote><ul><li>解决数组存储数据的弊端</li></ul><blockquote><p>集合的分类</p></blockquote><p>Java的集合可分为Collection和Map两种体系</p><ul><li><strong>Collection</strong>接口：<strong>单列数据</strong>，定义了存储一组对象的方法的集合<ul><li><strong>List</strong>：元素&#x3D;&#x3D;有序、可重复&#x3D;&#x3D;的集合</li><li><strong>Set</strong>：元素&#x3D;&#x3D;无序、不可重复&#x3D;&#x3D;的集合</li></ul></li><li><strong>Map</strong>接口：<strong>双列数据</strong>，保存具有&#x3D;&#x3D;映射关系“key-value键值对”&#x3D;&#x3D;的集合</li></ul><blockquote><p>集合的框架结构</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">     |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span><br><span class="line">           |----ArrayList：作为List接口的主要实现类，线程不安全的，效率高;底层采用Object[] elementData数组存储</span><br><span class="line">           |----LinkedList：对于频繁的插入删除操作，使用此类效率比ArrayList效率高底层采用双向链表存储</span><br><span class="line">           |----Vector：作为List的古老实现类，线程安全的，效率低;底层采用Object[]数组存储</span><br><span class="line">           </span><br><span class="line">     |----Set接口：存储无序的、不可重复的数据   --&gt;数学概念上的“集合”</span><br><span class="line">           |----HashSet：作为Set接口主要实现类;线程不安全;可以存<span class="literal">null</span>值</span><br><span class="line">           |----LinkedHashSet：作为HashSet的子类;遍历其内部数据时，可以按照添加顺序遍历;对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">           |----TreeSet：可以按照添加对象的指定属性，进行排序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)</span><br><span class="line">     |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储<span class="literal">null</span>的key和value</span><br><span class="line">          |----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。</span><br><span class="line">                    原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</span><br><span class="line">                    对于频繁的遍历操作，此类执行效率高于HashMap。</span><br><span class="line">     |----TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序</span><br><span class="line">                      底层使用红黑树</span><br><span class="line">     |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储<span class="literal">null</span>的key和value</span><br><span class="line">          |----Properties:常用来处理配置文件。key和value都是String类型</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-2、Collection接口"><a href="#2-2-2、Collection接口" class="headerlink" title="2.2.2、Collection接口"></a>2.2.2、Collection接口</h3><ul><li><p>Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和 Queue集合。</p></li><li><p>JDK不提供此接口的任何直接实现，而是提供更具体的子接口（如：Set和List）实现。</p></li><li><p>在JDK 5.0之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object类型处理；从JDK 5.0增加了泛型以后，Java集合可以记住容器中对象的数据类型。</p></li></ul><blockquote><p>单列集合框架结构</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">     |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span><br><span class="line">           |----ArrayList：作为List接口的主要实现类，线程不安全的，效率高;底层采用Object[] elementData数组存储</span><br><span class="line">           |----LinkedList：对于频繁的插入删除操作，使用此类效率比ArrayList效率高底层采用双向链表存储</span><br><span class="line">           |----Vector：作为List的古老实现类，线程安全的，效率低;底层采用Object[]数组存储</span><br><span class="line">           </span><br><span class="line">     |----Set接口：存储无序的、不可重复的数据   --&gt;数学概念上的“集合”</span><br><span class="line">           |----HashSet：作为Set接口主要实现类;线程不安全;可以存<span class="literal">null</span>值</span><br><span class="line">           |----LinkedHashSet：作为HashSet的子类;遍历其内部数据时，可以按照添加顺序遍历;对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">           |----TreeSet：可以按照添加对象的指定属性，进行排序。</span><br></pre></td></tr></table></figure><p>图示：</p><p><img src="/2022/06/13/javaSE/image-20220522150831530.png" alt="image-20220522150831530"> </p><blockquote><p>Collection接口常用方法</p></blockquote><ol><li>添加<ul><li>add(Object obj)</li><li>addAll(Collection coll)</li></ul></li><li>获取有效元素个数<ul><li>int size()</li></ul></li><li>清空集合<ul><li>void clear()</li></ul></li><li>是否为空集合<ul><li>boolean isEmpty()</li></ul></li><li>是否包含某个元素<ul><li>boolean contains(Object obj)：通过元素的equals()方法来判断是否是同一个对象</li><li>boolean contains(Collection coll)：也是调用元素的equals方法来比较的。用两个集合的元素逐一比较</li></ul></li><li>删除<ul><li>boolean remove(Object obj)：通过元素的equals方法判断是否要删除的那个元素，只会删除找到的第一个元素</li><li>boolean removeAll(Collection coll)：取当前集合的差集</li></ul></li><li>取两个集合的交集<ul><li>boolean retainAll(Collection coll)：把交集的结果存到当前集合中，不影响coll集合</li></ul></li><li>集合是否相等<ul><li>boolean equals(Object obj)</li></ul></li><li>集合数组互转<ul><li>集合–&gt;数组：<code>Object[] toArray();</code></li><li>数组–&gt;集合：<code>Arrays.asList(new int[]&#123;123, 345&#125;);</code></li></ul></li><li>获取集合对象的哈希值<ul><li>hashCode()</li></ul></li><li>遍历<ul><li>iterator()：返回迭代器对象，用于集合遍历</li></ul></li></ol><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">//1.add(Object e):将元素添加到集合中</span></span><br><span class="line">    collection.add(<span class="string">&quot;ZZ&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    collection.add(<span class="number">123</span>);</span><br><span class="line">    collection.add(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="comment">//2.size():获取添加元素的个数</span></span><br><span class="line">    System.out.println(collection.size());<span class="comment">//5</span></span><br><span class="line">    <span class="comment">//3.addAll(Collection coll1):将coll1集合中的元素添加到当前集合中</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    collection1.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    collection1.add(<span class="number">213</span>);</span><br><span class="line">    collection.addAll(collection1);</span><br><span class="line">    System.out.println(collection.size());<span class="comment">//9</span></span><br><span class="line">    <span class="comment">//调用collection1中的toString()方法输出</span></span><br><span class="line">    System.out.println(collection);<span class="comment">//[ZZ, AA, BB, 123, Tue Apr 28 09:22:34 CST 2020, 213, 213]</span></span><br><span class="line">    <span class="comment">//4.clear():清空集合元素</span></span><br><span class="line">    collection1.clear();</span><br><span class="line">    System.out.println(collection1.size());<span class="comment">//0</span></span><br><span class="line">    System.out.println(collection1);<span class="comment">//[]</span></span><br><span class="line">    <span class="comment">//5.isEmpty():判断当前集合是否为空</span></span><br><span class="line">    System.out.println(collection1.isEmpty());<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//6.contains(Object obj):判断当前集合中是否包含obj</span></span><br><span class="line">    <span class="comment">//判断时需要调用obj对象所在类的equals()方法</span></span><br><span class="line">    System.out.println(coll.contains(<span class="number">123</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>)));<span class="comment">//true</span></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">23</span>)));<span class="comment">//false</span></span><br><span class="line">    <span class="comment">//7.containsAll(Collection coll1):判断形参coll1中的元素是否都存在当前集合中</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">4566</span>);</span><br><span class="line">    System.out.println(coll.containsAll(coll1));<span class="comment">//flase</span></span><br><span class="line">    <span class="comment">//8.remove(Object obj):从当前集合中移除obj元素</span></span><br><span class="line">    coll.remove(<span class="number">123</span>);</span><br><span class="line">    System.out.println(coll);<span class="comment">//[456, Person&#123;name=&#x27;Tom&#x27;, age=23&#125;, Person&#123;name=&#x27;Jarry&#x27;, age=34&#125;, false]</span></span><br><span class="line">    <span class="comment">//9.removeAll(Collection coll1):差集：从当前集合中和coll1中所有的元素</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">456</span>, <span class="literal">false</span>);</span><br><span class="line">    coll.removeAll(coll2);</span><br><span class="line">    System.out.println(coll);<span class="comment">//[Person&#123;name=&#x27;Tom&#x27;, age=23&#125;, Person&#123;name=&#x27;Jarry&#x27;, age=34&#125;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//10.retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，并返回给当前集合</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">345</span>, <span class="number">456</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> coll.retainAll(coll1);</span><br><span class="line">    System.out.println(b);<span class="comment">//true</span></span><br><span class="line">    System.out.println(coll);<span class="comment">//[123, 456]</span></span><br><span class="line">    <span class="comment">//11.equals(Object obj):返回true需要当前集合和形参集合的元素相同</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll2.add(<span class="number">123</span>);</span><br><span class="line">    coll2.add(<span class="number">456</span>);</span><br><span class="line">    System.out.println(coll.equals(coll2));<span class="comment">//true</span></span><br><span class="line">    <span class="comment">//12.hashCode():返回当前对象的哈希值</span></span><br><span class="line">    System.out.println(coll.hashCode());<span class="comment">//5230</span></span><br><span class="line">    <span class="comment">//13.集合---&gt;数组:toArray()</span></span><br><span class="line">    Object[] array = coll.toArray();</span><br><span class="line">    <span class="keyword">for</span> (Object obj : array) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//14.数组---&gt;集合:调用Arrays类的静态方法asList()</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; ints = Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">345</span>&#125;);</span><br><span class="line">    System.out.println(ints.size());<span class="comment">//1</span></span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    System.out.println(strings);<span class="comment">//[AA, BB, CC]</span></span><br><span class="line">    <span class="comment">//15.iteratoriterator():返回Iterator接口的实例，用于遍历集合元素。</span></span><br><span class="line">            <span class="comment">//迭代器遍历</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> list1.iterator();<span class="comment">//创建一个迭代器</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Collection集合与数组间的转换</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//集合 ---&gt;数组：toArray()</span></span><br><span class="line">Object[] arr = coll.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展：数组 ---&gt;集合:调用Arrays类的静态方法asList(T ... t)</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr1</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr1.size());<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr2</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr2.size());<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>使用 Collection 集合存储对象，要求对象所属的类满足：</p><ul><li>向 Collection 接口的实现类的对象中添加数据 obj 时，要求 obj 所在类要重写 <code>equals()</code>。</li></ul><h3 id="2-2-3、Iterator接口和foreach的循环"><a href="#2-2-3、Iterator接口和foreach的循环" class="headerlink" title="2.2.3、Iterator接口和foreach的循环"></a>2.2.3、Iterator接口和foreach的循环</h3><blockquote><p>遍历Collection的两种方式：</p></blockquote><p>① 使用迭代器Iterator</p><p>② foreach循环（或增强for循环）</p><blockquote><p>java.utils包下定义的迭代器接口：iterator</p></blockquote><p><strong>说明：</strong></p><p>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。 GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</p><p><strong>作用：</strong></p><p>遍历Collection集合元素</p><p><strong>如何获取实例：</strong></p><p><code>coll.iterator()</code>：返回一个实例</p><p><strong>遍历代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"><span class="comment">//hasNext():判断是否还下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="comment">//next():①指针下移 ②将下移以后集合位置上的元素返回</span></span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图示说明：</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2459e96817c4abe98f9e25ac8d70c45~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200427150811299"> </p><p><strong>iterator中remove()方法的使用：</strong></p><ul><li><p>测试Iterator中的 <code>remove()</code></p></li><li><p>如果还未调用 <code>next()</code> 或在上一次调用 <code>next()</code> 方法之后已经调用了 <code>remove()</code> 方法，再调用 remove 都会报 <code>IllegalStateException</code>。</p></li><li><p>内部定义了 <code>remove()</code>,&#x3D;&#x3D;可以<strong>在遍历的时候</strong>，删除集合中的元素&#x3D;&#x3D;。此方法不同于集合直接调用<code>remove()</code></p></li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    coll.add(<span class="string">&quot;Tom&quot;</span></span><br><span class="line">            );</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除集合中&quot;Tom&quot;</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">//            iterator.remove();</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">            <span class="comment">//                iterator.remove();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将指针重新放到头部，遍历集合</span></span><br><span class="line">    iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JDK5.0新特性：增强for循环（foreach）</p></blockquote><p><strong>1、遍历集合举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for(集合元素的类型 局部变量 : 集合对象)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>内部仍然调用了迭代器。</p><p><strong>2、遍历数组举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//for(数组元素的类型 局部变量 : 数组对象)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-4、Collection子接口：List接口"><a href="#2-2-4、Collection子接口：List接口" class="headerlink" title="2.2.4、Collection子接口：List接口"></a>2.2.4、Collection子接口：List接口</h3><blockquote><p>存储数据特点：</p></blockquote><p>存储&#x3D;&#x3D;有序的、可重复&#x3D;&#x3D;的数据</p><ul><li><p>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</p></li><li><p>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</p></li><li><p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</p></li><li><p>JDK AP中List接口的实现类常用的有：ArrayList、LinkedList和 Vector.</p></li></ul><blockquote><p>常用方法：</p></blockquote><p>List除了从 Collection集合继承的方法外，List集合里添加了一些&#x3D;&#x3D;根据索引来操作集合元素&#x3D;&#x3D;的方法。</p><p><code>void add(int index, Object ele)</code>:在index位置插入ele元素</p><p><code>boolean addAll(int index, Collection eles)</code>:从index位置开始将eles中的所有元素添加进来</p><p><code>Object get(int index)</code>:获取指定index位置的元素</p><p><code>int indexOf(Object obj)</code>:返回obj在集合中首次出现的位置</p><p><code>int lastIndexOf(Object obj)</code>:返回obj在当前集合中末次出现的位置</p><p><code>Object remove(int index)</code>:移除指定index位置的元素，并返回此元素</p><p><code>Object set(int index, Object ele)</code>:设置指定index位置的元素为ele</p><p><code>List subList(int fromIndex, int toIndex)</code>:返回从fromIndex到toIndex位置的子集合</p><p><strong>总结：</strong></p><ul><li><p>增：<code>add(Object obj)</code></p></li><li><p>删：<code>remove(int index)</code> &#x2F; <code>remove(Object obj)</code></p></li><li><p>改：<code>set(int index, Object ele)</code></p></li><li><p>查：<code>get(int index)</code></p></li><li><p>插：<code>add(int index, Object ele)</code></p></li><li><p>长度：<code>size()</code></p></li><li><p>遍历： ① Iterator迭代器方式 ② foreach（增强for循环） ③ 普通的循环</p></li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    <span class="comment">//int indexOf(Object obj):返回obj在集合中首次出现的位置。如果不存在，返回-1.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(<span class="number">4567</span>);</span><br><span class="line">    System.out.println(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置。如果不存在，返回-1.</span></span><br><span class="line">    System.out.println(list.lastIndexOf(<span class="number">456</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object set(int index, Object ele):设置指定index位置的元素为ele</span></span><br><span class="line">    list.set(<span class="number">1</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的左闭右开区间的子集合</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">subList</span> <span class="operator">=</span> list.subList(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    System.out.println(subList);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//void add(int index, Object ele):在index位置插入ele元素</span></span><br><span class="line">    list.add(<span class="number">1</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    list.addAll(list1);</span><br><span class="line">    <span class="comment">//        list.add(list1);</span></span><br><span class="line">    System.out.println(list.size());<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object get(int index):获取指定index位置的元素</span></span><br><span class="line">    System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>常用实现类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> 常用实现类：</span><br><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">  |----List接口：存储序的、可重复的数据。  --&gt;“动态”数组,替换原的数组</span><br><span class="line">      |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</span><br><span class="line">      |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</span><br><span class="line">      |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</span><br></pre></td></tr></table></figure><p><strong>ArrayList</strong></p><ul><li>ArrayList是List接口的典型实现类，主要实现类</li><li>本质上，ArrayList是对象引用的一个”可变长度“数组</li><li>ArrayList的JDK1.8之前与之后实现的区别：<ul><li><strong>JDK1.7</strong>：ArrayList像饿汉式，<strong>直接创建</strong>一个初始容量为10的数组</li><li><strong>JDK 1.8</strong>：ArrayList像懒汉式，<strong>一开始创建一个长度为0的数组</strong>，<strong>当添加第一个元素时再创建一个始容量为10的数组</strong></li></ul></li><li><code>Arrays.asList(...)</code>方法返回的List集合，既不是 ArrayList实例，也不是Vector实例。<code>Arrays.asList(...)</code>返回值是一个固定长度的List集合</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">345</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//iterator()遍历ArrayList集合</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedList</strong></p><ul><li>对于频繁的<strong>插入</strong>【<code>add(int index, Object ele)</code>】和<strong>删除</strong>【<code>remove(int index)</code> &#x2F; <code>remove(Object obj)</code>】元素操作，建议使用LinkedList类，效率更高</li><li>新增方法：<ul><li>void addFirst(Object obj)</li><li>void addLast(Object obj)</li><li>Object getFirst()</li><li>Object getLast()</li><li>Object removeFirest()</li><li>Object removeLast()</li></ul></li><li>LinkedList：双向链表，内部没有声明数组，定义了Node类型的First、Last，用于记录首末元素，同时，定义内部类Node,作为LinkedList中保存的基本数据结构。Node除了保存数据，还定义了两个变量：<ul><li>prev：记录前一个元素的位置</li><li>next：记录下一个元素的位置</li></ul></li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    linkedList.add(<span class="number">123</span>);</span><br><span class="line">    linkedList.add(<span class="number">345</span>);</span><br><span class="line">    linkedList.add(<span class="number">2342</span>);</span><br><span class="line">    linkedList.add(<span class="string">&quot;DDD&quot;</span>);</span><br><span class="line">    linkedList.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> linkedList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>源码分析</p></blockquote><p><strong>1、ArrayList源码分析</strong></p><p><strong>Jdk7.0情况下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//elementData[0] = new Integer(123);</span></span><br><span class="line">...</span><br><span class="line">list.add(<span class="number">11</span>);<span class="comment">//如果此次的添加导致底层elementData数组容量不够，则扩容。</span></span><br></pre></td></tr></table></figure><ul><li>默认情况下，扩容为原来容量的1.5倍，同时将原有数组中的数据复制到新的数组中。</li><li>结论：建议开发中使用带参的构造器：<code>ArrayList list = new ArrayList(int capacity)</code></li></ul><p><strong>jdk8.0中ArrayList的变化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//底层Object[] elementData初始化为&#123;&#125;.并没创建长度为10的数组</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>后续的添加和扩容操作与JDK 7.0 无异。</p><p><strong>小结：</strong></p><p>JDK 7.0中的ArrayList的对象的创建类似于单例的饿汉式，<br>JDK 8.0中的ArrayList的对象的创建类似于单例的懒汉式，&#x3D;&#x3D;延迟了数组的创建，节省内存。&#x3D;&#x3D;</p><hr><p><strong>2、LinkedList源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(); <span class="comment">//内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//将123封装到Node中，创建了Node对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其中，Node定义为：体现了LinkedList的双向链表的说法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>3、Vector的源码分析</strong></p><ul><li><p>Vector是一个古老的集合，JDK 1.0就有了。大多数操作与ArrayList相同，区别在于Vector是线程安全的</p></li><li><p>在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免选择使用。</p></li><li><p>JDK 7.0和JDK 8.0中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</p></li><li><p>在扩容方面，默认扩容为原来的数组长度的2倍。</p></li></ul><blockquote><p>存储元素的要求</p></blockquote><p>添加的对象，所在的类要重写equals()；</p><blockquote><p>面试题</p></blockquote><p>请问 ArrayList&#x2F;LinkedList&#x2F;Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？ Vector和 ArrayList的最大区别？</p><ul><li>ArrayList和LinkedList的异同<ul><li>二者都是线程不安全的，相比线程安全的Vector，ArrayList执行效率高。</li><li>ArrayLists实现了基于动态数组的数据结构，LinkedList是基于链表的数据结构。</li><li>对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针</li><li>对于插入add和删除remove操作，LinkedList占优势，双向链表结构</li></ul></li><li>ArrayList和Vector的区别<ul><li>唯一区别在于Vector是同步类，线程安全</li></ul></li><li>Vector每次扩容请求是其大小的2倍空间，ArrayList是1.5倍。</li></ul><h3 id="2-2-5、Collection子接口：Set接口"><a href="#2-2-5、Collection子接口：Set接口" class="headerlink" title="2.2.5、Collection子接口：Set接口"></a>2.2.5、Collection子接口：Set接口</h3><ul><li><p>Set接口是Collection的子接口，set接口没有提供额外的方法</p></li><li><p>Set集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set集合中，则添加操作失败。（多用于过滤操作，去掉重复数据）     </p></li><li><p>Set判断两个对象是否相同不是使用&#x3D;&#x3D;运算符，而是根据equals()方法</p></li></ul><blockquote><p>存储的数据特点</p></blockquote><p>用于存放&#x3D;&#x3D;无序的、不可重复&#x3D;&#x3D;的元素</p><p>以HashSet为例说明：</p><ol><li>无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。</li><li>不可重复性：保证添加的元素照equals()判断时，不能返回true.即：相同的元素只能添加一个。</li></ol><h3 id="2-2-6、Map接口"><a href="#2-2-6、Map接口" class="headerlink" title="2.2.6、Map接口"></a>2.2.6、Map接口</h3><h3 id="2-2-7、Collection工具类的使用"><a href="#2-2-7、Collection工具类的使用" class="headerlink" title="2.2.7、Collection工具类的使用"></a>2.2.7、Collection工具类的使用</h3><h3 id="2-2-8、数据结构简述"><a href="#2-2-8、数据结构简述" class="headerlink" title="2.2.8、数据结构简述"></a>2.2.8、数据结构简述</h3><h2 id="2-3、泛型"><a href="#2-3、泛型" class="headerlink" title="2.3、泛型"></a>2.3、泛型</h2><h2 id="2-4、IO流"><a href="#2-4、IO流" class="headerlink" title="2.4、IO流"></a>2.4、IO流</h2><h2 id="2-5、多线程"><a href="#2-5、多线程" class="headerlink" title="2.5、多线程"></a>2.5、多线程</h2><h3 id="2-5-1、程序、进程、线程"><a href="#2-5-1、程序、进程、线程" class="headerlink" title="2.5.1、程序、进程、线程"></a>2.5.1、程序、进程、线程</h3><blockquote><p>程序</p></blockquote><p>概念：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。</p><blockquote><p>进程</p></blockquote><p>概念：&#x3D;&#x3D;程序的一次执行过程，或是正在运行的一个程序&#x3D;&#x3D;。 说明：进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。</p><blockquote><p>线程</p></blockquote><p>概念：进程可进一步细化为线程，是一个程序内部的一条执行路径。 说明：线程作为调度和执行的单位，每个线程拥独立的运行栈和程序计数器(pc)，线程切换的开销小。</p><p><img src="/2022/06/13/javaSE/image-20220519214024983.png" alt="image-20220519214024983"> </p><p><strong>内存结构：</strong></p><p><img src="/2022/06/13/javaSE/image-20220519214035442.png" alt="image-20220519214035442"> </p><p><strong>说明：</strong></p><p>进程可以细化为多个线程。 </p><ul><li><p>&#x3D;&#x3D;<strong>每个</strong>线程，拥有自己<strong>独立</strong>的：<strong>栈、程序计数器</strong>&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;<strong>多个</strong>线程，<strong>共享</strong>同一个进程中的结构：<strong>方法区、堆</strong>。&#x3D;&#x3D;</p></li></ul><h3 id="2-5-2、并行与并发"><a href="#2-5-2、并行与并发" class="headerlink" title="2.5.2、并行与并发"></a>2.5.2、并行与并发</h3><blockquote><p>单核CPU与多核CPU</p></blockquote><ul><li><p>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。涉及到CPU处理线程的方式，CPU在单位时间（也就是说一个时间片内）内只能处理一个线程，于是就将其他的线程设置为阻塞状态，加入到阻塞队列中，等到处理完成当前线程后从就绪队列中取出新的线程进行处理，由于切换和处理时间很快用户感知不到于是用户便认为CPU在同一时间内处理多个线程。</p></li><li><p>多核CPU，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</p></li><li><p>一个Java应用程序java.exe，其实至少三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</p></li></ul><blockquote><p>并行与并发的理解</p></blockquote><p>并行：&#x3D;&#x3D;多个&#x3D;&#x3D;CPU&#x3D;&#x3D;同时&#x3D;&#x3D;执行&#x3D;&#x3D;多个任务&#x3D;&#x3D;。比如：多个人同时<strong>做&#x3D;&#x3D;不同&#x3D;&#x3D;的事</strong>。</p><p>并发：&#x3D;&#x3D;一个&#x3D;&#x3D;CPU（采用时间片）同时执行多个任务。比如：多个人同时<strong>做&#x3D;&#x3D;同一&#x3D;&#x3D;件事</strong>。</p><p><strong>为什么要使用多线程</strong></p><p>当我们在进行商品抢购的时候，在支付按钮上总是有个计时器在进行倒计时，但是我们此时仍然可以进行商品信息的查看，这个计时器和我们浏览商品信息的线程是同时进行的，这样也就实现了抢购场景，增加了用户的体验。</p><blockquote><p>多线程程序优点</p></blockquote><ol><li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</li><li>提高计算机系统CPU的利用率。</li><li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。</li></ol><blockquote><p>应用场景</p></blockquote><ol><li>程序需要<strong>同时</strong>执行两个或多个任务。</li><li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等</li><li>需要一些后台运行的程序时</li></ol><h3 id="2-5-3、Thread类"><a href="#2-5-3、Thread类" class="headerlink" title="2.5.3、Thread类"></a>2.5.3、Thread类</h3><p>Java语言的JVM允许程序运行多个线程，它通过 java. lang.Thread类来体现</p><blockquote><p>Thread类特性</p></blockquote><p>每个线程都是通过某个特定 Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体 &#x3D;&#x3D;通过该 Thread对象的 **start()**方法来启动这个线程，而非直接调用run()；&#x3D;&#x3D;</p><blockquote><p>构造器</p></blockquote><ul><li><p>Thread()：创建新的 Thread对象</p></li><li><p>Thread（String threadName）：创建线程并指定线程实例名</p></li><li><p>Thread（Runnable target）：指定创建线程的目标对象，它实现了 Runnable接口中的run方法</p></li><li><p>Thread（Runnable target， String name）：创建新的 Thread对象</p></li></ul><blockquote><p>创建多线程的两种方式</p></blockquote><p><strong>1、继承Thread类</strong></p><ol><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</li><li>创建Thread类的子类的对象</li><li>通过此对象调用start()：①启动当前线程 ② 调用当前线程的run()</li></ol><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.继承Thread类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.重run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//3.新建Thread对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//4.调用start方法</span></span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ol><li>我们启动一个线程，&#x3D;&#x3D;必须调用start()&#x3D;&#x3D;，不能调用run()的方式启动线程。 如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start().（注意后面的点）</li><li>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式</li><li>&#x3D;&#x3D;run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。&#x3D;&#x3D;</li><li>想要启动多线程，必须调用 start方法。</li><li>&#x3D;&#x3D;一个线程对象只能调用一次 start()方法启动&#x3D;&#x3D;，如果重复调用了，则将抛出异常“lllegalThreadStateException”.</li></ol><p><img src="/2022/06/13/javaSE/image-20220519233135707.png" alt="image-20220519233135707"> </p><p><strong>2、实现Runnable接口</strong></p><ol><li>创建一个实现了Runnable接口的类</li><li>实现类去实现Runnable中的抽象方法：run()</li><li>创建实现类的对象<br><code>RunnableTest runnableTest = new RunnableTest();</code></li><li>&#x3D;&#x3D;将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象&#x3D;&#x3D;<br><code>Thread thread = new Thread(runnableTest);</code></li><li>通过Thread类的对象调用start()<br><code>thread.start();</code></li></ol><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3. 创建实现类的对象</span></span><br><span class="line">        <span class="type">RunnableTest</span> <span class="variable">runnableTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableTest</span>();</span><br><span class="line">        <span class="comment">//4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableTest);</span><br><span class="line">        <span class="comment">//5. 通过Thread类的对象调用start()</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两种方式的对比：</strong></p><p>开发中优先选择：实现Runnable接口的方式</p><p><strong>原因：</strong></p><ol><li>实现的方式没类的单继承性的局限性</li><li>实现的方式更适合来处理多个线程共享数据的情况。</li></ol><p><strong>联系：</strong>Thread类也是实现了Runnable接口的：<code>public class Thread implements Runnable</code></p><p><strong>相同点：</strong>两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 目前两种方式，要想启动线程，都是调用的Thread类中的start()。</p><blockquote><p>采用创建匿名类的方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Thread类的匿名子类的方式</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Thread类常用方法</p></blockquote><p><strong>常用方法</strong></p><ul><li><p>start():启动当前线程；调用当前线程的run()，只有Thread类和他的子类才能调用start()方法</p></li><li><p>run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</p></li><li><p>currentThread():静态方法，返回执行当前代码的线程</p><ul><li>getName():获取当前线程的名字</li><li>setName():设置当前线程的名字</li></ul></li><li><p>yield():释放当前cpu的执行权</p></li><li><p>join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。</p></li><li><p>stop():已过时。当执行此方法时，强制结束当前线程。</p></li><li><p>sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。</p></li><li><p>isAlive():判断当前线程是否存活</p></li></ul><p><strong>线程的优先级：</strong></p><ul><li>MAX_PRIORITY：10</li><li>MIN _PRIORITY：1</li><li>NORM_PRIORITY：5 –&gt;默认优先级</li></ul><p>获取和设置当前线程的优先级：</p><ul><li>getPriority():获取线程的优先级</li><li>setPriority(int p):设置线程的优先级</li></ul><p><strong>说明：</strong>高优先级的线程要抢占低优先级线程CPU的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。</p><p><strong>线程通信</strong>：wait() &#x2F; notify() &#x2F; notifyAll() :此三个方法定义在Object类中的。</p><p><strong>线程的分类</strong></p><ul><li>守护线程，如：垃圾回收线程，依赖于主线程而存在</li><li>用户线程，如：main方法的线程</li></ul><blockquote><p>Thread类的生命周期</p></blockquote><p><strong>线程的五种状态</strong></p><ul><li>新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。</li><li>就绪：处于新建状态的线程被start()后，将进入线程队列，等待CPU时间片，此时已经具备了运行条件，只是未分配到CPU资源。</li><li>运行：当就绪的线程被调度，并获得CPU资源时，并进入运行状态，run()方法定义了线程的操作和功能。</li><li>阻塞：在某种特殊情况下，被人为挂起，或执行输入输出操作时，让出CPU并临时终止自己执行，进入阻塞状态。</li><li>死亡：线程完成了它的全部工作，或线程被提前强制性停止，或出现异常导致结束。</li></ul><p><img src="/2022/06/13/javaSE/image-20220520004930246.png" alt="image-20220520004930246"> </p><p><strong>说明：</strong></p><ol><li>生命周期关注两个概念：状态、相应的方法</li><li>关注：状态a–&gt;状态b:哪些方法执行了（回调方法） 某个方法主动调用：状态a–&gt;状态b</li><li>阻塞：临时状态，不可以作为最终状态</li><li>死亡：最终状态。</li></ol><h3 id="2-5-4、线程的同步机制"><a href="#2-5-4、线程的同步机制" class="headerlink" title="2.5.4、线程的同步机制"></a>2.5.4、线程的同步机制</h3><blockquote><p>背景</p></blockquote><p>例子：创建个窗口卖票，总票数为100张.使用实现Runnable接口的方式</p><ul><li>问题：卖票过程中，出现了重票、错票 –&gt;出现了线程的安全问题</li><li>问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。</li><li>如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。</li></ul><blockquote><p>Java解决方案</p></blockquote><p>在Java中，我们通过同步机制，来解决线程的安全问题。</p><p><strong>方式一：同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;<span class="comment">//同步监视器就是需要同步线程的公共对象</span></span><br><span class="line">   <span class="comment">//需要被同步的代码</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li>操作共享数据的代码，即为需要被同步的代码。 –&gt;不能包含代码多了，也不能包含代码少了。</li><li>&#x3D;&#x3D;共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>同步监视器</strong>，俗称：锁。任何一个类的对象，都可以充当锁。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;要求多个线程必须要共用同一把锁。&#x3D;&#x3D;</li></ol><ul><li>在<strong>实现Runnable接口</strong>创建多线程的方式中，我们可以<strong>考虑使用this充当同步监视器</strong>。</li><li>在<strong>继承Thread类</strong>创建多线程的方式中，慎用this充当同步监视器，<strong>考虑使用当前类充当同步监视器</strong>。</li></ul><p><strong>代码示例：</strong></p><p><strong>1、实现Runnable接口形式同步代码块：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tick</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号窗口买票，票号为：&quot;</span> + tick--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        thread3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承Thread类形式同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">//这里注意要static修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tick</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ticket2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            <span class="comment">//synchronized (Ticket2.class) &#123;//通过反射调用当前类</span></span><br><span class="line">                <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号窗口买票，票号为&quot;</span> + tick--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line"></span><br><span class="line">        ticket1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        ticket2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        ticket3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ticket1.start();</span><br><span class="line">        ticket2.start();</span><br><span class="line">        ticket3.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式二：同步方法</strong></p><p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String namer)</span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tick</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isFlag) &#123;</span><br><span class="line">            show();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;<span class="comment">//同步show方法，继承Thread类方法一样，只需同步方法即可，同时需要给方法加static关键字，确保不会创建多个对象</span></span><br><span class="line">        <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号窗口买票，票号为：&quot;</span> + tick--);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isFlag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket3</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket3</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        thread3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式三：Lock锁–jdk5.0新增</strong></p><p>从JDK 5.0开始，Java提供了更强大的线程同步机制–通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</p><p>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p><p>&#x3D;&#x3D;ReentrantLock&#x3D;&#x3D;类实现了Lock，它拥有与 synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是 <strong>Reentrantlock</strong>，可以显式加锁、释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//1.实例化ReentrantLock对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReenTrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReenTrantLook</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span> <span class="params">()</span>&#123;</span><br><span class="line">        lock.lock<span class="comment">//2.先加锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//保证线程同步的代码</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();<span class="comment">//3.后解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：如果同步代码块有异常，要将unlock()写入finally语句块中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//1.实例化ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//2.调用锁定方法lock()</span></span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：售票，票号为：&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//3.调用解锁方法：unlock()</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Window</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>同步方法的总结</p></blockquote><p>在《 Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他仼务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。</p><p><strong>synchronized的锁是什么</strong>：</p><ol><li>任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）</li><li><strong>同步方法的锁</strong>：&#x3D;&#x3D;静态方法（类名.class）&#x3D;&#x3D;、&#x3D;&#x3D;非静态方法（this）&#x3D;&#x3D;</li><li><strong>同步代码块</strong>：自己指定，很多时候也是指定为this或类名.class</li></ol><p><strong>注意点：</strong></p><ol><li>必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全</li><li>&#x3D;&#x3D;一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎）&#x3D;&#x3D;</li><li><strong>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</strong></li><li>&#x3D;&#x3D;非静态的<strong>同步方法</strong>，同步监视器是：this&#x3D;&#x3D;</li><li>&#x3D;&#x3D;静态的<strong>同步方法</strong>，同步监视器是：当前类本身&#x3D;&#x3D;</li></ol><hr><blockquote><p>同步的范围</p></blockquote><p><strong>如何找问题，即代码是否存在线程安全？（非常重要)</strong></p><p>（1）明确哪些代码是多线程运行的代码</p><p>（2）明确多个线程是否有共享数据</p><p>（3）明确多线程运行代码中是否有多条语句操作共享数据</p><p><strong>如何解决呢？（非常重要）</strong></p><p>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。 &#x3D;&#x3D;即所有操作共享数据的这些语句都要放在同步范围中&#x3D;&#x3D;</p><p><strong>注意点：</strong></p><p>范围太小：没锁住所有有安全问题的代码 范围太大：没发挥多线程的功能。</p><blockquote><p>面试题</p></blockquote><p><strong>1. synchronized 与 Lock的异同？</strong></p><ul><li>相同：二者都可以解决线程安全问题</li><li>不同：<ul><li>synchronized机制在执行完相应的同步代码之后，会自动释放同步监视器</li><li>Lock需要手动启动同步（lock()）,同时结束同步也需要手动的实现（unlock()）</li></ul></li><li>使用的优先顺序<ul><li>Lock–&gt;同步代码块（已经进入了方法体，分配了相应资源）–&gt;同步方法（在方法体之外）</li></ul></li><li>利弊：<ul><li>同步的方式解决了线程安全问题</li><li>操作代码的时，只能一个线程参与，其他线程等待；相当于一个单线程的过程，效率低</li></ul></li></ul><p><strong>2. Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同</strong></p><p>利用同步锁的方式，有三种方式：&#x3D;&#x3D;同步代码块&#x3D;&#x3D;，&#x3D;&#x3D;同步方法&#x3D;&#x3D;，&#x3D;&#x3D;lock()&#x3D;&#x3D;方法;</p><p><strong>3. synchronized和Lock方式解决线程安全问题的对比</strong></p><ul><li>相同：都可以解决线程安全问题</li><li>不同：<ul><li>synchronized机制，在执行完相应的同步代码之后，会自动释放同步监视器。</li><li>Lock需要手动启动同步lock()；结束同步的话也需要手动实现unlock();</li></ul></li></ul><hr><blockquote><p>线程安全的单例模式（饿汉单例为线程安全）</p></blockquote><p><strong>使用同步机制将单例模式中的&#x3D;&#x3D;懒汉式改写为线程安全&#x3D;&#x3D;的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">使用同步机制将单例模式中的懒汉式改写为线程安全的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//方式一：效率稍差</span></span><br><span class="line"><span class="comment">//        synchronized (Bank.class) &#123;</span></span><br><span class="line"><span class="comment">//            if(instance == null)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                instance = new Bank();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            return instance;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//方式二：效率更高</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Bank.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>死锁问题</p></blockquote><p>1、死锁的理解：不同的线程都在占用对方需要同步的资源不放弃，都在等待对方放弃自己需要同步的资源，就形成了线程的锁</p><p>2、说明：</p><ul><li>出现死锁后不会出现异常，不会出现提示，只是所有的线程处于阻塞状态，无法继续</li><li>我们使用同步时，要避免出现死锁</li></ul><p><strong>死锁举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line"></span><br><span class="line">                s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                s2.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line">                    s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(s1);</span><br><span class="line">                    System.out.println(s2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line"></span><br><span class="line">                s1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">                s2.append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line">                    s1.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(s1);</span><br><span class="line">                    System.out.println(s2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-5、线程通讯"><a href="#2-5-5、线程通讯" class="headerlink" title="2.5.5、线程通讯"></a>2.5.5、线程通讯</h3><p><strong>为了解决线程死锁问题，引入了线程通讯</strong></p><blockquote><p>线程通讯涉及到的三个方法</p></blockquote><ul><li>wait()：执行此方法，表示当前线程进入阻塞状态，并释放同步监视器（释放锁）</li><li>notify()：执行此方法，表示唤醒被wait（阻塞）的线程；若多个线程被wait，那么久唤醒优先级高的那个。</li><li>notifyAll()：执行此方法，表示唤醒所有wait（阻塞）的线程</li></ul><p><strong>说明：</strong></p><ul><li><p>wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。</p></li><li><p>wait()，notify()，notifyAll()三个方法的&#x3D;&#x3D;<strong>调用者必须是</strong>同步代码块或同步方法中的<strong>同步监视器</strong>。&#x3D;&#x3D;<br>否则，会出现IllegalMonitorStateException异常</p></li><li><p>wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。</p></li></ul><p><strong>代码示例：</strong></p><p>使用两个线程打印 1-100，线程1, 线程2 交替打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                object.notify();<span class="comment">//调用notify()方法唤醒线程</span></span><br><span class="line">                <span class="keyword">if</span> (number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="comment">//线程休眠</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + number);</span><br><span class="line">                    number++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();<span class="comment">//打印输出一次后调用wait()方法将线程阻塞</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommunicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;线程1:&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;线程2:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>面试题：</strong></p></blockquote><p><strong>问：sleep()和wait()的异同点</strong></p><p>相同点：都是起到阻塞线程的作用，一旦执行，使线程进入阻塞状态</p><p>不同点：1、声明位置不同，sleep()是Thread声明；wait()是Object类（同步监视器）声明</p><p>​2、调用要求不同，sleep()可在任何需要的场调用；wait()必须在同步代码块活同步方法中调用</p><p>​3、关于是否会释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会  释放锁。</p><blockquote><p>释放锁的操作</p></blockquote><ul><li><p>当前线程的同步方法、同步代码块执行结束</p></li><li><p>当前线程在同步代码块、同步方法中遇到 break、 return终止了该代码块该方法的继续执行。</p></li><li><p>当前线程在同步代码块、同步方法中出现了未处理的Error或 Exception，导致异常结束。</p></li><li><p>当前线程在同步代码块、同步方法中执行了线程对象的 wait()方法，当前线程暂停，并释放锁</p></li></ul><blockquote><p>不会释放锁的操作</p></blockquote><ul><li>线程在执行同步代码块或同步方法时，程序调用了<code>Thread.sleep()</code>、<code>Thread.yield()</code>暂停了当前线程的执行</li><li>线程在执行同步代码块或同步方法时，<strong>其他线程</strong>调用了该线程的<code>suspend()</code>方法，将该线程挂起，该线程不会释放锁（同步监视器）</li><li>应尽量避免使用 <code>suspend()</code>和 <code>resume()</code>来控制线程</li></ul><h3 id="2-5-6、JDK5-0新增线程创建方式"><a href="#2-5-6、JDK5-0新增线程创建方式" class="headerlink" title="2.5.6、JDK5.0新增线程创建方式"></a>2.5.6、JDK5.0新增线程创建方式</h3><blockquote><p>新增方式一、实现Callable接口</p></blockquote><p><strong>实现方法：</strong></p><ol><li>创建一个实现Callable的实现类</li><li>实现call方法，将此线程需要执行的操作声明在call()中</li><li>创建Callable接口实现类的对象<br><code>NumThread numThread = new NumThread();</code></li><li>将此Callable接口实现类的对象作为传递到**&#x3D;&#x3D;FutureTask&#x3D;&#x3D;**构造器中，创建FutureTask的对象<br><code>FutureTask futureTask = new FutureTask(numThread);</code></li><li>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()<br><code>new Thread(futureTask).start();</code></li><li>获取Callable中call方法的返回值<br><code>Object sum = futureTask.get();</code></li></ol><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</strong></p><ol><li>call()可以返回值的。</li><li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li><li>Callable是支持泛型的</li></ol><blockquote><p>方式二、使用线程池</p></blockquote><p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程对性能影响很大。</p><p><strong>解决方法</strong></p><p>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。</p><p><strong>实现方法</strong></p><p>1、提供指定数量的线程池</p><p>2、执行指定的线程操作。提供实现Runnable接口或Callable接口实现类对象。</p><p>3、关闭连接池</p><p><strong>相关API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JDK <span class="number">5.0</span>起提供了线程池相关AP|： Executor Service和 Executors</span><br><span class="line"></span><br><span class="line">Executor Service：真正的线程池接口。常见子类 Thread Poolexecutor</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command）：执行任务/命令，没有返回值，一般用来执行Runnable</span></span><br><span class="line"><span class="params">&lt;T&gt; Future&lt;T&gt; submit（Callable&lt;T&gt;task）：执行任务，有返回值，一般又来执行Callable</span></span><br><span class="line"><span class="params"><span class="keyword">void</span> shutdown()</span>：关闭连接池</span><br><span class="line"></span><br><span class="line">Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</span><br><span class="line">Executors. newCachedThreadPool()：创建一个可根据需要创建新线程的线程池</span><br><span class="line">Executors.newFⅸedthreadPool(n)；创建一个可重用固定线程数的线程池</span><br><span class="line">EXecutors. newSingleThreadEXecutor()：创建一个只有一个线程的线程池</span><br><span class="line">Executors. <span class="keyword">new</span> <span class="title class_">thread</span> Poo(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</span><br></pre></td></tr></table></figure><p>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池<br>Executors. **newCachedThreadPool()**：&#x3D;&#x3D;创建一个可根据需要创建新线程的线程池&#x3D;&#x3D;<br>Executors.**newFⅸedthreadPool(n)**；&#x3D;&#x3D;创建一个可重用固定线程数的线程池&#x3D;&#x3D;<br>EXecutors. **newSingleThreadEXecutor()**：&#x3D;&#x3D;创建一个只有一个线程的线程池&#x3D;&#x3D;<br>Executors. new thread Poo(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//        service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//        service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用线程池的好处：</strong></p><ol><li><p>提高响应速度（减少了创建新线程的时间）</p></li><li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p></li><li><p>便于线程管理</p><p>corePoolSize：核心池的大小</p><p>maximumPoolSize：最大线程数</p><p>keepAliveTime：线程没任务时最多保持多长时间后会终止</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>创建多线程的方式：</p></blockquote><p>1、继承Thread类（其本质也是实现Runnable方法）<br>2、实现Runnable方法<br>3、创建匿名类new Thread(){&#x2F;&#x2F;重写run()}.start();<br>–jdk5新增两种线程创建方式<br>4、实现Callable接口<br>5、使用线程池</p><blockquote><p>线程安全问题–同步机制（同步监视器）（同步锁）</p></blockquote><p>同步代码块、同步方法、ReentrantLock&#x3D;&#x3D;&gt;lock(),unlock()【finally中执行】</p><blockquote><p>死锁问题–线程通讯</p></blockquote><p>wait();noitfy();notifyAll();</p><h2 id="2-6、java常用类"><a href="#2-6、java常用类" class="headerlink" title="2.6、java常用类"></a>2.6、java常用类</h2><h3 id="2-6-1、String类"><a href="#2-6-1、String类" class="headerlink" title="2.6.1、String类"></a>2.6.1、String类</h3><p><code>java.lang.String</code> 类的使用</p><blockquote><p>概述</p></blockquote><p>String:字符串，使用一对””引起来表示。</p><ol><li><p>String声明为final的，不可被继承</p></li><li><p>String 实现了 <code>Serializable</code> 接口：表示字符串是支持序列化的。 实现了  <code>Comparable</code> 接口：表示String可以比较大小</p></li><li><p>String内部定义了 <code>final char[] value</code> 用于存储字符串数据</p></li><li><p>String:代表不可变的字符序列。简称：不可变性。</p><p><strong>体现：</strong></p><p>4.1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</p><p>4.2.当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p><p>4.3.当调用String的 <code>replace()</code> 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p></li><li><p>通过字面量的方式（区别于new给一个字符串赋值，此时的字符串值声明在字符串常量池中)。</p></li><li><p>字符串常量池中，是不会存储相同内容的字符串的(使用String类的equals()比较，返回true)。</p></li></ol><blockquote><p>String 的特性</p></blockquote><p>String类：代表字符串。Java程序中的所有字符串字面值（如”abc”）都作为此类的实例实现。 &#x3D;&#x3D;String是一个final类&#x3D;&#x3D;，代表&#x3D;&#x3D;不可变&#x3D;&#x3D;的字符序列。 &#x3D;&#x3D;字符串是常量&#x3D;&#x3D;，用双引号引起来表示。&#x3D;&#x3D;它们的值在创建之后不能更改。&#x3D;&#x3D; String对象的字符内容是存储在一个字符数组vaue[]中的。</p><p><strong>String源码构造器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>1、String的不可变性</strong></p></blockquote><p>当&#x3D;&#x3D;对字符串重新赋值&#x3D;&#x3D;时，&#x3D;&#x3D;需要<strong>重新指定内存区域</strong>赋值&#x3D;&#x3D;，不能使用原有的value进行赋值。</p><p>当对新的字符串&#x3D;&#x3D;进行连接&#x3D;&#x3D;操作时，也&#x3D;&#x3D;需要<strong>重新指定内存区域</strong>赋值&#x3D;&#x3D;，不能使用原有的value进行赋值。</p><p>当&#x3D;&#x3D;调用String的 <code>replace()</code> 方法修改指定字符或字符串&#x3D;&#x3D;时，也需要&#x3D;&#x3D;重新<strong>指定内存区域</strong>赋值&#x3D;&#x3D;，不能使用原有的value进行赋值。</p><p><strong>代码举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//通过字面量的定义方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false 比较s1与s2的地址值</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1);<span class="comment">//hello</span></span><br><span class="line">System.out.println(s2);<span class="comment">//def</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s3 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">System.out.println(s3);<span class="comment">//abcdef</span></span><br><span class="line">System.out.println(s2);<span class="comment">//def</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span><span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4.replace(<span class="string">&quot;t&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">System.out.println(s4);<span class="comment">//test</span></span><br><span class="line">System.out.println(s5);<span class="comment">//besb</span></span><br></pre></td></tr></table></figure><p><strong>图示解析：</strong></p><p><img src="/2022/06/13/javaSE/image-20220521133042924.png" alt="image-20220521133042924"> </p><blockquote><p><strong>2、String实例化方法</strong></p></blockquote><p><strong>实现方式说明：</strong></p><ul><li>方式一：通过字面量定义的方式</li><li>方式二：通过new + 构造器的方式</li></ul><p><strong>问：</strong><code>String s = new String(&quot;abc&quot;);</code> 方式创建对象，在内存中创建了几个对象？</p><p><strong>答：</strong>两个:一个是堆空间中new结构，另一个是<code>char[]</code>对应的常量池中的数据：”abc”</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="comment">//通过new + 构造器的方式:此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><code>String str1=“abc”;</code> 与 <code>String str2= new String(“abc”);</code> 的区别?</p><ul><li><strong>字符串常量存储在字符串常量池，</strong>目的是共享</li><li><strong>字符串非常量对象存储在堆中</strong></li></ul><p><img src="/2022/06/13/javaSE/image-20220521135018230.png" alt="image-20220521135018230"> </p><p><img src="/2022/06/13/javaSE/image-20220521135031470.png" alt="image-20220521135031470"></p><blockquote><p>字符串拼接方法赋值比较</p></blockquote><p><strong>说明：</strong></p><ol><li>&#x3D;&#x3D;常量与常量的拼接结果在常量池&#x3D;&#x3D;。且&#x3D;&#x3D;常量池中<strong>不会存在相同内容的常量</strong>&#x3D;&#x3D;。</li><li>&#x3D;&#x3D;只要<strong>其中一个是变量</strong>，结果就在<strong>堆</strong>中。&#x3D;&#x3D;</li><li>如果拼接的结果调用 <code>intern()</code> 方法，返回值就在常量池中</li></ol><p><strong>代码示例</strong>ll</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();<span class="comment">//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop”</span></span><br><span class="line">System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">****************************</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;<span class="comment">//s4:常量</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s1 == s5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>内存解析：</strong></p><p><img src="/2022/06/13/javaSE/image-20220521140647520.png" alt="image-20220521140647520"> </p><blockquote><p>String使用陷阱</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;a&quot;</span>；</span><br></pre></td></tr></table></figure><p>说明：在字符串常量池中创建了一个字面量为”a”的字符串。</p><p>s1&#x3D;s1+”b”</p><p>说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+”b”（也就是”ab”）。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。</p><p><code>String s2=&quot;ab&quot;;</code> 说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。</p><p><code>String s3=&quot;a&quot;+&quot;b&quot;;</code> 说明：s3指向字符串常量池中已经创建的”ab”的字符串。</p><p><code>String s4=s1.intern(); </code>说明：堆空间的S1对象在调用 intern()之后，会将常量池中已经存在的”ab”字符串赋值给s4。</p><blockquote><p>String 类常用方法</p></blockquote><p><strong>1、字符串操作</strong></p><p><code>int length()</code>：返回字符串的长度： <code>return value.length</code></p><p><code>char charAt(int index)</code>： 返回某索引处的字符 <code>return value[index]</code></p><p><code>boolean isEmpty()</code>：判断是否是空字符串：<code>return value.length == 0</code></p><p><code>String toLowerCase()</code>：使用默认语言环境，将 String 中的所字符转换为小写</p><p><code>String toUpperCase()</code>：使用默认语言环境，将 String 中的所字符转换为大写</p><p><code>String trim()</code>：返回字符串的副本，忽略前导空白和尾部空白</p><p><code>boolean equals(Object obj)</code>：比较字符串的内容是否相同</p><p><code>boolean equalsIgnoreCase(String anotherString)</code>：与 <code>equals()</code> 方法类似，忽略大小写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String concat(String str)`：将指定字符串连接到此字符串的结尾。 等价于用 `+</span><br></pre></td></tr></table></figure><p><code>int compareTo(String anotherString)</code>：比较两个字符串的大小</p><p><code>String substring(int beginIndex)</code>：返回一个新的字符串，它是此字符串的从beginIndex 开始截取到最后的一个子字符串。</p><p><code>String substring(int beginIndex, int endIndex)</code> ：返回一个新字符串，它是此字符串从 beginIndex 开始截取到 endIndex (不包含)的一个子字符串。</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;helloword&quot;</span>;</span><br><span class="line">    System.out.println(s1.length());<span class="comment">//9</span></span><br><span class="line">    System.out.println(s1.charAt(<span class="number">4</span>));<span class="comment">//o</span></span><br><span class="line">    System.out.println(s1.isEmpty());<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;HELLOword&quot;</span>;</span><br><span class="line">    System.out.println(s2.toLowerCase());<span class="comment">//hellowod</span></span><br><span class="line">    System.out.println(s2.toUpperCase());<span class="comment">//HELLOWORD</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot; hello word &quot;</span>;</span><br><span class="line">    System.out.println(s3.trim());<span class="comment">//hello word</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;helloword&quot;</span>;</span><br><span class="line">    System.out.println(s4.equals(s1));<span class="comment">//true</span></span><br><span class="line">    System.out.println(s4.equalsIgnoreCase(s2));<span class="comment">//true</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    System.out.println(s5.compareTo(s4));<span class="comment">//-4 相等时返回0，小的时候返回负数</span></span><br><span class="line">    System.out.println(s4.compareTo(s1));<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s4.substring(<span class="number">5</span>));<span class="comment">//word [</span></span><br><span class="line">    System.out.println(s4.substring(<span class="number">5</span>, <span class="number">9</span>));<span class="comment">//word,取值范围，前闭后开[)【从0开始】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断字符</strong></p><p><code>boolean endsWith(String suffix)</code>：测试此字符串是否以指定的后缀结束</p><p><code>boolean startsWith(String prefix)</code>：测试此字符串是否以指定的前缀开始</p><p><code>boolean startsWith(String prefix, int toffset)</code>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    System.out.println(s1.endsWith(<span class="string">&quot;EE&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(s1.startsWith(<span class="string">&quot;a&quot;</span>));<span class="comment">//false</span></span><br><span class="line">    System.out.println(s1.startsWith(<span class="string">&quot;EE&quot;</span>, <span class="number">4</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、查找字符串中的字符</strong></p><p><code>boolean contains(CharSequence s)：</code>当且仅当此字符串包含指定的 char 值序列时，返回 true</p><p><code>int indexOf(String str)</code>：返回指定子字符串在此字符串中第一次出现处的索引</p><p><code>int indexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</p><p><code>int lastIndexOf(String str)</code>：返回指定子字符串在此字符串中最右边出现处的索引</p><p><code>int lastIndexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</p><p><strong>注：</strong><code>indexOf</code> 和 <code>lastIndexOf</code> 方法如果&#x3D;&#x3D;未找到&#x3D;&#x3D;都是&#x3D;&#x3D;返回 <strong>-1</strong>&#x3D;&#x3D;</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        String s2=<span class="string">&quot;hello word&quot;</span>;</span><br><span class="line">        System.out.println(s2.length());<span class="comment">//10</span></span><br><span class="line">        System.out.println(s2.contains(<span class="string">&quot;o&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(s2.indexOf(<span class="string">&quot;o&quot;</span>));<span class="comment">//4</span></span><br><span class="line">        <span class="comment">//从指定索引处开始，取后面的字符，返回指定字符串的索引</span></span><br><span class="line">        System.out.println(s2.indexOf(<span class="string">&quot;o&quot;</span>, <span class="number">5</span>));<span class="comment">//7</span></span><br><span class="line">        <span class="comment">//返回指定字符串，最后出现的索引</span></span><br><span class="line">        System.out.println(s2.lastIndexOf(<span class="string">&quot;o&quot;</span>));<span class="comment">//7</span></span><br><span class="line">        <span class="comment">//从指定索引处开始，取前面的字符，反向取最近字符索引</span></span><br><span class="line">        System.out.println(s2.lastIndexOf(<span class="string">&quot;o&quot;</span>, <span class="number">9</span>));<span class="comment">//7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、字符串操作方法</strong></p><p><strong>替换</strong>：</p><ul><li><code>String replace(char oldChar, char newChar)</code>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。</li><li><code>String replace(CharSequence target, CharSequence replacement)</code>：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。</li><li><code>String replaceAll(String regex, String replacement)</code>：使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。</li><li><code>String replaceFirst(String regex, String replacement)</code>：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</li></ul><p><strong>匹配</strong>:</p><ul><li><code>boolean matches(String regex)</code>：告知此字符串是否匹配给定的正则表达式。</li></ul><p><strong>切片</strong>：</p><ul><li><code>String[] split(String regex)</code>：根据给定正则表达式的匹配拆分此字符串。</li><li><code>String[] split(String regex, int limit)</code>：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;北京你好，你好北京&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str1.replace(<span class="string">&#x27;北&#x27;</span>, <span class="string">&#x27;南&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(str1);<span class="comment">//北京你好，你好北京</span></span><br><span class="line">    System.out.println(str2);<span class="comment">//南京你好，你好南京</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str1.replace(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">    System.out.println(str3);<span class="comment">//上海你好，你好上海</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************************&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;12hello34world5java7891mysql456&quot;</span>;</span><br><span class="line">    <span class="comment">//把字符串中的数字替换成,，如果结果中开头和结尾有，的话去掉</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> str.replaceAll(<span class="string">&quot;\\d+&quot;</span>, <span class="string">&quot;,&quot;</span>).replaceAll(<span class="string">&quot;^,|,$&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    System.out.println(string);<span class="comment">//hello,world,java,mysql</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************************&quot;</span>);</span><br><span class="line">    str = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">    <span class="comment">//判断str字符串中是否全部有数字组成，即有1-n个数字组成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> str.matches(<span class="string">&quot;\\d+&quot;</span>);</span><br><span class="line">    System.out.println(matches);<span class="comment">//true</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> <span class="string">&quot;0571-4534289&quot;</span>;</span><br><span class="line">    <span class="comment">//判断这是否是一个杭州的固定电话</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> tel.matches(<span class="string">&quot;0571-\\d&#123;7,8&#125;&quot;</span>);</span><br><span class="line">    System.out.println(result);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************************&quot;</span>);</span><br><span class="line">    str = <span class="string">&quot;hello|world|java&quot;</span>;</span><br><span class="line">    String[] strs = str.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        System.out.println(strs[i]);<span class="comment">//依次输出hello word java</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    str2 = <span class="string">&quot;hello.world.java&quot;</span>;</span><br><span class="line">    String[] strs2 = str2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs2.length; i++) &#123;</span><br><span class="line">        System.out.println(strs2[i]);<span class="comment">//依次输出hello word java</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>String与其他结构的转换</p></blockquote><p><strong>1、String与基本数据类型、包装类之间的转换</strong></p><ul><li>String 转–&gt;基本数据类型、包装类 ；&#x3D;&#x3D;&gt; 调用包装类静态方法：<code>parseXxx(str)</code><ul><li>例：<code>Integer.parseInt(str);</code></li></ul></li><li>基本数据类型、包装类 转–&gt;String；&#x3D;&#x3D;&gt; 调用String重载的 <code>String.valueOf(xxx)</code><ul><li>例：<code>Stirng.valueOf(int)</code></li></ul></li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringToBasic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    System.out.println(i == <span class="number">123</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">456</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(j);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(s.equals(<span class="string">&quot;456&quot;</span>));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、与字符数组之间的转换</strong></p><ul><li>String –&gt; char[]:调用String的 <code>toCharArray()</code> </li><li>char[] –&gt; String:调用String的构造器<code>new String(charArray)</code></li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BasicToString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;helloword&quot;</span>;</span><br><span class="line">    <span class="type">char</span>[] chars = s1.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        System.out.println(chars[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] charArray = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    System.out.println(s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、与字节数组之间的转换</strong></p><ul><li><p>编码：String –&gt; byte[]:调用String的 <code>getBytes()</code></p><ul><li>字符串 –&gt;字节 (看得懂 —&gt;看不懂的二进制数据)</li></ul></li><li><p>解码：byte[] –&gt; String:调用String的构造器<code>new String(gbks,&quot;gbk&quot;)</code></p><ul><li>编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂）</li></ul></li></ul><p>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringToByteTest</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span><span class="string">&quot;你好java世界&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] bytesArray = s1.getBytes();<span class="comment">//使用默认字符集编码</span></span><br><span class="line">    System.out.println(Arrays.toString(bytesArray));<span class="comment">//[-28, -67, -96, -27, -91, -67, 106, 97, 118, 97, -28, -72, -106, -25, -107, -116]</span></span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] gbks = s1.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk编码集合</span></span><br><span class="line">    System.out.println(Arrays.toString(gbks));<span class="comment">//[-60, -29, -70, -61, 106, 97, 118, 97, -54, -64, -67, -25]</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String str1=<span class="keyword">new</span> <span class="title class_">String</span>(bytesArray);<span class="comment">//使用默认字符进行解码</span></span><br><span class="line">    System.out.println(str1);<span class="comment">//你好java世界</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks);<span class="comment">//使用默认字符对gbk编码进行解码</span></span><br><span class="line">    System.out.println(str2);<span class="comment">//���java����解码错误，出现中文乱码,原因：编码和解码不一致</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks,<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk格式进行解码</span></span><br><span class="line">    System.out.println(str3);<span class="comment">//你好java世界，解码正确，原因：编码和解码一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、与StringBuffer、StringBuilder之间的转换</strong></p><ul><li>String –&gt;StringBuffer、StringBuilder: 调用StringBuffer、StringBuilder构造器<ul><li><code>new StringBuffer(str1);</code></li><li><code>new StringBuilder(str1);</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringToStringBufferTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span><span class="string">&quot;helloword&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str1);</span><br><span class="line">    System.out.println(stringBuffer);<span class="comment">//helloword</span></span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str1);</span><br><span class="line">    System.out.println(stringBuilder);<span class="comment">//helloword</span></span><br><span class="line"></span><br><span class="line">    stringBuffer.append(<span class="string">&quot;isStringBuffer&quot;</span>);</span><br><span class="line">    System.out.println(stringBuffer);<span class="comment">//hellowordandgood</span></span><br><span class="line"></span><br><span class="line">    stringBuilder.append(<span class="string">&quot;isStringBuider&quot;</span>);</span><br><span class="line">    System.out.println(stringBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>StringBuffer、StringBuilder –&gt;String:<ul><li>调用String构造器<code>new String(str)</code></li><li>StringBuffer、StringBuilder的<code>toString()</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringBuiderOrStringBufferToStringTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello StringBuffer&quot;</span>);</span><br><span class="line">    System.out.println(sb1);</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello StringBuider&quot;</span>);</span><br><span class="line">    System.out.println(sb2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb1);</span><br><span class="line">    System.out.println(str1);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb2);</span><br><span class="line">    System.out.println(str2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">    System.out.println(sb1.toString());</span><br><span class="line">    System.out.println(sb2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、JVM字符串常量池存放位置</strong></p><p>jdk 1.6 (jdk 6.0 ,java 6.0):字符串常量池存储在方法区（永久区）</p><p>jdk 1.7:字符串常量池存储在堆空间</p><p>jdk 1.8:字符串常量池存储在方法区（元空间）</p><p><strong>6、常见算法题目考察</strong></p><p>1、模拟一个trim方法，去除字符串两端的空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">myTrim</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录从前往后首次索引位置不是空格的位置索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> str.length() - <span class="number">1</span>;<span class="comment">//记录从后往前首次索引位置不是空格的位置索引</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; str.charAt(start) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; str.charAt(end) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(start) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse1</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1.转换成char型数组</span></span><br><span class="line">        <span class="type">char</span>[] charArray = str.toCharArray();</span><br><span class="line">        <span class="comment">//2.进行反转操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> charArray[i];</span><br><span class="line">            charArray[i] = charArray[j];</span><br><span class="line">            charArray[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.返回值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="comment">//分析：整个字符串分为三部分不反转的、反转的、不反转的</span></span><br><span class="line"><span class="comment">//先将前面不反转的部分取出来，将反转的部分取出后进行拼接</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse2</span><span class="params">(String string, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(string != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//第一部分</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> string.substring(<span class="number">0</span>, start);</span><br><span class="line">    <span class="comment">//第二部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end; i &gt;= start; i--) &#123;</span><br><span class="line">        newStr += string.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三部分</span></span><br><span class="line">    newStr += string.substring(end + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//拼接操作</span></span><br><span class="line">    <span class="keyword">return</span> newStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三,使用StringBuffer或StringBuilder替换String优化</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse3</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="comment">//1.新建StringBuffer</span></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str.length());</span><br><span class="line">    <span class="comment">//2.第一部分</span></span><br><span class="line">    stringBuffer.append(str.substring(<span class="number">0</span>, start));</span><br><span class="line">    <span class="comment">//3.第二部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end; i &gt;= start; i--) &#123;</span><br><span class="line">        stringBuffer.append(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.第三部分</span></span><br><span class="line">    stringBuffer.append(str.substring(end + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//5.拼接操作</span></span><br><span class="line">    <span class="keyword">return</span> stringBuffer.toString();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、获取一个字符串在另一个字符串中出现的次数。 比如：获取“ ab”在 “abkkcadkabkebfkabkskab” 中出现的次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(String mainStr, String subStr)</span> &#123;</span><br><span class="line">    <span class="comment">//1.判断主串和部分串的大小</span></span><br><span class="line">    <span class="keyword">if</span> (mainStr.length() &gt;= subStr.length()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//2.在主串中取出子串下标，并将新的下标赋值给主串，统计量加1</span></span><br><span class="line">        <span class="comment">//            while ((index = mainStr.indexOf(subStr) )!= -1)&#123;</span></span><br><span class="line">        <span class="comment">//                count++;</span></span><br><span class="line">        <span class="comment">////从已经找到的子串的下一个开始</span></span><br><span class="line">        <span class="comment">//                mainStr = mainStr.substring(index + subStr.length());</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line">        <span class="comment">//改进，不再新建字符串，只做位置比对</span></span><br><span class="line">        <span class="keyword">while</span> ((index = mainStr.indexOf(subStr, index)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            index += subStr.length();</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、获取两个字符串中最大相同子串。比如： str1 &#x3D; “abcwerthelloyuiodef“;str2 &#x3D; “cvhellobnm” 提示：将短的那个串进行长度依次递减的子串与较长的串比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只存在一个子串的情况</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getMaxSameSubString</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="comment">//1.判断两个字串的大小</span></span><br><span class="line">    <span class="keyword">if</span> (str1 != <span class="literal">null</span> &amp;&amp; str2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">maxStr</span> <span class="operator">=</span> (str1.length() &gt;= str2.length()) ? str1 : str2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">minStr</span> <span class="operator">=</span> (str1.length() &lt; str2.length()) ? str1 : str2;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> minStr.length();</span><br><span class="line">        <span class="comment">//2.用小的依次去比对大的子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;<span class="comment">//这层for循环用来确定需要比对的字符次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = len - i; y &lt;= len; x++, y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (maxStr.contains(minStr.substring(x, y))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> minStr.substring(x, y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存在多个相同子串的情况</span></span><br><span class="line"><span class="comment">// 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便</span></span><br><span class="line"><span class="keyword">public</span> String [] getMaxSameSubStrings(String str1, String str2) &#123;</span><br><span class="line">    <span class="comment">//1.先比较出两个子串的大小</span></span><br><span class="line">    <span class="keyword">if</span> (str1 != <span class="literal">null</span> &amp;&amp; str2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">maxStr</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str1 : str2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">minStr</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str2 : str1;</span><br><span class="line">        <span class="comment">//2.用小的去依次匹配大的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> minStr.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = len - i; y &lt;= len; x++,y++ )&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">subString</span> <span class="operator">=</span> minStr.substring(x,y);</span><br><span class="line">                <span class="comment">//3.取出匹配到的子串</span></span><br><span class="line">                <span class="keyword">if</span> (maxStr.contains(subString))&#123;</span><br><span class="line">                    stringBuffer.append(subString+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(stringBuffer);</span></span><br><span class="line">            <span class="keyword">if</span> (stringBuffer.length() != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String [] split = stringBuffer.toString().replaceAll(<span class="string">&quot;,$&quot;</span>,<span class="string">&quot;&quot;</span>).split(<span class="string">&quot;\\,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> split;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、对字符串中字符进行自然顺序排序。 提示：</p><ol><li>字符串变成字符数组。</li><li>对数组排序，择，冒泡，<code>Arrays.sort()</code>;</li><li>将排序后的数组变成字符串。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello java&quot;</span>;</span><br><span class="line">    <span class="type">char</span>[] charArray = str1.toCharArray();</span><br><span class="line"></span><br><span class="line">    Arrays.sort(charArray);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    System.out.println(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-2、StringBuffer和StringBulider"><a href="#2-6-2、StringBuffer和StringBulider" class="headerlink" title="2.6.2、StringBuffer和StringBulider"></a>2.6.2、StringBuffer和StringBulider</h3><blockquote><p>StringBuffer</p></blockquote><p><strong>概述：</strong></p><p><code>java.lang.String.Buffer</code> 代表可变的字符序列，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。 很多方法与 String相同 作为参数传递时，方法内部可以改变值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>[] value;<span class="comment">//value没有final声明，value可以不断扩容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> count;<span class="comment">//count记录有效字符个数</span></span><br></pre></td></tr></table></figure><ul><li>StringBuffer类不同于String，&#x3D;&#x3D;其对象必须使用构造器生成&#x3D;&#x3D;</li><li>有三个构造器<ul><li><code>StringBuffer()</code>：初始容量为16的字符串缓冲区</li><li><code>StringBuffer(int size)</code>：构造指定容量的字符串缓冲区</li><li><code>StringBuffer(String str)</code>：将内容初始化为指定字符串内容</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s= <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我喜欢学习&quot;</span>)；</span><br><span class="line">StringBuffer buffer= <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;我喜欢学习&quot;</span>)；</span><br><span class="line">buffer. append(<span class="string">&quot;数学&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/06/13/javaSE/image-20220521203327349.png" alt="image-20220521203327349"> </p><p><strong>常用方法：</strong></p><ol><li><code>StringBuffer append(xxx)</code>：提供了很多的 <code>append()</code> 方法，用于进行字符串拼接</li><li><code>StringBuffer delete(int start,int end)</code>：删除指定位置的内容</li><li><code>StringBuffer replace(int start, int end, String str)</code>：把[start,end)位置替换为str</li><li><code>StringBuffer insert(int offset, xxx)</code>：在指定位置插入xxx</li><li><code>StringBuffer reverse()</code> ：把当前字符序列逆转</li></ol><p>当 append和insert时，如果原来vaue数组长度不够，可扩容。 如上这些方法支持方法链操作。 方法链的原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>public int indexOf(String str)</code>：返回子串的下标</p><p><code>public String substring(int start,int end)</code>:返回一个从start开始到end索引结束的左闭右开区间的子字符串</p><p><code>public int length()</code>：获取字符串的长度</p><p><code>public char charAt(int n )</code>：返回指定位置的字符</p><p><code>public void setCharAt(int n ,char ch)</code>：设置指定位置的字符</p><p><strong>总结：</strong></p><p>增：<code>append(xxx)</code> ；</p><p>删：<code>delete(int start,int end)</code> ；</p><p>改：<code>setCharAt(int n ,char ch) </code>&#x2F;<code> replace(int start, int end, String str)</code> ；</p><p>查：<code>charAt(int n )</code> ；</p><p>插：<code>insert(int offset, xxx)</code> ；</p><p>长度：<code>length()</code>;</p><p>遍历：<code>for() + charAt() </code>&#x2F;<code> toString()</code>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stringBufferMethodTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    System.out.println(s1);</span><br><span class="line"></span><br><span class="line">    System.out.println(s1.append(<span class="string">&quot;1&quot;</span>));<span class="comment">//abc1</span></span><br><span class="line">    System.out.println(s1.delete(<span class="number">0</span>, <span class="number">1</span>));<span class="comment">//bc1</span></span><br><span class="line">    System.out.println(s1.replace(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>));<span class="comment">//helloc1</span></span><br><span class="line">    System.out.println(s1.insert(<span class="number">3</span>, <span class="string">&quot;v&quot;</span>));<span class="comment">//helvloc1</span></span><br><span class="line">    System.out.println(s1.reverse());<span class="comment">//1colvleh</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>StringBuilder</p></blockquote><p>StringBuilder和 StringBuffer非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样，只是&#x3D;&#x3D;StringBuilder类没有加线程锁&#x3D;&#x3D;，&#x3D;&#x3D;执行效率更高&#x3D;&#x3D;。</p><p><strong>1、String、StringBuffer、StringBuilder三者的对比</strong></p><p>String:不可变的字符序列；底层使用 <code>char[]</code> 存储；占用内存（会不断的创建和回收对象）</p><p>StringBuffer:可变的字符序列；线程安全的，效率低；线程安全；底层使用char[]存储；</p><p>StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；线程不安全；底层使用 <code>char[]</code> 存储</p><p><strong>注意：</strong>作为参数传递的话，方法内部String不会改变其值， StringBuffer和 StringBuilder会改变其值。</p><p><strong>2、StringBuffer与StringBuilder的内存解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//char[] value = new char[0];</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();<span class="comment">//char[] value = new char[16];底层创建了一个长度是16的数组。</span></span><br><span class="line">System.out.println(sb1.length());<span class="comment">//</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br></pre></td></tr></table></figure><p><strong>StringBuffer构造器源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题1. <code>System.out.println(sb2.length());//3</code></p><p>问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。 默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。</p><p>指导意义：开发中建议大家使用：<code>StringBuffer(int capacity)</code> 或 <code>StringBuilder(int capacity)</code></p><p> <strong>对比String、StringBuffer、StringBuilder三者的执行效率</strong></p><ul><li>从高到低排列：StringBuilder &gt; StringBuffer &gt; String</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始设置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//开始对比</span></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        buffer.append(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        builder.append(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        text = text + i;</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;String的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-3、JDK8-0之前的日期时间API"><a href="#2-6-3、JDK8-0之前的日期时间API" class="headerlink" title="2.6.3、JDK8.0之前的日期时间API"></a>2.6.3、JDK8.0之前的日期时间API</h3><blockquote><p>java.lang.System类</p></blockquote><p>System类提供的 <code>public static long currentTimeMillis()</code> 用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。(时间戳) 此方法适于计算时间差。</p><p><strong>计算世界时间的主要标准有</strong>：</p><ul><li>UTC（Coordinated Universal Time）</li><li>GMT（Greenwich Mean Time）</li><li>CST（Central Standard Time）</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取系统当前时间：System类中的currentTimeMillis()</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span></span><br><span class="line"><span class="comment">//称为时间戳</span></span><br><span class="line">System.out.println(time);</span><br></pre></td></tr></table></figure><blockquote><p>java.util.Date类</p></blockquote><p>表示特定的瞬间，精确到毫秒</p><p><strong>构造器</strong></p><p><code>Date()</code>:使用无参的构造器创建对象可以获取本地当前时间</p><p><code>Date(long date)</code></p><p><strong>常用方法</strong></p><p><code>getTime()</code>：返回自1970年1月1日00：00：00GMT以来此Date对象表示的毫秒数</p><p><code>tostring()</code>：把此Date对象转换为以下形式的 String</p><ul><li><p>dow mon dd</p></li><li><p>hh: mm:ss zzz yyyy</p><p>其中：doW是一周中的某一天（Sun，Mon，Tue，Wed，Thu，Fri，Sat），zzz是时间标准。 其它很多方法都过时了</p></li></ul><blockquote><p>java.util.Date类与java.sql.Date 类</p></blockquote><p><strong>1、两个构造器的使用</strong></p><ul><li>构造器一：<code>new Date()</code>：创建一个对应当前时间的Date对象</li><li>构造器二：<code>new Date(15872745176L)</code>：创建指定毫秒数的Date对象</li></ul><p><strong>2、两个方法的使用</strong></p><ul><li><code>toString()</code>:显示当前的年、月、日、时、分、秒</li><li><code>getTime()</code>:获取当前Date对象对应的毫秒数。（时间戳）</li></ul><p><strong>3、<code>java.sql.Date</code> 对应着数据库中的日期类型的变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dateTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    System.out.println(date1.toString());<span class="comment">//Sun Apr 19 13:35:12 CST 2020</span></span><br><span class="line">    System.out.println(date1.getTime());<span class="comment">//1587274512876</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">15872745176L</span>);</span><br><span class="line">    System.out.println(date2.toString());</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建java.sql.Date对象</span></span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">date3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">1587274512876L</span>);</span><br><span class="line">    System.out.println(date3.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//第一种方式，存在问题：java.util.Date cannot be cast to java.sql.Date</span></span><br><span class="line">    <span class="comment">//        java.sql.Date date6 = (java.sql.Date) date4;</span></span><br><span class="line">    <span class="comment">//        System.out.println(date6);</span></span><br><span class="line">    <span class="comment">//第二种方式</span></span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">date5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date4.getTime());</span><br><span class="line">    System.out.println(date5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>java.text.SimpleDateFormat 类</p></blockquote><p>Date类的API不易于国际化，大部分被废弃了， <code>java.text.SimpleDateFormat</code> 类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</p><p>它允许进行格式化：日期→文本、解析：文本→日期</p><p><strong>实例化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>格式化：</strong></p><p>​<code>SimpleDateFormat()</code>：默认的模式和语言环境创建对象</p><p>​<code>public SimpleDateFormat(String pattern)</code>：该构造方法可以用参数 pattern指定的格式创建一个对象，该对象调用：</p><p>​<code>public String format(Datedate)</code>：方法&#x3D;&#x3D;格式化时间对象date&#x3D;&#x3D;</p><p><strong>解析</strong>：</p><p>​ <code>public Date parse(String source)</code>：从给定字符串的开始&#x3D;&#x3D;解析文本&#x3D;&#x3D;，以生成个日期</p><p><strong>SimpleDateFormat对日期Date类的格式化和解析</strong></p><ul><li><p>格式化：<code>format(date1)</code>日期 —&gt;字符串</p></li><li><p>解析：<code>parse(&quot;2020-04-20 14:20:下午&quot;)</code>格式化的逆过程，字符串 —&gt; 日期</p></li></ul><p><strong>SimpleDateFormat的实例化:new + 构造器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:aa&quot;</span>);</span><br><span class="line"><span class="comment">//格式化format</span></span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(date1);</span><br><span class="line">System.out.println(format.toString());<span class="comment">//2020-09-19 02:09:下午</span></span><br><span class="line"><span class="comment">//解析parse</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> simpleDateFormat.parse(<span class="string">&quot;2020-04-20 14:20:下午&quot;</span>);</span><br><span class="line">System.out.println(date2.toString());<span class="comment">//Tue Jan 21 02:20:00 CST 2020</span></span><br></pre></td></tr></table></figure><p><img src="/2022/06/13/javaSE/image-20220521220849369.png" alt="image-20220521220849369"> </p><p><strong>练习：</strong>将字符串”2020-09-08”转换为 <code>java.sql.Date</code> 格式的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="comment">//将字符串&quot;2020-09-08&quot;转换为 java.sql.Date 格式的时间</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="comment">//文本解析成utilDate</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">utilDate</span> <span class="operator">=</span> simpleDateFormat.parse(<span class="string">&quot;2020-09-08&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;utilDate==&gt;&quot;</span>+utilDate.toString());<span class="comment">//utilDate==&gt;Tue Sep 08 00:00:00 CST 2020</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//utilDate转sqlDate</span></span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">sqlDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(utilDate.getTime());</span><br><span class="line">    System.out.println(<span class="string">&quot;sqlDate==&gt;&quot;</span>+sqlDate);<span class="comment">//sqlDate==&gt;2020-09-08</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Calendar类：日历类、抽象类</p></blockquote><p>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。</p><ul><li><p>获取 Calenda实例的方法 使用 Calendar.getInstance()方法 调用它的子类 GregorianCalendarl的构造器。</p></li><li><p>一个 Calendar的实例是系统时间的抽象表示，通过 get(int field)方法来取得想要的时间信息。 比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY、MINUTE、SECOND</p></li></ul><p><strong>注意：</strong> 获取月份时：一月是0，二月是1，以此类推，12月是11 获取星期时：周日是1，周一是2，。。。周六是7</p><p><strong>实例化</strong></p><ul><li>创建其子类(GregorianCalendar)的对象</li><li>调用其静态方法 <code>getInstance()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br></pre></td></tr></table></figure><p><strong>常用方法</strong></p><p><code>get()</code>:获取日期</p><p><code>set()</code>:设置日期</p><p><code>add()</code>:添加、修改日期</p><p><code>getTime</code>:日历类–&gt;Date</p><p><code>setTime</code>:Date–&gt;日历类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//        System.out.println(calendar.getClass());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.常用方法</span></span><br><span class="line"><span class="comment">//get()</span></span><br><span class="line"><span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);<span class="comment">//获取本月第几天</span></span><br><span class="line">System.out.println(days);</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_YEAR));<span class="comment">//获取本年第几天</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set()</span></span><br><span class="line"><span class="comment">//calendar可变性</span></span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH,<span class="number">22</span>);<span class="comment">//设置本月第几天</span></span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br><span class="line"></span><br><span class="line"><span class="comment">//add()</span></span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH,-<span class="number">3</span>);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br><span class="line"></span><br><span class="line"><span class="comment">//getTime():日历类---&gt; Date</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">//setTime():Date ---&gt; 日历类</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">calendar.setTime(date1);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure><h3 id="2-6-4、JDK8-0中新的日期时间类"><a href="#2-6-4、JDK8-0中新的日期时间类" class="headerlink" title="2.6.4、JDK8.0中新的日期时间类"></a>2.6.4、JDK8.0中新的日期时间类</h3><blockquote><p>日期时间API的迭代</p></blockquote><p>第一代：jdk 1.0 Date类</p><p>第二代：jdk 1.1 Calendar类，一定程度上替换Date类</p><p>第三代：jdk 1.8 提出了新的一套API</p><blockquote><p>前两代的问题</p></blockquote><p>可变性：像日期和时间这样的类应该是不可变的。</p><p>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</p><p>格式化：格式化只对Date用，Calendar则不行。 此外，它们也不是线程安全的；不能处理闰秒等。</p><p>Java 8.0中新引入的java.time API:</p><p>Java 8.0吸收了Joda-Time的精华，以一个新的开始为Java创建优秀的APl。新的java.time中包含了所有关于本地日期(LocalDate)、本地时间(Localtime)、本地日期时间(LocalDate time)、时区(ZonedDate time)和持续时间(Duration)的类。历史悠久的Date类新增了tolnstant()方法用于把Date转换成新的表示形式。这些新增的本地化时间日期API大大简化了日期时间和本地化的管理。</p><blockquote><p>Java8.0中新的日期时间API涉及的包</p></blockquote><p><img src="/2022/06/13/javaSE/image-20220521223213524.png" alt="image-20220521223213524"> </p><blockquote><p> 本地日期、本地时间、本地日期时间的使用：</p></blockquote><ul><li>LocalDate &#x2F; LocalTime &#x2F; LocalDateTime</li></ul><p><strong>说明：</strong></p><p>① 分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p><p>② LocalDateTime相较于LocalDate、LocalTime，使用频率要高</p><p>③ 类似于Calendar</p><p><strong>常用方法</strong></p><p><img src="/2022/06/13/javaSE/image-20220521223543707.png" alt="image-20220521223543707"> </p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//now():获取当前的日期、时间、日期时间</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    System.out.println(localDate);<span class="comment">//2020-04-21</span></span><br><span class="line">    System.out.println(localTime);<span class="comment">//18:52:54.929</span></span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:52:54.929</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//of():设置指定的年、月、日、时、分、秒。没有偏移量</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">12</span>);</span><br><span class="line">    System.out.println(localDateTime1);<span class="comment">//2020-10-06T12:13:12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//getXxx()：获取相关的属性</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfMonth());<span class="comment">//21</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfWeek());<span class="comment">//TUESDAY</span></span><br><span class="line">    System.out.println(localDateTime.getMonth());<span class="comment">//APRIL</span></span><br><span class="line">    System.out.println(localDateTime.getMonthValue());<span class="comment">//4</span></span><br><span class="line">    System.out.println(localDateTime.getMinute());<span class="comment">//52</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//体现不可变性</span></span><br><span class="line">    <span class="comment">//withXxx():设置相关的属性</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> localDate.withDayOfMonth(<span class="number">22</span>);</span><br><span class="line">    System.out.println(localDate);<span class="comment">//2020-04-21</span></span><br><span class="line">    System.out.println(localDate1);<span class="comment">//2020-04-22</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime2</span> <span class="operator">=</span> localDateTime.withHour(<span class="number">4</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:59:17.484</span></span><br><span class="line">    System.out.println(localDateTime2);<span class="comment">//2020-04-21T04:59:17.484</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不可变性</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime3</span> <span class="operator">=</span> localDateTime.plusMonths(<span class="number">3</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:59:17.484</span></span><br><span class="line">    System.out.println(localDateTime3);<span class="comment">//2020-07-21T18:59:17.484</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime4</span> <span class="operator">=</span> localDateTime.minusDays(<span class="number">6</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:59:17.484</span></span><br><span class="line">    System.out.println(localDateTime4);<span class="comment">//2020-04-15T18:59:17.484</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间点：Instant</p></blockquote><p><strong>说明：</strong></p><p>① 时间线上的一个瞬时点。 概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC开始的秒数。）</p><p>② 类似于 <code>java.util.Date</code> 类</p><p><strong>常用方法：</strong></p><p><img src="/2022/06/13/javaSE/image-20220521223718589.png" alt="image-20220521223718589"> </p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//now():获取本初子午线对应的标准时间</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">    System.out.println(instant);<span class="comment">//2020-04-21T11:03:21.469Z</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加时间的偏移量</span></span><br><span class="line">    <span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span> <span class="operator">=</span> instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    System.out.println(offsetDateTime);<span class="comment">//2020-04-21T19:03:21.469+08:00</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数  ---&gt; Date类的getTime()</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">milli</span> <span class="operator">=</span> instant.toEpochMilli();</span><br><span class="line">    System.out.println(milli);<span class="comment">//1587467105795</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ofEpochMilli():通过给定的毫秒数，获取Instant实例  --&gt;Date(long millis)</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.ofEpochMilli(<span class="number">1587467105795L</span>);</span><br><span class="line">    System.out.println(instant1);<span class="comment">//2020-04-21T11:05:05.795Z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>日期时间格式化类：DateTimeFormatter</p></blockquote><p> <strong>说明：</strong></p><p>① 格式化或解析日期、时间</p><p>② 类似于 <code>SimpleDateFormat</code></p><p><strong>常用方法：</strong></p><ol><li>实例化方式： 预定义的标准格式。如：<code>ISO\_LOCAL\_DATE\_TIME;</code></li></ol><ul><li>ISO_LOCAL_DATE;ISO_LOCAL_TIME 本地化相关的格式：</li><li>如：<code>ofLocalizedDateTime(FormatStyle.LONG) </code></li><li>自定义的格式：如：<code>ofPattern(“yyyy-MM-dd hh:mm:ss”)</code></li></ul><p><img src="/2022/06/13/javaSE/image-20220521224008828.png" alt="image-20220521224008828"> </p><p><strong>特别的：</strong>自定义的格式。如：<code>ofPattern(“yyyy-MM-dd hh:mm:ss”)</code></p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//        方式一：预定义的标准格式。</span></span><br><span class="line">    <span class="comment">//        如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">    <span class="comment">//格式化:日期--&gt;字符串</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> formatter.format(localDateTime);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T19:13:13.530</span></span><br><span class="line">    System.out.println(str1);<span class="comment">//2020-04-21T19:13:13.53</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析：字符串 --&gt;日期</span></span><br><span class="line">    <span class="type">TemporalAccessor</span> <span class="variable">parse</span> <span class="operator">=</span> formatter.parse(<span class="string">&quot;2000-04-21T19:13:13.53&quot;</span>);</span><br><span class="line">    System.out.println(parse);<span class="comment">//&#123;&#125;,ISO resolved to 2000-04-21T19:13:13.530</span></span><br><span class="line">    <span class="comment">//        方式二：</span></span><br><span class="line">    <span class="comment">//        本地化相关的格式。如：ofLocalizedDateTime()</span></span><br><span class="line">    <span class="comment">//        FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter1</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> formatter1.format(localDateTime);</span><br><span class="line">    System.out.println(str2);<span class="comment">//2020年4月21日 下午07时16分57秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//      本地化相关的格式。如：ofLocalizedDate()</span></span><br><span class="line">    <span class="comment">//      FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter2</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM);</span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> formatter2.format(LocalDate.now());</span><br><span class="line">    System.out.println(str3);<span class="comment">//2020-4-21</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//       重点： 方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter3</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">Str4</span> <span class="operator">=</span> formatter3.format(LocalDateTime.now());</span><br><span class="line">    System.out.println(Str4);<span class="comment">//2020-04-21 07:24:04</span></span><br><span class="line"></span><br><span class="line">    <span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> formatter3.parse(<span class="string">&quot;2020-02-03 05:23:06&quot;</span>);</span><br><span class="line">    System.out.println(accessor);<span class="comment">//&#123;SecondOfMinute=6, HourOfAmPm=5, NanoOfSecond=0, MicroOfSecond=0, MinuteOfHour=23, MilliOfSecond=0&#125;,ISO resolved to 2020-02-03</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他API的使用</p></blockquote><p><img src="/2022/06/13/javaSE/image-20220521224218705.png" alt="image-20220521224218705"> </p><p><strong>1、带时区的日期时间</strong></p><p>ZonedDateTime &#x2F; ZoneId</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZoneId:类中包含了所的时区信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//getAvailableZoneIds():获取所的ZoneId</span></span><br><span class="line">    Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">    <span class="keyword">for</span>(String s : zoneIds)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取“Asia/Tokyo”时区对应的时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Tokyo&quot;</span>));</span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ZonedDateTime:带时区的日期时间</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//now():获取本时区的ZonedDateTime对象</span></span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">    System.out.println(zonedDateTime);</span><br><span class="line">    <span class="comment">//now(ZoneId id):获取指定时区的ZonedDateTime对象</span></span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime1</span> <span class="operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Tokyo&quot;</span>));</span><br><span class="line">    System.out.println(zonedDateTime1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、时间间隔</strong></p><p>Duration–用于计算两个“时间”间隔，以秒和纳秒为基准</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">localTime1</span> <span class="operator">=</span> LocalTime.of(<span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line">    <span class="comment">//between():静态方法，返回Duration对象，表示两个时间的间隔</span></span><br><span class="line">    <span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(localTime1, localTime);</span><br><span class="line">    System.out.println(duration);</span><br><span class="line"></span><br><span class="line">    System.out.println(duration.getSeconds());</span><br><span class="line">    System.out.println(duration.getNano());</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2017</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Duration</span> <span class="variable">duration1</span> <span class="operator">=</span> Duration.between(localDateTime1, localDateTime);</span><br><span class="line">    System.out.println(duration1.toDays());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、日期间隔</strong></p><p>Period –用于计算两个“日期”间隔，以年、月、日衡量</p><p><img src="/2022/06/13/javaSE/image-20220521224507834.png" alt="image-20220521224507834"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2028</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(localDate, localDate1);</span><br><span class="line">    System.out.println(period);</span><br><span class="line"></span><br><span class="line">    System.out.println(period.getYears());</span><br><span class="line">    System.out.println(period.getMonths());</span><br><span class="line">    System.out.println(period.getDays());</span><br><span class="line"></span><br><span class="line">    <span class="type">Period</span> <span class="variable">period1</span> <span class="operator">=</span> period.withYears(<span class="number">2</span>);</span><br><span class="line">    System.out.println(period1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、日期时间校正器<code>TemporalAdjuster</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取当前日期的下一个周日是哪天？</span></span><br><span class="line">    <span class="type">TemporalAdjuster</span> <span class="variable">temporalAdjuster</span> <span class="operator">=</span> TemporalAdjusters.next(DayOfWeek.SUNDAY);</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now().with(temporalAdjuster);</span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取下一个工作日是哪天？</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now().with(<span class="keyword">new</span> <span class="title class_">TemporalAdjuster</span>()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Temporal <span class="title function_">adjustInto</span><span class="params">(Temporal temporal)</span> &#123;</span><br><span class="line">            <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> (LocalDate)temporal;</span><br><span class="line">            <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.FRIDAY))&#123;</span><br><span class="line">                <span class="keyword">return</span> date.plusDays(<span class="number">3</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.SATURDAY))&#123;</span><br><span class="line">                <span class="keyword">return</span> date.plusDays(<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> date.plusDays(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;下一个工作日是：&quot;</span> + localDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、新的日期API与原来API的转化问题</strong></p><p><img src="/2022/06/13/javaSE/image-20220521224846067.png" alt="image-20220521224846067"></p><h3 id="2-6-5、Java比较器"><a href="#2-6-5、Java比较器" class="headerlink" title="2.6.5、Java比较器"></a>2.6.5、Java比较器</h3><blockquote><p>使用背景</p></blockquote><ul><li><p>Java中的对象，正常情况下，只能进行比较：<code>==</code> 或 <code>!=</code>。不能使用 <code>&gt;</code> 或 <code>&lt;</code> 的</p></li><li><p>但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。</p></li><li><p>如何实现？使用两个接口中的任何一个：Comparable（自然排序） 或 Comparator（定制排序）</p></li></ul><blockquote><p>Comparable（自然排序）</p></blockquote><ol><li>像 String 或包装类等实现了Comparable接口，重写了 <code>compareTo(obj)</code> 方法，给出了比较两个对象大小的方式。</li></ol><p>像 String 或包装类重写 <code>compareTo()</code> 方法以后，进行了从小到大的排列</p><ol start="2"><li><p>重写 <code>compareTo(obj)</code> 的规则： 如果当前对象this大于形参对象obj，则返回正整数， 如果当前对象this小于形参对象obj，则返回负整数， 如果当前对象this等于形参对象obj，则返回零。</p></li><li><p>对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写  <code>compareTo(obj)</code> 方法。在<code> compareTo(obj)</code> 方法中指明如何排序</p></li><li><p>Comparable的典型实现：(&#x3D;&#x3D;默认都是<strong>从小到大</strong>排列的&#x3D;&#x3D;) String：按照字符串中字符的Uincode值进行比较 ;Character：按照字符的 Unicode值来进行比较 数值类型对应的包装类以及 BigInteger、BigDecimal：按照它们对应的数值大小进行比较 Boolean：true对应的包装类实例大于false对应的包装类实例 Date、Time等：后面的日期时间比前面的日期时间大</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span>  <span class="title class_">Comparable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指明商品比较大小的方式:照价格从低到高排序,再照产品名称从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//        System.out.println(&quot;**************&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods)o;</span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//                return 0;</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line">            <span class="comment">//           return Double.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//        return 0;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter、setter、toString()、构造器：省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定制排序：使用Comparator接口</p></blockquote><ol><li>背景：</li></ol><p>当元素的类型没实现 <code>java.lang.Comparable</code> 接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序</p><ol start="2"><li>重写 <code>compare(Object o1,Object o2)</code> 方法，比较o1和o2的大小：</li></ol><ul><li>如果方法返回正整数，则表示o1大于o2；</li><li>如果返回0，表示相等；</li><li>返回负整数，表示o1小于o2。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">          <span class="comment">//指明商品比较大小的方式:照产品名称从低到高排序,再照价格从高到低排序</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">              <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">                  <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods)o1;</span><br><span class="line">                  <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods)o2;</span><br><span class="line">                  <span class="keyword">if</span>(g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                      <span class="keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());</span><br><span class="line">                  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                      <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Goods</span>();</span><br><span class="line">      g1.setName(<span class="string">&quot;xx&quot;</span>);</span><br><span class="line">      g1.setPrice(<span class="number">9.9</span>);</span><br><span class="line">      <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Goods</span>();</span><br><span class="line">      g2.setName(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">      g2.setPrice(<span class="number">99.99</span>);</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">      com.compare(g1,g2);</span><br></pre></td></tr></table></figure><p><strong>两种排序方式对比</strong></p><ul><li>Comparable接口的方式是一定的，保证Comparable接口实现类的对象在任何位置都可以比较大小。</li><li>Comparator接口属于临时性的比较。</li></ul><h3 id="2-6-6、其他常用类"><a href="#2-6-6、其他常用类" class="headerlink" title="2.6.6、其他常用类"></a>2.6.6、其他常用类</h3><blockquote><p>System类</p></blockquote><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。</p><p>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</p><p><strong>成员方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">native</span> <span class="type">long</span> <span class="title function_">currentTimeMillis</span><span class="params">()</span>：</span><br></pre></td></tr></table></figure><p>该方法的作用是&#x3D;&#x3D;返回当前的计算机时间&#x3D;&#x3D;，时间的表达格式为当前计算机时间和GMT时间（格林威治时间）1970年1月1号0时0分0秒所差的毫秒数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br></pre></td></tr></table></figure><p>该方法的作用是&#x3D;&#x3D;退出程序&#x3D;&#x3D;。其中 status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">gc</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>该方法的作用是请求系统进行&#x3D;&#x3D;垃圾回收&#x3D;&#x3D;。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getProperty</span><span class="params">(String key)</span></span><br></pre></td></tr></table></figure><p>该方法的作用是&#x3D;&#x3D;获得系统中属性名为key的属性对应的值&#x3D;&#x3D;。系统中常见的属性名以及属性的作用如下表所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b00d883e59204e80855556b458c56548~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200421114933166"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">javaVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;java的version:&quot;</span> + javaVersion);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">javaHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.home&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;java的home:&quot;</span> + javaHome);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;os的name:&quot;</span> + osName);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">osVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.version&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;os的version:&quot;</span> + osVersion);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user的name:&quot;</span> + userName);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">userHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user的home:&quot;</span> + userHome);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user的dir:&quot;</span> + userDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Math类</p></blockquote><p><code>java.lang.Math</code> 提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型</p><p><img src="/2022/06/13/javaSE/image-20220522002127236.png" alt="image-20220522002127236"> </p><blockquote><p><strong>BigInteger类、BigDecimal类</strong></p></blockquote><p><strong>BigInteger</strong></p><p><code>java.math </code>包的BigInteger可以表示不可变的任意精度的整数。</p><p>BigInteger提供所有Java的基本整数操作符的对应物，并提供 <code>java.lang.Math</code> 的所有相关方法。另外，BigInteger还提供以下运算：模算术、GCD计算、质数测试、素数生成、位操作以及一些其他操作。</p><p>构造器： <code>BigInteger(String val)</code>：根据字符串构建 BigInteger对象</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546e8ddf062840e5ac1dcb88e86a7d4b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200421115521295"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1243324112234324324325235245346567657653&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    System.out.println(bi);</span><br><span class="line">    <span class="comment">//         System.out.println(bd.divide(bd2));</span></span><br><span class="line">    System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">    System.out.println(bd.divide(bd2, <span class="number">25</span>, BigDecimal.ROUND_HALF_UP));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BigDecimal</strong></p><p>要求数字精度比较高，用到 <code>java.math.BigDecimal</code> 类</p><p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p><p><strong>构造器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BigDecimal</span><span class="params">(<span class="type">double</span> val)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BigDecimal</span><span class="params">(String val)</span></span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">add</span><span class="params">(BigDecimal augend)</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">subtract</span><span class="params">(BigDecimal subtrahend)</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">multiply</span><span class="params">(BigDecimal multiplicand)</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal divisor， <span class="type">int</span> scale， <span class="type">int</span> rounding Mode)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1243324112234324324325235245346567657653&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    System.out.println(bi);</span><br><span class="line">    <span class="comment">//         System.out.println(bd.divide(bd2));</span></span><br><span class="line">    System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">    System.out.println(bd.divide(bd2, <span class="number">25</span>, BigDecimal.ROUND_HALF_UP));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7、java反射机制"><a href="#2-7、java反射机制" class="headerlink" title="2.7、java反射机制"></a>2.7、java反射机制</h2><h2 id="2-8、网络编程"><a href="#2-8、网络编程" class="headerlink" title="2.8、网络编程"></a>2.8、网络编程</h2><h2 id="2-9、java8-amp-Lambda表达式-amp-Stream-API的使用"><a href="#2-9、java8-amp-Lambda表达式-amp-Stream-API的使用" class="headerlink" title="2.9、java8&amp;Lambda表达式&amp;Stream API的使用"></a>2.9、java8&amp;Lambda表达式&amp;Stream API的使用</h2><h2 id="2-10、java9-amp-10-amp-11-新特性"><a href="#2-10、java9-amp-10-amp-11-新特性" class="headerlink" title="2.10、java9&amp;10&amp;11 新特性"></a>2.10、java9&amp;10&amp;11 新特性</h2><h1 id="三、java技术拓展"><a href="#三、java技术拓展" class="headerlink" title="三、java技术拓展"></a>三、java技术拓展</h1><h2 id="3-1、数据结构"><a href="#3-1、数据结构" class="headerlink" title="3.1、数据结构"></a>3.1、数据结构</h2><h2 id="3-2、常用算法"><a href="#3-2、常用算法" class="headerlink" title="3.2、常用算法"></a>3.2、常用算法</h2><h2 id="3-3、常用设计模式"><a href="#3-3、常用设计模式" class="headerlink" title="3.3、常用设计模式"></a>3.3、常用设计模式</h2><h2 id="3-4、JVM"><a href="#3-4、JVM" class="headerlink" title="3.4、JVM"></a>3.4、JVM</h2>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署Hexo显示Permission Denied的解决方法</title>
      <link href="/2022/06/11/deploy-hexo/"/>
      <url>/2022/06/11/deploy-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><h3 id="查看-config-yml-中git的配置-和GitHub的ssh配置"><a href="#查看-config-yml-中git的配置-和GitHub的ssh配置" class="headerlink" title="查看_config.yml 中git的配置,和GitHub的ssh配置"></a>查看_config.yml 中git的配置,和GitHub的ssh配置</h3><p> _config.yml 中git的配置如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:start-spt/start-spt.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><h3 id="第一步检查无误后-仍然存在问题-删除deploy-git-重新以下-操作"><a href="#第一步检查无误后-仍然存在问题-删除deploy-git-重新以下-操作" class="headerlink" title="第一步检查无误后,仍然存在问题,删除deploy_git,重新以下,操作"></a>第一步检查无误后,仍然存在问题,删除deploy_git,重新以下,操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 构建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/06/11/hello-world/"/>
      <url>/2022/06/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
