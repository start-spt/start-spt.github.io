<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>为你读诗--&lt;&lt;秋天&gt;&gt;(两首)</title>
      <link href="/2022/11/09/poem-2022-11-09/"/>
      <url>/2022/11/09/poem-2022-11-09/</url>
      
        <content type="html"><![CDATA[<h2 id="lt-lt-秋天-gt-gt-两首"><a href="#lt-lt-秋天-gt-gt-两首" class="headerlink" title="&lt;&lt;秋天&gt;&gt;两首"></a>&lt;&lt;秋天&gt;&gt;两首</h2><h3 id="作者-杨炼"><a href="#作者-杨炼" class="headerlink" title="作者:杨炼"></a>作者:杨炼</h3><blockquote><p>其一</p></blockquote><p>轻轻地把一枚落叶拾起，</p><p>轻轻地，不留下一丝叹息。</p><p>那是只金色的小船，</p><p>载满秋天的回忆。<br><br><br>落叶夹进书册，</p><p>花朵却遗失在夜里。</p><p>一抹淡淡的初霜，</p><p>叫心灵懂得了分离。<br><br><br>分离就分离吧，</p><p>逝去的就悄悄逝去。</p><p>秋天用红硕的语言叮咛：</p><p>生命永远有新的含意。<br><br><br>再不必追悔往事，</p><p>更无须怨恨自己，</p><p>轻轻地把一枚落叶拾起,</p><p>轻轻地，不留下一丝叹息。</p><blockquote><p>其二</p></blockquote><p>黑夜是凝滞的岁月</p><p>岁月是流动的黑夜。<br><br><br>你停在门口</p><p>回过头，递给我短短一瞥。</p><p>这就是离别吗？</p><p>难道一切都将被忘却？<br><br><br>像绚丽的秋天过去，</p><p>到处要蒙上冷漠的白雪</p><p>我珍爱果实，</p><p>但也不畏惧这空旷的拒绝。</p><p>只要心灵饮着热血，</p><p>未来就没有凋残的季节！<br><br><br>秋风摇荡繁星，</p><p>——哦，那是永恒在天空书写；</p><p>是的，一瞥就尽够了，</p><p>我已该深深把你感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试准备--JVM</title>
      <link href="/2022/11/09/jvm-2022-11-09/"/>
      <url>/2022/11/09/jvm-2022-11-09/</url>
      
        <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000014395186">JVM 完整深入解析</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为你读诗--&lt;&lt;秋日有感&gt;&gt;</title>
      <link href="/2022/11/06/poem-2022-11-06/"/>
      <url>/2022/11/06/poem-2022-11-06/</url>
      
        <content type="html"><![CDATA[<p><code>有感于近日之生活,遂记之以诗</code></p><p>&lt;&lt;秋日有感&gt;&gt;</p><p>人生多岐路,万理自森著,诚领岁月教,落棋无悔处</p><p>道生至万物,归一方可复,人为三才中,岂能以我故</p><p>平日常急忿,福运安能驻,吾生也有涯,尽事听天数</p><p>纵浪大化中,不喜亦不惧,应尽便须尽,无复独多忧</p><p><code>解释:</code></p><blockquote><p><strong>1 . 2</strong> 句是生活的感悟,人的一生有很多崎岖坎坷,世间万物各有道理,所以不要将生活中的遭遇一直放在心上,人生如棋,落子无悔,自己做的决定不要后悔,以真挚之心接受岁月的洗礼当你经历过痛苦,挫折,以后便会更加从容</p></blockquote><blockquote><p><strong>3 . 4</strong> 句是哲思,从0到1再至更多,都是需要反复总结然后继续探索的,是渐进的,三才者:天,地,人.我们作为一个平凡的人,哪能一自我为中心去看待世界,我们只能省时度势,将自己的主观能动性结合到客观规律之中,才能发挥自身价值.</p></blockquote><blockquote><p><strong>5 . 6</strong> 句是反思,平日里一味的急躁冒进,处理不好人情事故,失道者寡助,福气和运气怎么能把握住呢?不要苛责自己什么事情都做的尽善尽美,相对于生活中的事物,人的生命是有限的,把能做的用心做好,其他的就交给运气吧</p></blockquote><blockquote><p><strong>7 . 8</strong> 句是思考后对自己的寄语,在这多姿多彩又富有变化的世界中自由自在的生活吧,不悲不喜来去从容,逝去的就让它悄悄的逝去,岁月静好,敞开心扉,不要再闭塞自己而独自叹息.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗歌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试准备--MySQL</title>
      <link href="/2022/10/31/mysql-2022-10-31/"/>
      <url>/2022/10/31/mysql-2022-10-31/</url>
      
        <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://relph1119.github.io/mysql-learning-notes/#/">《MySQL 是怎样运行的：从根儿上理解 MySQL》</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国共产党第二十次全国代表大会闭幕会(文字实录)</title>
      <link href="/2022/10/22/news-2022-10-22/"/>
      <url>/2022/10/22/news-2022-10-22/</url>
      
        <content type="html"><![CDATA[<h1 id="中国共产党第二十次全国代表大会在京闭幕-习近平主持大会并发表重要讲话"><a href="#中国共产党第二十次全国代表大会在京闭幕-习近平主持大会并发表重要讲话" class="headerlink" title="中国共产党第二十次全国代表大会在京闭幕 习近平主持大会并发表重要讲话"></a>中国共产党第二十次全国代表大会在京闭幕 习近平主持大会并发表重要讲话</h1><p><img src="https://s2.loli.net/2022/10/22/Xey7fdVRPmhK5tq.png" alt="avatar"></p><p><font color="red" size="3"> <center>中国共产党第二十次全国代表大会在京闭幕</center></font></p><p><font color="red" size="3"> <center>选举产生新一届中央委员会和中央纪律检查委员会</center></font></p><p><font color="red" size="3"> <center>通过关于十九届中央委员会报告的决议、关于十九届中央纪律检查委员会工作报告的决议、关于《中国共产党章程（修正案）》的决议</center></font></p><p><font color="red" size="3"> <center>习近平主持大会并发表重要讲话</center></font></p><p>　　中国共产党第二十次全国代表大会在选举产生新一届中央委员会和中央纪律检查委员会，通过关于十九届中央委员会报告的决议、关于十九届中央纪律检查委员会工作报告的决议、关于《中国共产党章程（修正案）》的决议后，22日上午在人民大会堂胜利闭幕。</p><p>　　大会号召，全党全军全国各族人民紧密团结在以习近平同志为核心的党中央周围，牢记空谈误国、实干兴邦，坚定信心、同心同德，埋头苦干、奋勇前进，为全面建设社会主义现代化国家、全面推进中华民族伟大复兴而团结奋斗。</p><p>　　习近平同志主持大会。</p><p>　　习近平、李克强、栗战书、汪洋、王沪宁、赵乐际、韩正、王岐山、丁薛祥、王晨、刘鹤、许其亮、孙春兰、李希、李强、李鸿忠、杨洁篪、杨晓渡、张又侠、陈希、陈全国、陈敏尔、胡春华、郭声琨、黄坤明、蔡奇、胡锦涛、李瑞环、温家宝、贾庆林、张德江、俞正声、宋平、李岚清、曾庆红、吴官正、李长春、贺国强、刘云山、张高丽、尤权、张庆黎等大会主席团常务委员会成员在主席台前排就座。</p><p>　　上午9时，闭幕会开始。</p><p>　　今天大会应到代表和特邀代表2378人，实到2338人。实到代表超过应到代表的半数，符合大会选举办法的规定。</p><p>　　会议首先通过了2名总监票人和36名监票人名单。</p><p>　　在总监票人和监票人监督下，到会的代表和特邀代表以无记名投票方式，选举出由205名委员、171名候补委员组成的二十届中央委员会，选举出二十届中央纪律检查委员会委员133名。</p><p>　　11时09分，习近平宣布，第二十届中央委员会和中央纪律检查委员会，已经党的第二十次全国代表大会选举产生。全场响起长时间的热烈掌声。</p><p>　　随后，大会通过了关于十九届中央委员会报告的决议。大会批准习近平同志代表十九届中央委员会所作的报告。决议指出，大会通过的十九届中央委员会的报告，是党和人民智慧的结晶，是党团结带领全国各族人民夺取中国特色社会主义新胜利的政治宣言和行动纲领，是马克思主义的纲领性文献。</p><p>　　大会认为，报告阐明的大会主题是大会的灵魂，是党和国家事业发展的总纲。全党要高举中国特色社会主义伟大旗帜，深刻领悟”两个确立”的决定性意义，坚决维护习近平同志党中央的核心、全党的核心地位，全面贯彻习近平新时代中国特色社会主义思想，弘扬伟大建党精神，自信自强、守正创新，踔厉奋发、勇毅前行，为全面建设社会主义现代化国家、全面推进中华民族伟大复兴而团结奋斗。</p><p>　　大会高度评价十九届中央委员会的工作。党的十九大以来的五年，是极不寻常、极不平凡的五年。五年来，以习近平同志为核心的党中央审时度势、守正创新，敢于斗争、善于斗争，团结带领全党全军全国各族人民有效应对严峻复杂的国际形势和接踵而至的巨大风险挑战，以奋发有为的精神把新时代中国特色社会主义不断推向前进，攻克了许多长期没有解决的难题，办成了许多事关长远的大事要事，推动党和国家事业取得举世瞩目的重大成就。</p><p>　　大会强调，党的十八大召开十年来，我们经历了对党和人民事业具有重大现实意义和深远历史意义的三件大事：一是迎来中国共产党成立一百周年，二是中国特色社会主义进入新时代，三是完成脱贫攻坚、全面建成小康社会的历史任务，实现第一个百年奋斗目标。新时代十年的伟大变革，在党史、新中国史、改革开放史、社会主义发展史、中华民族发展史上具有里程碑意义。中国共产党在革命性锻造中更加坚强有力，中国人民焕发出更为强烈的历史自觉和主动精神，实现中华民族伟大复兴进入了不可逆转的历史进程，科学社会主义在二十一世纪的中国焕发出新的蓬勃生机。</p><p>　　大会强调，新时代十年的伟大变革，是在以习近平同志为核心的党中央坚强领导下、在习近平新时代中国特色社会主义思想指引下全党全国各族人民团结奋斗取得的。党确立习近平同志党中央的核心、全党的核心地位，确立习近平新时代中国特色社会主义思想的指导地位，反映了全党全军全国各族人民共同心愿，对新时代党和国家事业发展、对推进中华民族伟大复兴历史进程具有决定性意义。新时代新征程上把中国特色社会主义事业推向前进，最紧要的是深刻领悟”两个确立”的决定性意义，增强”四个意识”、坚定”四个自信”、做到”两个维护”，自觉在思想上政治上行动上同以习近平同志为核心的党中央保持高度一致。</p><p>　　大会强调，党的十八大以来，我们党勇于进行理论探索和创新，以全新的视野深化对共产党执政规律、社会主义建设规律、人类社会发展规律的认识，取得重大理论创新成果，集中体现为习近平新时代中国特色社会主义思想。党的十九大、十九届六中全会提出的”十个明确”、”十四个坚持”、”十三个方面成就”概括了这一思想的主要内容，必须长期坚持并不断丰富发展。</p><p>　　大会提出，从现在起，中国共产党的中心任务就是团结带领全国各族人民全面建成社会主义现代化强国、实现第二个百年奋斗目标，以中国式现代化全面推进中华民族伟大复兴。</p><p>　　大会指出，中国式现代化，是中国共产党领导的社会主义现代化，既有各国现代化的共同特征，更有基于自己国情的中国特色。中国式现代化是人口规模巨大的现代化、全体人民共同富裕的现代化、物质文明和精神文明相协调的现代化、人与自然和谐共生的现代化、走和平发展道路的现代化。中国式现代化的本质要求是：坚持中国共产党领导，坚持中国特色社会主义，实现高质量发展，发展全过程人民民主，丰富人民精神世界，实现全体人民共同富裕，促进人与自然和谐共生，推动构建人类命运共同体，创造人类文明新形态。</p><p>　　大会指出，全面建成社会主义现代化强国，总的战略安排是分两步走：从二〇二〇年到二〇三五年基本实现社会主义现代化；从二〇三五年到本世纪中叶把我国建成富强民主文明和谐美丽的社会主义现代化强国。未来五年是全面建设社会主义现代化国家开局起步的关键时期。</p><p>　　大会强调，前进道路上，必须牢牢把握以下重大原则：坚持和加强党的全面领导，坚持中国特色社会主义道路，坚持以人民为中心的发展思想，坚持深化改革开放，坚持发扬斗争精神。</p><p>　　大会同意报告对未来一个时期党和国家事业发展作出的战略部署。</p><p>　　大会强调，必须坚定不移贯彻总体国家安全观，把维护国家安全贯穿党和国家工作各方面全过程，健全国家安全体系，增强维护国家安全能力，提高公共安全治理水平，完善社会治理体系，确保国家安全和社会稳定。</p><p>　　大会强调，如期实现建军一百年奋斗目标，加快把人民军队建成世界一流军队，是全面建设社会主义现代化国家的战略要求。必须贯彻习近平强军思想，贯彻新时代军事战略方针，有效履行新时代人民军队使命任务。</p><p>　　大会强调，”一国两制”是中国特色社会主义的伟大创举，是香港、澳门回归后保持长期繁荣稳定的最佳制度安排，必须长期坚持。要坚持一个中国原则和”九二共识”，坚持贯彻新时代党解决台湾问题的总体方略，坚定反”独”促统，牢牢把握两岸关系主导权和主动权，坚定不移推进祖国统一大业。</p><p>　　大会同意报告对国际形势的分析和外交工作的部署。</p><p>　　大会强调，全面建设社会主义现代化国家、全面推进中华民族伟大复兴，关键在党。必须持之以恒推进全面从严治党，深入推进新时代党的建设新的伟大工程，以党的自我革命引领社会革命，落实新时代党的建设总要求，健全全面从严治党体系，全面推进党的自我净化、自我完善、自我革新、自我提高，坚持和加强党中央集中统一领导，坚持不懈用习近平新时代中国特色社会主义思想凝心铸魂，完善党的自我革命制度规范体系，建设堪当民族复兴重任的高素质干部队伍，增强党组织政治功能和组织功能，坚持以严的基调强化正风肃纪，坚决打赢反腐败斗争攻坚战持久战。</p><p>　　大会通过了关于十九届中央纪律检查委员会工作报告的决议。大会充分肯定十九届中央纪律检查委员会的工作。</p><p>　　大会通过了关于《中国共产党章程（修正案）》的决议，决定这一修正案自通过之日起生效。</p><p>　　大会认为，党的十九大以来，以习近平同志为核心的党中央坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，提出一系列治国理政新理念新思想新战略，不断丰富和发展习近平新时代中国特色社会主义思想，开辟了马克思主义中国化时代化新境界。习近平新时代中国特色社会主义思想是当代中国马克思主义、二十一世纪马克思主义，是中华文化和中国精神的时代精华。大会一致同意，把党的十九大以来习近平新时代中国特色社会主义思想新发展写入党章，以更好反映以习近平同志为核心的党中央推进党的理论创新、实践创新、制度创新成果。</p><p>　　大会认为，在百年奋斗历程中，党始终践行党的初心使命，团结带领全国各族人民书写了中华民族几千年历史上最恢宏的史诗，创造了一系列伟大成就，积累了宝贵历史经验。大会同意把党的初心使命、党的百年奋斗重大成就和历史经验的内容写入党章。敢于斗争、敢于胜利，是党和人民不可战胜的强大精神力量。党和人民取得的一切成就，都是通过斗争取得的。大会同意把发扬斗争精神、增强斗争本领的内容写入党章。</p><p>　　大会认为，习近平同志在庆祝中国共产党成立一百周年大会上代表党和人民作出实现了第一个百年奋斗目标、全面建成了小康社会、正在向着全面建成社会主义现代化强国的第二个百年奋斗目标迈进的庄严宣告，党章据此作出相应修改。</p><p>　　大会认为，党的二十大提出以中国式现代化全面推进中华民族伟大复兴，并将此确定为新时代新征程中国共产党的中心任务。公有制为主体、多种所有制经济共同发展，按劳分配为主体、多种分配方式并存，社会主义市场经济体制等社会主义基本经济制度，是中国特色社会主义制度的重要支柱。大会同意把上述内容写入党章，同意把逐步实现全体人民共同富裕，把握新发展阶段，贯彻创新、协调、绿色、开放、共享的新发展理念，加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局，推动高质量发展，充分发挥人才作为第一资源的作用，促进国民经济更高质量、更有效率、更加公平、更可持续、更为安全发展等内容写入党章。</p><p>　　大会认为，全面建设社会主义现代化国家，是一项伟大而艰巨的事业，前途光明，任重道远。全面建成社会主义现代化强国，总的战略安排是分两步走：从二〇二〇年到二〇三五年基本实现社会主义现代化；从二〇三五年到本世纪中叶把我国建成富强民主文明和谐美丽的社会主义现代化强国。党章据此作出相应修改。</p><p>　　大会同意，把走中国特色社会主义法治道路，发展更加广泛、更加充分、更加健全的全过程人民民主，建立健全民主选举、民主协商、民主决策、民主管理、民主监督的制度和程序，统筹发展和安全等内容写入党章。</p><p>　　大会同意，把坚持政治建军、改革强军、科技强军、人才强军、依法治军，把人民军队建设成为世界一流军队；全面准确、坚定不移贯彻”一个国家、两种制度”的方针，坚决反对和遏制”台独”；弘扬和平、发展、公平、正义、民主、自由的全人类共同价值，推动建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界等内容写入党章。</p><p>　　大会同意，把弘扬坚持真理、坚守理想，践行初心、担当使命，不怕牺牲、英勇斗争，对党忠诚、不负人民的伟大建党精神，以伟大自我革命引领伟大社会革命等要求写入党章；把必须提高政治判断力、政治领悟力、政治执行力，增强贯彻落实党的理论和路线方针政策的自觉性和坚定性，推进马克思主义中国化时代化，党的自我革命永远在路上，不断健全党内法规体系，强化全面从严治党主体责任和监督责任，一体推进不敢腐、不能腐、不想腐等内容写入党章；把坚持新时代党的组织路线作为党的建设的基本要求之一写入党章。</p><p>　　大会认为，中国共产党是领导我们事业的核心力量，党的领导是实现中华民族伟大复兴的根本保证。大会同意把党是最高政治领导力量，坚持和加强党的全面领导等内容写入党章。</p><p>　　大会认为，总结吸收党的十九大以来党的工作和党的建设的成功经验，并同总纲部分修改相衔接，对党章部分条文作适当修改很有必要。</p><p>　　大会认为，进入新时代，党和国家面临的形势之复杂、斗争之严峻、改革发展稳定任务之艰巨世所罕见、史所罕见，正是因为确立了习近平同志党中央的核心、全党的核心地位，确立了习近平新时代中国特色社会主义思想的指导地位，党才有力解决了影响党长期执政、国家长治久安、人民幸福安康的突出矛盾和问题，消除了党、国家、军队内部存在的严重隐患，从根本上确保实现中华民族伟大复兴进入了不可逆转的历史进程。”两个确立”是党在新时代取得的重大政治成果，是推动党和国家事业取得历史性成就、发生历史性变革的决定性因素。全党必须深刻领悟”两个确立”的决定性意义，更加自觉地维护习近平同志党中央的核心、全党的核心地位，更加自觉地维护以习近平同志为核心的党中央权威和集中统一领导，全面贯彻习近平新时代中国特色社会主义思想，坚定不移在思想上政治上行动上同以习近平同志为核心的党中央保持高度一致。</p><p>　　大会完成各项议程后，习近平在热烈的掌声中发表了重要讲话。他表示，在全体代表共同努力下，大会取得了圆满成功，达到了统一思想、坚定信心、明确方向、鼓舞斗志的目的。这是一次高举旗帜、凝聚力量、团结奋进的大会。大会通过的十九届中央委员会的报告，高举中国特色社会主义伟大旗帜，坚持马克思列宁主义、毛泽东思想、邓小平理论、”三个代表”重要思想、科学发展观，全面贯彻新时代中国特色社会主义思想，分析了国际国内形势，提出了党的二十大主题，回顾总结了过去五年的工作和新时代十年的伟大变革，阐述了开辟马克思主义中国化时代化新境界、中国式现代化的中国特色和本质要求等重大问题，对全面建设社会主义现代化国家、全面推进中华民族伟大复兴进行了战略谋划，对统筹推进”五位一体”总体布局、协调推进”四个全面”战略布局作出了全面部署，为新时代新征程党和国家事业发展、实现第二个百年奋斗目标指明了前进方向、确立了行动指南。这个报告，是党和人民智慧的结晶，是党团结带领全国各族人民夺取中国特色社会主义新胜利的政治宣言和行动纲领，是马克思主义的纲领性文献。大会通过的十九届中央纪律检查委员会工作报告，总结了党的十九大以来在党中央坚强领导下，各级纪律检查委员会推进全面从严治党的实践探索和重要成效，阐明了深化全面从严治党、深入推进新时代党的建设新的伟大工程对全面建设社会主义现代化国家、全面推进中华民族伟大复兴的极端重要性，揭示了以党的自我革命引领社会革命的重大意义，宣示了党以永远在路上的清醒和坚定推进党风廉政建设和反腐败斗争的坚强决心。大会通过的党章修正案，体现了党的十九大以来党的理论创新、实践创新、制度创新成果，对坚持和加强党的全面领导、坚定不移推进全面从严治党、坚持和完善党的建设、推进党的自我革命提出了明确要求。大会选举产生的新一届中央委员会，集中了各地区各部门、各条战线、各个行业党的执政骨干和优秀代表，素质优良、分布均衡、结构合理，符合党中央要求和干部群众期待，符合领导班子和干部队伍实际，一定能够担负起团结带领全党全国各族人民全面建设社会主义现代化国家、全面推进中华民族伟大复兴的历史重任。大会还选举产生了新一届中央纪律检查委员会。我们相信，党的二十大作出的各项决策部署、取得的各项成果，必将对全面建设社会主义现代化国家、全面推进中华民族伟大复兴，对夺取中国特色社会主义新胜利发挥十分重要的指导和保证作用。</p><p>　　习近平强调，我们作为党的全国代表大会代表，使命光荣，责任重大，一定要牢记党的初心使命，坚定理想信念，弘扬伟大建党精神，认真学习领会党的理论和路线方针政策，贯彻落实党中央关于全面建设社会主义现代化国家、全面推进中华民族伟大复兴的战略部署，更加自觉地学习党章、遵守党章、贯彻党章、维护党章，在思想上政治上行动上同党中央保持高度一致；一定要牢记江山就是人民、人民就是江山，践行全心全意为人民服务的根本宗旨，保持同人民群众的血肉联系，始终同人民站在一起、想在一起、干在一起，积极反映广大党员和人民群众呼声，正确履行代表职责，自觉接受党和人民监督；一定要牢记”国之大者”，提高政治判断力、政治领悟力、政治执行力，带头维护党中央权威和集中统一领导，带头遵守政治纪律和政治规矩，带头提高党性修养、提升素质能力，为党和人民事业贡献自己的全部智慧和力量，为全体党员作出表率，不辜负广大党员信任。</p><p>　　习近平表示，大会期间，各民主党派中央、全国工商联和各族各界人士向大会表示祝贺，广大人民群众通过各种方式向大会表示祝贺，许多国家政党和组织来电来函对大会表示祝贺，大会主席团谨向他们表示衷心的感谢。</p><p>　　习近平强调，中国共产党走过了百年奋斗历程，又踏上了新的赶考之路。一百年来，党团结带领全国各族人民取得了新民主主义革命、社会主义革命和建设、改革开放和社会主义现代化建设的伟大胜利，开创了中国特色社会主义新时代。百年成就无比辉煌，百年大党风华正茂。我们完全有信心有能力在新时代新征程创造令世人刮目相看的新的更大奇迹。全党要紧密团结在党中央周围，高举中国特色社会主义伟大旗帜，坚定历史自信，增强历史主动，敢于斗争、敢于胜利，埋头苦干、锐意进取，团结带领全国各族人民为实现党的二十大确定的目标任务而奋斗。</p><p>　　大会选举后，现任和曾任全国人大常委会副委员长、全国政协副主席的党外人士，在京各民主党派中央、全国工商联副主席，无党派代表人士，宗教界代表人士，在京全国人大、全国政协常委中的民主党派、无党派和民族宗教界人士作为来宾列席会议。党内有关负责同志也列席了会议。</p><p>　　大会在雄壮的《国际歌》声中圆满结束。</p><p>来源：新华社</p><p>责编：张明宇 姚润萍 郝多 冯文雅</p><p>编审：陈卫平 陈竞超</p>]]></content>
      
      
      <categories>
          
          <category> 新闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时政 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试准备--SpringCloud</title>
      <link href="/2022/10/20/interview-springCloud-001/"/>
      <url>/2022/10/20/interview-springCloud-001/</url>
      
        <content type="html"><![CDATA[<h2 id="问题简答"><a href="#问题简答" class="headerlink" title="问题简答"></a>问题简答</h2><h3 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a><code>什么是微服务？</code></h3><p>单个轻量级服务一般为一个单独微服务，微服务讲究的是 专注某个功能的实现，比如登录系统只专注于用户登录方面功能的实现，讲究的是职责单一，开箱即用，可以独立运行。微服务架构系统是一个分布式的系统，按照业务进行划分服务单元模块，解决单个系统的不足，满足越来越复杂的业务需求。</p><p>马丁福勒（Martin Fowler）：就目前而言，对于微服务业界并没有一个统一的、标准的定义。但通常而言，微服务架构是一种架构模式或者说是架构风格，它提倡将单一应用程序划分成一组小的服务。每个服务运行在其独立的自己的进程中服务之间相互配合、相互协调，为用户提供最终价值。服务之间采用轻量级通信。每个服务都围绕具体业务进行构建，并能够独立部署到生产环境等。另外应尽量避免统一的、集中的服务管理机制。</p><h3 id="通俗的来讲："><a href="#通俗的来讲：" class="headerlink" title="通俗的来讲："></a><code>通俗的来讲：</code></h3><p>微服务就是一个独立的职责单一的服务应用程序。在 intellij idea 工具里面就是用maven开发的一个个独立的module，具体就是使用springboot 开发的一个小的模块，处理单一专业的业务逻辑，一个模块只做一个事情。</p><p>微服务强调的是服务大小，关注的是某一个点，具体解决某一个问题&#x2F;落地对应的一个服务应用，可以看做是idea 里面一个 module。</p><p>比如你去医院：你的牙齿不舒服，那么你就去牙科。你的头疼，那么你就去脑科。一个个的科室，就是一个微服务，一个功能就是一个服务。</p><h3 id="微服务的优缺点是什么？"><a href="#微服务的优缺点是什么？" class="headerlink" title="微服务的优缺点是什么？"></a><code>微服务的优缺点是什么？</code></h3><ul><li><p><strong>优点</strong>： 松耦合，聚焦单一业务功能，无关开发语言，团队规模降低。在开发中，不需要了解多有业务，只专注于当前功能，便利集中，功能小而精。微服务一个功能受损，对其他功能影响并不是太大，可以快速定位问题。微服务只专注于当前业务逻辑代码，不会和 html、css 或其他界面进行混合。可以灵活搭配技术，独立性比较舒服。</p></li><li><p><strong>缺点</strong>： 随着服务数量增加，管理复杂，部署复杂，服务器需要增多，服务通信和调用压力增大，运维工程师压力增大，人力资源增多，系统依赖增强，数据一致性，性能监控</p></li></ul><h3 id="什么是微服务架构？"><a href="#什么是微服务架构？" class="headerlink" title="什么是微服务架构？"></a><code>什么是微服务架构？</code></h3><p>微服务架构 就是 对微服务进行管理整合应用的。微服务架构 依赖于 微服务，是在微服务基础之上的。</p><p>例如：上面已经列举了什么是微服务。在医院里，每一个科室都是一个独立的微服务，那么 这个医院 就是 一个大型的微服务架构，就类似 院长 可以 对下面的 科室进行管理。微服务架构主要就是这种功能。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大白话中台系统</title>
      <link href="/2022/10/19/zhongTai-sys-20221019/"/>
      <url>/2022/10/19/zhongTai-sys-20221019/</url>
      
        <content type="html"><![CDATA[<p>什么是中台系统？它是如何诞生的？它长什么模样？我们为什么需要它？一串串的问题不禁浮现在我们的脑海，今天我们就带着这些问题，一起走进中台。</p><p>　<strong>1、中台诞生</strong></p><p>　　任何一个软件系统都是通过帮助客户解决问题来实现价值的。针对不同的需求会建立不同的软件项目。</p><p>　　这些软件项目包含客户端的应用和后台管理配置的应用。久而久之就形成了固定的”前台”和”后台”系统，而且大家都在乐此不疲地开发着类似的业务系统。</p><p>　　但是，时间一长大家就发现了，这些系统中有一些部分大同小异，在做第二个项目的时候并不用将所有的功能重写，可以把之前项目中那些共有的模块拿出来，稍作修改就可以在新项目中应用了。这就是中台的雏形。</p><p>　　<strong>转动的齿轮</strong></p><p>　　抽象和解耦是软件开发铁律，同样也适用于中台系统。中台系统就是将”后台”系统中那些针对技术，业务，组织的通用”模块&#x2F;服务”从原来固定的项目中抽离出来，并且使之能够成为一个自治的服务提供给更多的”前台”使用。</p><p>　　中台就是”前台”和”后台”之间联动的齿轮，也是：</p><p>　　调节器：前台业务变化快，后台系统相对比较稳定，中台就是他们中间的速度调节器。</p><p>　　加速器：新业务上马，接入中台即刻享受服务，不用 0 开始。</p><p>　　稳定器：前台业务多如牛毛，后台数据排山倒海，而中台提供各式各样的接口对接两者使用户享受稳定可靠的服务。</p><p>　　</p><p><img src="/2022/10/19/zhongTai-sys-20221019/1.png" alt="图片"></p><p>　　“中台系统”犹如齿轮，带动”前，后台系统”飞速转动</p><p>　<strong>2、中台的分类</strong></p><p>　　中台是一种能力的抽象，这种能力可以是业务能力，技术能力，数据能力甚至是组织能力。我们可以从不同的维度对其进行分类。</p><p>　　<br><img src="/2022/10/19/zhongTai-sys-20221019/2.png" alt="图片"></p><p>　　中台分为如下几类：</p><p>　　业务中台</p><p>　　技术中台</p><p>　　数据中台</p><p>　　组织中台</p><p>　<strong>①业务中台</strong></p><p>　　业务是根本，特别是用户的核心业务。对于中台来说需要针对业务进行颗粒度划分。例如：客户服务，结算中心，订单中心。</p><p>　　如果业务发生变化需要对上述服务进行拆解，例如：将结算中心拆解成支付服务和核销服务。</p><p>　　这样的分类和拆解是为了更好的支持前台，给前台业务提供更多的可能性，从而为用户组合出更多的使用场景。</p><p>　　这类平台的提供者一般在某一个行业深耕多年，积累大量的行业知识。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/3.png" alt="图片"></p><p>　　业务中台：根据业务对服务进行划分</p><p>　　<strong>②技术中台</strong></p><p>　　作为技术人员接触过最多的就是技术中台，通常我们会将服务进行拆解通过微服务的方式重新组织。</p><p>　　每个微服务都是自我治理的，通过服务注册，服务网关，服务跟踪的方式让他们形成一个整体。</p><p>　　技术中台的划分通常分为两个维度，第一个是基础服务，这些服务针对整个系统来说相对通用，如：日志服务，安全服务等等。</p><p>　　第二个就是业务服务，这些服务都针对每个业务模块做划分，通常这些服务会根据业务的变化或者增量进行更新或者横向扩展。</p><p>　　这类平台的提供者，一般都是科技型企业，涉及过多个行业，对基础组件和模块的应用得心应手，往往他们设计出来的中台架构性能和可靠性方面比较优秀。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/4.png" alt="图片"></p><p>　　技术中台：利用微服务，DevOps 给前台提供支撑</p><p>　<strong>③数据中台</strong></p><p>　　数据的获取通常需要经过数据采集，数据清洗&#x2F;过滤，数据存储，数据归档几个步骤，最后才能通过数据服务的形式展现给用户。</p><p>　　特别是针对客户端来说，同时通过数据中台提供的服务来获取数据的。数据中台会根据不同的业务场景，生成不同的数据服务，满足客户的需要。</p><p>　　提供类似平台的企业进入 IT<br>信息化的时间比较早，积累了一大批数据，通过对数据的整合和分析可以助力业务发展。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/5.png" alt="图片"></p><p>　　数据中台：让前端不用关心数据处理过程，只专注于”数据服务”</p><p>　　<strong>④组织中台</strong></p><p>　　中台是需要人来实现的，如何组织好这些人就显得尤为重要了。如果要谈谈组织中台，那么就要先说说下面几种组织结构。</p><p>　　职能型：每个部门各司其职，虽然都是一个老板管，但是部门之间的界限明确。</p><p>　　每次有了项目就从各个部门抽调人员，当项目完成以后人员都回到各自的部门当中。</p><p>　　如果再有新的项目就再次抽调。这种方式沟通成本高，责权不清，出现问题以后容易踢皮球，对用户需求的反应相对较慢。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/6.png" alt="图片"></p><p>　　职能型：根据职能对组织进行划分</p><p>　　矩阵型：随着互联网的兴起，矩阵型的组织结构也悄然兴起。把人员从原来的部门中完全剥离出来成立专门的项目，并且指定项目经理。</p><p>　　人员汇报的线路也从原来的部门经理换成了项目经理。而项目经理又对 CTO<br>直接负责，这样的结构相对简单，实用性较强，避开了职能型组织结构的一些缺点。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/7.png" alt="图片"></p><p>　　矩阵型：从职能部门中抽取合适的人形成独立的组织</p><p>　　产品型：随着产品意识的不断提升，人们不再拘泥于之前的矩阵型组织结构了，于是加入了产品和产品经理，更重要的是把客户也纳入到组织当中。</p><p>　　让客户参与产品决策，验收测试，增加用户的参与感，做到产品为客户所用。用户自己设计，测试出来的产品他想说不好都难。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/8.png" alt="图片"></p><p>　　产品型：在职能型的基础上，让组织围绕产品和用户工作</p><p>　　随着组织中台的不断发展，我们的组织结构也慢慢从职能型向矩阵型，产品型进行过渡。</p><p>　　<strong>3、中台的生命周期</strong></p><p>　　任何事物都有自身的运转规律，中台系统也不例外。首先我们需要满足使用者在某种场景中的需求，通过对需求的转化我们知道需要通过哪些功能或者系统来实现。</p><p>　　这些功能或者系统是否已经在中台系统中存在？如果存在是否需要进行优化或者拆分，如果不存在是否做成可以有通用性的模块？</p><p>　　在定义了以上几点以后，再进行设计，编码调试，集成测试。最后，发布给客户去验证业务的可行性。</p><p>　　如果发现问题再回到需求的原点重新走一次上面的过程，周而复始，直到满足客户的需求为止。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/9.png" alt="图片"></p><p>　　“需求”，”实施”，”验证”不断循环，直到满足用户的需求</p><p>　<strong>4、中台的作用</strong></p><p>　　大家既然对中台有了一定的了解，那我们再从两个维度来看看中台的作用。虽然上面已经介绍了很多关乎作用的例子，但是我们还是希望从两个维度来归纳总结一下。</p><p><strong>①快速切入市场</strong></p><p>　　在中台出现之前，我们进入每个行业是比较困难的。在了解业务的基础上需要搭建基础的业务模块。</p><p>　　现在不需要了，有了中台策略的加持即使对一些行业不太了解也能够从容应对。</p><p>　　在 BAT<br>中已经有染指汽车制造，航空航天等专业性很强的行业了，靠的就是中台能力的输出。<br>      <strong>②专业人员融入系统</strong></p><p>　　有了中台系统，那么就离不开行业中的专业人员。行业中的专业人员，协助中台系统打磨各个业务模块，通过<br>PASS 平台打造行业自身的应用。让业务和技术更好的融合，产生化学作用。</p><p>　　<strong>③定义平台规则</strong></p><p>　　现在阿里的钉钉就把用户，服务提供商，经销商都拉到了一个平台上了。通过阿里平台的能力，将钉钉打造成企业服务的中台，让多方从中受益。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/10.png" alt="图片"></p><p>　　业务方面：通过满足市场需求，提高专业化程度，打造平台战略，逐步升级</p><p><strong>5、技术方面的作用</strong><br><strong>①服务重用</strong></p><p>　　不要重复造轮子是我们始终面对的问题，中台的初衷就是抽离通用的部分，让更多人能够享受他们。</p><p>　　<strong>②服务进化</strong><br>技术会跟随业务的进化而进化，每一次进化都是一次技术的沉淀。以前这些技术进化是不可见的，现在新的项目也可以通过中台系统享受这些技术的进化。</p><p>　　<strong>③快速响应</strong><br>由于中台系统针对服务进行颗粒化处理，让每个服务都有独立性，可以针对业务的需求对服务进行横向扩展，从而提高服务的响应时间。</p><p>　<strong>④数据积累</strong></p><p>　　长年累月的数据积累，特别是对业务数据的积累，能够帮助我们带来商业价值。</p><p>　　<strong>⑤提高效率</strong></p><p>　　不用从无到有去搭建整个项目架构，也大大缩短了给用户的交付时间，高效的组织结构也促进了交付质量，提高了用户的满意度。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/11.png" alt="图片"></p><p>　　技术方面：服务重用，服务进化，快速响应，数据积累，提高效率相辅相成</p><p><strong>6、如何建立自己公司的中台</strong></p><p>　　不管是阿里的”中台，前台”战略，还是华为的”平台炮火支撑精兵作战”战略，仿佛都离我们很远。</p><p>　　有人说：”中台系统就是大公司的事情，我们做好自己手上的项目就好了。”这话对也不对！</p><p>　　中台系统确实需要具备一定规模以后才能产生，只有项目足够多，行业足够丰富，资源充足的情况下可以实行。</p><p>　　这些都是中小公司无法做到的，但是，作为我们可以利用中台策略的思维来优化我们的开发，产品，项目甚至是组织。</p><p>　　从业务方面，我们是否能够把自己专精行业的业务进行一个模块划分，让用户可以自由选择需要的业务模块，提高我们业务适配的灵活性。</p><p>　　从技术方面，我们是否能够总结一下哪些模块，服务可以从系统中解耦出来成为单独的服务，甚至可以单独部署做到真正的自治。以后搭建技术框架的时候就好像搭积木一样方便可靠。</p><p>　　从组织方面，由康威定理可以得出什么样的组织结构直接影响这个组织结构生产的软件。</p><p>　　我们是否还在遵循传统的职能型的方式在推进项目。是否可以考虑以客户为中心的开发模式，让开发人员更加贴近客户，为客户创造价值。</p><p>　　中台对于个体来说意味着什么？</p><p>　　前面提到了中台的定义，中台的作用以及对中小公司的思考。那么对于我们个人而言中台又意味着什么呢？我们可以在其中做些什么呢？这里我分享一下自己的想法。</p><p>　　如果说淘宝网整个就看成一个大中台来说，它提供了各式各样的服务，接口，数据，为商家和消费者创造交易的环境。那么我们把淘宝网可以看成一个”面”。</p><p>　　那么对于商家来说，他需要利用一些营销工具，聘请一些模特拍照，利用一些物流信息为自己送货。商家可以看成一条”线”。</p><p>　　那些提供营销工具，拍照服务，物流服务的供应商就可以看成”点”。</p><p>　　对于我们而言，可能无法成为”面”，但是可以通过”面”的支持去做”线”和”点”。</p><p>　　再把眼界扩大一点，到微信小程序，支付宝小程序，钉钉应用，都是有发挥空间的。</p><p><img src="/2022/10/19/zhongTai-sys-20221019/12.png" alt="图片"></p><p>　　供应商，商家，平台，构成”点”，”线”，”面”的有机整体</p><p><strong>7、总结</strong></p><p>　　中台是 IT<br>信息化过程中经验总结的产物，他是前人归纳总结出来的方法论，也是解决问题的思路。</p><p>　　它把这些经验和方法从具体的场景中抽离出来，为的是服务于更多的场景。</p><p>　　我们可以从业务，技术，数据，组织多个维度来看待它。它不仅仅可以应用到企业，对个人的发展也是有帮助的。</p><hr><p>转载说明：本文转载自：51CTO、架构师技术联盟等，如有侵权请联系相关工作人员。<br>来源:<a href="https://blog.csdn.net/jiangjiang_jian/article/details/103006494">https://blog.csdn.net/jiangjiang_jian/article/details/103006494</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国共产党第二十次全国代表大会开幕会文字实录</title>
      <link href="/2022/10/18/news-2022-10-16/"/>
      <url>/2022/10/18/news-2022-10-16/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/10/18/news-2022-10-16/1.jpg" alt="图片"></p><p>10月16日，中国共产党第二十次全国代表大会在北京人民大会堂开幕。这是习近平、李克强、栗战书、汪洋、王沪宁、赵乐际、韩正、胡锦涛在主席台上。</p><p>以下为文字实录：</p><p>同志们：现在，我代表第十九届中央委员会向大会作报告。</p><p>中国共产党第二十次全国代表大会，是在全党全国各族人民迈上全面建设社会主义现代化国家新征程、向第二个百年奋斗目标进军的关键时刻召开的一次十分重要的大会。</p><p>大会的主题是：高举中国特色社会主义伟大旗帜，全面贯彻新时代中国特色社会主义思想，弘扬伟大建党精神，自信自强、守正创新，踔厉奋发、勇毅前行，为全面建设社会主义现代化国家、全面推进中华民族伟大复兴而团结奋斗。</p><p>中国共产党已走过百年奋斗历程。我们党立志于中华民族千秋伟业，致力于人类和平与发展崇高事业，责任无比重大，使命无上光荣。全党同志务必不忘初心、牢记使命，务必谦虚谨慎、艰苦奋斗，务必敢于斗争、善于斗争，坚定历史自信，增强历史主动，谱写新时代中国特色社会主义更加绚丽的华章。</p><p><code>一、过去五年的工作和新时代十年的伟大变革</code></p><p>十九大以来的五年，是极不寻常、极不平凡的五年。党中央统筹中华民族伟大复兴战略全局和世界百年未有之大变局，就党和国家事业发展作出重大战略部署，团结带领全党全军全国各族人民有效应对严峻复杂的国际形势和接踵而至的巨大风险挑战，以奋发有为的精神把新时代中国特色社会主义不断推向前进。</p><p>五年来，我们坚持加强党的全面领导和党中央集中统一领导，全力推进全面建成小康社会进程，完整、准确、全面贯彻新发展理念，着力推动高质量发展，主动构建新发展格局，蹄疾步稳推进改革，扎实推进全过程人民民主，全面推进依法治国，积极发展社会主义先进文化，突出保障和改善民生，集中力量实施脱贫攻坚战，大力推进生态文明建设，坚决维护国家安全，防范化解重大风险，保持社会大局稳定，大力度推进国防和军队现代化建设，全方位开展中国特色大国外交，全面推进党的建设新的伟大工程。我们隆重庆祝中国共产党成立一百周年、中华人民共和国成立七十周年，制定第三个历史决议，在全党开展党史学习教育，号召全党学习和践行伟大建党精神。特别是面对突如其来的新冠肺炎疫情，我们坚持人民至上、生命至上，坚持动态清零不动摇，开展抗击疫情人民战争、总体战、阻击战，最大限度保护了人民生命安全和身体健康，统筹疫情防控和经济社会发展取得重大积极成果。面对香港局势动荡变化，我们依照宪法和基本法有效实施对特别行政区的全面管治权，落实”爱国者治港”原则，香港局势实现由乱到治的重大转折。面对”台独”势力分裂活动和外部势力干涉台湾事务的严重挑衅，我们坚决开展反分裂、反干涉重大斗争，展示了我们维护国家主权和领土完整、反对”台独”的坚强决心和强大能力。面对国际局势急剧变化，我们保持战略定力，发扬斗争精神，在斗争中维护国家尊严和核心利益，牢牢掌握了我国发展和安全主动权。五年来，我们党团结带领人民，攻克了许多长期没有解决的难题，办成了许多事关长远的大事要事，推动党和国家事业取得举世瞩目的重大成就。</p><p>同志们！十八大召开至今已经十年了。十年来，我们经历了对党和人民事业具有重大现实意义和深远历史意义的三件大事：一是迎来中国共产党成立一百周年，二是中国特色社会主义进入新时代，三是完成脱贫攻坚、全面建成小康社会的历史任务，实现第一个百年奋斗目标。这是中国共产党和中国人民团结奋斗赢得的历史性胜利，是彪炳中华民族发展史册的历史性胜利，也是对世界具有深远影响的历史性胜利。</p><p>十年前，我们面对的形势是，改革开放和社会主义现代化建设取得巨大成就，党的建设新的伟大工程取得显著成效，为我们继续前进奠定了坚实基础、创造了良好条件、提供了重要保障，同时一系列长期积累及新出现的突出矛盾和问题亟待解决。面对这些影响党长期执政、国家长治久安、人民幸福安康的突出矛盾和问题，党中央审时度势、果敢抉择，锐意进取、攻坚克难，团结带领全党全军全国各族人民撸起袖子加油干、风雨无阻向前行，义无反顾进行具有许多新的历史特点的伟大斗争。</p><p>十年来，我们坚持马克思列宁主义、毛泽东思想、邓小平理论、”三个代表”重要思想、科学发展观，全面贯彻新时代中国特色社会主义思想，全面贯彻党的基本路线、基本方略，采取一系列战略性举措，推进一系列变革性实践，实现一系列突破性进展，取得一系列标志性成果，经受住了来自政治、经济、意识形态、自然界等方面的风险挑战考验，党和国家事业取得历史性成就、发生历史性变革，推动我国迈上全面建设社会主义现代化国家新征程。</p><ul><li><p>我们创立了新时代中国特色社会主义思想，明确坚持和发展中国特色社会主义的基本方略，提出一系列治国理政新理念新思想新战略，实现了马克思主义中国化时代化新的飞跃。</p></li><li><p>我们全面加强党的领导，确保党中央权威和集中统一领导，确保党发挥总揽全局、协调各方的领导核心作用，我们这个拥有九千六百多万名党员的马克思主义政党更加团结统一。</p></li><li><p>我们经过接续奋斗，实现了小康这个中华民族的千年梦想，打赢了人类历史上规模最大的脱贫攻坚战，历史性地解决了绝对贫困问题，为全球减贫事业作出了重大贡献。</p></li><li><p>我们对新时代党和国家事业发展作出科学完整的战略部署，提出实现中华民族伟大复兴的中国梦，统揽伟大斗争、伟大工程、伟大事业、伟大梦想，明确”五位一体”总体布局和”四个全面”战略布局，确定稳中求进工作总基调，统筹发展和安全，明确我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，并紧紧围绕这个社会主要矛盾推进各项工作，不断丰富和发展人类文明新形态。</p></li><li><p>我们提出并贯彻新发展理念，着力推进高质量发展，推动构建新发展格局，实施供给侧结构性改革，制定一系列具有全局性意义的区域重大战略，我国经济实力实现历史性跃升，国内生产总值从五十四万亿元增长到一百一十四万亿元，我国经济总量占世界经济的比重达百分之十八点五，提高七点二个百分点，稳居世界第二位；人均国内生产总值从三万九千八百元增加到八万一千元。谷物总产量稳居世界首位，制造业规模、外汇储备稳居世界第一。一些关键核心技术实现突破，战略性新兴产业发展壮大，载人航天、探月探火、深海深地探测、超级计算机、卫星导航、量子信息、核电技术、大飞机制造、生物医药等取得重大成果，进入创新型国家行列。</p></li><li><p>我们以巨大的政治勇气全面深化改革，许多领域实现历史性变革、系统性重塑、整体性重构，中国特色社会主义制度更加成熟更加定型，国家治理体系和治理能力现代化水平明显提高。</p></li><li><p>我们实行更加积极主动的开放战略，共建”一带一路”成为深受欢迎的国际公共产品和国际合作平台，我国成为一百四十多个国家和地区的主要贸易伙伴，货物贸易总额居世界第一，吸引外资和对外投资居世界前列，形成更大范围、更宽领域、更深层次对外开放格局。</p></li><li><p>我们坚持走中国特色社会主义政治发展道路，全面发展全过程人民民主，社会主义民主政治制度化、规范化、程序化全面推进，人民当家作主更为扎实，全面依法治国总体格局基本形成。</p></li><li><p>我们确立和坚持马克思主义在意识形态领域指导地位的根本制度，社会主义核心价值观广泛传播，中华优秀传统文化得到创造性转化、创新性发展，文化事业日益繁荣，网络生态持续向好，意识形态领域形势发生全局性、根本性转变。</p></li><li><p>我们深入贯彻以人民为中心的发展思想，在幼有所育、学有所教、劳有所得、病有所医、老有所养、住有所居、弱有所扶上持续用力，建成世界上规模最大的教育体系、社会保障体系、医疗卫生体系，人民群众获得感、幸福感、安全感更加充实、更有保障、更可持续，共同富裕取得新成效。</p></li><li><p>我们坚持绿水青山就是金山银山的理念，坚持山水林田湖草沙一体化保护和系统治理，生态文明制度体系更加健全，生态环境保护发生历史性、转折性、全局性变化，我们的祖国天更蓝、山更绿、水更清。</p></li><li><p>我们贯彻总体国家安全观，以坚定的意志品质维护国家主权、安全、发展利益，国家安全得到全面加强，扫黑除恶专项斗争取得阶段性成果，有力应对一系列重大自然灾害，平安中国建设迈向更高水平。</p></li><li><p>我们确立党在新时代的强军目标，贯彻新时代党的强军思想，贯彻新时代军事战略方针，坚持党对人民军队的绝对领导，统筹加强各方向各领域军事斗争，大刀阔斧深化国防和军队改革，人民军队体制一新、结构一新、格局一新、面貌一新。</p></li><li><p>我们全面准确推进”一国两制”实践，坚持”一国两制”、”港人治港”、”澳人治澳”、高度自治的方针，推动香港进入由乱到治走向由治及兴的新阶段，香港、澳门保持长期稳定发展良好态势。我们提出新时代解决台湾问题的总体方略，促进两岸交流合作，坚决反对”台独”分裂行径，坚决反对外部势力干涉，牢牢把握两岸关系主导权和主动权。</p></li><li><p>我们全面推进中国特色大国外交，推动构建人类命运共同体，坚定维护国际公平正义，倡导践行真正的多边主义，旗帜鲜明反对一切霸权主义和强权政治，毫不动摇反对任何单边主义、保护主义、霸凌行径。我们推动构建新型国际关系，积极参与全球治理体系改革和建设，全面开展抗击新冠肺炎疫情国际合作，赢得广泛国际赞誉，我国国际影响力、感召力、塑造力显著提升。</p></li><li><p>我们深入推进全面从严治党，坚持打铁必须自身硬，提出和落实新时代党的建设总要求，以党的政治建设统领党的建设各项工作。我们以钉钉子精神纠治”四风”，反对特权思想和特权现象，刹住了一些长期没有刹住的歪风，纠治了一些多年未除的顽瘴痼疾。我们开展了史无前例的反腐败斗争，以”得罪千百人、不负十四亿”的使命担当祛疴治乱，”打虎”、”拍蝇”、”猎狐”多管齐下，反腐败斗争取得压倒性胜利并全面巩固，消除了党、国家、军队内部存在的严重隐患。经过不懈努力，党找到了自我革命这一跳出治乱兴衰历史周期率的第二个答案，确保党永远不变质、不变色、不变味。</p></li></ul><p>在充分肯定党和国家事业取得举世瞩目成就的同时，必须清醒看到，我们的工作还存在一些不足，面临不少困难和问题。对这些问题，我们已经采取一系列措施加以解决，今后必须加大工作力度。</p><p>同志们！新时代的伟大成就是党和人民一道拼出来、干出来、奋斗出来的！在这里，我代表中共中央，向全体中国共产党员，向全国各族人民，向各民主党派、各人民团体和各界爱国人士，向香港特别行政区同胞、澳门特别行政区同胞和台湾同胞以及广大侨胞，向关心和支持中国现代化建设的各国朋友，表示衷心的感谢！</p><p>新时代十年的伟大变革，在党史、新中国史、改革开放史、社会主义发展史、中华民族发展史上具有里程碑意义。走过百年奋斗历程的中国共产党在革命性锻造中更加坚强有力，在坚持和发展中国特色社会主义的历史进程中始终成为坚强领导核心。中国人民的前进动力更加强大、奋斗精神更加昂扬、必胜信念更加坚定，中国共产党和中国人民正信心百倍推进中华民族从站起来、富起来到强起来的伟大飞跃。改革开放和社会主义现代化建设深入推进，实现中华民族伟大复兴进入了不可逆转的历史进程。科学社会主义在二十一世纪的中国焕发出新的蓬勃生机，中国式现代化为人类实现现代化提供了新的选择，中国共产党和中国人民为解决人类面临的共同问题提供更多更好的中国智慧、中国方案、中国力量，为人类和平与发展崇高事业作出新的更大的贡献！</p><p><code>二、开辟马克思主义中国化时代化新境界</code></p><p>马克思主义是我们立党立国、兴党兴国的根本指导思想。实践告诉我们，中国共产党为什么能，中国特色社会主义为什么好，归根到底是马克思主义行，是中国化时代化的马克思主义行。拥有马克思主义科学理论指导是我们党坚定信仰信念、把握历史主动的根本所在。</p><p>十八大以来，我们党勇于进行理论探索和创新，以全新的视野深化对共产党执政规律、社会主义建设规律、人类社会发展规律的认识，取得重大理论创新成果，集中体现为新时代中国特色社会主义思想。十九大、十九届六中全会提出的”十个明确”、”十四个坚持”、”十三个方面成就”概括了这一思想的主要内容，必须长期坚持并不断丰富发展。</p><p>中国共产党人深刻认识到，只有把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，坚持运用辩证唯物主义和历史唯物主义，才能正确回答时代和实践提出的重大问题，才能始终保持马克思主义的蓬勃生机和旺盛活力。</p><p>实践没有止境，理论创新也没有止境。不断谱写马克思主义中国化时代化新篇章，是当代中国共产党人的庄严历史责任。继续推进实践基础上的理论创新，首先要把握好新时代中国特色社会主义思想的世界观和方法论，坚持好、运用好贯穿其中的立场观点方法。必须坚持人民至上，坚持自信自立，坚持守正创新，坚持问题导向，坚持系统观念，坚持胸怀天下，站稳人民立场、把握人民愿望、尊重人民创造、集中人民智慧，坚持对马克思主义的坚定信仰、对中国特色社会主义的坚定信念，坚定道路自信、理论自信、制度自信、文化自信，不断提出真正解决问题的新理念新思路新办法，为前瞻性思考、全局性谋划、整体性推进党和国家各项事业提供科学思想方法。</p><p><code>三、新时代新征程中国共产党的使命任务</code></p><p>从现在起，中国共产党的中心任务就是团结带领全国各族人民全面建成社会主义现代化强国、实现第二个百年奋斗目标，以中国式现代化全面推进中华民族伟大复兴。</p><p>中国式现代化，是中国共产党领导的社会主义现代化，既有各国现代化的共同特征，更有基于自己国情的中国特色。中国式现代化是人口规模巨大的现代化，是全体人民共同富裕的现代化，是物质文明和精神文明相协调的现代化，是人与自然和谐共生的现代化，是走和平发展道路的现代化。</p><p>中国式现代化的本质要求是：坚持中国共产党领导，坚持中国特色社会主义，实现高质量发展，发展全过程人民民主，丰富人民精神世界，实现全体人民共同富裕，促进人与自然和谐共生，推动构建人类命运共同体，创造人类文明新形态。</p><p>全面建成社会主义现代化强国，总的战略安排是分两步走：从二〇二〇年到二〇三五年基本实现社会主义现代化；从二〇三五年到本世纪中叶把我国建成富强民主文明和谐美丽的社会主义现代化强国。未来五年是全面建设社会主义现代化国家开局起步的关键时期。</p><p>全面建设社会主义现代化国家，是一项伟大而艰巨的事业，前途光明，任重道远。我们必须增强忧患意识，坚持底线思维，做到居安思危、未雨绸缪，准备经受风高浪急甚至惊涛骇浪的重大考验。前进道路上，必须牢牢把握以下重大原则：坚持和加强党的全面领导，坚持中国特色社会主义道路，坚持以人民为中心的发展思想，坚持深化改革开放，坚持发扬斗争精神。要增强全党全国各族人民的志气、骨气、底气，不信邪、不怕鬼、不怕压，知难而进、迎难而上，统筹发展和安全，全力战胜前进道路上各种困难和挑战，依靠顽强斗争打开事业发展新天地。</p><p><code>四、加快构建新发展格局，着力推动高质量发展</code></p><p>高质量发展是全面建设社会主义现代化国家的首要任务。发展是党执政兴国的第一要务。没有坚实的物质技术基础，就不可能全面建成社会主义现代化强国。必须完整、准确、全面贯彻新发展理念，坚持社会主义市场经济改革方向，坚持高水平对外开放，加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局。</p><p>我们要坚持以推动高质量发展为主题，把实施扩大内需战略同深化供给侧结构性改革有机结合起来，增强国内大循环内生动力和可靠性，提升国际循环质量和水平，加快建设现代化经济体系，着力提高全要素生产率，着力提升产业链供应链韧性和安全水平，着力推进城乡融合和区域协调发展，推动经济实现质的有效提升和量的合理增长。</p><p>我们要构建高水平社会主义市场经济体制，坚持和完善社会主义基本经济制度，毫不动摇巩固和发展公有制经济，毫不动摇鼓励、支持、引导非公有制经济发展，充分发挥市场在资源配置中的决定性作用，更好发挥政府作用。建设现代化产业体系，坚持把发展经济的着力点放在实体经济上，推进新型工业化，加快建设制造强国、质量强国、航天强国、交通强国、网络强国、数字中国。全面推进乡村振兴，坚持农业农村优先发展，巩固拓展脱贫攻坚成果，加快建设农业强国，扎实推动乡村产业、人才、文化、生态、组织振兴，全方位夯实粮食安全根基，牢牢守住十八亿亩耕地红线，确保中国人的饭碗牢牢端在自己手中。促进区域协调发展，深入实施区域协调发展战略、区域重大战略、主体功能区战略、新型城镇化战略，优化重大生产力布局，构建优势互补、高质量发展的区域经济布局和国土空间体系。推进高水平对外开放，稳步扩大规则、规制、管理、标准等制度型开放，加快建设贸易强国，推动共建”一带一路”高质量发展，维护多元稳定的国际经济格局和经贸关系。</p><p><code>五、实施科教兴国战略，强化现代化建设人才支撑</code></p><p>教育、科技、人才是全面建设社会主义现代化国家的基础性、战略性支撑。必须坚持科技是第一生产力、人才是第一资源、创新是第一动力，深入实施科教兴国战略、人才强国战略、创新驱动发展战略，开辟发展新领域新赛道，不断塑造发展新动能新优势。</p><p>我们要坚持教育优先发展、科技自立自强、人才引领驱动，加快建设教育强国、科技强国、人才强国，坚持为党育人、为国育才，全面提高人才自主培养质量，着力造就拔尖创新人才，聚天下英才而用之。</p><p>我们要办好人民满意的教育，全面贯彻党的教育方针，落实立德树人根本任务，培养德智体美劳全面发展的社会主义建设者和接班人，加快建设高质量教育体系，发展素质教育，促进教育公平。完善科技创新体系，坚持创新在我国现代化建设全局中的核心地位，健全新型举国体制，强化国家战略科技力量，提升国家创新体系整体效能，形成具有全球竞争力的开放创新生态。加快实施创新驱动发展战略，加快实现高水平科技自立自强，以国家战略需求为导向，集聚力量进行原创性引领性科技攻关，坚决打赢关键核心技术攻坚战，加快实施一批具有战略性全局性前瞻性的国家重大科技项目，增强自主创新能力。深入实施人才强国战略，坚持尊重劳动、尊重知识、尊重人才、尊重创造，完善人才战略布局，加快建设世界重要人才中心和创新高地，着力形成人才国际竞争的比较优势，把各方面优秀人才集聚到党和人民事业中来。</p><p><code>六、发展全过程人民民主，保障人民当家作主</code></p><p>我国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家，国家一切权力属于人民。人民民主是社会主义的生命，是全面建设社会主义现代化国家的应有之义。全过程人民民主是社会主义民主政治的本质属性，是最广泛、最真实、最管用的民主。必须坚定不移走中国特色社会主义政治发展道路，坚持党的领导、人民当家作主、依法治国有机统一，坚持人民主体地位，充分体现人民意志、保障人民权益、激发人民创造活力。</p><p>我们要健全人民当家作主制度体系，扩大人民有序政治参与，保证人民依法实行民主选举、民主协商、民主决策、民主管理、民主监督，发挥人民群众积极性、主动性、创造性，巩固和发展生动活泼、安定团结的政治局面。</p><p>我们要加强人民当家作主制度保障，坚持和完善我国根本政治制度、基本政治制度、重要政治制度，拓展民主渠道，丰富民主形式，支持和保证人民通过人民代表大会行使国家权力。深化工会、共青团、妇联等群团组织改革和建设，有效发挥桥梁纽带作用。坚持走中国人权发展道路，推动人权事业全面发展。全面发展协商民主，推进协商民主广泛多层制度化发展，坚持和完善中国共产党领导的多党合作和政治协商制度，完善人民政协民主监督和委员联系界别群众制度机制。积极发展基层民主，健全基层党组织领导的基层群众自治机制，完善基层直接民主制度体系和工作体系。全心全意依靠工人阶级，维护职工合法权益。巩固和发展最广泛的爱国统一战线，完善大统战工作格局，坚持大团结大联合，动员全体中华儿女围绕实现中华民族伟大复兴中国梦一起来想、一起来干。加强同民主党派和无党派人士的团结合作。以铸牢中华民族共同体意识为主线，加强和改进党的民族工作。坚持我国宗教中国化方向，积极引导宗教与社会主义社会相适应。加强和改进侨务工作，形成共同致力民族复兴的强大力量。</p><p><code>七、坚持全面依法治国，推进法治中国建设</code></p><p>全面依法治国是国家治理的一场深刻革命，关系党执政兴国，关系人民幸福安康，关系党和国家长治久安。必须更好发挥法治固根本、稳预期、利长远的保障作用，在法治轨道上全面建设社会主义现代化国家。</p><p>我们要坚持走中国特色社会主义法治道路，建设中国特色社会主义法治体系、建设社会主义法治国家，围绕保障和促进社会公平正义，坚持依法治国、依法执政、依法行政共同推进，坚持法治国家、法治政府、法治社会一体建设，全面推进科学立法、严格执法、公正司法、全民守法，全面推进国家各方面工作法治化。</p><p>我们要完善以宪法为核心的中国特色社会主义法律体系，加强宪法实施和监督，加强重点领域、新兴领域、涉外领域立法，推进科学立法、民主立法、依法立法。扎实推进依法行政，转变政府职能，优化政府职责体系和组织结构，提高行政效率和公信力，全面推进严格规范公正文明执法。严格公正司法，深化司法体制综合配套改革，全面准确落实司法责任制，加快建设公正高效权威的社会主义司法制度，努力让人民群众在每一个司法案件中感受到公平正义。加快建设法治社会，弘扬社会主义法治精神，传承中华优秀传统法律文化，引导全体人民做社会主义法治的忠实崇尚者、自觉遵守者、坚定捍卫者，努力使尊法学法守法用法在全社会蔚然成风。</p><p><code>八、推进文化自信自强，铸就社会主义文化新辉煌</code></p><p>全面建设社会主义现代化国家，必须坚持中国特色社会主义文化发展道路，增强文化自信，围绕举旗帜、聚民心、育新人、兴文化、展形象建设社会主义文化强国，发展面向现代化、面向世界、面向未来的，民族的科学的大众的社会主义文化，激发全民族文化创新创造活力，增强实现中华民族伟大复兴的精神力量。</p><p>我们要坚持马克思主义在意识形态领域指导地位的根本制度，坚持为人民服务、为社会主义服务，坚持百花齐放、百家争鸣，坚持创造性转化、创新性发展，以社会主义核心价值观为引领，发展社会主义先进文化，弘扬革命文化，传承中华优秀传统文化，满足人民日益增长的精神文化需求，巩固全党全国各族人民团结奋斗的共同思想基础，不断提升国家文化软实力和中华文化影响力。</p><p>我们要建设具有强大凝聚力和引领力的社会主义意识形态，牢牢掌握党对意识形态工作领导权，全面落实意识形态工作责任制，巩固壮大奋进新时代的主流思想舆论，加强全媒体传播体系建设，推动形成良好网络生态。广泛践行社会主义核心价值观，弘扬以伟大建党精神为源头的中国共产党人精神谱系，深入开展社会主义核心价值观宣传教育，深化爱国主义、集体主义、社会主义教育，着力培养担当民族复兴大任的时代新人。提高全社会文明程度，实施公民道德建设工程，弘扬中华传统美德，加强家庭家教家风建设，推动明大德、守公德、严私德，提高人民道德水准和文明素养，在全社会弘扬劳动精神、奋斗精神、奉献精神、创造精神、勤俭节约精神。繁荣发展文化事业和文化产业，坚持以人民为中心的创作导向，推出更多增强人民精神力量的优秀作品，健全现代公共文化服务体系，实施重大文化产业项目带动战略。促进群众体育和竞技体育全面发展，加快建设体育强国。增强中华文明传播力影响力，坚守中华文化立场，讲好中国故事、传播好中国声音，展现可信、可爱、可敬的中国形象，推动中华文化更好走向世界。</p><p><code>九、增进民生福祉，提高人民生活品质</code></p><p>江山就是人民，人民就是江山。中国共产党领导人民打江山、守江山，守的是人民的心。治国有常，利民为本。为民造福是立党为公、执政为民的本质要求。必须坚持在发展中保障和改善民生，鼓励共同奋斗创造美好生活，不断实现人民对美好生活的向往。</p><p>我们要实现好、维护好、发展好最广大人民根本利益，紧紧抓住人民最关心最直接最现实的利益问题，坚持尽力而为、量力而行，深入群众、深入基层，采取更多惠民生、暖民心举措，着力解决好人民群众急难愁盼问题，健全基本公共服务体系，提高公共服务水平，增强均衡性和可及性，扎实推进共同富裕。</p><p>我们要完善分配制度，坚持按劳分配为主体、多种分配方式并存，坚持多劳多得，鼓励勤劳致富，促进机会公平，增加低收入者收入，扩大中等收入群体，规范收入分配秩序，规范财富积累机制。实施就业优先战略，强化就业优先政策，健全就业公共服务体系，加强困难群体就业兜底帮扶，消除影响平等就业的不合理限制和就业歧视，使人人都有通过勤奋劳动实现自身发展的机会。健全社会保障体系，健全覆盖全民、统筹城乡、公平统一、安全规范、可持续的多层次社会保障体系，扩大社会保险覆盖面。坚持男女平等基本国策，保障妇女儿童合法权益。促进残疾人事业全面发展。加快建立多主体供给、多渠道保障、租购并举的住房制度。推进健康中国建设，把保障人民健康放在优先发展的战略位置，建立生育支持政策体系，实施积极应对人口老龄化国家战略，促进中医药传承创新发展，健全公共卫生体系，加强重大疫情防控救治体系和应急能力建设，有效遏制重大传染性疾病传播。</p><p><code>十、推动绿色发展，促进人与自然和谐共生</code></p><p>大自然是人类赖以生存发展的基本条件。尊重自然、顺应自然、保护自然，是全面建设社会主义现代化国家的内在要求。必须牢固树立和践行绿水青山就是金山银山的理念，站在人与自然和谐共生的高度谋划发展。</p><p>我们要推进美丽中国建设，坚持山水林田湖草沙一体化保护和系统治理，统筹产业结构调整、污染治理、生态保护、应对气候变化，协同推进降碳、减污、扩绿、增长，推进生态优先、节约集约、绿色低碳发展。</p><p>我们要加快发展方式绿色转型，实施全面节约战略，发展绿色低碳产业，倡导绿色消费，推动形成绿色低碳的生产方式和生活方式。深入推进环境污染防治，持续深入打好蓝天、碧水、净土保卫战，基本消除重污染天气，基本消除城市黑臭水体，加强土壤污染源头防控，提升环境基础设施建设水平，推进城乡人居环境整治。提升生态系统多样性、稳定性、持续性，加快实施重要生态系统保护和修复重大工程，实施生物多样性保护重大工程，推行草原森林河流湖泊湿地休养生息，实施好长江十年禁渔，健全耕地休耕轮作制度，防治外来物种侵害。积极稳妥推进碳达峰碳中和，立足我国能源资源禀赋，坚持先立后破，有计划分步骤实施碳达峰行动，深入推进能源革命，加强煤炭清洁高效利用，加快规划建设新型能源体系，积极参与应对气候变化全球治理。</p><p><code>十一、推进国家安全体系和能力现代化，坚决维护国家安全和社会稳定</code></p><p>国家安全是民族复兴的根基，社会稳定是国家强盛的前提。必须坚定不移贯彻总体国家安全观，把维护国家安全贯穿党和国家工作各方面全过程，确保国家安全和社会稳定。</p><p>我们要坚持以人民安全为宗旨、以政治安全为根本、以经济安全为基础、以军事科技文化社会安全为保障、以促进国际安全为依托，统筹外部安全和内部安全、国土安全和国民安全、传统安全和非传统安全、自身安全和共同安全，统筹维护和塑造国家安全，夯实国家安全和社会稳定基层基础，完善参与全球安全治理机制，建设更高水平的平安中国，以新安全格局保障新发展格局。</p><p>我们要健全国家安全体系，完善高效权威的国家安全领导体制，完善国家安全法治体系、战略体系、政策体系、风险监测预警体系、国家应急管理体系，构建全域联动、立体高效的国家安全防护体系。增强维护国家安全能力，坚定维护国家政权安全、制度安全、意识形态安全，确保粮食、能源资源、重要产业链供应链安全，维护我国公民、法人在海外合法权益，筑牢国家安全人民防线。提高公共安全治理水平，坚持安全第一、预防为主，完善公共安全体系，提高防灾减灾救灾和急难险重突发公共事件处置保障能力，加强个人信息保护。完善社会治理体系，健全共建共治共享的社会治理制度，提升社会治理效能，畅通和规范群众诉求表达、利益协调、权益保障通道，建设人人有责、人人尽责、人人享有的社会治理共同体。</p><p><code>十二、实现建军一百年奋斗目标，开创国防和军队现代化新局面</code></p><p>如期实现建军一百年奋斗目标，加快把人民军队建成世界一流军队，是全面建设社会主义现代化国家的战略要求。必须贯彻新时代党的强军思想，贯彻新时代军事战略方针，坚持党对人民军队的绝对领导，坚持政治建军、改革强军、科技强军、人才强军、依法治军，加快军事理论现代化、军队组织形态现代化、军事人员现代化、武器装备现代化，提高捍卫国家主权、安全、发展利益战略能力，有效履行新时代人民军队使命任务。</p><p>全面加强人民军队党的建设，确保枪杆子永远听党指挥。健全贯彻军委主席负责制体制机制。建强人民军队党的组织体系，推进政治整训常态化制度化，持之以恒正风肃纪反腐。</p><p>我们要全面加强练兵备战，提高人民军队打赢能力，创新军事战略指导，发展人民战争战略战术，打造强大战略威慑力量体系，增加新域新质作战力量比重，深入推进实战化军事训练。全面加强军事治理，巩固拓展国防和军队改革成果，完善军事力量结构编成，体系优化军事政策制度，实施国防科技和武器装备重大工程，建强新型军事人才培养体系，加强依法治军机制建设和战略规划。巩固提高一体化国家战略体系和能力，加强国防科技工业能力建设，加强国防动员和后备力量建设，做好退役军人服务保障工作，巩固发展军政军民团结。</p><p><code>十三、坚持和完善&quot;一国两制&quot;，推进祖国统一</code></p><p>“一国两制”是中国特色社会主义的伟大创举，是香港、澳门回归后保持长期繁荣稳定的最佳制度安排，必须长期坚持。</p><p>全面准确、坚定不移贯彻”一国两制”、”港人治港”、”澳人治澳”、高度自治的方针，坚持依法治港治澳，落实中央全面管治权，落实”爱国者治港”、”爱国者治澳”原则，支持香港、澳门发展经济、改善民生、破解经济社会发展中的深层次矛盾和问题，促进香港、澳门长期繁荣稳定，支持香港、澳门更好融入国家发展大局，为实现中华民族伟大复兴更好发挥作用。</p><p>坚持贯彻新时代党解决台湾问题的总体方略，坚定不移推进祖国统一大业。我们始终尊重、关爱、造福台湾同胞，继续致力于促进两岸经济文化交流合作，推动两岸共同弘扬中华文化，促进两岸同胞心灵契合。解决台湾问题是中国人自己的事，要由中国人来决定。我们坚持以最大诚意、尽最大努力争取和平统一的前景，但决不承诺放弃使用武力，保留采取一切必要措施的选项，这针对的是外部势力干涉和极少数”台独”分裂分子及其分裂活动，绝非针对广大台湾同胞。国家统一、民族复兴的历史车轮滚滚向前，祖国完全统一一定要实现，也一定能够实现！</p><p><code>十四、促进世界和平与发展，推动构建人类命运共同体</code></p><p>当前，世界之变、时代之变、历史之变正以前所未有的方式展开，人类社会面临前所未有的挑战。世界又一次站在历史的十字路口，何去何从取决于各国人民的抉择。</p><p>中国始终坚持维护世界和平、促进共同发展的外交政策宗旨，致力于推动构建人类命运共同体。</p><p>中国坚定奉行独立自主的和平外交政策，始终根据事情本身的是非曲直决定自己的立场和政策，维护国际关系基本准则，维护国际公平正义，坚决反对一切形式的霸权主义和强权政治，反对冷战思维，反对干涉别国内政，反对搞双重标准。中国永远不称霸、永远不搞扩张。</p><p>中国坚持在和平共处五项原则基础上同各国发展友好合作，推动构建新型国际关系，深化拓展平等、开放、合作的全球伙伴关系，致力于扩大同各国利益的汇合点。秉持真实亲诚理念和正确义利观加强同发展中国家团结合作，维护发展中国家共同利益。</p><p>中国坚持对外开放的基本国策，坚定奉行互利共赢的开放战略，不断以中国新发展为世界提供新机遇，推动建设开放型世界经济，更好惠及各国人民。中国坚持经济全球化正确方向，共同营造有利于发展的国际环境，共同培育全球发展新动能。中国积极参与全球治理体系改革和建设，坚持真正的多边主义，推进国际关系民主化，推动全球治理朝着更加公正合理的方向发展。</p><p>中国提出了全球发展倡议、全球安全倡议，愿同国际社会一道努力落实。我们真诚呼吁，世界各国弘扬和平、发展、公平、正义、民主、自由的全人类共同价值，促进各国人民相知相亲，共同应对各种全球性挑战。中国人民愿同世界人民携手开创人类更加美好的未来！</p><p><code>十五、坚定不移全面从严治党，深入推进新时代党的建设新的伟大工程</code></p><p>全面建设社会主义现代化国家、全面推进中华民族伟大复兴，关键在党。我们党作为世界上最大的马克思主义执政党，要始终赢得人民拥护、巩固长期执政地位，必须时刻保持解决大党独有难题的清醒和坚定。全党必须牢记，全面从严治党永远在路上，党的自我革命永远在路上，决不能有松劲歇脚、疲劳厌战的情绪，必须持之以恒推进全面从严治党，深入推进新时代党的建设新的伟大工程，以党的自我革命引领社会革命。</p><p>我们要落实新时代党的建设总要求，健全全面从严治党体系，全面推进党的自我净化、自我完善、自我革新、自我提高，使我们党坚守初心使命，始终成为中国特色社会主义事业的坚强领导核心。</p><p>我们要坚持和加强党中央集中统一领导，健全总揽全局、协调各方的党的领导制度体系，完善党中央重大决策部署落实机制，确保全党在政治立场、政治方向、政治原则、政治道路上同党中央保持高度一致，确保党的团结统一。坚持不懈用新时代中国特色社会主义思想凝心铸魂，全面加强党的思想建设，加强理想信念教育，引导全党牢记党的宗旨，自觉做共产主义远大理想和中国特色社会主义共同理想的坚定信仰者和忠实实践者。完善党的自我革命制度规范体系，坚持制度治党、依规治党，健全党统一领导、全面覆盖、权威高效的监督体系，发挥政治巡视利剑作用，落实全面从严治党政治责任，用好问责利器。建设堪当民族复兴重任的高素质干部队伍，坚持德才兼备、以德为先、五湖四海、任人唯贤，树立选人用人正确导向，选拔忠诚干净担当的高素质专业化干部，选优配强各级领导班子，加强干部斗争精神和斗争本领养成，激励干部敢于担当、积极作为。增强党组织政治功能和组织功能，坚持大抓基层的鲜明导向，把基层党组织建设成为有效实现党的领导的坚强战斗堡垒，激励党员发挥先锋模范作用，保持党员队伍先进性和纯洁性。坚持以严的基调强化正风肃纪，锲而不舍落实中央八项规定精神，持续深化纠治”四风”，重点纠治形式主义、官僚主义，坚决破除特权思想和特权行为。坚决打赢反腐败斗争攻坚战持久战，腐败是危害党的生命力和战斗力的最大毒瘤，反腐败是最彻底的自我革命。只要存在腐败问题产生的土壤和条件，反腐败斗争就一刻不能停，必须永远吹冲锋号，坚持不敢腐、不能腐、不想腐一体推进，以零容忍态度反腐惩恶，决不姑息。</p><p>同志们！时代呼唤着我们，人民期待着我们，唯有矢志不渝、笃行不怠，方能不负时代、不负人民。全党必须牢记，坚持党的全面领导是坚持和发展中国特色社会主义的必由之路，中国特色社会主义是实现中华民族伟大复兴的必由之路，团结奋斗是中国人民创造历史伟业的必由之路，贯彻新发展理念是新时代我国发展壮大的必由之路，全面从严治党是党永葆生机活力、走好新的赶考之路的必由之路。这是我们在长期实践中得出的至关紧要的规律性认识，必须倍加珍惜、始终坚持，咬定青山不放松，引领和保障中国特色社会主义巍巍巨轮乘风破浪、行稳致远。</p><p>团结就是力量，团结才能胜利。全面建设社会主义现代化国家，必须充分发挥亿万人民的创造伟力。全党要坚持全心全意为人民服务的根本宗旨，树牢群众观点，贯彻群众路线，尊重人民首创精神，坚持一切为了人民、一切依靠人民，从群众中来、到群众中去，始终保持同人民群众的血肉联系，始终接受人民批评和监督，始终同人民同呼吸、共命运、心连心，不断巩固全国各族人民大团结，加强海内外中华儿女大团结，形成同心共圆中国梦的强大合力。</p><p>青年强，则国家强。当代中国青年生逢其时，施展才干的舞台无比广阔，实现梦想的前景无比光明。全党要把青年工作作为战略性工作来抓，用党的科学理论武装青年，用党的初心使命感召青年，做青年朋友的知心人、青年工作的热心人、青年群众的引路人。广大青年要坚定不移听党话、跟党走，怀抱梦想又脚踏实地，敢想敢为又善作善成，立志做有理想、敢担当、能吃苦、肯奋斗的新时代好青年，让青春在全面建设社会主义现代化国家的火热实践中绽放绚丽之花。</p><p>同志们！党用伟大奋斗创造了百年伟业，也一定能用新的伟大奋斗创造新的伟业。全党全军全国各族人民要紧密团结在党中央周围，牢记空谈误国、实干兴邦，坚定信心、同心同德，埋头苦干、奋勇前进，为全面建设社会主义现代化国家、全面推进中华民族伟大复兴而团结奋斗！</p><p>来源：新华网图文实录</p>]]></content>
      
      
      <categories>
          
          <category> 新闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时政 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot--自动配置原理</title>
      <link href="/2022/09/22/springboot-start-20220922/"/>
      <url>/2022/09/22/springboot-start-20220922/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>不论在工作中，亦或是求职面试，SpringBoot已经成为我们必知必会的技能项。除了某些老旧的政府项目或金融项目持有观望态度外，如今的各行各业都在飞速的拥抱这个已经不是很新的Spring启动框架。</p><p>当然，作为SpringBoot的精髓，自动配置原理的工作过程往往只有在”面试”的时候才能用得上，但是如果在工作中你能够深入的理解SpringBoot的自动配置原理，将无往不利。</p><p>SpringBoot的出现，得益于”习惯优于配置”的理念，没有繁琐的配置、难以集成的内容（大多数流行第三方技术都被集成），这是基于Spring4.x提供的按条件配置Bean的能力。</p><h2 id="Spring-Boot的配置文件"><a href="#Spring-Boot的配置文件" class="headerlink" title="Spring Boot的配置文件"></a>Spring Boot的配置文件</h2><p>初识Spring Boot时我们就知道，SpringBoot有一个全局配置文件：<code>application.properties</code>或<code>application.yml</code>。</p><p>我们的各种属性都可以在这个文件中进行配置，最常配置的比如：<code>server.port</code>、<code>logging.level.*</code> 等等，然而我们实际用到的往往只是很少的一部分，那么这些属性是否有据可依呢？答案当然是肯定的，这些属性都可以在官方文档中查找到：</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle//#common-application-properties">https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/\#common-application-properties</a></p></blockquote><p><img src="/2022/09/22/springboot-start-20220922/640(1).png" alt="图片"></p><p>（所以，话又说回来，找资料还得是官方文档，百度出来一大堆，还是稍显业余了一些）</p><p>除了官方文档为我们提供了大量的属性解释，我们也可以使用IDE的相关提示功能，比如IDEA的自动提示，和Eclipse的YEdit插件，都可以很好的对你需要配置的属性进行提示，下图是使用Eclipse的YEdit插件的效果，Eclipse的版本是：STS4。</p><p><img src="/2022/09/22/springboot-start-20220922/640(2).png" alt="图片"></p><p>以上，是Spring Boot的配置文件的大致使用方法，其实都是些题外话。</p><p>那么问题来了：<strong>这些配置是如何在SpringBoot项目中生效的呢？</strong> 那么接下来，就需要聚焦本篇博客的主题：自动配置工作原理或者叫实现方式。</p><h2 id="工作原理剖析"><a href="#工作原理剖析" class="headerlink" title="工作原理剖析"></a>工作原理剖析</h2><p>Spring Boot关于自动配置的源码在spring-boot-autoconfigure-x.x.x.x.jar中：</p><p><img src="/2022/09/22/springboot-start-20220922/640(3).png" alt="图片"></p><p>当然，自动配置原理的相关描述，官方文档貌似是没有提及。不过我们不难猜出，SpringBoot的启动类上有一个@SpringBootApplication注解，这个注解是SpringBoot项目必不可少的注解。那么自动配置原理一定和这个注解有着千丝万缕的联系！</p><h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><p><img src="/2022/09/22/springboot-start-20220922/640(4).png" alt="图片"></p><p>@SpringBootApplication是一个复合注解或派生注解，在@SpringBootApplication中有一个注解@EnableAutoConfiguration，翻译成人话就是开启自动配置，其定义如下：</p><p><img src="/2022/09/22/springboot-start-20220922/640(5).png" alt="图片"></p><p>而这个注解也是一个派生注解，其中的关键功能由@Import提供，其导入的AutoConfigurationImportSelector的selectImports()方法通过SpringFactoriesLoader.loadFactoryNames()扫描所有具有<strong>META-INF&#x2F;spring.factories</strong> 的jar包。<br>spring-boot-autoconfigure-x.x.x.x.jar里就有一个这样的spring.factories文件。<br>这个spring.factories文件也是一组一组的key&#x3D;value的形式，其中一个key是EnableAutoConfiguration类的全类名，而它的value是一个xxxxAutoConfiguration的类名的列表，这些类名以逗号分隔，如下图所示：</p><p><img src="/2022/09/22/springboot-start-20220922/640(6).png" alt="图片"></p><p>这个@EnableAutoConfiguration注解通过@SpringBootApplication被间接的标记在了SpringBoot的启动类上.在<code>&quot;SpringApplication.run(\...)&quot;</code>的内部就会执行selectImports()方法，找到所有JavaConfig自动配置类的全限定名对应的class，然后将所有自动配置类加载到Spring容器中。</p><h2 id="自动配置生效"><a href="#自动配置生效" class="headerlink" title="自动配置生效"></a>自动配置生效</h2><p>每一个XxxxAutoConfiguration自动配置类都是在某些条件之下才会生效的，这些条件的限制在Spring<br>Boot中以注解的形式体现，常见的条件注解有如下几项：</p><ul><li><p>@ConditionalOnBean：当容器里有指定的bean的条件下。</p></li><li><p>@ConditionalOnMissingBean：当容器里不存在指定bean的条件下。</p></li><li><p>@ConditionalOnClass：当类路径下有指定类的条件下。</p></li><li><p>@ConditionalOnMissingClass：当类路径下不存在指定类的条件下。</p></li><li><p>@ConditionalOnProperty：指定的属性是否有指定的值，比如@ConditionalOnProperties(prefix&#x3D;”xxx.xxx”,<br>value&#x3D;”enable”,<br>matchIfMissing&#x3D;true)，代表当xxx.xxx为enable时条件的布尔值为true，如果没有设置的情况下也为true。</p></li></ul><p>以ServletWebServerFactoryAutoConfiguration配置类为例，解释一下全局配置文件中的属性如何生效，比如：server.port&#x3D;8081，是如何生效的（当然不配置也会有默认值，这个默认值来自于org.apache.catalina.startup.Tomcat）。</p><p><img src="/2022/09/22/springboot-start-20220922/640(7).png" alt="图片"></p><p>在ServletWebServerFactoryAutoConfiguration类上，有一个@EnableConfigurationProperties注解：开启配置属性，而它后面的参数是一个ServerProperties类，这就是习惯优于配置的最终落地点。</p><p><img src="/2022/09/22/springboot-start-20220922/640(8).png" alt="图片"></p><p>在这个类上，我们看到了一个非常熟悉的注解：@ConfigurationProperties，它的作用就是从配置文件中绑定属性到对应的bean上，而@EnableConfigurationProperties负责导入这个已经绑定了属性的bean到spring容器中（见上面截图）。那么所有其他的和这个类相关的属性都可以在全局配置文件中定义，也就是说，真正”限制”我们可以在全局配置文件中配置哪些属性的类就是这些XxxxProperties类，它与配置文件中定义的prefix关键字开头的一组属性是唯一对应的。</p><p>至此，我们大致可以了解。在全局配置的属性如：server.port等，通过@ConfigurationProperties注解，绑定到对应的XxxxProperties配置实体类上封装为一个bean，然后再通过@EnableConfigurationProperties注解导入到Spring容器中。</p><p>而诸多的XxxxAutoConfiguration自动配置类，就是Spring容器的JavaConfig形式，作用就是为Spring<br>容器导入bean，而所有导入的bean所需要的属性都通过xxxxProperties的bean来获得。</p><p>可能到目前为止还是有所疑惑，但面试的时候，其实远远不需要回答的这么具体，你只需要这样回答：</p><blockquote><p>SpringBoot启动的时候会通过@EnableAutoConfiguration注解找到META-INF&#x2F;spring.factories配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性如：server.port，而XxxxProperties类是通过@ConfigurationProperties注解与全局配置文件中对应的属性进行绑定的。</p></blockquote><p>通过一张图标来理解一下这一繁复的流程：</p><p><img src="/2022/09/22/springboot-start-20220922/640(9).png" alt="图片"></p><p>图片来自于王福强老师的博客：<a href="https://afoo.me/posts/2015-07-09-how-spring-boot-works.html">https://afoo.me/posts/2015-07-09-how-spring-boot-works.html</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上是对自动配置原理的讲解。当然，在浏览源码的时候一定要记得不要太过拘泥与代码的实现，而是应该抓住重点脉络。</p><p>一定要记得XxxxProperties类的含义是：封装配置文件中相关属性；XxxxAutoConfiguration类的含义是：自动配置类，目的是给容器中添加组件。</p><p>而其他的主方法启动，则是为了加载这些五花八门的XxxxAutoConfiguration类。</p><p><em>来源：blog.csdn.net&#x2F;u014745069&#x2F;article&#x2F;details&#x2F;83820511</em></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学位英语--翻译001</title>
      <link href="/2022/09/21/learn-en-translate-20220921/"/>
      <url>/2022/09/21/learn-en-translate-20220921/</url>
      
        <content type="html"><![CDATA[<p>翻译题 </p><blockquote><p>34(2分) Four score and seven years ago our fathers brought forth on this continent a new nation</p></blockquote><p>A、87年前，我们的父亲们在这块大陆上创建了一个新的国家</p><p>B、87年前，我们的先辈在这块大陆上创建了一个新的国家</p><p>C、在历经4个20年和1个7年之后，我们的父亲们在这块大陆上创建了一个新的国家</p><p>参考答案： A：70%； B：100%； C：30%；</p><p>解析：</p><p>英语中的计量词，如score, dozen,decade等在汉语中没有相应的表达方式，应加以转换。B译文将”Four score and seven years”转换为”87年前”，符合汉语的表达习惯。A译文中对于”our fathers”翻译不够精确，此处应指”先辈，前辈”之意。C译文除了以上的错误，对于计量词的翻译也不够恰当。</p><blockquote><p>35(2分) It was William who defended him against a tyrant at the school where they were</p></blockquote><p>A、 他们学校里有一个恶霸欺负他，幸而有威廉的保护着才没有吃亏</p><p>B、 正是有了威廉的保护才使他免受他们学校里的一个小恶霸的欺负</p><p>C、 基于威廉的保护，他才避免受学校本来存在的恶棍的欺负</p><p>参考答案： A：70%； B：100%； C：30%；</p><p>解析：</p><p>It is …who…引导的是个强调句型。tyrant意思是”专制统治者，暴君；（古希腊的）僭主；专横的人”，这里指”专横的人，恶霸”。比较来看，选项B译意准确，表达自然。选项A只是将原句的基本意思译出了，没有译出强调句型的特点。选项C的译意出入较大。综合考虑：答案从优到劣的排序为B-A-C。</p><blockquote><p>36(2分) Pressure in liquids become rapidly greater with increasing depth as any one knows who has swum even a few feet below the surface of a lake</p></blockquote><p>A、 谁都知道，入液越深，液压就迅速增强，凡是在湖面以下几英尺游过泳的人都知道这一点</p><p>B、 入液越深，液压就迅速增强；凡是在湖面以下几英尺游过泳的人都知道这一点</p><p>C、 越往下潜，液体的压力就迅速增强，湖面以下游上一游的人都知道这一点</p><p>参考答案： A：70%； B：100%； C：30%；</p><p>解析：</p><p>句中的as是代词，意思是”这一点”。如As is well known, 众所周知。who 引导的是定语从句，修饰any one。比较来看，选项B为首选，翻译准确到位。选项A多了个”谁都知道”。选项C后半句的译意与原句不符。综合考虑：答案从优到劣的排序为B-A-C。</p><blockquote><p>37(2分) We cannot ignore our neighbors; only at our peril can we ignore their distress</p></blockquote><p> A、 我们不能不顾忌我们的邻国；只有在我们处于自身难保的时候才顾不了它们的安危</p><p> B、 我们不能不顾及我们的邻邦；我们如果不顾忌它们的安危，就只能陷入自身难保的境地</p><p> C、 我们不能忽视我们的邻居；只有我们自己在自身难保的时候才能忽视他们的安危</p><p>参考答案： A：70%； B：100%； C：30%；</p><p>解析：</p><p>原文后半句意思为”If we ignore their distress, then we will be only at our peril.”B译文意思准确。A译文后半句处理不当，颠倒了逻辑关系。 C译文不仅颠倒了逻辑关系，将”neighbors”译为”邻居”也是不准确的。</p><blockquote><p>38(2分) If they get the feeling you really care，they&#39;ll respond to that.They&#39;ll actually become reluctant not to buy from you</p></blockquote><p>A、 如果顾客觉得你很关心他们，他们便会作出反应，就不会不愿意从你手上买鞋</p><p>B、 假如顾客感觉到你确实关心他们，他们就不会无动于衷，就不会不买你的鞋而一走了之</p><p>C、 如果顾客有你真的关心他们的感觉，他们对此将会反应出来。实际上，他们将从你那里买鞋的</p><p>参考答案： A：70%； B：100%； C：30%；</p><blockquote><p>39(2分) My maternal grandfather was cut off in the flower of his youth</p></blockquote><p>A、 我的外祖父割掉了他的年轻的花朵</p><p>B、 我的外祖父年轻的时候就如花一样凋谢了</p><p>C、 我外祖父在风华正茂的年龄就去世了</p><p>参考答案： A：30%； B：70%； C：100%；</p><blockquote><p>40(2分) The university students in Britain are usually under pressure because their academic performance will affect their future careers</p></blockquote><p>A、 英国大学生通常压力较大，因为他们的学业成绩将会影响到未来的职业</p><p>B、 大学里的英国学生通常压力较大，因为他们在学术上的表现对未来将要从事的职业会有影响</p><p>C、 英国大学生通常课业负担较重，因为他们的学业成绩对未来的职业生涯会有影响</p><p>参考答案： A：100%； B：30%； C：70%；</p><p>解析：</p><p>A译文忠于原文，用词简洁。 C译文前半句将”under pressure”增译为”课业负担较重”，不够忠实原文，且译文不够简练。B译文用词拖沓，稍显啰嗦，且前半句不够通顺。</p><blockquote><p>41(2分) The inside of each tent depended on the personality of its occupant</p></blockquote><p>A、 每个帐篷的内部取决于各个使用者的性格</p><p>B、 每个帐篷内部怎么布置，这就要看各个使用者的性格了</p><p>C、 每个帐篷的里面依赖于每个使用者的个性</p><p>参考答案： A：70%； B：100%； C：30%；</p><p>解析：</p><p>为了让句子通顺，有时会采用单词分译的方法，将一个单词译成一个句子。原文中名词”inside”若仅译为”内部”，则会产生歧义。译成”内部怎么布置”，句意一目了然，因此B译文最佳。A译文次之。其次，C译文将”depend on”译为依”依赖”，不符合语境。</p><blockquote><p>42(2分) If the United States betrays the millions of people who have relied on us in Vietnam，the President of the United States，whoever he is，will not deserve nor receive the respect…</p></blockquote><p>A、 如果美国背叛了信赖我们的千百万越南人民，那么，不论谁担任美国总统，都无权享受尊敬，也得不到尊敬…</p><p>B、 如果美国背叛数百万在越南信任我们的人们，那么，不管谁是美国总统，都不值得也得不到尊敬…</p><p>C、 如果美国背叛了千百万在越南问题上信赖我们的人，那么，不论谁当美国总统，他都不值得尊敬，也得不到尊敬 …</p><p>参考答案： A：70%； B：30%； C：100%；</p><p>解析：</p><p>rely on意思是：”信赖; 依赖; 依靠; 信任”； who引导的是定语从句; whoever 引导的是让步状语从句。选择的焦点主要集中在if从句所表达的意思。比较来看，选项C为首选。综合考虑：答案从优到劣的排序为C-A-B。</p><blockquote><p>43(2分) The oxygen atom is nearly 16 times as heavy as hydrogen atom</p></blockquote><p>A、 氧原子的重量几乎是氢原子的16倍</p><p>B、 氧原子重量的16倍和氢原子的重量差不多</p><p>C、 一个氧原子的重量和16个氢原子的重量一样</p><p>参考答案： A：100%； B：30%； C：70%；</p><p>解析：</p><p>“倍数+as…as”译为”是…的几倍”或者”几倍于…”。 A 译文倍数翻译准确，译文简练。C译文倍数解释正确，但语句啰嗦，且”nearly”（几乎）不等于”一样”。B译文倍数关系错误。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty系列--进击的NIO！Reactor模式！</title>
      <link href="/2022/09/19/netty-nio-002/"/>
      <url>/2022/09/19/netty-nio-002/</url>
      
        <content type="html"><![CDATA[<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="/2022/09/19/netty-nio-002/640" alt="640"></p><h1 id="一、Reactor模式介绍"><a href="#一、Reactor模式介绍" class="headerlink" title="一、Reactor模式介绍"></a>一、Reactor模式介绍</h1><p>本文主要参考Doug Lea(大神)的《<strong>Scalable IO in Java</strong>》中讲述的Reactor模式。</p><p>原文地址：<a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p><p>有兴趣的可以看看这本书，受益匪浅！</p><h2 id="1-1-什么是Reactor模式"><a href="#1-1-什么是Reactor模式" class="headerlink" title="1.1 什么是Reactor模式"></a>1.1 什么是Reactor模式</h2><p>Reactor模式一般翻译成&quot;<strong>反应器模式</strong>&quot;，也有人称为&quot;<strong>分发者模式</strong>&quot;。它是将客户端请求提交到一个或者多个服务处理程序的设计模式。工作原理是由<strong>一个线程来接收所有的请求</strong>，然后<strong>派发这些请求到相关的工作线程中</strong>。</p><h2 id="1-2-为什么使用Reactor模式"><a href="#1-2-为什么使用Reactor模式" class="headerlink" title="1.2 为什么使用Reactor模式"></a>1.2 为什么使用Reactor模式</h2><p>在java中，没有NIO出现之前都是使用socket编程。socket的接收请求是阻塞的，需要处理完一个请求才能处理下一个请求，所以在面对高并发的服务请求时，性能就会很差。</p><p>那有人就会说使用多线程（如下图所示）。接收到一个请求，就创建一个线程处理，这样就不会阻塞了。实际上这样的确是可以在提升性能上起到一定的作用，<strong>但是当请求很多的时候，就会创建大量的线程，维护线程需要资源的消耗，线程之间的切换也需要消耗性能</strong>。而且系统创建线程的数量也是有限的，所以当高并发时，会直接把系统拖垮。</p><p><img src="/2022/09/19/netty-nio-002/640(1)" alt="640(1)"></p><p>由于以上的问题，提出了Reactor模式。</p><p>基于Java，Doug Lea（Java并发包作者）提出了三种形式，<strong>单Reactor单线程，单Reactor多线程和多Reactor多线程</strong>。</p><h1 id="二、Reactor模式的演进过程"><a href="#二、Reactor模式的演进过程" class="headerlink" title="二、Reactor模式的演进过程"></a>二、Reactor模式的演进过程</h1><p>在介绍三种Reactor模式前，先简单地说明三个角色：</p><blockquote><p><code>Reactor</code>：负责响应事件，将事件分发到绑定了对应事件的Handler，如果是连接事件，则分发到Acceptor。<code>Handler</code>：事件处理器。负责执行对应事件对应的业务逻辑。<code>Acceptor</code>：绑定了connect 事件，当客户端发起connect请求时，Reactor会将accept事件分发给Acceptor处理。</p></blockquote><h2 id="2-1-单Reactor单线程"><a href="#2-1-单Reactor单线程" class="headerlink" title="2.1 单Reactor单线程"></a>2.1 单Reactor单线程</h2><p><img src="/2022/09/19/netty-nio-002/640(2)" alt="640(2)"></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p>只有一个<code>select</code>循环接收请求，客户端（client）注册进来由<code>Reactor</code>接收注册事件，然后再由reactor分发（dispatch）出去，由下面的处理器（Handler）去处理。</p></blockquote><h3 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>一个餐厅里只有一个既是前台也是服务员的人，负责接待客人，也负责把客人点的菜下达给厨师。</p><h3 id="单Reactor单线程的特点"><a href="#单Reactor单线程的特点" class="headerlink" title="单Reactor单线程的特点"></a>单Reactor单线程的特点</h3><p>单线程的问题实际上是很明显的。只要其中一个Handler方法阻塞了，那就会导致所有的client的Handler都被阻塞了，也会导致注册事件也无法处理，无法接收新的请求。所以这种模式用的比较少，因为不能充分利用到多核的资源。</p><p>这种模式仅仅只能处理Handler比较快速完成的场景。</p><h2 id="2-2-单Reactor多线程"><a href="#2-2-单Reactor多线程" class="headerlink" title="2.2 单Reactor多线程"></a>2.2 单Reactor多线程</h2><p><img src="/2022/09/19/netty-nio-002/640(3)" alt="640(3)"></p><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p>在<strong>多线程Reactor</strong>中，注册接收事件都是由<code>Reactor</code>来做，其它的计算，编解码由一个线程池来做。从图中可以看出工作线程是多线程的，监听注册事件的<code>Reactor</code>还是单线程。</p></blockquote><h3 id="通俗解释-1"><a href="#通俗解释-1" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>相当于餐厅里有一个前台，多个服务员。前台只负责接待客人，服务员只负责服务客人。</p><h3 id="单Reactor多线程的特点"><a href="#单Reactor多线程的特点" class="headerlink" title="单Reactor多线程的特点"></a>单Reactor多线程的特点</h3><p>对比<strong>单线程Reactor</strong>模型，多线程Reactor模式在Handler读写处理时，交给工作线程池处理，不会导致Reactor无法执行，因为Reactor分发和Handler处理是分开的，能充分地利用资源。从而提升应用的性能。</p><p>缺点：Reactor只在主线程中运行，承担所有事件的监听和响应，如果短时间的高并发场景下，依然会造成性能瓶颈。</p><h2 id="2-3-多Reactor多线程"><a href="#2-3-多Reactor多线程" class="headerlink" title="2.3 多Reactor多线程"></a>2.3 多Reactor多线程</h2><p><img src="/2022/09/19/netty-nio-002/640(4)" alt="640(4)"></p><h3 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h3><blockquote><p>1、mainReactor负责监听客户端请求，专门处理新连接的建立，将建立好的连接注册到subReactor。</p></blockquote><blockquote><p>2、subReactor将分配的连接加入到队列进行监听，当有新的事件发生时，会调用连接相对应的Handler进行处理。</p></blockquote><h3 id="通俗解释-2"><a href="#通俗解释-2" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>相当于餐厅里有多个前台和多个服务员，前台只负责接待客人，服务员只负责服务客人。</p><h3 id="多Reactor多线程的特点"><a href="#多Reactor多线程的特点" class="headerlink" title="多Reactor多线程的特点"></a>多Reactor多线程的特点</h3><p>mainReactor主要是用来处理客户端请求连接建立的操作。subReactor主要做和建立起来的连接做数据交互和事件业务处理操作，每个subReactor一个线程来处理。</p><blockquote><p>这样的模型使得每个模块更加专一，耦合度更低，能支持更高的并发量。许多框架也使用这种模式，比如接下来要讲的Netty框架就采用了这种模式。</p></blockquote><h1 id="三、在Netty中的应用"><a href="#三、在Netty中的应用" class="headerlink" title="三、在Netty中的应用"></a>三、在Netty中的应用</h1><p>Netty可谓是框架中精品中的极品，要用一张图或者一段话来总结概括不太可能，所以下面我仅分析一下Netty框架的架构模型。在下一篇文章再继续深入探究Netty。</p><p><img src="/2022/09/19/netty-nio-002/640(5)" alt="640(5)"></p><p>这个架构实际上跟多Reactor多线程模型比较像。</p><blockquote><p>1、BossGroup相当于mainReactor，负责建立连接并且把连接注册到WorkGroup中。WorkGroup负责处理连接对应的读写事件。</p><p>2、BossGroup和WorkGroup是两个线程池，里面有多个NioEventGroup(实际上是线程)，默认BossGroup和WorkGroup里的线程数是cpu核数的两倍（源码中有体现）。</p><p>3、每一个NioEventGroup都是一个无限循环，负责监听相对应的事件。4、Pipeline(通道)里包含多个ChannelHandler(业务处理)，按顺序执行。</p></blockquote><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>其实上面的这些模型都只是一种思想，很多人可能觉得学习思想不是很重要。实际上要学习一门技术，要先有天上飞的理论才有落地的产品。世界上的事物大多都是如此。</p><p>最后借用大神<strong>Doug Lea</strong>的名言：</p><blockquote><p>分享知识和分享苹果是不一样的，苹果会越分越少，而自己的知识并不会因为给了别人就减少了，知识的分享更能激荡出不一样的火花。</p></blockquote><hr><p><strong>免责声明：</strong></p><p>本公博客部分分享的资料来自网络收集和整理，所有文字和图片版权归属于原作者所有，且仅代表作者个人观点，与<strong>本博客</strong>无关，文章仅供读者学习交流使用，并请自行核实相关内容，如文章内容涉及侵权，请联系后台管理员删除。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学位英语--完型填空001</title>
      <link href="/2022/09/16/learn-en-cf-20220916/"/>
      <url>/2022/09/16/learn-en-cf-20220916/</url>
      
        <content type="html"><![CDATA[<p>  When I first went to Hong Kong a number of years ago，I had no idea about the Chinese language  <u> <code>1</code></u> the Chinese culture.Shortly after my arrival，I went to the bank on my way to school.I was  <u> <code>2</code></u>  surprised when the bank clerk asked me  <u> <code>3</code></u>  I had had my lunch .In British culture，this question would be regarded as an indirect invitation to lunch，and between unmarried young people it indicates a young man’s interest in dating a girl.  <u> <code>4</code></u>  he was a complete stranger，I was quite taken aback.1 proceeded to school and was even more surprised when one of the teachers asked me the  <u> <code>5</code></u>  question .By now I realized that it could not be an  <u> <code>6</code></u>  ，but I was puzzled as to why they kept asking it .In the following days， as I was asked the question again and again，I came to the conclusion  <u> <code>7</code></u>  people must be concerned about my health.I was somewhat underweight，and I assumed they must be worried that I was not eating properly.Only later， did I find out that the question had   <u> <code>8</code></u>  real significance at all，it was merely a greeting.</p><p>   English people have a very strong sense of privacy.They are easily offended by comments which seem to invade their personal lives，so the Chinese greeting“Where are you going?”is uncomfortable to them.They regard it as a request for information and  <u> <code>9</code></u>   an invasion of their privacy .In fact，many foreign teachers in China have complained that their room attendants are spies  <u> <code>10</code></u>  the attendants have greeted them with“Where are you going? ”</p><p>1)、(单选题)</p><p>A、and     </p><p>B、than</p><p>C、otherwise</p><p>D、or</p><p>2)、(单选题)</p><p>A、slowly</p><p>B、extremely</p><p>C、quietly</p><p>D、suddenly</p><p>3)、(单选题)</p><p>A、what </p><p>B、where</p><p>C、when</p><p>D、if</p><p>4)、(单选题)</p><p>A、Since        </p><p>B、Although </p><p>C、Even</p><p>D、Though </p><p>5)、(单选题)</p><p>A、easy         </p><p>B、different</p><p>C、same</p><p>D、complex</p><p>6)、(单选题)</p><p>A、question     </p><p>B、invitation  </p><p>C、concern </p><p>D、invasion </p><p>7)、(单选题)</p><p>A、that  </p><p>B、which</p><p>C、when</p><p>D、whether</p><p>8)、(单选题)</p><p>A、little   </p><p>B、some</p><p>C、any</p><p>D、no</p><p>9)、(单选题)</p><p>A、in        </p><p>B、to</p><p>C、as</p><p>D、for</p><p>10)、(单选题)</p><p>A、because       </p><p>B、when</p><p>C、though</p><p>D、some people</p><p><code>参考答案：</code></p><blockquote><ol><li>D； 2) B； 3) D； 4) A； 5) C； 6) B； 7) A； 8) D； 9) C； 10) A；</li></ol></blockquote><p><code>解析：</code></p><ul><li><p>1.D  这里表达的是并列关系，否定句，故选or。</p></li><li><p>2.B  此处是表示非常惊讶。</p></li><li><p>3.D  这里根据文意，应选择表示“是否”之意的if作宾语从句的引导词。</p></li><li><p>4.A  根据上文语境，这里对上述现象进行解释说明。</p></li><li><p>5.C  此处作者想表达的是当被问及同样问题时，更加惊讶，故选same。</p></li><li><p>6.B  根据上文语境判断，选invitation，邀请，招待。</p></li><li><p>7.A  “that ” 引导同位语从句。</p></li><li><p>8.D  “not&#x2F; no…at all”为固定短语，意为“一点也没有”。</p></li><li><p>9.C  “regard … as”，固定搭配“把……看作”。</p></li><li><p>10.A  这里说明原因,故选A.because。</p></li></ul><p><code>原文</code></p><p>When I first went to Hong Kong a number of years ago，I had no idea about the Chinese language or the Chinese culture.Shortly after my arrival，I went to the bank on my way to school.I was extremely surprised when the bank clerk asked me if I had had my lunch.In British culture，this question would be regarded as an indirect invitation to lunch，and between unmarried young people it indicates a young man’s interest in dating a girl. Since he was a complete stranger，I was quite taken aback.1 proceeded to school and was even more surprised when one of the teachers asked me the same question.By now I realized that it could not be an invitation ，but I was puzzled as to why they kept asking it.In the following days， as I was asked the question again and again，I came to the conclusion that people must be concerned about my health.I was somewhat underweight，and I assumed they must be worried that I was not eating properly.Only later， did I find out that the question had no real significance at all，it was merely a greeting.</p><p>English people have a very strong sense of privacy.They are easily offended by comments which seem to invade their personal lives，so the Chinese greeting“Where are you going?”is uncomfortable to them.They regard it as a request for information and as an invasion of their privacy.In fact，many foreign teachers in China have complained that their room attendants are spies because the attendants have greeted them with“Where are you going? ”</p><p><code>翻译;</code></p><p>几年前我第一次去香港的时候，我对中国语言和中国文化一无所知。到达后不久，我在上学的路上去了银行。当银行职员问我是否吃过午饭时，我非常惊讶。在英国文化中，这个问题会被视为是对午餐的间接邀请，在未婚年轻人之间，它表明年轻人对约会女孩的兴趣。由于他是一个完全陌生的人，我大吃一惊。我继续上学，当一位老师问我同样的问题时，我更加惊讶。现在我意识到这不可能是一个邀请，但我不明白为什么他们一直问我。在接下来的几天里，当我一次又一次被问到这个问题时，我得出结论，人们必须关心我的健康。我有点体重不足，我想他们一定担心我吃得不好。直到后来，我才发现这个问题根本没有真正的意义，只是一个问候而已。<br>英国人有很强的隐私意识。他们很容易被那些似乎侵犯了他们个人生活的评论所冒犯，所以中国人的问候语“你要去哪里？”对他们来说是不舒服的。他们认为这是对信息的请求，是对他们隐私的侵犯。事实上，许多在中国的外籍教师抱怨说，他们的客房服务员是间谍，因为服务员用“你要去哪里？”</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty系列--NIO从入门到踹门</title>
      <link href="/2022/09/15/netty-nio-001/"/>
      <url>/2022/09/15/netty-nio-001/</url>
      
        <content type="html"><![CDATA[<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="/2022/09/15/netty-nio-001/640" alt="640"></p><blockquote><p>学如逆水行舟，不进则退</p></blockquote><h1 id="NIO概述"><a href="#NIO概述" class="headerlink" title="NIO概述"></a>NIO概述</h1><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong>java.nio</strong>全称<strong>java non-blocking IO</strong>，是指<strong>JDK1.4及以上</strong>版本里提供的新api（New IO），为所有的原始类型（boolean类型除外）提供<strong>缓存支持的数据容器</strong>，使用它可以提供<strong>非阻塞式</strong>的高伸缩性网络(来源于百度百科)。</p><h3 id="1-2-为什么使用NIO"><a href="#1-2-为什么使用NIO" class="headerlink" title="1.2 为什么使用NIO"></a>1.2 为什么使用NIO</h3><p>在上面的描述中提到，是在JDK1.4以上的版本才提供NIO，那在之前使用的是什么呢？答案很简单，就是<strong>BIO</strong>(阻塞式IO)，也就是我们常用的IO流。</p><p>BIO的问题其实不用多说了，因为在使用BIO时，主线程会进入阻塞状态，这就非常影响程序的性能，<strong>不能充分利用机器资源</strong>。但是这样就会有人提出疑问了，那我<strong>使用多线程</strong>不就可以了吗？</p><p>但是在高并发的情况下，会创建很多线程，线程会占用内存，线程之间的切换也会浪费资源开销。</p><p>而NIO<strong>只有在连接&#x2F;通道真正有读写事件</strong>发生时(<strong>事件驱动</strong>)，<strong>才会进行读写</strong>，就大大地减少了系统的开销。不必为每一个连接都创建一个线程，也不必去维护多个线程。</p><p><strong>避免了多个线程之间的上下文切换</strong>，导致资源的浪费。</p><h3 id="2-NIO的三大核心"><a href="#2-NIO的三大核心" class="headerlink" title="2 NIO的三大核心"></a>2 NIO的三大核心</h3><table><thead><tr><th>NIO的核心</th><th>对应的类或接口</th><th>应用</th><th>作用</th></tr></thead><tbody><tr><td>缓冲区</td><td>Buffer</td><td>文件IO&#x2F;网络IO</td><td>存储数据</td></tr><tr><td>通道</td><td>Channel</td><td>文件IO&#x2F;网络IO</td><td>运输</td></tr><tr><td>选择器</td><td>Selector</td><td>网络IO</td><td>控制器</td></tr></tbody></table><h3 id="2-1-1-什么是缓冲区"><a href="#2-1-1-什么是缓冲区" class="headerlink" title="2.1.1 什么是缓冲区"></a>2.1.1 什么是缓冲区</h3><p>我们先看以下这张类图，可以看到<code>Buffer</code>有七种类型。</p><p><img src="/2022/09/15/netty-nio-001/640(1)" alt="640(1)"></p><p><code>Buffer</code>是一个内存块。在<code>NIO</code>中，所有的数据都是用<code>Buffer</code>处理，有读写两种模式。所以NIO和传统的IO的区别就体现在这里。传统IO是面向<code>Stream</code>流，<code>NIO</code>而是面向缓冲区(<code>Buffer</code>)。</p><h3 id="2-1-2-常用的类型ByteBuffer"><a href="#2-1-2-常用的类型ByteBuffer" class="headerlink" title="2.1.2 常用的类型ByteBuffer"></a>2.1.2 常用的类型ByteBuffer</h3><p>一般我们常用的类型是<code>ByteBuffer</code>，把数据转成字节进行处理。实质上是一个<code>byte[]</code>数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ByteBuffer</span> <span class="keyword">extends</span> <span class="title class_">Buffer</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;ByteBuffer&gt;&#123;</span><br><span class="line">    <span class="comment">//存储数据的数组</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">byte</span>[] hb;</span><br><span class="line">    <span class="comment">//构造器方法</span></span><br><span class="line">    ByteBuffer(<span class="type">int</span> mark, <span class="type">int</span> pos, <span class="type">int</span> lim, <span class="type">int</span> cap, <span class="type">byte</span>[] hb, <span class="type">int</span> offset) &#123;</span><br><span class="line">        <span class="built_in">super</span>(mark, pos, lim, cap);</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="built_in">this</span>.hb = hb;</span><br><span class="line">        <span class="built_in">this</span>.offset = offset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-3-创建Buffer的方式"><a href="#2-1-3-创建Buffer的方式" class="headerlink" title="2.1.3 创建Buffer的方式"></a>2.1.3 创建Buffer的方式</h3><p>主要分成两种：JVM堆内内存块Buffer、堆外内存块Buffer。</p><p>创建堆内内存块(非直接缓冲区)的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建堆内内存块HeapByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;java技术爱好者&quot;</span>;</span><br><span class="line"><span class="comment">//包装一个byte[]数组获得一个Buffer，实际类型是HeapByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer2</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br></pre></td></tr></table></figure><p>创建堆外内存块(直接缓冲区)的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建堆外内存块DirectByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer3</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><h3 id="2-1-3-1"><a href="#2-1-3-1" class="headerlink" title="2.1.3.1"></a>2.1.3.1</h3><h3 id="HeapByteBuffer与DirectByteBuffer"><a href="#HeapByteBuffer与DirectByteBuffer" class="headerlink" title="HeapByteBuffer与DirectByteBuffer"></a>HeapByteBuffer与DirectByteBuffer</h3><p>其实根据类名就可以看出，<code>HeapByteBuffer</code>所创建的字节缓冲区就是在JVM堆中的，即JVM内部所维护的字节数组。而<code>DirectByteBuffer</code>是<strong>直接操作操作系统本地代码</strong>创建的<strong>内存缓冲数组</strong>。</p><p><code>DirectByteBuffer</code>的使用场景：</p><ol><li><p>java程序与本地磁盘、socket传输数据</p></li><li><p>大文件对象，可以使用。不会受到堆内存大小的限制。</p></li><li><p>不需要频繁创建，生命周期较长的情况，能重复使用的情况。</p></li></ol><p><code>HeapByteBuffer</code>的使用场景：</p><p>除了以上的场景外，其他情况还是建议使用<code>HeapByteBuffer</code>，没有达到一定的量级，实际上使用<code>DirectByteBuffer</code>是体现不出优势的。</p><h3 id="2-1-3-2-Buffer的初体验"><a href="#2-1-3-2-Buffer的初体验" class="headerlink" title="2.1.3.2 Buffer的初体验"></a>2.1.3.2 Buffer的初体验</h3><p>接下来，使用<code>ByteBuffer</code>做一个小例子，熟悉一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;java技术爱好者，起飞！&quot;</span>;</span><br><span class="line">            <span class="comment">//创建一个固定大小的buffer(返回的是HeapByteBuffer)</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">byte</span>[] bytes = msg.getBytes();</span><br><span class="line">            <span class="comment">//写入数据到Buffer中</span></span><br><span class="line">            byteBuffer.put(bytes);</span><br><span class="line">            <span class="comment">//切换成读模式，关键一步</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="comment">//创建一个临时数组，用于存储获取到的数据</span></span><br><span class="line">            <span class="type">byte</span>[] tempByte = <span class="keyword">new</span> <span class="title class_">byte</span>[bytes.length];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//如果还有数据，就循环。循环判断条件</span></span><br><span class="line">            <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">//获取byteBuffer中的数据</span></span><br><span class="line">                <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> byteBuffer.get();</span><br><span class="line">                <span class="comment">//放到临时数组中</span></span><br><span class="line">                tempByte[i] = b;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印结果</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(tempByte));<span class="comment">//java技术爱好者，起飞！</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这上面有一个<code>flip()</code>方法是很重要的。意思是切换到读模式。上面已经提到<strong>缓存区是双向的</strong>，<strong>既可以往缓冲区写入数据，也可以从缓冲区读取数据</strong>。但是不能同时进行，需要切换。那么这个切换模式的本质是什么呢？</p><h3 id="2-1-4-三个重要参数"><a href="#2-1-4-三个重要参数" class="headerlink" title="2.1.4 三个重要参数"></a>2.1.4 三个重要参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//位置，默认是从第一个开始</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//限制，不能读取或者写入的位置索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line"><span class="comment">//容量，缓冲区所包含的元素的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> capacity;</span><br></pre></td></tr></table></figure><p>那么我们以上面的例子，一句一句代码进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;java技术爱好者，起飞！&quot;</span>;</span><br><span class="line"><span class="comment">//创建一个固定大小的buffer(返回的是HeapByteBuffer)</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>当创建一个缓冲区时，参数的值是这样的：</p><p><img src="/2022/09/15/netty-nio-001/640(2)" alt="640(2)"></p><p><img src="/2022/09/15/netty-nio-001/640(3)" alt="640(3)"></p><p>当执行到<code>byteBuffer.put(bytes)</code>，当<code>put()</code>进入多少数据，position就会增加多少，参数就会发生变化：</p><p><img src="/2022/09/15/netty-nio-001/640(4)" alt="640(4)"></p><p><img src="/2022/09/15/netty-nio-001/640(5)" alt="640(5)"></p><p>接下来关键一步<code>byteBuffer.flip()</code>，会发生如下变化：</p><p><img src="/2022/09/15/netty-nio-001/640(6)" alt="640(6)"></p><p><img src="/2022/09/15/netty-nio-001/640(7)" alt="640(7)"></p><p><code>flip()</code>方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">            limit = position;</span><br><span class="line">            position = <span class="number">0</span>;</span><br><span class="line">            mark = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>为什么要这样赋值呢？因为下面有一句循环条件判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byteBuffer.hasRemaining();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasRemaining</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//判断position的索引是否小于limit。</span></span><br><span class="line">    <span class="comment">//所以可以看出limit的作用就是记录写入数据的位置，那么当读取数据时，就知道读到哪个位置</span></span><br><span class="line">    <span class="keyword">return</span> position &lt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是在<code>while</code>循环中<code>get()</code>读取数据，读取完之后。</p><p><img src="/2022/09/15/netty-nio-001/640(8)" alt="640(8)"></p><p><img src="/2022/09/15/netty-nio-001/640(9)" alt="640(9)"></p><p>最后当<code>position</code>等于<code>limit</code>时，循环判断条件不成立，就跳出循环，读取完毕。</p><p>所以可以看出实质上<code>capacity</code>容量大小是不变的，实际上是通过控制<code>position</code>和<code>limit</code>的值来控制读写的数据。</p><h3 id="2-2-管道-Channel"><a href="#2-2-管道-Channel" class="headerlink" title="2.2 管道(Channel)"></a>2.2 管道(Channel)</h3><p>首先我们看一下Channel有哪些子类：</p><p><img src="/2022/09/15/netty-nio-001/640(10)" alt="640(10)"></p><p>常用的Channel有这四种：</p><blockquote><p>FileChannel，读写文件中的数据。<br>SocketChannel，通过TCP读写网络中的数据。<br>ServerSockectChannel，监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。<br>DatagramChannel，通过UDP读写网络中的数据。</p></blockquote><p><strong>Channel本身并不存储数据，只是负责数据的运输</strong>。必须要和<code>Buffer</code>一起使用。</p><h3 id="2-2-1-1-FileChannel"><a href="#2-2-1-1-FileChannel" class="headerlink" title="2.2.1.1 FileChannel"></a>2.2.1.1 FileChannel</h3><p>FileChannel的获取方式，下面举个文件复制拷贝的例子进行说明：</p><p><img src="/2022/09/15/netty-nio-001/640(11)" alt="640(11)"></p><p>首先准备一个&quot;1.txt&quot;放在项目的根目录下，然后编写一个main方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//获取文件输入流</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="comment">//从文件输入流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">inputStreamChannel</span> <span class="operator">=</span> inputStream.getChannel();</span><br><span class="line">            <span class="comment">//获取文件输出流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;2.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//从文件输出流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">outputStreamChannel</span> <span class="operator">=</span> outputStream.getChannel();</span><br><span class="line">            <span class="comment">//创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>)file.length());</span><br><span class="line">            <span class="comment">//把输入流通道的数据读取到缓冲区</span></span><br><span class="line">            inputStreamChannel.read(byteBuffer);</span><br><span class="line">            <span class="comment">//切换成读模式</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="comment">//把数据从缓冲区写入到输出流通道</span></span><br><span class="line">            outputStreamChannel.write(byteBuffer);</span><br><span class="line">            <span class="comment">//关闭通道</span></span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            outputStreamChannel.close();</span><br><span class="line">            inputStreamChannel.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>执行后，我们就获得一个&quot;2.txt&quot;。执行成功。</p><p><img src="/2022/09/15/netty-nio-001/640(12)" alt="640(12)"></p><p>以上的例子，可以用一张示意图表示，是这样的：</p><p><img src="/2022/09/15/netty-nio-001/640(13)" alt="640(13)"></p><h3 id="2-2-1-2-SocketChannel"><a href="#2-2-1-2-SocketChannel" class="headerlink" title="2.2.1.2 SocketChannel"></a>2.2.1.2 SocketChannel</h3><p>接下来我们学习获取<code>SocketChannel</code>的方式。</p><p>还是一样，我们通过一个例子来快速上手：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//获取ServerSocketChannel</span></span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">            <span class="comment">//绑定地址，端口号</span></span><br><span class="line">            serverSocketChannel.bind(address);</span><br><span class="line">            <span class="comment">//创建一个缓冲区</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//获取SocketChannel</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                <span class="keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//打印结果</span></span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array()));</span><br><span class="line">                    <span class="comment">//清空缓冲区</span></span><br><span class="line">                    byteBuffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后运行main()方法，我们可以通过<code>telnet</code>命令进行连接测试：</p><p><img src="/2022/09/15/netty-nio-001/640(14)" alt="640(14)"></p><p>通过上面的例子可以知道，通过<code>ServerSocketChannel.open()</code>方法可以获取服务器的通道，然后绑定一个地址端口号，接着<code>accept()</code>方法可获得一个<code>SocketChannel</code>通道，也就是客户端的连接通道。</p><p>最后配合使用<code>Buffer</code>进行读写即可。</p><p>这就是一个简单的例子，实际上上面的例子是阻塞式的。要做到非阻塞还需要使用选择器<code>Selector</code>。</p><h3 id="2-3-选择器-Selector"><a href="#2-3-选择器-Selector" class="headerlink" title="2.3 选择器(Selector)"></a>2.3 选择器(Selector)</h3><p><code>Selector</code>翻译成<strong>选择器</strong>，有些人也会翻译成<strong>多路复用器</strong>，实际上指的是同一样东西。</p><p>只有网络IO才会使用选择器，文件IO是不需要使用的。</p><p>选择器可以说是NIO的核心组件，它可以监听通道的状态，来实现异步非阻塞的IO。换句话说，也就是事件驱动。以此实现<strong>单线程管理多个Channel</strong>的目的。</p><p><img src="/2022/09/15/netty-nio-001/640(15)" alt="640(15)"></p><h3 id="2-3-1-核心API"><a href="#2-3-1-核心API" class="headerlink" title="2.3.1 核心API"></a>2.3.1 核心API</h3><table><thead><tr><th>API方法名</th><th>作用</th></tr></thead><tbody><tr><td>Selector.open()</td><td>打开一个选择器。</td></tr><tr><td>select()</td><td>选择一组键，其相应的通道已为 I&#x2F;O 操作准备就绪。</td></tr><tr><td>selectedKeys()</td><td>返回此选择器的已选择键集。</td></tr></tbody></table><p>以上的API会在后面的例子用到，先有个印象。</p><h1 id="NIO快速入门"><a href="#NIO快速入门" class="headerlink" title="NIO快速入门"></a>NIO快速入门</h1><h3 id="3-1-1-通道间的数据传输"><a href="#3-1-1-通道间的数据传输" class="headerlink" title="3.1.1 通道间的数据传输"></a>3.1.1 通道间的数据传输</h3><p>这里主要介绍两个通道与通道之间数据传输的方式：</p><p><code>transferTo()</code>：把源通道的数据传输到目的通道中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//获取文件输入流</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="comment">//从文件输入流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">inputStreamChannel</span> <span class="operator">=</span> inputStream.getChannel();</span><br><span class="line">            <span class="comment">//获取文件输出流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;2.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//从文件输出流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">outputStreamChannel</span> <span class="operator">=</span> outputStream.getChannel();</span><br><span class="line">            <span class="comment">//创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>) file.length());</span><br><span class="line">            <span class="comment">//把输入流通道的数据读取到输出流的通道</span></span><br><span class="line">            inputStreamChannel.transferTo(<span class="number">0</span>, byteBuffer.limit(), outputStreamChannel);</span><br><span class="line">            <span class="comment">//关闭通道</span></span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            outputStreamChannel.close();</span><br><span class="line">            inputStreamChannel.close();</span><br><span class="line">        &#125;    </span><br></pre></td></tr></table></figure><p><code>transferFrom()</code>：把来自源通道的数据传输到目的通道。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//获取文件输入流</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="comment">//从文件输入流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">inputStreamChannel</span> <span class="operator">=</span> inputStream.getChannel();</span><br><span class="line">            <span class="comment">//获取文件输出流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;2.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//从文件输出流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">outputStreamChannel</span> <span class="operator">=</span> outputStream.getChannel();</span><br><span class="line">            <span class="comment">//创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>) file.length());</span><br><span class="line">            <span class="comment">//把输入流通道的数据读取到输出流的通道</span></span><br><span class="line">            outputStreamChannel.transferFrom(inputStreamChannel,<span class="number">0</span>,byteBuffer.limit());</span><br><span class="line">            <span class="comment">//关闭通道</span></span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            outputStreamChannel.close();</span><br><span class="line">            inputStreamChannel.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-分散读取和聚合写入"><a href="#3-1-2-分散读取和聚合写入" class="headerlink" title="3.1.2 分散读取和聚合写入"></a>3.1.2 分散读取和聚合写入</h3><p>我们先看一下FileChannel的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FileChannel</span> <span class="keyword">extends</span> <span class="title class_">AbstractInterruptibleChannel</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">SeekableByteChannel</span>, GatheringByteChannel, ScatteringByteChannel &#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出实现了GatheringByteChannel,ScatteringByteChannel接口。也就是支持分散读取和聚合写入的操作。怎么使用呢，请看以下例子：</p><p>我们写一个main方法来实现复制1.txt文件，文件内容是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcdefghijklmnopqrstuvwxyz//26个字母</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//获取文件输入流</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="comment">//从文件输入流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">inputStreamChannel</span> <span class="operator">=</span> inputStream.getChannel();</span><br><span class="line">            <span class="comment">//获取文件输出流</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;2.txt&quot;</span>));</span><br><span class="line">            <span class="comment">//从文件输出流获取通道</span></span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">outputStreamChannel</span> <span class="operator">=</span> outputStream.getChannel();</span><br><span class="line">            <span class="comment">//创建三个缓冲区，分别都是5</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">            <span class="comment">//创建一个缓冲区数组</span></span><br><span class="line">            ByteBuffer[] buffers = <span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;byteBuffer1, byteBuffer2, byteBuffer3&#125;;</span><br><span class="line">            <span class="comment">//循环写入到buffers缓冲区数组中，分散读取</span></span><br><span class="line">            <span class="type">long</span> read;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sumLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((read = inputStreamChannel.read(buffers)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                sumLength += read;</span><br><span class="line">                Arrays.stream(buffers)</span><br><span class="line">                        .map(buffer -&gt; <span class="string">&quot;posstion=&quot;</span> + buffer.position() + <span class="string">&quot;,limit=&quot;</span> + buffer.limit())</span><br><span class="line">                        .forEach(System.out::println);</span><br><span class="line">                <span class="comment">//切换模式</span></span><br><span class="line">                Arrays.stream(buffers).forEach(Buffer::flip);</span><br><span class="line">                <span class="comment">//聚合写入到文件输出通道</span></span><br><span class="line">                outputStreamChannel.write(buffers);</span><br><span class="line">                <span class="comment">//清空缓冲区</span></span><br><span class="line">                Arrays.stream(buffers).forEach(Buffer::clear);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;总长度:&quot;</span> + sumLength);</span><br><span class="line">            <span class="comment">//关闭通道</span></span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            outputStreamChannel.close();</span><br><span class="line">            inputStreamChannel.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">posstion=5,limit=5</span><br><span class="line">posstion=5,limit=5</span><br><span class="line">posstion=5,limit=5</span><br><span class="line"></span><br><span class="line">posstion=5,limit=5</span><br><span class="line">posstion=5,limit=5</span><br><span class="line">posstion=1,limit=5</span><br><span class="line"></span><br><span class="line">总长度:26</span><br></pre></td></tr></table></figure><p>可以看到循环了两次。第一次循环时，三个缓冲区都读取了5个字节，总共读取了15，也就是读满了。还剩下11个字节，于是第二次循环时，前两个缓冲区分配了5个字节，最后一个缓冲区给他分配了1个字节，刚好读完。总共就是26个字节。</p><p>这就是分散读取，聚合写入的过程。</p><p>使用场景就是可以<strong>使用一个缓冲区数组，自动地根据需要去分配缓冲区的大小。可以减少内存消耗</strong>。网络IO也可以使用，这里就不写例子演示了。</p><h3 id="3-1-3-非直接-x2F-直接缓冲区"><a href="#3-1-3-非直接-x2F-直接缓冲区" class="headerlink" title="3.1.3 非直接&#x2F;直接缓冲区"></a>3.1.3 非直接&#x2F;直接缓冲区</h3><p>非直接缓冲区的创建方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static ByteBuffer allocate(int capacity)</span><br></pre></td></tr></table></figure><p>直接缓冲区的创建方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static ByteBuffer allocateDirect(int capacity)</span><br></pre></td></tr></table></figure><p>非直接&#x2F;直接缓冲区的区别示意图：</p><p><img src="/2022/09/15/netty-nio-001/640(16)" alt="640(16)"></p><p><img src="/2022/09/15/netty-nio-001/640(17)" alt="640(17)"></p><p>从示意图中我们可以发现，最大的不同在于直接缓冲区不需要再把文件内容copy到物理内存中。这就大大地提高了性能。其实在介绍Buffer时，我们就有接触到这个概念。直接缓冲区是堆外内存，在本地文件IO效率会更高一点。</p><p>接下来我们来对比一下效率，以一个136 MB的视频文件为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">starTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//获取文件输入流</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\小电影.mp4&quot;</span>);<span class="comment">//文件大小136 MB</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">    <span class="comment">//从文件输入流获取通道</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">inputStreamChannel</span> <span class="operator">=</span> inputStream.getChannel();</span><br><span class="line">    <span class="comment">//获取文件输出流</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test.mp4&quot;</span>));</span><br><span class="line">    <span class="comment">//从文件输出流获取通道</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">outputStreamChannel</span> <span class="operator">=</span> outputStream.getChannel();</span><br><span class="line">    <span class="comment">//创建一个直接缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//创建一个非直接缓冲区</span></span><br><span class="line">    <span class="comment">//ByteBuffer byteBuffer = ByteBuffer.allocate(5 * 1024 * 1024);</span></span><br><span class="line">    <span class="comment">//写入到缓冲区</span></span><br><span class="line">    <span class="keyword">while</span> (inputStreamChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//切换读模式</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        outputStreamChannel.write(byteBuffer);</span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭通道</span></span><br><span class="line">    outputStream.close();</span><br><span class="line">    inputStream.close();</span><br><span class="line">    outputStreamChannel.close();</span><br><span class="line">    inputStreamChannel.close();</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;消耗时间：&quot;</span> + (endTime - starTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>直接缓冲区的消耗时间：283毫秒</p><p>非直接缓冲区的消耗时间：487毫秒</p><h3 id="3-2-网络IO"><a href="#3-2-网络IO" class="headerlink" title="3.2 网络IO"></a>3.2 网络IO</h3><p>其实NIO的主要用途是网络IO，在NIO之前java要使用网络编程就只有用<code>Socket</code>。而<code>Socket</code>是阻塞的，显然对于高并发的场景是不适用的。所以NIO的出现就是解决了这个痛点。</p><p>主要思想是把Channel通道注册到Selector中，通过Selector去监听Channel中的事件状态，这样就不需要阻塞等待客户端的连接，从主动等待客户端的连接，变成了通过事件驱动。没有监听的事件，服务器可以做自己的事情。</p><h3 id="3-2-1-使用Selector的小例子"><a href="#3-2-1-使用Selector的小例子" class="headerlink" title="3.2.1 使用Selector的小例子"></a>3.2.1 使用Selector的小例子</h3><p>接下来趁热打铁，我们来做一个服务器接受客户端消息的例子：</p><p>首先服务端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//打开一个ServerSocketChannel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//绑定地址</span></span><br><span class="line">        serverSocketChannel.bind(address);</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//打开一个选择器</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">//serverSocketChannel注册到选择器中,监听连接事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">//循环等待客户端的连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//等待3秒，（返回0相当于没有事件）如果没有事件，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (selector.select(<span class="number">3000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器等待3秒，没有连接&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有事件selector.select(3000)&gt;0的情况,获取事件</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//获取迭代器遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//获取到事件</span></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> it.next();</span><br><span class="line">                <span class="comment">//判断如果是连接事件</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">//服务器与客户端建立连接，获取socketChannel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    <span class="comment">//设置成非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">//把socketChannel注册到selector中，监听读事件，并绑定一个缓冲区</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果是读事件</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">//获取通道</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">//获取关联的ByteBuffer</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) selectionKey.attachment();</span><br><span class="line">                    <span class="comment">//打印从客户端获取到的数据</span></span><br><span class="line">                    socketChannel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;from 客户端：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从事件集合中删除已处理的事件，防止重复处理</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">connect</span> <span class="operator">=</span> socketChannel.connect(address);</span><br><span class="line">        <span class="comment">//判断是否连接成功</span></span><br><span class="line">        <span class="keyword">if</span>(!connect)&#123;</span><br><span class="line">            <span class="comment">//等待连接的过程中</span></span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接服务器需要时间，期间可以做其他事情...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello java技术爱好者！&quot;</span>;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">        <span class="comment">//把byteBuffer数据写入到通道中</span></span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">        <span class="comment">//让程序卡在这个位置，不关闭连接</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来启动服务端，然后再启动客户端，我们可以看到控制台打印以下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务器等待3秒，没有连接</span><br><span class="line">服务器等待3秒，没有连接</span><br><span class="line">from 客户端：hello java技术爱好者！                       </span><br><span class="line">服务器等待3秒，没有连接</span><br><span class="line">服务器等待3秒，没有连接</span><br></pre></td></tr></table></figure><p>通过这个例子我们引出以下知识点。</p><h3 id="3-2-2-SelectionKey"><a href="#3-2-2-SelectionKey" class="headerlink" title="3.2.2 SelectionKey"></a>3.2.2 SelectionKey</h3><p>在<code>SelectionKey</code>类中有四个常量表示四种事件，来看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SelectionKey</span> &#123;</span><br><span class="line">    <span class="comment">//读事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">//2^0=1</span></span><br><span class="line">    <span class="comment">//写事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>; <span class="comment">// 2^2=4</span></span><br><span class="line">    <span class="comment">//连接操作,Client端支持的一种操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_CONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">// 2^3=8</span></span><br><span class="line">    <span class="comment">//连接可接受操作,仅ServerSocketChannel支持</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_ACCEPT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 2^4=16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附加的对象(可选)，把通道注册到选择器中时可以附加一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops, Object att)</span></span><br></pre></td></tr></table></figure><p>从<code>selectionKey</code>中获取附件对象可以使用<code>attachment()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">attachment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> attachment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用NIO实现多人聊天室"><a href="#4-使用NIO实现多人聊天室" class="headerlink" title="4 使用NIO实现多人聊天室"></a>4 使用NIO实现多人聊天室</h3><p>接下来进行一个实战例子，用NIO实现一个多人运动版本的聊天室。</p><p>服务端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器初始化成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//打开一个选择器</span></span><br><span class="line">            <span class="built_in">this</span>.selector = Selector.open();</span><br><span class="line">            <span class="comment">//打开serverSocketChannel</span></span><br><span class="line">            <span class="built_in">this</span>.serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定地址，端口号</span></span><br><span class="line">            <span class="built_in">this</span>.serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, PORT));</span><br><span class="line">            <span class="comment">//设置为非阻塞</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//把通道注册到选择器中</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听，并且接受客户端消息，转发到其他客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//获取监听的事件总数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    <span class="comment">//获取SelectionKey集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">                        <span class="comment">//如果是获取连接事件</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                            <span class="comment">//设置为非阻塞</span></span><br><span class="line">                            socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            <span class="comment">//注册到选择器中</span></span><br><span class="line">                            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                            System.out.println(socketChannel.getRemoteAddress() + <span class="string">&quot;上线了~&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果是读就绪事件</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="comment">//读取消息，并且转发到其他客户端</span></span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        it.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取客户端发送过来的消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readData</span><span class="params">(SelectionKey selectionKey)</span> &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从selectionKey中获取channel</span></span><br><span class="line">            socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//创建一个缓冲区</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">//把通道的数据写入到缓冲区</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> socketChannel.read(byteBuffer);</span><br><span class="line">            <span class="comment">//判断返回的count是否大于0，大于0表示读取到了数据</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//把缓冲区的byte[]转成字符串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array());</span><br><span class="line">                <span class="comment">//输出该消息到控制台</span></span><br><span class="line">                System.out.println(<span class="string">&quot;from 客户端：&quot;</span> + msg);</span><br><span class="line">                <span class="comment">//转发到其他客户端</span></span><br><span class="line">                notifyAllClient(msg, socketChannel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//打印离线的通知</span></span><br><span class="line">                System.out.println(socketChannel.getRemoteAddress() + <span class="string">&quot;离线了...&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                selectionKey.cancel();</span><br><span class="line">                <span class="comment">//关闭流</span></span><br><span class="line">                socketChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转发消息到其他客户端</span></span><br><span class="line"><span class="comment">     * msg 消息</span></span><br><span class="line"><span class="comment">     * noNotifyChannel 不需要通知的Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyAllClient</span><span class="params">(String msg, SocketChannel noNotifyChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息~&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (SelectionKey selectionKey : selector.keys()) &#123;</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> selectionKey.channel();</span><br><span class="line">            <span class="comment">//channel的类型实际类型是SocketChannel，并且排除不需要通知的通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; channel != noNotifyChannel) &#123;</span><br><span class="line">                <span class="comment">//强转成SocketChannel类型</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) channel;</span><br><span class="line">                <span class="comment">//通过消息，包裹获取一个缓冲区</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                socketChannel.write(byteBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">GroupChatServer</span> <span class="variable">chatServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatServer</span>();</span><br><span class="line">        <span class="comment">//启动服务器，监听</span></span><br><span class="line">        chatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClinet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatClinet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//打开选择器</span></span><br><span class="line">            <span class="built_in">this</span>.selector = Selector.open();</span><br><span class="line">            <span class="comment">//连接服务器</span></span><br><span class="line">            socketChannel = SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, GroupChatServer.PORT));</span><br><span class="line">            <span class="comment">//设置为非阻塞</span></span><br><span class="line">            socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//注册到选择器中</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            <span class="comment">//获取用户名</span></span><br><span class="line">            userName = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">            System.out.println(userName + <span class="string">&quot; is ok~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息到服务端</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        msg = userName + <span class="string">&quot;说：&quot;</span> + msg;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(msg.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取服务端发送过来的消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    <span class="comment">//判断是读就绪事件</span></span><br><span class="line">                    <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">                        <span class="comment">//创建一个缓冲区</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//从服务器的通道中读取数据到缓冲区</span></span><br><span class="line">                        channel.read(byteBuffer);</span><br><span class="line">                        <span class="comment">//缓冲区的数据，转成字符串，并打印</span></span><br><span class="line">                        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">GroupChatClinet</span> <span class="variable">chatClinet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatClinet</span>();</span><br><span class="line">        <span class="comment">//启动线程，读取服务器转发过来的消息</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                chatClinet.readMsg();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//主线程发送消息到服务器</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            chatClinet.sendMsg(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动服务端的main方法，再启动两个客户端的main方法：</p><p><img src="/2022/09/15/netty-nio-001/640(18)" alt="640(18)"></p><p>然后使用两个客户端开始聊天了~</p><p><img src="/2022/09/15/netty-nio-001/640(19)" alt="640(19)"></p><p><img src="/2022/09/15/netty-nio-001/640(20)" alt="640(20)"></p><p>以上就是使用NIO<strong>实现多人聊天室</strong>的例子，同学们可以看着我这个例子自己完成一下。要多写代码才好理解这些概念。</p><hr><p><strong>免责声明：</strong></p><p>本公博客部分分享的资料来自网络收集和整理，所有文字和图片版权归属于原作者所有，且仅代表作者个人观点，与<strong>本博客</strong>无关，文章仅供读者学习交流使用，并请自行核实相关内容，如文章内容涉及侵权，请联系后台管理员删除。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Quartz，更优雅地管理你的定时任务</title>
      <link href="/2022/09/14/quartz20220914/"/>
      <url>/2022/09/14/quartz20220914/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><p>初识Quartz</p></li><li><p>Quartz基础使用</p><ul><li><p>基于时间间隔的定时任务</p></li><li><p>基于Cron表达式的定时任务</p></li></ul></li><li><p>Quartz解读</p><ul><li><p>Job</p></li><li><p>Trigger</p></li><li><p>Scheduler</p></li></ul></li><li><p>Quartz进阶使用</p><ul><li><p>多触发器的定时任务</p></li><li><p>Job中注入Bean</p></li><li><p>Quartz的持久化</p></li></ul></li></ul><p>最近在工作遇到了定时任务场景，因此特地对定时任务相关知识进行了调研，记录在此，后文中使用的代码已经上传到Github：<a href="https://github.com/ThinkMugz/springboot-demo-major%EF%BC%8C%E9%9C%80%E8%A6%81%E7%9A%84%E4%BC%99%E4%BC%B4%E5%84%BF%E8%87%AA%E5%8F%96%E3%80%82">https://github.com/ThinkMugz/springboot-demo-major，需要的伙伴儿自取。</a></p><p>本文主要有以下内容：</p><ul><li><p>Quartz的基本认知和源码初探</p></li><li><p>Quartz的基本使用</p></li><li><p>Quartz的进阶使用，包括Job中注入Mapper层、Quartz的持久化</p></li></ul><p>在Java领域，有很多定时任务框架，这里简单对比一下目前比较流行的三款：</p><p><img src="/2022/09/14/quartz20220914/saved_resource" alt="saved_resource"></p><ul><li><p>Quartz文档：<a href="https://www.w3cschool.cn/quartz/_doc/">https://www.w3cschool.cn/quartz\_doc/</a></p></li><li><p>xxl-job博客：<a href="https://www.cnblogs.com/xuxueli/p/5021979.html">https://www.cnblogs.com/xuxueli/p/5021979.html</a></p></li></ul><h2 id="一-初识Quartz"><a href="#一-初识Quartz" class="headerlink" title="一 . 初识Quartz"></a>一 . 初识Quartz</h2><p>如果你的定时任务没有分布式需求，但需要对任务有一定的动态管理，例如任务的启动、暂停、恢复、停止和触发时间修改，那么Quartz非常适合你。</p><p>Quartz是Java定时任务领域一个非常优秀的框架，由OpenSymphony（一个开源组织）开发，这个框架进行了优良地解耦设计，整个模块可以分为三大部分：</p><ul><li><p><strong>Job</strong>：顾名思义，指待定时执行的具体工作内容；</p></li><li><p><strong>Trigger</strong>：触发器，指定运行参数，包括运行次数、运行开始时间和技术时间、运行时长等；</p></li><li><p><strong>Scheduler</strong>：调度器，将Job和Trigger组装起来，使定时任务被真正执行；</p></li></ul><p><img src="/2022/09/14/quartz20220914/saved_resource(1)" alt="saved_resource(1)"><br>下面这个图简略地描述了三者之间的关系：</p><ul><li><p>一个JobDetail（Job的实现类）可以绑定多个Trigger，但一个Trigger只能绑定一个JobDetail；</p></li><li><p>每个JobDetail和Trigger通过group和name来标识唯一性；</p></li><li><p>一个Scheduler可以调度多组JobDetail和Trigger。</p></li></ul><p><img src="/2022/09/14/quartz20220914/saved_resource(2)" alt="saved_resource(2)"></p><p>为了便于理解和记忆，可以把这套设计机制与工厂车间相关联：</p><ul><li><p><strong>Job</strong>：把Job比作车间要生产的一类产品，例如汽车、电脑等。</p></li><li><p><strong>Trigger</strong>：trigger可以理解为一条生产线，一条生产线只能生产一类产品，但一类产品可以由多条生产线生产。</p></li><li><p><strong>Scheduler</strong>：Scheduler则可以理解为车间主任，指挥调度着车间内的生产任务（Scheduler内置线程池，线程池内的工作线程即为车间工人，每个工人承担着一组任务的真正执行）。</p></li></ul><p><img src="/2022/09/14/quartz20220914/saved_resource(3)" alt="saved_resource(3)"></p><h2 id="二-Quartz基础使用"><a href="#二-Quartz基础使用" class="headerlink" title="二. Quartz基础使用"></a>二. Quartz基础使用</h2><p><code>Quartz提供了丰富的API，下面我们在Springboot中使用Quartz完成一些简单的demo。</code></p><h3 id="基于时间间隔的定时任务"><a href="#基于时间间隔的定时任务" class="headerlink" title="基于时间间隔的定时任务"></a>基于时间间隔的定时任务</h3><p>基于时间间隔和时间长度实现定时任务，借助SimpleTrigger，例如这个场景——每隔2s在控制台输出线程名和当前时间，持续30s。</p><h4 id="a-导入依赖："><a href="#a-导入依赖：" class="headerlink" title="a.导入依赖："></a>a.导入依赖：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- quartz任务--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="b-新建Job，实现我们想要定时执行的任务："><a href="#b-新建Job，实现我们想要定时执行的任务：" class="headerlink" title="b.新建Job，实现我们想要定时执行的任务："></a>b.新建Job，实现我们想要定时执行的任务：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/9/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个事件，下面仅创建一个输出语句作演示</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&quot;</span></span><br><span class="line">                + DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(LocalDateTime.now()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c-创建Scheduler和Trigger，执行定时任务："><a href="#c-创建Scheduler和Trigger，执行定时任务：" class="headerlink" title="c.创建Scheduler和Trigger，执行定时任务："></a>c.创建Scheduler和Trigger，执行定时任务：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能描述</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ASUS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/9/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleQuartzTest</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 基于时间间隔的定时任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleTest</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1、创建Scheduler（调度器）</span></span><br><span class="line">        <span class="type">SchedulerFactory</span> <span class="variable">schedulerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> schedulerFactory.getScheduler();</span><br><span class="line">        <span class="comment">// 2、创建JobDetail实例，并与SimpleJob类绑定(Job执行内容)</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(SimpleJob.class)</span><br><span class="line">                .withIdentity(<span class="string">&quot;job1&quot;</span>, <span class="string">&quot;group1&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 3、构建Trigger（触发器），定义执行频率和时长</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                <span class="comment">// 指定group和name，这是唯一身份标识</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;trigger-1&quot;</span>, <span class="string">&quot;trigger-group&quot;</span>)</span><br><span class="line">                .startNow()  <span class="comment">//立即生效</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">2</span>) <span class="comment">//每隔2s执行一次</span></span><br><span class="line">                        .repeatForever())  <span class="comment">// 永久执行</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//4、将Job和Trigger交给Scheduler调度</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">        <span class="comment">// 5、启动Scheduler</span></span><br><span class="line">        scheduler.start();</span><br><span class="line">        <span class="comment">// 休眠，决定调度器运行时间，这里设置30s</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 关闭Scheduler</span></span><br><span class="line">        scheduler.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动测试方法后，控制台观察现象即可。注意到这么一句日志：Using threadpool ‘org.quartz.simpl.SimpleThreadPool&#39; - with 10 threads.，这说明Scheduler确实是内置了10个线程的线程池，通过打印线程名也印证了这一点。</p><p>另外要尤其注意的是，我们之所以通过TimeUnit.SECONDS.sleep(30);设置休眠，是因为定时任务是交由线程池异步执行的，而测试方法运行结束，主线程随之结束导致定时任务也不再执行了，所以需要设置休眠hold住主线程。在真实项目中，项目的进程是一直存活的，因此不需要设置休眠时间。</p><p>这其中的区别可以参考</p><p><code> https://github.com/ThinkMugz/springboot-demo-major。</code></p><h3 id="基于Cron表达式的定时任务"><a href="#基于Cron表达式的定时任务" class="headerlink" title="基于Cron表达式的定时任务"></a>基于Cron表达式的定时任务</h3><p>基于Cron表达式的定时任务demo如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 基于cron表达式的定时任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cronTest</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1、创建Scheduler（调度器）</span></span><br><span class="line">        <span class="type">SchedulerFactory</span> <span class="variable">schedulerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> schedulerFactory.getScheduler();</span><br><span class="line">        <span class="comment">// 2、创建JobDetail实例，并与SimpleJob类绑定</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(SimpleJob.class)</span><br><span class="line">                .withIdentity(<span class="string">&quot;job-1&quot;</span>, <span class="string">&quot;job-group&quot;</span>).build();</span><br><span class="line">        <span class="comment">// 3、构建Trigger（触发器），定义执行频率和时长</span></span><br><span class="line">        <span class="type">CronTrigger</span> <span class="variable">cronTrigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">&quot;trigger-1&quot;</span>, <span class="string">&quot;trigger-group&quot;</span>)</span><br><span class="line">                .startNow()  <span class="comment">//立即生效</span></span><br><span class="line">                .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">&quot;* 30 10 ? * 1/5 *&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、执行</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, cronTrigger);</span><br><span class="line">        scheduler.start();</span><br><span class="line">        <span class="comment">// 休眠，决定调度器运行时间，这里设置30s</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 关闭Scheduler</span></span><br><span class="line">        scheduler.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="三-Quartz解读"><a href="#三-Quartz解读" class="headerlink" title="三 .  Quartz解读"></a>三 .  Quartz解读</h2><p>整个Quartz体系涉及的类及之间的关系如下图所示：</p><p><img src="/2022/09/14/quartz20220914/saved_resource(4)" alt="saved_resource(4)"></p><ul><li><p><strong>JobDetail</strong>：Job接口的实现类，由JobBuilder将具体定义任务的类包装而成。</p></li><li><p><strong>Trigger</strong>：触发器，定义定时任务的触发规则，包括执行间隔、时长等，使用    TriggerBuilder创建，JobDetail和Trigger可以一对多，反之不可。触发器可以拥有多种状态。</p></li><li><p><strong>Scheduler</strong>：调度器，将Job和Trigger组装起来，使定时任务被真正执行；是Quartz的核心，提供了大量API。</p></li><li><p><strong>JobDataMap</strong>：集成Map，通过键值对为JobDetail存储一些额外信息。</p></li><li><p><strong>JobStore</strong>：用来存储任务和触发器相关的信息，例如任务名称、数量、状态等等。Quartz<br>中有两种存储任务的方式，一种在在内存（RAMJobStore），一种是在数据库（JDBCJobStore）。</p></li></ul><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>Job是一个接口，只有一个方法execute()，我们创建具体的任务类时要继承Job并重写execute()方法，使用JobBuilder将具体任务类包装成一个JobDetail（使用了建造者模式）交给Scheduler管理。每个JobDetail由name和group作为其唯一身份标识。</p><ul><li><p>JobDataMap中可以包含不限量的（序列化的）数据对象，在job实例执行的时候，可以使用其中的数据。</p></li><li><p>JobDataMap继承Map，可通过键值对为JobDetail存储一些额外信息。</p></li></ul><h3 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h3><p>Trigger有四类实现，分别如下：</p><ul><li><p><strong>SimpleTrigger</strong>：简单触发器，支持定义任务执行的间隔时间，执行次数的规则有两种，一是定义重复次数，二是定义开始时间和结束时间。如果同时设置了结束时间与重复次数，先结束的会覆盖后结束的，以先结束的为准。</p></li><li><p><strong>CronTrigger</strong>：基于Cron表达式的触发器。</p></li><li><p><strong>CalendarIntervalTrigger</strong>：基于日历的触发器，比简单触发器更多时间单位，且能智能区分大小月和平闰年。</p></li><li><p><strong>DailyTimeIntervalTrigger</strong>：基于日期的触发器，如每天的某个时间段。</p></li></ul><p>Trigger是有状态的：NONE,NORMAL,PAUSED,COMPLETE,ERROR,BLOCKED，状态之间转换关系：</p><p><img src="/2022/09/14/quartz20220914/saved_resource(5)" alt="saved_resource(5)"><br>COMPLETE状态比较特殊，我在实际操作中发现，当Trigger长时间暂停后（具体时长不太确定）再恢复，状态就会变为COMPLETE，这种状态下无法再次启动该触发器。</p><h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>调度器，是 Quartz的指挥官，由StdSchedulerFactory产生，它是单例的。Scheduler中提供了Quartz中最重要的API，默认是实现类是StdScheduler。</p><p>Scheduler中主要的API大概分为三种：</p><ul><li><p><strong>操作Scheduler本身</strong>：例如start、shutdown等；</p></li><li><p><strong>操作Job</strong>：例如：addJob、pauseJob、pauseJobs、resumeJob、resumeJobs、getJobKeys、getJobDetail等</p></li><li><p><strong>操作Trigger</strong>：例如pauseTrigger、resumeTrigger等</p></li></ul><p>这些API使用非常简单，源码中也有完善的注释，这里不再赘述。</p><h2 id="四-Quartz进阶使用"><a href="#四-Quartz进阶使用" class="headerlink" title="四 . Quartz进阶使用"></a>四 . Quartz进阶使用</h2><p>除了基本使用外，Quartz还有一些较为复杂的应用场景。</p><h3 id="多触发器的定时任务"><a href="#多触发器的定时任务" class="headerlink" title="多触发器的定时任务"></a>多触发器的定时任务</h3><p>前文提过，一个JobDetail可以绑定多个触发器，这种场景还是有一些注意点的：</p><ul><li><p>首先，要通过storeDurably()方法将JobDetail设置为孤立后保存存储（没有触发器指向该作业的情况）；</p></li><li><p>Scheduler通过addJob()将给定的作业添加到计划程序中-没有关联的触发器。作业将处于”休眠”状态，直到使用触发器或调度程序对其进行调度；</p></li><li><p>触发器通过forJob(JobDetail jobDetail)指定要绑定的JobDetail，scheduleJob()方法只传入触发器，触发后将自动执行addJob过的绑定JobDetail。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.quartz.demo.schedule.SimpleJob;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiQuartzTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multiJobTest</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1、创建Scheduler（调度器）</span></span><br><span class="line">        <span class="type">SchedulerFactory</span> <span class="variable">schedulerFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StdSchedulerFactory</span>();</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> schedulerFactory.getScheduler();</span><br><span class="line">        <span class="comment">// 2、创建JobDetail实例，与执行内容类SimpleJob绑定，注意要设置 .storeDurably()，否则报错</span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(SimpleJob.class)</span><br><span class="line">                .withIdentity(<span class="string">&quot;job1&quot;</span>, <span class="string">&quot;job-group&quot;</span>)</span><br><span class="line">                .storeDurably()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、分别构建Trigger实例</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger().withIdentity(<span class="string">&quot;trigger1&quot;</span>, <span class="string">&quot;trigger-group&quot;</span>)</span><br><span class="line">                .startNow()<span class="comment">//立即生效</span></span><br><span class="line">                .forJob(jobDetail)</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder</span><br><span class="line">                        .simpleSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">2</span>) <span class="comment">//每隔3s执行一次</span></span><br><span class="line">                        .repeatForever()) <span class="comment">// 永久循环</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger2</span> <span class="operator">=</span> TriggerBuilder.newTrigger().withIdentity(<span class="string">&quot;trigger2&quot;</span>, <span class="string">&quot;trigger-group&quot;</span>)</span><br><span class="line">                .startNow()<span class="comment">//立即生效</span></span><br><span class="line">                .forJob(jobDetail)</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">3</span>) <span class="comment">//每隔5s执行一次</span></span><br><span class="line">                        .repeatForever()).build(); <span class="comment">// 永久循环</span></span><br><span class="line">        <span class="comment">//4、调度器中添加job</span></span><br><span class="line">        scheduler.addJob(jobDetail, <span class="literal">false</span>);</span><br><span class="line">        scheduler.scheduleJob(trigger);</span><br><span class="line">        scheduler.scheduleJob(trigger2);</span><br><span class="line">        <span class="comment">// 启动调度器</span></span><br><span class="line">        scheduler.start();</span><br><span class="line">        <span class="comment">// 休眠任务执行时长</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        scheduler.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Job中注入Bean"><a href="#Job中注入Bean" class="headerlink" title="Job中注入Bean"></a>Job中注入Bean</h3><p>有时候，我们要在定时任务中操作数据库，但Job中无法直接注入数据层，解决这种问题，有两种解决方案。</p><h4 id="方案一：借助JobDataMap"><a href="#方案一：借助JobDataMap" class="headerlink" title="方案一：借助JobDataMap"></a>方案一：借助JobDataMap</h4><p>在构建JobDetail时，可以将数据放入JobDataMap，基本类型的数据通过usingJobData方法直接放入，mapper这种类型数据手动put进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PersonMapper personMapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建定时任务</span></span><br><span class="line"><span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(MajorJob.class)</span><br><span class="line">        .withIdentity(jobName, jobGroupName)</span><br><span class="line">        .usingJobData(<span class="string">&quot;jobName&quot;</span>, <span class="string">&quot;QuartzDemo&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">// 将mapper放入jobDetail的jobDataMap中</span></span><br><span class="line">jobDetail.getJobDataMap().put(<span class="string">&quot;personMapper&quot;</span>, personMapper);</span><br></pre></td></tr></table></figure><p>在job的执行过程中，可以从JobDataMap中取出数据，如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.quartz.demo.entity.Person;</span><br><span class="line"><span class="keyword">import</span> com.quartz.demo.mapper.PersonMapper;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobDataMap;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MajorJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> &#123;</span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">dataMap</span> <span class="operator">=</span> jobExecutionContext.getJobDetail().getJobDataMap();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jobName</span> <span class="operator">=</span> dataMap.getString(<span class="string">&quot;jobName&quot;</span>);</span><br><span class="line">        <span class="type">PersonMapper</span> <span class="variable">personMapper</span> <span class="operator">=</span> (PersonMapper) dataMap.get(<span class="string">&quot;personMapper&quot;</span>);</span><br><span class="line">        <span class="comment">// 这样就可以执行mapper层方法了</span></span><br><span class="line">        List&lt;Person&gt; personList = personMapper.queryList();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&quot;</span></span><br><span class="line">                + DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(LocalDateTime.now()) + <span class="string">&quot;--&quot;</span></span><br><span class="line">                + jobName + <span class="string">&quot;--&quot;</span> + personList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方案相对简单，但在持久化中会遇到mapper的序列化问题：</p><blockquote><p>java.io.NotSerializableException: Unable to serialize JobDataMap for insertion into database because the value of property ‘personMapper’ is not serializable: org.mybatis.spring.SqlSessionTemplate</p></blockquote><h4 id="方案二：静态工具类"><a href="#方案二：静态工具类" class="headerlink" title="方案二：静态工具类"></a>方案二：静态工具类</h4><ul><li>创建工具类SpringContextJobUtil，实现ApplicationContextAware接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringContextJobUtil</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;static-access&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext contex)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = contex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据name获取bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bean对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> context.getBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMessage</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> context.getMessage(key, <span class="literal">null</span>, Locale.getDefault());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>mapper类上打上@Service注解，并赋予其name：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;personMapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select id,name,age,sex,address,sect,skill,power,create_time createTime,modify_time modifyTime from mytest.persons&quot;)</span></span><br><span class="line">    List&lt;Person&gt; <span class="title function_">queryList</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Job中通过SpringContextJobUtil的getBean获取mapper的bean：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MajorJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> &#123;</span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">dataMap</span> <span class="operator">=</span> jobExecutionContext.getJobDetail().getJobDataMap();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jobName</span> <span class="operator">=</span> dataMap.getString(<span class="string">&quot;jobName&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PersonMapper</span> <span class="variable">personMapper</span> <span class="operator">=</span> (PersonMapper) SpringContextJobUtil.getBean(<span class="string">&quot;personMapper&quot;</span>);</span><br><span class="line">        List&lt;Person&gt; personList = personMapper.queryList();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&quot;</span></span><br><span class="line">                + DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(LocalDateTime.now()) + <span class="string">&quot;--&quot;</span></span><br><span class="line">                + jobName + <span class="string">&quot;--&quot;</span> + personList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>推荐使用这个方法。</li></ul><h3 id="Quartz的持久化"><a href="#Quartz的持久化" class="headerlink" title="Quartz的持久化"></a>Quartz的持久化</h3><p>定时任务的诸多要素，如任务名称、数量、状态、运行频率、运行时间等，是要存储起来的。JobStore，就是用来存储任务和触发器相关的信息的。</p><p>Quartz中有两种存储任务的方式，一种在在内存（RAMJobStore），一种是在数据库（JDBCJobStore）。</p><p>Quartz默认的JobStore是RAMJobstore，也就是把任务和触发器信息运行的信息存储在内存中，用到了HashMap、TreeSet、HashSet等等数据结构，如果程序崩溃或重启，所有存储在内存中的数据都会丢失。所以我们需要把这些数据持久化到磁盘。</p><p>实现Quartz的持久化并不困难，按下列步骤操作即可：</p><h4 id="添加相关依赖："><a href="#添加相关依赖：" class="headerlink" title="添加相关依赖："></a>添加相关依赖：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.mchange&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9.5.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="编写配置："><a href="#编写配置：" class="headerlink" title="编写配置："></a>编写配置：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.Scheduler;</span><br><span class="line"><span class="keyword">import</span> org.quartz.ee.servlet.QuartzInitializerListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.PropertiesFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.quartz.SchedulerFactoryBean;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> muguozheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2022/4/19 18:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> Quartz配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulerConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取quartz.properties,将值初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Properties</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException io</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Properties <span class="title function_">quartzProperties</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PropertiesFactoryBean</span> <span class="variable">propertiesFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertiesFactoryBean</span>();</span><br><span class="line">        propertiesFactoryBean.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;/quartz.properties&quot;</span>));</span><br><span class="line">        propertiesFactoryBean.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> propertiesFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将配置文件的数据加载到SchedulerFactoryBean中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SchedulerFactoryBean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException io</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SchedulerFactoryBean <span class="title function_">schedulerFactoryBean</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SchedulerFactoryBean</span> <span class="variable">schedulerFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchedulerFactoryBean</span>();</span><br><span class="line">        schedulerFactoryBean.setQuartzProperties(quartzProperties());</span><br><span class="line">        <span class="keyword">return</span> schedulerFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> QuartzInitializerListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> QuartzInitializerListener <span class="title function_">executorListener</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">QuartzInitializerListener</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得Scheduler对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Scheduler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException io</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Scheduler <span class="title function_">scheduler</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> schedulerFactoryBean().getScheduler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="创建quartz-properties配置文件"><a href="#创建quartz-properties配置文件" class="headerlink" title="创建quartz.properties配置文件"></a>创建quartz.properties配置文件</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化ThreadPool时，使用的线程类为SimpleThreadPool</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.class</span>=<span class="string">org.quartz.simpl.SimpleThreadPool</span></span><br><span class="line"><span class="comment"># 并发个数</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadCount</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 优先级</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadPriority</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.misfireThreshold</span>=<span class="string">5000</span></span><br><span class="line"><span class="comment"># 持久化使用的类</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.class</span>=<span class="string">org.quartz.impl.jdbcjobstore.JobStoreTX</span></span><br><span class="line"><span class="comment"># 数据库中表的前缀</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.tablePrefix</span>=<span class="string">QRTZ_</span></span><br><span class="line"><span class="comment"># 数据源命名</span></span><br><span class="line"><span class="attr">org.quartz.jobStore.dataSource</span>=<span class="string">qzDS</span></span><br><span class="line"><span class="comment"># qzDS 数据源</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.qzDS.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.qzDS.URL</span>=<span class="string">jdbc:mysql://localhost:3306/mytest?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.qzDS.user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.qzDS.password</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">org.quartz.dataSource.qzDS.maxConnections</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure><h4 id="创建Quartz持久化数据的表"><a href="#创建Quartz持久化数据的表" class="headerlink" title="创建Quartz持久化数据的表"></a>创建Quartz持久化数据的表</h4><p>数据表初始化sql放置在External Libraries的org&#x2F;quartz&#x2F;impl&#x2F;jdbcjobstore中，直接用其初始化相关表即可。要注意的是，用来放置这些表的库要与quartz.properties的库一致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># <span class="keyword">In</span> your Quartz properties file, you<span class="string">&#x27;ll need to set</span></span><br><span class="line"><span class="string"># org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># By: Ron Cordell - roncordell</span></span><br><span class="line"><span class="string">#  I didn&#x27;</span>t see this anywhere, so I thought I<span class="string">&#x27;d post it here. This is the script from Quartz to create the tables in a MySQL database, modified to use INNODB instead of MYISAM.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_FIRED_TRIGGERS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_PAUSED_TRIGGER_GRPS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_SCHEDULER_STATE;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_LOCKS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_SIMPLE_TRIGGERS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_SIMPROP_TRIGGERS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_CRON_TRIGGERS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_BLOB_TRIGGERS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_TRIGGERS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_JOB_DETAILS;</span></span><br><span class="line"><span class="string">DROP TABLE IF EXISTS QRTZ_CALENDARS;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_JOB_DETAILS(</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">JOB_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">JOB_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">DESCRIPTION VARCHAR(250) NULL,</span></span><br><span class="line"><span class="string">JOB_CLASS_NAME VARCHAR(250) NOT NULL,</span></span><br><span class="line"><span class="string">IS_DURABLE VARCHAR(1) NOT NULL,</span></span><br><span class="line"><span class="string">IS_NONCONCURRENT VARCHAR(1) NOT NULL,</span></span><br><span class="line"><span class="string">IS_UPDATE_DATA VARCHAR(1) NOT NULL,</span></span><br><span class="line"><span class="string">REQUESTS_RECOVERY VARCHAR(1) NOT NULL,</span></span><br><span class="line"><span class="string">JOB_DATA BLOB NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_TRIGGERS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">JOB_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">JOB_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">DESCRIPTION VARCHAR(250) NULL,</span></span><br><span class="line"><span class="string">NEXT_FIRE_TIME BIGINT(13) NULL,</span></span><br><span class="line"><span class="string">PREV_FIRE_TIME BIGINT(13) NULL,</span></span><br><span class="line"><span class="string">PRIORITY INTEGER NULL,</span></span><br><span class="line"><span class="string">TRIGGER_STATE VARCHAR(16) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_TYPE VARCHAR(8) NOT NULL,</span></span><br><span class="line"><span class="string">START_TIME BIGINT(13) NOT NULL,</span></span><br><span class="line"><span class="string">END_TIME BIGINT(13) NULL,</span></span><br><span class="line"><span class="string">CALENDAR_NAME VARCHAR(190) NULL,</span></span><br><span class="line"><span class="string">MISFIRE_INSTR SMALLINT(2) NULL,</span></span><br><span class="line"><span class="string">JOB_DATA BLOB NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span></span><br><span class="line"><span class="string">FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)</span></span><br><span class="line"><span class="string">REFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_SIMPLE_TRIGGERS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">REPEAT_COUNT BIGINT(7) NOT NULL,</span></span><br><span class="line"><span class="string">REPEAT_INTERVAL BIGINT(12) NOT NULL,</span></span><br><span class="line"><span class="string">TIMES_TRIGGERED BIGINT(10) NOT NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span></span><br><span class="line"><span class="string">FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span></span><br><span class="line"><span class="string">REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_CRON_TRIGGERS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">CRON_EXPRESSION VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">TIME_ZONE_ID VARCHAR(80),</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span></span><br><span class="line"><span class="string">FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span></span><br><span class="line"><span class="string">REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_SIMPROP_TRIGGERS</span></span><br><span class="line"><span class="string">  (</span></span><br><span class="line"><span class="string">    SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">    TRIGGER_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">    TRIGGER_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">    STR_PROP_1 VARCHAR(512) NULL,</span></span><br><span class="line"><span class="string">    STR_PROP_2 VARCHAR(512) NULL,</span></span><br><span class="line"><span class="string">    STR_PROP_3 VARCHAR(512) NULL,</span></span><br><span class="line"><span class="string">    INT_PROP_1 INT NULL,</span></span><br><span class="line"><span class="string">    INT_PROP_2 INT NULL,</span></span><br><span class="line"><span class="string">    LONG_PROP_1 BIGINT NULL,</span></span><br><span class="line"><span class="string">    LONG_PROP_2 BIGINT NULL,</span></span><br><span class="line"><span class="string">    DEC_PROP_1 NUMERIC(13,4) NULL,</span></span><br><span class="line"><span class="string">    DEC_PROP_2 NUMERIC(13,4) NULL,</span></span><br><span class="line"><span class="string">    BOOL_PROP_1 VARCHAR(1) NULL,</span></span><br><span class="line"><span class="string">    BOOL_PROP_2 VARCHAR(1) NULL,</span></span><br><span class="line"><span class="string">    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span></span><br><span class="line"><span class="string">    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span></span><br><span class="line"><span class="string">    REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_BLOB_TRIGGERS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">BLOB_DATA BLOB NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span></span><br><span class="line"><span class="string">INDEX (SCHED_NAME,TRIGGER_NAME, TRIGGER_GROUP),</span></span><br><span class="line"><span class="string">FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span></span><br><span class="line"><span class="string">REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_CALENDARS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">CALENDAR_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">CALENDAR BLOB NOT NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,CALENDAR_NAME))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_FIRED_TRIGGERS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">ENTRY_ID VARCHAR(95) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">TRIGGER_GROUP VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">INSTANCE_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">FIRED_TIME BIGINT(13) NOT NULL,</span></span><br><span class="line"><span class="string">SCHED_TIME BIGINT(13) NOT NULL,</span></span><br><span class="line"><span class="string">PRIORITY INTEGER NOT NULL,</span></span><br><span class="line"><span class="string">STATE VARCHAR(16) NOT NULL,</span></span><br><span class="line"><span class="string">JOB_NAME VARCHAR(190) NULL,</span></span><br><span class="line"><span class="string">JOB_GROUP VARCHAR(190) NULL,</span></span><br><span class="line"><span class="string">IS_NONCONCURRENT VARCHAR(1) NULL,</span></span><br><span class="line"><span class="string">REQUESTS_RECOVERY VARCHAR(1) NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,ENTRY_ID))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_SCHEDULER_STATE (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">INSTANCE_NAME VARCHAR(190) NOT NULL,</span></span><br><span class="line"><span class="string">LAST_CHECKIN_TIME BIGINT(13) NOT NULL,</span></span><br><span class="line"><span class="string">CHECKIN_INTERVAL BIGINT(13) NOT NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,INSTANCE_NAME))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE TABLE QRTZ_LOCKS (</span></span><br><span class="line"><span class="string">SCHED_NAME VARCHAR(120) NOT NULL,</span></span><br><span class="line"><span class="string">LOCK_NAME VARCHAR(40) NOT NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY (SCHED_NAME,LOCK_NAME))</span></span><br><span class="line"><span class="string">ENGINE=InnoDB;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_J_REQ_RECOVERY ON QRTZ_JOB_DETAILS(SCHED_NAME,REQUESTS_RECOVERY);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_J_GRP ON QRTZ_JOB_DETAILS(SCHED_NAME,JOB_GROUP);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_J ON QRTZ_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_JG ON QRTZ_TRIGGERS(SCHED_NAME,JOB_GROUP);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_C ON QRTZ_TRIGGERS(SCHED_NAME,CALENDAR_NAME);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_G ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_N_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_STATE);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_N_G_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP,TRIGGER_STATE);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_NEXT_FIRE_TIME ON QRTZ_TRIGGERS(SCHED_NAME,NEXT_FIRE_TIME);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_NFT_ST ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE,NEXT_FIRE_TIME);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_NFT_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_STATE);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE_GRP ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_GROUP,TRIGGER_STATE);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_FT_TRIG_INST_NAME ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_FT_INST_JOB_REQ_RCVRY ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME,REQUESTS_RECOVERY);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_FT_J_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_FT_JG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_GROUP);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_FT_T_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP);</span></span><br><span class="line"><span class="string">CREATE INDEX IDX_QRTZ_FT_TG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">commit;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><hr><p><strong>免责声明：</strong></p><p>本公博客部分分享的资料来自网络收集和整理，所有文字和图片版权归属于原作者所有，且仅代表作者个人观点，与<strong>本博客</strong>无关，文章仅供读者学习交流使用，并请自行核实相关内容，如文章内容涉及侵权，请联系后台管理员删除。</p><p>转载链接<a href="https://www.cnblogs.com/chch213/articles/16678448.html">点击这里</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> quartz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经济发展之内循环、外循环</title>
      <link href="/2022/09/14/economy20220814/"/>
      <url>/2022/09/14/economy20220814/</url>
      
        <content type="html"><![CDATA[<h2 id="经济发展之内循环、外循环"><a href="#经济发展之内循环、外循环" class="headerlink" title="经济发展之内循环、外循环"></a>经济发展之内循环、外循环</h2><h3 id="一、什么是”内循环”？"><a href="#一、什么是”内循环”？" class="headerlink" title="一、什么是”内循环”？"></a>一、什么是”内循环”？</h3><p>“内循环”不是什么新的理念，而是早就开始使用的一种发展经济的手段，但是最近几年效果正在减弱。</p><p>我个人认为从2002年至今，中国的经济发展可以划分为两个阶段：第一阶段是2002年至2009年，外循环+内循环的经济增长模式；第二阶段是2010年至今的内循环为主的经济增长模式。其中第一阶段也可是说是出口+投资的经济增长模式，第二阶段是负债+投资的经济增长模式。无论是外循环、内循环、外循环+内循环的模式都是凯恩斯主义的产物，最终都有潮水褪去的一天。</p><h3 id="二、第一阶段的经济发展"><a href="#二、第一阶段的经济发展" class="headerlink" title="二、第一阶段的经济发展"></a>二、第一阶段的经济发展</h3><p>一个产品被生产出来后，一般有两种结局，一是售出，二是再加工。在经济学中将”再加工”可以称为投资。售出因为购买的对象不同，再次被细分为消费和出口，其中消费是指本国消费者购买，出口是指外国消费者购买。那么该如何衡量一个国家的经济发展水平呢？——GDP。其实GDP就是指用货币来对消费、投资和净出口进行计量，可以简单理解为GDP&#x3D;消费+投资+净出口。</p><p>一个企业生产出的产品，国内消费者不购买，无法进行再加工，国外消费者也不购买，那这个企业就要出现危机了。将这个道理推广到一个国家也是一样的，一个国家的多个”产品”不能消费、出口或投资，那这个国家就要出现经济危机。因此经济危机大多数时候是因为产能过剩、消费力下降导致的。</p><p>中国1996年的时候开始出现了产能过剩，如果任由其发展，必然造成经济危机。解决经济危机的方法至今也只有一招，就是将过剩的产品销售出去。详细区分可以分为国内销售和出口国外，当时政府的办法是在1998年开启房改，提振国内消费需求，同时在2001年加入WTO，增加出口，在这两剂良药的作用下，我国1996年的经济危机成功的得到了延缓。</p><h3 id="三、外循环和内循环"><a href="#三、外循环和内循环" class="headerlink" title="三、外循环和内循环"></a>三、外循环和内循环</h3><p>外部循环中最重要的环节是出口。</p><p>我国将产品出口欧美，再用获得的外汇储备购买美债，让美国股市得到发展，美国股市的上涨，带来了经济的繁荣，美国人有钱了，然后开始购买中国产品，拉动中国经济增长。</p><p>内循环最重要的是消费和投资。</p><p>中国内循环最重要的投资方式是城镇化，最重要的消费方式是房地产。老百姓将钱存入银行，银行将这些钱通过土地开发、土地交易和房产交易三种方式贷款给房地产市场。因此老百姓通过存款支撑房地产市场，再通过贷款去消化房价的上涨。</p><p>在消费方面，出口导致需求增长，企业开始扩招，工人们有工资，然后银行存款增加，房地产市场得到更充分的支撑，房价开始不断上涨，同时城镇化的推进导致需求的进一步增强。因此，可以判断我国的消费是由出口和投资来引领的，并不是像欧美国家由消费引领出口和投资。<br>这两个循环开起来很美好，但是终究是”永动机”设想。如果想要两个循环能够不断的运行，就需要美国的股市和中国的房市永远上涨，绝不下跌。但是2008年美国爆发次贷危机，导致外循环熄火。</p><h3 id="四、内循环"><a href="#四、内循环" class="headerlink" title="四、内循环"></a>四、内循环</h3><p>2008年的时候，美国的次贷危机爆发了两年，欧美国家的经济发展受到阻碍，手里没有钱了，自然要减少购买或者赊购，中国的出口开始减少，最终很多企业因为资金链断裂破产。因此出口对中国GDP的贡献从之前的10%下降到2.7%，在2009年进一步降低为-42.9%，从此我国外汇开始减少。</p><p>企业不挣钱了，自然会开始缩减生产规模，进行裁员。记得在2009年的时候香港的电视台还拍摄过广州火车站春节返乡的纪录片，大规模的人员开始返乡，国家如果再不出手，经济问题就会转化为社会问题。</p><p>既然外循环不行了，那就只能想办法提升内循环了，因此4万亿的基建来了，中国的经济发展也开始正式步入内循环发展阶段，其中2008年和2009年两年是一个过渡期。在2010年至今，你会发现中国修公路、建高铁、搞农村基础设施、建保障房，在这个过程中一旦经济开始下滑就房款房地产贷款和购房政策，努力挖掘房地产市场潜力，通过投资和消费带动工业需求，最终盘活了中国的经济。</p><p>但是通过政府为主，银行为辅，企业借款的方式大规模开启基建的方式提振内循环，将会导致3个知名的缺点。</p><h3 id="五、我国内循环引发的三个主要问题"><a href="#五、我国内循环引发的三个主要问题" class="headerlink" title="五、我国内循环引发的三个主要问题"></a>五、我国内循环引发的三个主要问题</h3><ul><li><p>问题1：基建是有周期的，大规模的刺激导致企业不计后果的加杠杆进行生产扩能，最终出现更大规模的产能过剩。</p><blockquote><p>例如：进行高铁线路建设需要购买大量的钢材，这样消耗了当前过剩的钢材，并且产生了更大的钢材需求，但是高铁线路修完后呢？更大规模的产能过剩出现了，再修一条，继续推高产能过剩？即使这样，你要明白，高铁总有修完的一天，并且你修建的高铁如果不能盈利，会对国家的财政造成极大的负担（这就是为什么国家批准高铁公司上市）。这样就开始进入恶性循环，最终这个气球会有兜不住的一天，在违背所有人的期望下”嘭”的炸开（日本的泡沫破碎、美国的次贷危机）。</p></blockquote></li><li><p>问题2：所有的企业都害怕自己错过大放水，拼命的加杠杆，造成企业债台高筑。</p><p>  <code>这个问题中说的企业，狭义指城建，广义指所有房地产相关企业</code></p><blockquote><p>企业的钱从哪里来，当然是银行提供的，银行提供的贷款可不是白用的。正所谓欠债还钱天经地义，借的钱总是要还的，可是我国很多基建不能产生收益啊，一个小县城负债7个亿就不提了。北京的高速、地铁等很多项目都是赔钱的，更何况其它二三四五线城市的基建。城建没钱了，怎么办呢？一般是有三种办法，第一继续加大杠杆发行衍生品种（本系列的文章不讨论此方法）；第二借更多的钱，这就像吸毒，停不下来；第三直接搞破，说我破产了，钱不还了（政府信用破灭，会引发更加严重的危机）。城建只能越借越多，最后多到利息都还不上了，然后其它提供原材料的企业因为无法收款，导致资金链断裂，开始破产、裁员，情况又向糟糕的方向发展了。中国的企业债务有多少呢？这个没有明确的答案，人大在2015年的时候做过一次调查研究，最后得出的结论是98%发债企业的利润根本无法偿还债务利息，在中国买债券，你是在赌博。</p></blockquote></li><li><p>问题3：实体经济受到致命打击，经济开始脱离实际，向虚拟化发展。</p><blockquote><p>这个问题大家应该很清楚了，制造业产能过剩，利润大幅下滑，房地产业高歌猛进，银行越来越不愿意将钱借给制造业，特别喜欢将钱借给”房”，这样房地产业进一步繁荣，制造业被扼杀。所有人都在想着怎么买房，如何将钱弄到房地产业中。这就造成了更加严重的产能过剩、负债高企、脱实就虚，内循环是一剂可行的药方，但副作用很可怕。因此2018年国家提出供给侧改革，已经是到了不改不行的阶段，不改就要出现社会动荡了。</p></blockquote></li></ul><p>后面还有一章，谈谈目前中国经济的情况。</p><h3 id="六、当前的的经济情况"><a href="#六、当前的的经济情况" class="headerlink" title="六、当前的的经济情况"></a>六、当前的的经济情况</h3><p>目前中国的经济情况是：外需不振、内需萎靡、投资下滑。</p><p>目前中国经济面临的三个问题出现时，可以通过外循环+内循环或者内循环的方式来平滑或者过渡吗？带动经济开始新的增长。</p><p>先说答案：恐怕不行。</p><p>接下来详细分析一下目前中国经济的状况。首先中国的产能过剩到底严重到什么程度，为什么我们没有直观的感受到物价下滑反而感觉物价在上涨呢？</p><p>翻一翻统计的数据可以知道，从2016年12月至2020年6月，中国重化工业就不存在不过剩的行业。既然原材料过剩这么多，那么跟我们生活积极相关的行业又怎么样呢？从图1-1中可以看出也是严重过剩。</p><p><img src="/2022/09/14/economy20220814/%E4%BA%A7%E8%83%BD%E8%BF%87%E5%89%A9.jpg" alt="产能过剩"></p><center> 图1-1 轻工业产能过剩情况</center><p>产品过剩了怎么办？前文我们已经给出了解决方案。无非是消费、投资和出口（不知道看到这里，你是不是能明白为什么一带一路了）。但是本节开篇就说了目前中国的经济情况是外需不振、内需萎靡、投资下滑。</p><p>现在的经济是什么情况呢？外需萎靡，内需不振，投资下滑。</p><h3 id="七、出口、消费、投资"><a href="#七、出口、消费、投资" class="headerlink" title="七、出口、消费、投资"></a>七、出口、消费、投资</h3><p>出口对应的是外贸，消费对应的是内需，投资对应基建。</p><p>首先我们分析一下出口。</p><p>从2008年的全球金融危机开始，这几年国际上就动荡不断，美国刚稳定了，欧洲债务危机又开始了，好不容易发达的国家消停了，结果新兴市场开始作妖了，在2017年终于可以出口气了，结果中国要顶不住了。美国衰退、川普上台后的神操作，导致我国从2009年至今出口都很低迷，国家眼看外循环不行，开始不断的强调提振内需。可是回头一看，差点没吓死，房地产业这个脱缰的野马差点将整个中国带入万丈深渊。</p><p>其次我们分析一下投资。</p><p>收到投资就不得不讲基建、城镇化。2009年之后，我们开启了大搞基建的内循环拉动经济，城镇化的进程也进一步加快，每个人都长出了一口气，中国的经济危机过去了，经济又开始突飞猛进。可是就在大家都在欢庆的时候，却忘了内循环的三大问题</p><p>从统计局公布的数据，我们可以看出，全社会固定资产投资的70%以上是制造业投资、基建投资和房地产投资，因此这三个投资能够增长，中国的经济才可以平稳健康的发展。</p><p>2008年就面临产品过剩的经济危机，国家4万亿的放水，也只是掩盖了问题，造就了虚假的繁荣，从2001年开始，制造业投资增速开始转向，从30%开始逐渐降低到2019年的3.1%，从数据可以看出，制造业投资对经济的增长，作用越来越小了。</p><p>基建就不用多说了，相信大家都已经经过城投债的普及了，目前基建对经济的拉动作用也越来越小了。既然制造业、基建都不行了，那我们就搞房地产吧，继续推动炒房来带动经济增长。目前中国的城镇化已经快要结束，此外我国的抚养比（老龄化问题）开始快速增长，现在房屋价格已经是富人的游戏了，跟普通消费者关系不大了，并且从2019年开始我国房地产投资增速也突破10%，加上城镇化的减缓，接下来房地产对经济的增长的作用，也将越来越小。</p><p>在上述三种困境前，国家提出了新基建希望能够发现新的经济增长引擎。但是新基建的放水规模远大于08年，但是其规模体量太小了。新能源、医药和尖端科技的规模体量都远超制造业、基建和房地产，但是这三个行业不是短时间可以开启的，需要经年累月的研发和积累，目前我国还有太多的路要走，可以说这三个也是远水解不了近渴。</p><p>八、消费可以化解目前中国的经济困境吗？</p><p>有经济学家提出：欧美国家的消费开始转移到自己国家内，那么我国可以通过增加本国国民的消费来拉动经济增长。说起来容易，做起来千难万难。</p><p>前文讲过，我国的消费是被动的，不像欧美国家是主动的，所以我们拉动消费需要出口和投资，这样就进入了一个死循环。</p><p>其实从2015年开始我们的人均实际可支配收入就长时间低于人均实际GDP增长率。换句话说，就是工资在降低，失业人员增加，全社会可供消费的工资总量增速加速下滑（这里如果再考虑贫富差距，结果会更可怕），但是我国的房价和房租要么横盘，要么增长，进一步挤压消费。总的来说，就是我国消费萎靡，无法消耗过剩产能。</p><h3 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h3><p>大家都知道我国大量放水，但是我国的CPI为什么没有大幅增长？因为统计局将房子移出统计范围了。因为我国有200多万亿的超发货币（绝对的世界之最，即使美国的无线QE也没有超过中国）被圈在房地产市场里面，甚至有人将房地产称为人民币的锚。正是因为房地产留住了大量的钱，所以中国没有中产，社会才能保持稳定。从这个角度说政府最希望的是房地产横盘，所以房地产下跌到一定程度就放点水滋润一下房地产让其暴涨一波。这种方式也早就了房地产神话，让所有的人都相信中国的房子不会下跌，大家会想尽一切办法，加杠杆将资金投入房地产，这样投资和消费会进一步萎缩。</p><p>泡沫终有破灭的时候，到时我们面临的不但是经济增长的停滞，还有巨量的货币涌向市场导致的通货膨胀，从而导致中国的经济出现滞胀。</p><hr><p> 转载链接 <a href="https://zhuanlan.zhihu.com/p/434423560">知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 社科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ebooks</title>
      <link href="/2022/08/02/ebooks/"/>
      <url>/2022/08/02/ebooks/</url>
      
        <content type="html"><![CDATA[<h2 id="搜书网站"><a href="#搜书网站" class="headerlink" title="搜书网站"></a>搜书网站</h2><h3 id="https-sobooks-net-books-18957-html"><a href="#https-sobooks-net-books-18957-html" class="headerlink" title="https://sobooks.net/books/18957.html"></a><a href="https://sobooks.net/books/18957.html">https://sobooks.net/books/18957.html</a></h3>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用rabbitMQ实现聊天消息的转发</title>
      <link href="/2022/06/18/rabbitMQ/"/>
      <url>/2022/06/18/rabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><h2 id="项目结构图"><a href="#项目结构图" class="headerlink" title="项目结构图"></a>项目结构图</h2><p><img src="/2022/06/18/rabbitMQ/2022-06-20_pro.png" alt="2022-06-20_pro"></p><h2 id="父pom文件"><a href="#父pom文件" class="headerlink" title="父pom文件"></a>父pom文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.spt&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cloud_mq&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;mq_rabbit&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;mq_rabbit02&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;mq_rabbit03_spring&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;cloud_mq&lt;/name&gt;</span><br><span class="line">    &lt;!-- FIXME change it to the project&#x27;s website --&gt;</span><br><span class="line">    &lt;url&gt;http://www.example.com&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--  因为是总项目 所以用dependencyManagement来管理  因为其他的子项目就不会来管理版本了了 可以直接引用 --&gt;</span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;!-- springboot的依赖--&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="子模块结构图"><a href="#子模块结构图" class="headerlink" title="子模块结构图"></a>子模块结构图</h2><p><img src="/2022/06/18/rabbitMQ/2022-06-20_model.png" alt="2022-06-20_model"></p><h2 id="子模块pom文件"><a href="#子模块pom文件" class="headerlink" title="子模块pom文件"></a>子模块pom文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;artifactId&gt;cloud_mq&lt;/artifactId&gt;</span><br><span class="line">    &lt;groupId&gt;com.spt&lt;/groupId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">  &lt;artifactId&gt;mq_rabbit&lt;/artifactId&gt;</span><br><span class="line">  &lt;name&gt;mq_rabbit&lt;/name&gt;</span><br><span class="line">  &lt;!-- FIXME change it to the project&#x27;s website --&gt;</span><br><span class="line">  &lt;url&gt;http://www.example.com&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="子模块配置文件"><a href="#子模块配置文件" class="headerlink" title="子模块配置文件"></a>子模块配置文件</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spirng-boot-rabbitmq</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtualHost:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><h3 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h3><ul><li><strong>host</strong> : rabbitMQ服务的地址</li><li><strong>port</strong> : rabbitMQ服务的端口 (5672为mq应用访问端口,15672为web访问端口)</li><li><strong>password</strong> : 密码</li><li><strong>username</strong> : 用户名</li><li><strong>virtualHost</strong> : 虚拟消息服务器 (每个VirtualHost相当于一个相对独立的RabbitMQ服务器；每个VirtualHost之间是相互隔离的，exchange、queue、message不能互通。 )</li></ul><h3 id="RabbitMQ配置参数详解"><a href="#RabbitMQ配置参数详解" class="headerlink" title="RabbitMQ配置参数详解:"></a>RabbitMQ配置参数详解:</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基础信息</span></span><br><span class="line"><span class="attr">spring.rabbitmq.host</span>: <span class="string">默认localhost</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>: <span class="string">默认5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>: <span class="string">用户名</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>: <span class="string">密码</span></span><br><span class="line"><span class="attr">spring.rabbitmq.virtual-host</span>: <span class="string">连接到代理时用的虚拟主机</span></span><br><span class="line"><span class="attr">spring.rabbitmq.addresses</span>: <span class="string">连接到server的地址列表（以逗号分隔），先addresses后host </span></span><br><span class="line"><span class="attr">spring.rabbitmq.requested-heartbeat</span>: <span class="string">请求心跳超时时间，0为不指定，如果不指定时间单位默认为妙</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-confirms</span>: <span class="string">是否启用【发布确认】，默认false</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-returns</span>: <span class="string">是否启用【发布返回】，默认false</span></span><br><span class="line"><span class="attr">spring.rabbitmq.connection-timeout</span>: <span class="string">连接超时时间，单位毫秒，0表示永不超时 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#SSL</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.enabled</span>: <span class="string">是否支持ssl，默认false</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.key-store</span>: <span class="string">持有SSL certificate的key store的路径</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.key-store-password</span>: <span class="string">访问key store的密码</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.trust-store</span>: <span class="string">持有SSL certificates的Trust store</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.trust-store-password</span>: <span class="string">访问trust store的密码</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.trust-store-type</span>=<span class="string">JKS：Trust store 类型.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.algorithm</span>: <span class="string">ssl使用的算法，默认由rabiitClient配置</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.validate-server-certificate</span>=<span class="string">true：是否启用服务端证书验证</span></span><br><span class="line"><span class="attr">spring.rabbitmq.ssl.verify-hostname</span>=<span class="string">true 是否启用主机验证</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#缓存cache</span></span><br><span class="line"><span class="attr">spring.rabbitmq.cache.channel.size</span>: <span class="string">缓存中保持的channel数量</span></span><br><span class="line"><span class="attr">spring.rabbitmq.cache.channel.checkout-timeout</span>: <span class="string">当缓存数量被设置时，从缓存中获取一个channel的超时时间，单位毫秒；如果为0，则总是创建一个新channel</span></span><br><span class="line"><span class="attr">spring.rabbitmq.cache.connection.size</span>: <span class="string">缓存的channel数，只有是CONNECTION模式时生效</span></span><br><span class="line"><span class="attr">spring.rabbitmq.cache.connection.mode</span>=<span class="string">channel: 连接工厂缓存模式：channel 和 connection</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Listener</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.type</span>=<span class="string">simple: 容器类型.simple或direct</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.auto-startup</span>=<span class="string">true: 是否启动时自动启动容器</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.acknowledge-mode</span>: <span class="string">表示消息确认方式，其有三种配置方式，分别是none、manual和auto；默认auto</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.concurrency</span>: <span class="string">最小的消费者数量</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.max-concurrency</span>: <span class="string">最大的消费者数量</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.prefetch</span>: <span class="string">一个消费者最多可处理的nack消息数量，如果有事务的话，必须大于等于transaction数量.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.transaction-size</span>: <span class="string">当ack模式为auto时，一个事务（ack间）处理的消息数量，最好是小于等于prefetch的数量.若大于prefetch， 则prefetch将增加到这个值</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.default-requeue-rejected</span>: <span class="string">决定被拒绝的消息是否重新入队；默认是true（与参数acknowledge-mode有关系）</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.missing-queues-fatal</span>=<span class="string">true 若容器声明的队列在代理上不可用，是否失败； 或者运行时一个多多个队列被删除，是否停止容器</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.idle-event-interval</span>: <span class="string">发布空闲容器的时间间隔，单位毫秒</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.retry.enabled</span>=<span class="string">false: 监听重试是否可用</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.retry.max-attempts</span>=<span class="string">3: 最大重试次数</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.retry.max-interval</span>=<span class="string">10000ms: 最大重试时间间隔</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.retry.initial-interval</span>=<span class="string">1000ms:第一次和第二次尝试传递消息的时间间隔</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.retry.multiplier</span>=<span class="string">1: 应用于上一重试间隔的乘数</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.retry.stateless</span>=<span class="string">true: 重试时有状态or无状态</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.acknowledge-mode</span>= <span class="string">ack模式</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.auto-startup</span>=<span class="string">true 是否在启动时自动启动容器</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.consumers-per-queue</span>= <span class="string">每个队列消费者数量.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.default-requeue-rejected</span>= <span class="string">默认是否将拒绝传送的消息重新入队.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.idle-event-interval</span>= <span class="string">空闲容器事件发布时间间隔.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.missing-queues-fatal</span>=<span class="string">false若容器声明的队列在代理上不可用，是否失败.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.prefetch</span>= <span class="string">每个消费者可最大处理的nack消息数量.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.retry.enabled</span>=<span class="string">false  是否启用发布重试机制.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.retry.initial-interval</span>=<span class="string">1000ms # Duration between the first and second attempt to deliver a message.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.retry.max-attempts</span>=<span class="string">3 # Maximum number of attempts to deliver a message.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.retry.max-interval</span>=<span class="string">10000ms # Maximum duration between attempts.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.retry.multiplier</span>=<span class="string">1 # Multiplier to apply to the previous retry interval.</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.direct.retry.stateless</span>=<span class="string">true # Whether retries are stateless or stateful.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Template</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.mandatory</span>: <span class="string">启用强制信息；默认false</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.receive-timeout</span>: <span class="string">receive() 操作的超时时间</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.reply-timeout</span>: <span class="string">sendAndReceive() 操作的超时时间</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.retry.enabled</span>=<span class="string">false: 发送重试是否可用 </span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.retry.max-attempts</span>=<span class="string">3: 最大重试次数</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.retry.initial-interva</span>=<span class="string">1000msl: 第一次和第二次尝试发布或传递消息之间的间隔</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.retry.multiplier</span>=<span class="string">1: 应用于上一重试间隔的乘数</span></span><br><span class="line"><span class="attr">spring.rabbitmq.template.retry.max-interval</span>=<span class="string">10000: 最大重试时间间隔</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考:<br>1.<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#integration-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#integration-properties</a><br>2.<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/html/common-application-properties.html">https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/html/common-application-properties.html</a></p><h1 id="springBoot整合rabbitMQ"><a href="#springBoot整合rabbitMQ" class="headerlink" title="springBoot整合rabbitMQ"></a>springBoot整合rabbitMQ</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>父模块引入spring-boot-dependencies确定版本后,子模块不写版本号,会使用默认版本<br><img src="/2022/06/18/rabbitMQ/2022-06-20_model_mvn.png" alt="2022-06-20_model_mvn"><h2 id="配置MQ"><a href="#配置MQ" class="headerlink" title="配置MQ"></a>配置MQ</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line">    <span class="comment">//fanout</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FANOUT_QUEUE1</span> <span class="operator">=</span> <span class="string">&quot;fanout.queue1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FANOUT_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;fanout.exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fanout模式</span></span><br><span class="line"><span class="comment">     * Fanout 就是我们熟悉的广播模式或者订阅模式，给Fanout交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(FANOUT_QUEUE1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(FANOUT_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">fanoutBinding1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>这里使用了rabbitMQ的fanout模式:<br><img src="/2022/06/18/rabbitMQ/2022-06-20_rabbit_fanout.png" alt="2022-06-20_rabbit_fanout"><blockquote><p><strong>Fanout</strong> :  这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的 所有队列中。系统中默认有些exchange 类型</p></blockquote><h2 id="发送者和接受者"><a href="#发送者和接受者" class="headerlink" title="发送者和接受者"></a>发送者和接受者</h2><h3 id="发送者代码"><a href="#发送者代码" class="headerlink" title="发送者代码:"></a>发送者代码:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutSender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String MSG_FROM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        MSG_FROM = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rabbitTemplate.convertAndSend(RabbitConfig.FANOUT_EXCHANGE, <span class="string">&quot;&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(MqMsgDto msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rabbitTemplate.convertAndSend(RabbitConfig.FANOUT_EXCHANGE, <span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收者代码"><a href="#接收者代码" class="headerlink" title="接收者代码:"></a>接收者代码:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutReceiver</span> &#123;</span><br><span class="line">    <span class="comment">// queues是指要监听的队列的名字</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = RabbitConfig.FANOUT_QUEUE1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveTopic1</span><span class="params">(MqMsgDto msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;【项目A,receiveFanout监听到消息】&quot;</span> + msg);</span><br><span class="line">        <span class="keyword">if</span> (!MSG_FROM.equals(msg.getFrom())) &#123;</span><br><span class="line">            <span class="comment">//mq转发--RECEIVE_MESSAGE--</span></span><br><span class="line">            System.out.println(<span class="string">&quot;项目A,mq转发--RECEIVE_MESSAGE--&quot;</span> + msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>请注意 <strong>MSG_FROM</strong> 该静态变量是一个标识,标识消息从哪个应用发出,在接收消息时,判断消息是否为”自己”发出的,是:不转发,否:转发</li></ul><h2 id="具体业务类"><a href="#具体业务类" class="headerlink" title="具体业务类"></a>具体业务类</h2><h3 id="api"><a href="#api" class="headerlink" title="api :"></a>api :</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SendMsgEvent sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/msg/send&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">snedMsg</span><span class="params">(<span class="meta">@RequestBody</span> MsgDto msg)</span> &#123;</span><br><span class="line">        <span class="type">MqMsgDto</span> <span class="variable">mqMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MqMsgDto</span>(MSG_FROM, msg);</span><br><span class="line">        sender.setMsg(mqMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息数据类"><a href="#消息数据类" class="headerlink" title="消息数据类"></a>消息数据类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgDto</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MsgDto</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MsgDto</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MsgDto&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;msg=&#x27;&quot;</span> + msg + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MQ数据传输类"><a href="#MQ数据传输类" class="headerlink" title="MQ数据传输类"></a>MQ数据传输类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqMsgDto</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="keyword">private</span> MsgDto mag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFrom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFrom</span><span class="params">(String from)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.from = from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MsgDto <span class="title function_">getMag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMag</span><span class="params">(MsgDto mag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mag = mag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MqMsgDto</span><span class="params">(String from, com.spt.chat.entity.MsgDto mag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.from = from;</span><br><span class="line">        <span class="built_in">this</span>.mag = mag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MqMsgDto&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;from=&#x27;&quot;</span> + from + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, mag=&quot;</span> + mag +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMsgEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    FanoutSender msgSender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(MqMsgDto msg)</span>&#123;</span><br><span class="line">        <span class="comment">//转发RECEIVE_MESSAGE</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A项目转发--RECEIVE_MESSAGE--消息&quot;</span>+msg);</span><br><span class="line">        <span class="comment">//将消息发送只mq</span></span><br><span class="line">        msgSender.sendMsg(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此,springBoot整合MQ部分完毕</p><h1 id="运行-amp-结果"><a href="#运行-amp-结果" class="headerlink" title="运行&amp;结果"></a>运行&amp;结果</h1><blockquote><p>同样的方式,创建子模块:mq_rabbit02,mq_rabbit03  (记得修改yml文件哟~~)</p></blockquote><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p><img src="/2022/06/18/rabbitMQ/2022-06-20_run.png" alt="2022-06-20_run"></p><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p><img src="/2022/06/18/rabbitMQ/2022-06-20_req_postman.png" alt="2022-06-20_req_postman"></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="mq-rabbit01"><a href="#mq-rabbit01" class="headerlink" title="mq_rabbit01"></a>mq_rabbit01</h3><blockquote><p>localhost:8001&#x2F;msg&#x2F;send请求到服务mq_rabbit上,mq_rabbit发送消息,监听消息,判断是”自己”发的后,不转发</p></blockquote><p><img src="/2022/06/18/rabbitMQ/2022-06-20_22-01.png" alt="2022-06-20_22-01"></p><h3 id="mq-rabbit02"><a href="#mq-rabbit02" class="headerlink" title="mq_rabbit02"></a>mq_rabbit02</h3><blockquote><p>mq_rabbit02,监听消息,判断消息不是”自己”发的后,转发</p></blockquote><p><img src="/2022/06/18/rabbitMQ/2022-06-20_22-02.png" alt="2022-06-20_22-02"></p><h3 id="mq-rabbit03"><a href="#mq-rabbit03" class="headerlink" title="mq_rabbit03"></a>mq_rabbit03</h3><blockquote><p>mq_rabbit03,监听消息,判断消息不是”自己”发的后,转发</p></blockquote><p><img src="/2022/06/18/rabbitMQ/2022-06-20_22-03.png" alt="2022-06-20_22-03"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的一些货物清单</title>
      <link href="/2022/06/14/goods/"/>
      <url>/2022/06/14/goods/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于月底要搬新家了,就要告别自己租了一年的房子了,租的房子里自己的购买的一些家具,家电,桌桌椅椅,花花草草,要给他们找个新主人了,欢迎各位前来围观…</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我的联系方式</span><br><span class="line"> - 微信:start-spt</span><br><span class="line"> - 电话:15311997163</span><br></pre></td></tr></table></figure><table><thead><tr><th>物品名</th><th>价格(元)</th></tr></thead><tbody><tr><td><a href="#img1">图一</a>,餐桌</td><td>40</td></tr><tr><td><a href="#img2">图二</a>,床(宽150cm)</td><td>100</td></tr><tr><td><a href="#img2">图二</a>,柜子</td><td>随床赠送,单买50</td></tr><tr><td><a href="#img2">图二</a>,椅子</td><td>60</td></tr><tr><td><a href="#img2">图二</a>,桌子</td><td>随床赠送,单买30</td></tr><tr><td><a href="#img3">图三</a>,床(宽120cm)</td><td>80 (附赠桌子,类似图二桌子)</td></tr><tr><td><a href="#img4">图四</a>,油烟机(美的)</td><td>400</td></tr><tr><td><a href="#img4">图四</a>,燃气灶(美的)</td><td>300</td></tr><tr><td><a href="#img5">图五</a>,橱柜(大的长160cm,小的长120)</td><td>540</td></tr><tr><td><a href="#img6">图六</a>,热水器(海尔&#x2F;60升)</td><td>380</td></tr><tr><td><a href="#img7">图七</a>,床(宽150cm)</td><td>100(赠送床头柜)</td></tr><tr><td>以上电器均有发票,九成新质量好,附近邻居可来家查看</td><td></td></tr></tbody></table><p><a id="img1">图一</a><br><img src="/2022/06/14/goods/1.jpg" alt="image-1"><br><a id="img2">图二</a><br><img src="/2022/06/14/goods/2.jpg" alt="image-2"><br><a id="img3">图三</a><br><img src="/2022/06/14/goods/3.jpg" alt="image-3"><br><a id="img4">图四</a><br><img src="/2022/06/14/goods/4.jpg" alt="image-4"><br><a id="img5">图五</a><br><img src="/2022/06/14/goods/5.jpg" alt="image-5"><br><a id="img6">图六</a><br><img src="/2022/06/14/goods/6.jpg" alt="image-6"><br><a id="img7">图七</a><br><img src="/2022/06/14/goods/7.jpg" alt="image-7"></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> goods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Hexo中使用本地图片</title>
      <link href="/2022/06/13/hexo-local-image/"/>
      <url>/2022/06/13/hexo-local-image/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>使用Hexo编写博文时，根据Hexo的官方文档使用起来不方便（无法直观地在本地markdown语法显现）。引用站外图片或图床时则不方便本地化操作。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用 hexo-asset-image 插件（hexo5版本以上建议使用 hexo-asset-image-for-hexo5 ）可以解决问题。</p><blockquote><p>经测试，hexo-asset-image-for-hexo5 插件在使用 Hexo 的 6.0 版本中有效。</p></blockquote><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>① 在hexo主目录安装插件，在bash中输入：npm install hexo-asset-image-for-hexo5 –save<br>② 在主目录的_config.yml文件中查找并修改post_asset_folder值为true：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>③ 在md文件的同级目录里创建同名文件夹，例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├─article</span><br><span class="line">├──test.png</span><br><span class="line">└─article.md</span><br></pre></td></tr></table></figure><p>④ 写法：在文章里即可使用<code>![](./article/test.png)</code>在本地显示图片test.png，同时在静态网页中也可以正常显示。</p><blockquote><p>注意事项：</p></blockquote><ul><li>1、创建文件夹名称要和md文件名称保持一致；</li><li>2、设置post_asset_folder: true后，若使用 hexo new 命令创建新博文时会自动创建同名文件夹；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE总结</title>
      <link href="/2022/06/13/javaSE/"/>
      <url>/2022/06/13/javaSE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、java基础"><a href="#一、java基础" class="headerlink" title="一、java基础"></a>一、java基础</h1><p>java 语言的特点：<strong>跨平台性</strong>：<strong>一次编译,到处运行write once,run anywhere</strong>。java程序是运行在jvm中的，不能操作体统有着不同平台的jvm.</p><p>jdk 包含了jre+开发工具集</p><p>jre 包含了jvm +javaSE标准类库</p><p><img src="/2022/06/13/javaSE/image-20211007194902014.png" alt="image-20211007194902014"></p><p><img src="/2022/06/13/javaSE/image-20211007200033099.png" alt="image-20211007200033099"></p><p>API：Application Programming Interface,应用程序编程接口。</p><h2 id="1-1、基本语法"><a href="#1-1、基本语法" class="headerlink" title="1.1、基本语法"></a>1.1、基本语法</h2><p>应用程序 &#x3D; 算法 + 数据结构</p><p><img src="/2022/06/13/javaSE/image-20220515150842061.png" alt="image-20220515150842061"></p><h2 id="1-2、数组"><a href="#1-2、数组" class="headerlink" title="1.2、数组"></a>1.2、数组</h2><blockquote><p>数组的理解</p></blockquote><p>数组Array,是多个相同类型数据按一定顺序排列的集合。并使用一个名字命名，通过编号的方式对这些数据进行统一管理</p><blockquote><p>数组特点</p></blockquote><ul><li>数组是有序排列的</li><li>数组属于引用数据类型的变量，数组的元素可以是基本数据类型，也可以是引用数据类型</li><li>创建数组对象会在内存中开辟一整块连续的内存空间</li><li>数组长度一旦确定，就不能修改</li></ul><blockquote><p>数组的分类</p></blockquote><ul><li>按照维数：一维数组、二维数组……</li><li>按照数组元素类型：基本数据类型元素的数组、引用数据类型的数组</li></ul><blockquote><p>数据结构</p></blockquote><p>1、数据与数据之间的逻辑关系：集合、一对一、一对多（二叉树）、多对多（社交网络）</p><p>2、数据的存储结构：线性表（比如：数组）、链表、栈、队列、树形结构：二叉树</p><h3 id="1-2-1一维数组"><a href="#1-2-1一维数组" class="headerlink" title="1.2.1一维数组"></a>1.2.1一维数组</h3><p><strong>一维数组的声明和初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;<span class="comment">//声明</span></span><br><span class="line">num = <span class="number">10</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;<span class="comment">//声明 + 初始化</span></span><br><span class="line"><span class="type">int</span>[] ids;<span class="comment">//声明</span></span><br><span class="line"><span class="comment">//1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行</span></span><br><span class="line">ids = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>&#125;;</span><br><span class="line"><span class="comment">//1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>[] arr4 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//类型推断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误方式</span></span><br><span class="line"><span class="comment">//int[] arr1 = new int[];</span></span><br><span class="line"><span class="comment">//int[5] arr2 = new int[5];</span></span><br><span class="line"><span class="comment">//int[] arr3 = new int[3]&#123;1,2,3&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>一维数组元素的引用</strong></p><p>通过角标的方式调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组的角标（或索引从0开始的，到数组的长度-1结束。</span></span><br><span class="line">names[<span class="number">0</span>] = <span class="string">&quot;王铭&quot;</span>;</span><br><span class="line">names[<span class="number">1</span>] = <span class="string">&quot;王赫&quot;</span>;</span><br><span class="line">names[<span class="number">2</span>] = <span class="string">&quot;张学良&quot;</span>;</span><br><span class="line">names[<span class="number">3</span>] = <span class="string">&quot;孙居龙&quot;</span>;</span><br><span class="line">names[<span class="number">4</span>] = <span class="string">&quot;王宏志&quot;</span>;<span class="comment">//charAt(0)</span></span><br></pre></td></tr></table></figure><p><strong>数组的属性：length</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(names.length);<span class="comment">//5</span></span><br><span class="line">System.out.println(ids.length);</span><br></pre></td></tr></table></figure><blockquote><p>说明： 数组一旦初始化，其长度就是确定的。arr.length 数组长度一旦确定，就不可修改</p></blockquote><p><strong>一维数组遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; names.length;i++)&#123;</span><br><span class="line">System.out.println(names[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一维数组元素默认初始化值</strong></p><ul><li>数组元素是整型：0</li><li>数组元素是浮点型：0.0</li><li>数组元素是char型：0或’\u0000’，而非’0’</li><li>数组元素是boolean型：false</li><li>数组元素是引用数据类型：null</li></ul><p><strong>一维数组的内存结构</strong></p><p><img src="/2022/06/13/javaSE/image-20220515194449091.png" alt="image-20220515194449091"></p><h3 id="1-2-2、二维数组"><a href="#1-2-2、二维数组" class="headerlink" title="1.2.2、二维数组"></a>1.2.2、二维数组</h3><p>数组属于引用数据类型 数组的元素也可以是引用数据类型 一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组。</p><p><strong>二维数组的声明和初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//一维数组</span></span><br><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">int</span>[][] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//动态初始化1</span></span><br><span class="line">String[][] arr2 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//动态初始化2</span></span><br><span class="line">String[][] arr3 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="comment">//也是正确的写法：</span></span><br><span class="line"><span class="type">int</span>[] arr4[] = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span>[] arr5[] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;<span class="comment">//类型推断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误方式</span></span><br><span class="line"><span class="comment">//String[][] arr4 = new String[][4];</span></span><br><span class="line"><span class="comment">//String[4][3] arr5 = new String[][];</span></span><br><span class="line"><span class="comment">//int[][] arr6 = new int[4][3]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>调用二维数组元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数说明：0：第几个元素，1：该元素下标</span></span><br><span class="line">System.out.println(arr1[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">//2</span></span><br><span class="line">System.out.println(arr2[<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">arr3[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line">System.out.println(arr3[<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">//null</span></span><br><span class="line">System.out.println(arr3[<span class="number">0</span>]);<span class="comment">//null</span></span><br></pre></td></tr></table></figure><p><strong>遍历二维数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr4.length;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr4[i].length;j++)&#123;</span><br><span class="line">System.out.print(arr4[i][j] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二维数组元素的默认初始化值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* 规定：二维数组分为外层数组的元素，内层数组的元素</span><br><span class="line">* <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line">* 外层元素：arr[<span class="number">0</span>],arr[<span class="number">1</span>]等</span><br><span class="line">* 内层元素：arr[<span class="number">0</span>][<span class="number">0</span>],arr[<span class="number">1</span>][<span class="number">2</span>]等</span><br><span class="line">* </span><br><span class="line">*   ⑤ 数组元素的默认初始化值 </span><br><span class="line">*   针对于初始化方式一：比如：<span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line">*      外层元素的初始化值为：地址值</span><br><span class="line">*      内层元素的初始化值为：与一维数组初始化情况相同</span><br><span class="line">*      </span><br><span class="line">*   针对于初始化方式二：比如：<span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br><span class="line">*   外层元素的初始化值为：<span class="literal">null</span></span><br><span class="line">*      内层元素的初始化值为：不能调用，否则报错。</span><br></pre></td></tr></table></figure><p><strong>二维数组内存结构</strong></p><p><img src="/2022/06/13/javaSE/image-20220515204417549.png" alt="image-20220515204417549"> </p><h3 id="1-2-3、数组的常见算法"><a href="#1-2-3、数组的常见算法" class="headerlink" title="1.2.3、数组的常见算法"></a>1.2.3、数组的常见算法</h3><p>1、数组的创建于元素的赋值</p><p>杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。</p><blockquote><p>杨辉三角</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.新建二位数组，动态初始化</span></span><br><span class="line"><span class="type">int</span>[][] yangHui = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][];</span><br><span class="line"><span class="comment">// 2.为二维数组赋值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; yangHui.length; i++) &#123;</span><br><span class="line">    yangHui[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 2.1为首末元素赋值</span></span><br><span class="line">    yangHui[i][<span class="number">0</span>] = yangHui[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 2.2为其余元素赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; yangHui[i].length - <span class="number">1</span>; j++) &#123;<span class="comment">//</span></span><br><span class="line">        yangHui[i][j] = yangHui[i - <span class="number">1</span>][j - <span class="number">1</span>] + yangHui[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.打印输出二维数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; yangHui.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; yangHui[i].length; j++) &#123;<span class="comment">// 第0个位置没有元素</span></span><br><span class="line">        System.out.print(yangHui[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、对于数值型的数组</p><p>最大值、最小值、总和、平均数等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.找到数组中的最大值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxArr</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxArr &lt; arr[i]) &#123;</span><br><span class="line">        maxArr = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;数组中的最大值为：&quot;</span> + maxArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.找到数组中的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">minArr</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (minArr &gt; arr[i]) &#123;</span><br><span class="line">        minArr = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;数组中的最小值为：&quot;</span> + minArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.找到数组中的平均数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    num += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;数组的平均数为：&quot;</span> + (num / arr.length));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.求总和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    num1 += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;数组的总和为：&quot;</span> + num1);</span><br></pre></td></tr></table></figure><p>3、数组的赋值与复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] str = &#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line">      <span class="comment">// 1.数组的赋值</span></span><br><span class="line">      String[] str1 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">      str1 = str;</span><br><span class="line">      str1[<span class="number">2</span>] = <span class="string">&quot;AA&quot;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">          System.out.print(str[i] + <span class="string">&quot; &quot;</span>);<span class="comment">//aa bb AA</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>赋值</strong></p><p>将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体。</p><p><img src="/2022/06/13/javaSE/image-20220515221658500.png" alt="image-20220515221658500"> </p><p><strong>复制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1数组的复制</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">    str1[i] = str[i];</span><br><span class="line">    System.out.print(str1[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过new的方式，给array2在堆空间中新开辟了数组的空间。将array1数组中的元素值一个一个的赋值到array2数组中。</p><p><img src="/2022/06/13/javaSE/image-20220515221804241.png" alt="image-20220515221804241"> </p><p><strong>4、数组元素的反转</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length / <span class="number">2</span>;i++)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[arr.length - i -<span class="number">1</span>];</span><br><span class="line">    arr[arr.length - i -<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = arr.length - <span class="number">1</span>;i &lt; j;i++,j--)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、数组中指定元素的查找：</strong></p><p><strong>线性查找</strong></p><p>实现思路：通过遍历的方式，一个一个的数据进行比较、查找。 适用性：具有普遍适应性</p><p><strong>二分查找</strong></p><p>实现思路：每次比较中间值，折半的方式检索。 适用性：（前提：数组必须有序）</p><h3 id="1-2-4、排序算法"><a href="#1-2-4、排序算法" class="headerlink" title="1.2.4、排序算法"></a>1.2.4、排序算法</h3><blockquote><p>十大排序算法</p></blockquote><ul><li>选择排序：<ul><li>直接选择排序、堆排序</li></ul></li><li>交换排序：<ul><li>冒泡排序、快速排序</li></ul></li><li>插入排序：<ul><li>直接插入排序、折半插入排序、希尔排序</li></ul></li><li>归并排序</li><li>桶排序</li><li>基数排序</li></ul><p>理解：</p><p> 1）衡量排序算法的优劣：</p><p> 时间复杂度、空间复杂度、稳定性</p><p>2）排序的分类：内部排序 与 外部排序（需要借助磁盘）</p><p>3）不同排序算法的时间复杂度</p><p><img src="/2022/06/13/javaSE/image-20220515225242922.png" alt="image-20220515225242922"> </p><blockquote><p>冒泡排序的实现</p><p><strong>需经过n-1轮排序</strong></p></blockquote><p><img src="/2022/06/13/javaSE/image-20220515231845127.png" alt="image-20220515231845127"></p><p><img src="/2022/06/13/javaSE/image-20220515232010978.png" alt="image-20220515232010978"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">21</span>, <span class="number">43</span>, <span class="number">64</span>, <span class="number">76</span>, <span class="number">878</span>, <span class="number">432</span>, <span class="number">21</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i -<span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;<span class="comment">//对比前后值大小，满足条件后交换位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/06/13/javaSE/image-20220515231544873.png" alt="image-20220515231544873"></p><blockquote><p>选择排序</p><p>每一次从待排序的数据元素中选出最小的一个元素，存放在序列的起始位置，然后再从剩余未排序元素中寻找到最小元素，然后放到已排序序列的末尾，以此类推</p><p><strong>特点：</strong>在排序中每一轮比较会把最小的数移到最前，所以相互比较的次数每一轮都会比前一轮少一次。</p></blockquote><p><img src="/2022/06/13/javaSE/image-20220515232723049.png" alt="image-20220515232723049"></p><h3 id="1-2-5、数据结构"><a href="#1-2-5、数据结构" class="headerlink" title="1.2.5、数据结构"></a>1.2.5、数据结构</h3><h3 id="1-2-6、Arrays工具类的使用"><a href="#1-2-6、Arrays工具类的使用" class="headerlink" title="1.2.6、Arrays工具类的使用"></a>1.2.6、Arrays工具类的使用</h3><blockquote><p>① 定义在java.util包下。 ② Arrays:提供了很多操作数组的方法。</p></blockquote><blockquote><p>使用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">21</span>, <span class="number">43</span>, <span class="number">542</span>, <span class="number">432</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr2[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">32</span>, <span class="number">43</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">76</span>, <span class="number">54</span>, <span class="number">68</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.Arrays.equals(arr1, arr2):判断数组是否相等</span></span><br><span class="line">System.out.println(Arrays.equals(arr1, arr2));</span><br><span class="line"><span class="comment">// 2.Arrays.toString(arr1):输出数组信息</span></span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.Arrays.fill(arr1, 2):将指定值填充到数组中</span></span><br><span class="line">Arrays.fill(arr1, <span class="number">2</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"><span class="comment">// 4.Arrays.sort(arr2):对数组进行排序</span></span><br><span class="line">Arrays.sort(arr2);</span><br><span class="line">System.out.println(Arrays.toString(arr2));</span><br><span class="line"><span class="comment">// 5.Arrays.binarySearch(arr2, 1):堆排序好的数组用二分法检索指定值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr2, <span class="number">1</span>);</span><br><span class="line">System.out.println(index);</span><br></pre></td></tr></table></figure><h3 id="1-2-7、数组常见异常"><a href="#1-2-7、数组常见异常" class="headerlink" title="1.2.7、数组常见异常"></a>1.2.7、数组常见异常</h3><p><strong>1、数组角标越界异常：ArrayIndexOutOfBoundsException</strong></p><p><strong>2、空指针异常：NullPointerException</strong></p><h2 id="1-3、面向对象三大特征"><a href="#1-3、面向对象三大特征" class="headerlink" title="1.3、面向对象三大特征"></a>1.3、面向对象三大特征</h2><h4 id="1-3-1、封装"><a href="#1-3-1、封装" class="headerlink" title="1.3.1、封装"></a>1.3.1、封装</h4><p>我们程序设计追求“高内聚，低耦合”</p><ul><li>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</li><li>低耦合：仅对外暴露少量的方法用于使用。</li></ul><p><strong>隐藏对象内部的复杂性，只对外公开简单的接口。</strong>便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露岀来。这就是封装性的设计思想。</p><blockquote><p><strong>封装性思想具体代码的体现</strong></p><p>1、将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//private属性私有化</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRadius</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRadius</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、不对外暴露的私有的方法</p><p>3、单例模式（将构造器私有化）</p><p>4、如果不希望类在包外被调用，可以将类设置为缺省的。</p></blockquote><p><strong>Java规定的四种权限修饰符</strong></p><p>通过对不同的方法属性设置不同的权限修饰符来达到对类进行封装的目的。</p><ul><li>权限从小到大顺序为：private &lt; 缺省 &lt; protected &lt; public</li><li>具体的修饰范围：</li></ul><table><thead><tr><th align="left">修饰符</th><th>类内部</th><th>同一个包</th><th>不同包的子类</th><th align="left">同一个工程</th></tr></thead><tbody><tr><td align="left">private</td><td>Yes</td><td></td><td></td><td align="left"></td></tr><tr><td align="left">（缺省）</td><td>Yes</td><td>Yes</td><td></td><td align="left"></td></tr><tr><td align="left">protected</td><td>Yes</td><td>Yes</td><td>Yes</td><td align="left"></td></tr><tr><td align="left">public</td><td>Yes</td><td>Yes</td><td>Yes</td><td align="left">Yes</td></tr></tbody></table><p><img src="/2022/06/13/javaSE/image-20220517001319208.png" alt="image-20220517001319208"> </p><p><strong>权限修饰符可用来修饰的结构说明</strong>：</p><ul><li>4种权限都可以用来修饰<strong>类的内部结构</strong>：属性、方法、构造器、内部类</li><li><strong>修饰类</strong>，只能使用：缺省、public</li></ul><h4 id="1-3-2、继承"><a href="#1-3-2、继承" class="headerlink" title="1.3.2、继承"></a>1.3.2、继承</h4><blockquote><p>引入继承的好处：</p></blockquote><ul><li>减少了代码的冗余，提高了代码的复用性</li><li>便于功能的扩展</li><li>为之后多态性的使用，提供了前提</li></ul><p><img src="/2022/06/13/javaSE/image-20220517001655002.png" alt="image-20220517001655002"> </p><blockquote><p>继承性的格式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125;</span><br><span class="line"> *    A:子类、派生类、subclass</span><br><span class="line"> *    B:父类、超类、基类、superclass</span><br></pre></td></tr></table></figure><p>判断是否要进行继承：A is a B,若成立，则B继承A</p><blockquote><p>子类继承父类后有哪些不同</p></blockquote><ul><li><p>子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。</p></li><li><p>子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。</p></li></ul><blockquote><p>继承性说明</p></blockquote><ol><li>一个类可以被多个子类继承。</li><li>Java中类的单继承性：一个类只能有一个父类</li><li>子父类是相对的概念。</li><li>子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类</li><li>子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75580d6fd0a44c9d81a15a9efd937ea1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200331090341980"> </p><p><strong>Object类</strong></p><p>是Java中所有类的父类，类似于二叉树中的根节点，定义了一些通用的方法。</p><ol><li>如果我们没显式的声明一个类的父类的话，则此类继承于java.lang.Object类</li><li>所的java类（除java.lang.Object类之外都直接或间接的继承于java.lang.Object类</li><li>意味着，所的java类具有java.lang.Object类声明的功能。</li><li>java.lang.Object类中定义的一些方法</li></ol><p><img src="/2022/06/13/javaSE/image-20220517002424679.png" alt="image-20220517002424679"> </p><blockquote><p>java.lang.Object</p></blockquote><ol><li>Object类是所Java类的根父类</li><li>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类</li><li>Object类中的功能(属性、方法)就具通用性。</li></ol><ul><li><p>属性：无</p></li><li><p>方法：equals() &#x2F; toString() &#x2F; getClass() &#x2F;hashCode() &#x2F; clone() &#x2F; finalize()</p><p>wait() 、 notify()、notifyAll()</p></li></ul><ol><li>Object类只声明了一个空参的构造器</li><li>数组也作为 Object类的子类出现，可以调用 Object类中声明的方法</li></ol><blockquote><p>equals()</p></blockquote><ul><li>是一个方法，而非运算符</li><li>只能适用于引用数据类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>使用说明</strong></p><p>Object类中定义的equals()和&#x3D;&#x3D;的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p><p>像&#x3D;&#x3D;String、Date、File、包装类&#x3D;&#x3D;等都重写了Object类中的equals()方法。&#x3D;&#x3D;重写&#x3D;&#x3D;以后，比较的不是两个引用的地址是否相同，而是&#x3D;&#x3D;比较两个对象的”实体内容”是否相同&#x3D;&#x3D;。</p><p>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对Object类中的equals()进行重写.</p><p>重写的原则：比较两个对象的实体内容是否相同.</p><p><strong>&#x3D;&#x3D; ：运算符</strong></p><ol><li><p>可以使用在基本数据类型变量和引用数据类型变量中</p></li><li><p>如果比较的是基本数据类型变量：</p><p>比较两个变量保存的数据是否相等。（不一定类型要相同）</p></li><li><p>如果比较的是引用数据类型变量：</p><p>比较两个对象的地址值是否相同,即两个引用是否指向同一个对象实体</p></li></ol><blockquote><p>toString()方法</p></blockquote><p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()方法</p><p>Object类中toString()的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回”实体内容”信息。</p><p>自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Customer [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>子类对象实例化的全过程</p></blockquote><p><strong>从结果上看：继承性</strong></p><p>子类继承父类以后，就获取了父类中声明的属性或方法。 创建子类的对象，在堆空间中，就会加载所父类中声明的属性。</p><p><strong>从过程上看：</strong></p><p>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，…直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48a24b48169f428aa8328916508e7dba~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200331090544208"> </p><p><strong>强调说明：</strong></p><p>虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7579cbffeba4bb5aa7b689b1b91d6a4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200328171148983"> </p><h4 id="1-3-3、多态"><a href="#1-3-3、多态" class="headerlink" title="1.3.3、多态"></a>1.3.3、多态</h4><blockquote><p>多态性的理解</p></blockquote><p>可以理解为一个事物的多种形态。比如数据库的连接方式，我们定义好了数据库的连接，也规定了连接时的步骤，但是我们并不知道用户会采用什么数据库，在没有多态以前我们只能针对不同的数据库写不同的连接方法，而有了多态以后我们只需要定义好数据库的类并书写好连接方法，让所有的数据库继承数据库类并重写数据库连接方法。</p><p>这样我们在调用的时候只需要通过声明数据库类并指向数据库的子类的方式，<strong>（即数据库类的引用指向继承了数据库类的具体实现类的对象）</strong>就可以进行数据库连接。而不是需要针对不同的数据库书写不同的连接方式。</p><blockquote><p>何为多态</p></blockquote><p>对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</p><p>编译时和运行时类型不一致，产生了多态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure><blockquote><p>多态性的使用</p></blockquote><p>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</p><p>总结：编译，看左边；运行，看右边。</p><p>对象的多态：在Java中，子类的对象可以替代父类的对象使用</p><ul><li>一个变量只能有一种确定的数据类型</li><li>一个引用类型变量可能指向（引用）多种不同类型的对象</li></ul><blockquote><p>&#x3D;&#x3D;多态性的使用前提&#x3D;&#x3D;</p></blockquote><p>**① 类的继承关系 **</p><p><strong>② 方法的重写</strong></p><blockquote><p>多态应用举例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">举例一：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Animal animal)</span>&#123;<span class="comment">//Animal animal = new Dog();</span></span><br><span class="line">animal.eat();</span><br><span class="line">animal.shout();</span><br><span class="line">&#125;</span><br><span class="line">举例二：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">举例三：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Driver</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doData</span><span class="params">(Connection conn)</span>&#123;<span class="comment">//conn = new MySQlConnection(); / conn = new OracleConnection();</span></span><br><span class="line"><span class="comment">//规范的步骤去操作数据</span></span><br><span class="line"><span class="comment">//conn.method1();</span></span><br><span class="line"><span class="comment">//conn.method2();</span></span><br><span class="line"><span class="comment">//conn.method3();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多态性使用注意点</p></blockquote><ul><li>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</li><li>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就&#x3D;&#x3D;不能&#x3D;&#x3D;再访问子类中添加的属性和方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">User</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">manTest</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;man……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Man</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        man.testUser();</span><br><span class="line">        man.manTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就==不能==再访问子类中添加的属性和方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">man2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        man2.testUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多态使用总结</p></blockquote><ul><li><p>多态的作用：提高了代码的通用性，常称作接口重用</p></li><li><p>使用前提：①需要存在继承或者实现关系 ②有方法的重写</p></li><li><p>成员方法：</p><ul><li>编译时：要查看引用变量所声明的类中是否有所调用的方法</li><li>运行时：调用实际new的对象所属的类中的重写方法</li></ul></li><li><p>成员变量：不具备多态性，只看引用变量所声明的类</p></li></ul><blockquote><p>关于向上转型与向下转型</p></blockquote><p>向上转型：多态</p><p><strong>为什么使用向下转型</strong></p><p>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型。</p><p><strong>如何实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用强制类型转换符：()</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"></span><br><span class="line">Man m1=（Man）p2；<span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure><p><strong>使用时的注意点：</strong></p><p>① 使用强转时，可能出现ClassCastException的异常。</p><p>② 为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</p><p>③ 只有对象A是B的子类实例化对象或者在下层的子类，才能向下转型</p><p><strong>instanceof的使用</strong></p><p>① a instanceof A:&#x3D;&#x3D;判断对象a&#x3D;&#x3D;是否是&#x3D;&#x3D;类A的实例&#x3D;&#x3D;。如果是，返回true；如果不是，返回false。</p><p>② 如果 a instanceof A返回true,则 a instanceof B也返回true.其中，类B是类A的父类。</p><p>③ 要求a所属的类与类A必须是子类和父类的关系，否则编译错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        <span class="type">Man</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(man <span class="keyword">instanceof</span> Man);<span class="comment">//true</span></span><br><span class="line">        System.out.println(man <span class="keyword">instanceof</span> User);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//说明User是Man的父类</span></span><br></pre></td></tr></table></figure><h2 id="1-4、异常处理"><a href="#1-4、异常处理" class="headerlink" title="1.4、异常处理"></a>1.4、异常处理</h2><h3 id="1-4-1、异常的定义"><a href="#1-4-1、异常的定义" class="headerlink" title="1.4.1、异常的定义"></a>1.4.1、异常的定义</h3><p>在Java语言中，将程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错误不是异常）</p><blockquote><p>异常的体系结构</p></blockquote><p><code>Error</code>： Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：堆栈溢出 <code>StackOverflowError</code> 和OOM。一般不编写针对性的代码进行处理。</p><p><code>Exception</code>：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。如：</p><ul><li>空指针访问</li><li>试图读取不存在的文件</li><li>网络连接中断</li><li>数组角标越界</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">异常的体系结构</span><br><span class="line"> * java.lang.Throwable</span><br><span class="line"> * |-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line"> * |-----java.lang.Exception:可以进行异常的处理</span><br><span class="line"> * |------编译时异常(checked)不会生成字节码文件</span><br><span class="line"> * |-----IOException</span><br><span class="line"> * |-----FileNotFoundException</span><br><span class="line"> * |-----ClassNotFoundException</span><br><span class="line"> * |------运行时异常(unchecked,RuntimeException)</span><br><span class="line"> * |-----NullPointerException<span class="comment">//空指针异常</span></span><br><span class="line"> * |-----ArrayIndexOutOfBoundsException<span class="comment">//数组角标越界</span></span><br><span class="line"> * |-----ClassCastException<span class="comment">//类型转化异常</span></span><br><span class="line"> * |-----NumberFormatException<span class="comment">//编码格式异常</span></span><br><span class="line"> * |-----InputMismatchException<span class="comment">//输入不匹配</span></span><br><span class="line"> * |-----ArithmeticException<span class="comment">//算术异常</span></span><br></pre></td></tr></table></figure><p><strong>java中异常类的继承关系</strong></p><p><img src="/2022/06/13/javaSE/image-20220516011754023.png" alt="image-20220516011754023"> </p><blockquote><p>按照异常发生的时间可以分成两类</p></blockquote><ul><li><p>编译时异常：执行 <code>javac.exe</code> 命令时，可能出现的异常：</p><p>指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常对于这类异常，如果程序不处理，可能会带来意想不到的结果。</p></li><li><p>运行时异常：执行 <code>java.exe</code> 命令时，出现的异常：</p><p>指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。 <code>java. lang. Runtime Exception</code> 类及它的子类都是运行时异常。对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。</p></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9c094c49e1441e38d8ed870f94ac9ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200403162029470"> </p><blockquote><p>常见异常类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line"><span class="comment">//ArithmeticException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    System.out.println(a / b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputMismatchException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">    System.out.println(score);</span><br><span class="line"></span><br><span class="line">    scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NumberFormatException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ClassCastException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line">    <span class="comment">//int[] arr = new int[10];</span></span><br><span class="line">    <span class="comment">//System.out.println(arr[10]);</span></span><br><span class="line">    <span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NullPointerException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//int[] arr = null;</span></span><br><span class="line">    <span class="comment">//System.out.println(arr[3]);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    str = <span class="literal">null</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line">    <span class="comment">//FileInputStream fis = new FileInputStream(file);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//int data = fis.read();</span></span><br><span class="line">    <span class="comment">//while(data != -1)&#123;</span></span><br><span class="line">    <span class="comment">//System.out.print((char)data);</span></span><br><span class="line">    <span class="comment">//data = fis.read();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//fis.close();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2、异常的处理"><a href="#1-4-2、异常的处理" class="headerlink" title="1.4.2、异常的处理"></a>1.4.2、异常的处理</h3><p>**过程一：”抛”**程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。</p><p>关于异常对象的产生：</p><ul><li>系统自动生成的异常对象</li><li>手动的生成一个异常对象，并抛出（<code>throw</code>）</li></ul><p>**过程二：”抓”**可以理解为异常的处理方式：① <code>try-catch-finally</code> ② <code>throws</code></p><blockquote><p>2.异常处理方式一：try-catch-finally</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的代码</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式3</span></span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//一定会执行的代码</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>使用说明</strong></p><ul><li><p><code>finally</code> 是可选的。</p></li><li><p>使用 <code>try</code> 将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去 <code>catch</code> 中进行匹配</p></li><li><p>一旦 <code>try</code> 中的异常对象匹配到某一个 <code>catch</code> 时，就进入 <code>catch</code> 中进行异常的处理。一旦处理完成，就跳出当前的 <code>try-catch</code> 结构（在没写 <code>finally</code> 的情况。继续执行其后的代码）</p></li><li><p><code>catch</code>中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓；<code>catch</code>中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则会报错</p></li><li><p>常用的异常对象处理的方式： ① <code>String getMessage()</code> ② <code>printStackTrace()</code></p></li><li><p>在<code>try</code> 结构中声明的变量，再出了 <code>try</code> 结构以后，就不能再被调用</p></li><li><p><code>try-catch-finally</code> 结构可以嵌套</p></li></ul><p><strong>如何看待代码中的编译时异常和运行时异常？</strong></p><ul><li><p>使用 <code>try-catch-finally</code> 处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用 <code>try-catch-finally</code> 将一个编译时可能出现的异常，延迟到运行时出现。</p></li><li><p>开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写 <code>try-catch-finally</code> 了。但是针对于编译时异常，一定要考虑异常的处理。</p></li></ul><p><strong>finally的再说明：</strong></p><ul><li><p><code>finally</code> 是可选的</p></li><li><p><code>finally</code> 中声明的是一定会被执行的代码。即使catch中又出现异常了，<code>try</code> 中包含 <code>return</code> 语句，或者<code>catch</code>中 <code>return</code> 包含语句等情况，<code>finally</code> 中的代码也会被执行。</p></li><li><p>像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放的代码，就需要声明在 <code>finally</code> 中。</p></li></ul><blockquote><p>异常处理方式二</p></blockquote><p><code>throws + 异常类型</code> 写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。 一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足 <code>throws</code> 后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</p><blockquote><p>二者处理方式对比</p></blockquote><p><code>try-catch-finally</code> 真正的将异常给处理掉了。 <code>throws</code> 的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。</p><blockquote><p>开发中如何选择两种处理方式</p></blockquote><ul><li><p>如果父类中被重写的方法没 <code>throws</code> 方式处理异常，则子类重写的方法也不能使用 <code>throws</code>，意味着如果子类重写的方法中异常，必须使用 <code>try-catch-finally</code> 方式处理。</p></li><li><p>执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用<code>throws</code> 的方式进行处理。而执行的方法a可以考虑使用 <code>try-catch-finally</code> 方式进行处理。</p></li></ul><h3 id="1-4-3、手动抛出异常对象"><a href="#1-4-3、手动抛出异常对象" class="headerlink" title="1.4.3、手动抛出异常对象"></a>1.4.3、手动抛出异常对象</h3><blockquote><p>使用说明</p></blockquote><p>在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的 <code>throw</code> 一个异常类的对象。</p><blockquote><p>throw和throws的区别</p></blockquote><p><code>throw</code> 和 <code>throws</code>区别： <code>throw</code> 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。 <code>throws</code> 属于异常处理的一种方式，声明在方法的声明处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//手动抛出异常对象</span></span><br><span class="line">            <span class="comment">//throw new RuntimeException(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line">            <span class="comment">//throw new Exception(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;不能输入负数&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-4、自定义异常类"><a href="#1-4-4、自定义异常类" class="headerlink" title="1.4.4、自定义异常类"></a>1.4.4、自定义异常类</h3><blockquote><p>如何自定义异常类</p></blockquote><ul><li>继承于现的异常结构：<code>RuntimeException 、Exception</code></li><li>提供全局常量：<code>serialVersionUID</code>（对类的唯一标识）</li><li>提供重载的构造器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7034897193246939L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5、JAVA类"><a href="#1-5、JAVA类" class="headerlink" title="1.5、JAVA类"></a>1.5、JAVA类</h2><h3 id="1-5-1、类和对象"><a href="#1-5-1、类和对象" class="headerlink" title="1.5.1、类和对象"></a>1.5.1、类和对象</h3><p>类中主要包括五种结构：属性、方法、构造器、代码块、内部类</p><blockquote><p>1、面向对象与面向过程</p></blockquote><ul><li>面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。</li><li>面向过程：强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做。</li></ul><blockquote><p>2、类和对象的关系</p></blockquote><p>类：对一类事物的描述，是抽象的，概念上的定义</p><p>对象：是实际存在的该类事物的每个个体，因而也称为实例。</p><p><code>面向对象程序设计的重点是类的设计，设计类就是设计类的成员。 二者的关系：对象，是由类new出来的，派生出来的</code></p><blockquote><p>3、面向对象思想实现的规则</p></blockquote><ol><li>创建类，设计类的成员</li><li>创建类的对象</li><li>通过<code>对象.属性</code> 或 <code>对象.方法</code>调用对象的结构</li></ol><p><strong>补充：</strong></p><ul><li>属性 &#x3D; 成员变量 &#x3D; field &#x3D; 域、字段</li><li>方法 &#x3D; 成员方法 &#x3D; 函数 &#x3D; method</li><li>创建类的对象 &#x3D; 类的实例化 &#x3D; 实例化类</li></ul><blockquote><p>4、对象的创建与对象的内存解析</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> p1;<span class="comment">//没有新创建一个对象，共用一个堆空间中的对象实体。</span></span><br><span class="line"><span class="comment">/*说明：</span></span><br><span class="line"><span class="comment">*如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的）</span></span><br><span class="line"><span class="comment">*意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>素组对象内存解析</strong>：</p><p><img src="/2022/06/13/javaSE/image-20220517232036783.png" alt="image-20220517232036783"> </p><p><strong>对象内存解析</strong></p><p><img src="/2022/06/13/javaSE/image-20220517232119741.png" alt="image-20220517232119741"> </p><blockquote><p>5、JVM内存结构</p></blockquote><p>编译完源程序后，生成一个或多个字节码文件，我们使用JVM中类的加载器和解释器，对生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。</p><p><img src="/2022/06/13/javaSE/image-20220517232428996.png" alt="image-20220517232428996"></p><p>&#x3D;&#x3D;虚拟机栈&#x3D;&#x3D;：即为平时提到的栈结构。【我们将局部变量存储到栈结构中】</p><p>&#x3D;&#x3D;虚拟机堆&#x3D;&#x3D;：我们将new出来的结构【比如：数组，对象】加载到堆空间</p><p><strong>补充：</strong></p><p>对象的属性【非static的】加载在堆空间</p><p>方法区：类的加载信息、常量池、静态域</p><blockquote><p>6、匿名对象</p></blockquote><p>我们创建的对象，没有显示的赋给一个变量名，即为匿名对象</p><p><strong>特点：</strong>匿名对象只能调用一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().sendEmail();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().playGame();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().price = <span class="number">1999</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().showPrice();<span class="comment">//0.0</span></span><br></pre></td></tr></table></figure><p>适用场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PhoneMall</span> <span class="variable">mall</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneMall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象的使用</span></span><br><span class="line">mall.show(<span class="keyword">new</span> <span class="title class_">Phone</span>());</span><br><span class="line">其中，</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneMall</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Phone phone)</span>&#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">        phone.playGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>7、万物皆对象</p></blockquote><p>在Java语言范畴中，我们将功功能、结构等封装到类中，通过类的实例化，来调用具体功能的结构。</p><ul><li>Scanner,String等</li><li>文件：File</li><li>网络资源：URL</li></ul><p>涉及到Java语言与前端HTML,后端数据库交互时，前后端的结构在JAVA层面交互时，都体现为类、对象。</p><h3 id="1-5-2、类的结构之一：属性"><a href="#1-5-2、类的结构之一：属性" class="headerlink" title="1.5.2、类的结构之一：属性"></a>1.5.2、类的结构之一：属性</h3><blockquote><p>1、属性vs局部变量</p><blockquote><p>相同点</p></blockquote><ul><li>定义变量的格式：数据类型 变量名 &#x3D; 变量值</li><li>先声明，后使用</li><li>变量都其对应的作用域</li></ul><blockquote><p>不同点：</p></blockquote><p>1.2.1 在类中声明的位置的不同</p><ul><li>属性：直接定义在类的一对{}内</li><li>局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量。</li></ul><p>1.2.2 关于权限修饰符的不同</p><ul><li>属性：可以在声明属性时，指明其权限，使用权限修饰符。<ul><li>常用的权限修饰符：private、public、缺省、protected —&gt;封装性</li><li>目前，声明属性时，使用缺省就可以。</li></ul></li><li>局部变量：不可以使用权限修饰符。</li></ul><p>1.2.3 默认初始化值的情况：</p><ul><li><strong>属性</strong>：类的属性，根据其类型，都默认初始化值。<ul><li>整型（byte、short、int、long：0）</li><li>浮点型（float、double：0.0）</li><li>字符型（char：0 （或’\u0000’））</li><li>布尔型（boolean：false）</li><li>引用数据类型（类、数组、接口：null）</li></ul></li><li><strong>局部变量</strong>：没默认初始化值。<ul><li>意味着，我们在调用局部变量之前，一定要显式赋值。</li><li>特别地：形参在调用时，我们赋值即可。</li></ul></li></ul><p>1.2.4 在内存中加载的位置：</p><ul><li>属性：加载到堆空间中 （非static）</li><li>局部变量：加载到栈空间</li></ul></blockquote><hr><blockquote><p>变量的分类</p></blockquote><ul><li>方式一：按照数据类型<ul><li>基本数据类型</li><li>引用数据类型</li></ul></li></ul><p><img src="/2022/06/13/javaSE/image-20220517235950220.png" alt="image-20220517235950220"> </p><ul><li>方式二：按照在类中声明的位置<ul><li>成员变量</li><li>局部变量</li></ul></li></ul><p><img src="/2022/06/13/javaSE/image-20220518000118400.png" alt="image-20220518000118400"> </p><h3 id="1-5-3、类的结构之二：方法"><a href="#1-5-3、类的结构之二：方法" class="headerlink" title="1.5.3、类的结构之二：方法"></a>1.5.3、类的结构之二：方法</h3><p>定义：描述类应该具有的功能。</p><blockquote><p>1、方法举例</p></blockquote><p><strong>1.1 JDK中的方法：</strong></p><ul><li><p>Math类：<code>sqrt()</code> <code>random()</code> …</p></li><li><p>&#96;&#96;&#96;<br>Scanner类：<code>nextXxx()</code> …</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  Arrays类：`sort()`    `binarySearch()`    `toString()`     `equals()`   ...</span><br><span class="line">  </span><br><span class="line">  复制代码</span><br></pre></td></tr></table></figure></li></ul><p><strong>1.2 自定义的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.printly(<span class="string">&quot;我要吃饭！！！&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getNation</span><span class="params">(String nation)</span>&#123;</span><br><span class="line">     System.out.printly(<span class="string">&quot;当前地点为&quot;</span> + nation);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>1.3 方法的声明：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 返回值类型  方法名(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">方法体</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、方法的说明</p></blockquote><ul><li>返回值类型：</li></ul><p><strong>如果方法有返回值</strong>，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用return关键字来返回指定类型的变量或常量：<code>return 数据</code>。</p><p><strong>如果方法没返回值</strong>，则方法声明时，使用void来表示。通常，没返回值的方法中，就不需要使用return。如果使用的话，只能使用 <code>return;</code> 表示结束此方法的意思。</p><ul><li><p>命名规范</p><ul><li>属于标识符，遵循标识符的规则和规范，“见名知意”</li><li>方法名应遵循小驼峰命名 <code>aaaBbbCcc</code></li><li>方法名最好使用英文单词，不要使用拼音或者缩写</li><li>更多规范要求请参考《Java开发手册》</li></ul></li><li><p>形参列表</p><ul><li><p>方法可以声明0个，1个，或多个形参。</p><p>也可以使用可变形参，但可变形参必须放到最后，详细说明请查看本章第五部分。</p><p>格式：<code>数据类型1 形参1</code> <code>数据类型2 形参2</code> …..</p></li></ul></li><li><p>方法体</p></li></ul><p>是方法中功能的体现，通过循环分支、条件判断等语句完成复杂的逻辑关系。</p><p>方法中可以调用其他方法，同类中可以直接调用，不同类中通过类的实例化对象调用。</p><blockquote><p>3、方法的使用</p></blockquote><ul><li>同类中的方法可以直接调用当前类的属性或方法，不同类中通过类的实例化对象调用。</li><li>特殊的：方法A中又调用了自身—递归方法。（自身调用）</li></ul><blockquote><p>4、重载</p></blockquote><p><strong>概念</strong>：在同一个类中，允许存在一个以上的同名方法，只要它们的&#x3D;&#x3D;参数个数&#x3D;&#x3D;或者&#x3D;&#x3D;参数类型&#x3D;&#x3D;不同即可。</p><p><strong>构成重载实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举例一：Arrays类中重载的sort() / binarySearch()；PrintStream中的println()</span></span><br><span class="line"><span class="comment">// 举例二：</span></span><br><span class="line"><span class="comment">// 如下的4个方法构成了重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(<span class="type">double</span> d1,<span class="type">double</span> d2)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(String s ,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> i,String s)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;不&#x3D;&#x3D;构成重载实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如下的3个方法不能与上述4个方法构成重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重载方法判断</strong>：</p><p><strong>如何判断是否构成方法重载？</strong></p><p>严格按照定义判断：两同一不同。跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系！</p><p><strong>如何确定类中某一个方法的调用：</strong></p><p>①方法名 —&gt; ②参数列表</p><blockquote><p>5、可变个数形参方法</p></blockquote><p>JDK 5.0新增的内容</p><p>JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void test(int a， String[] books);</span><br></pre></td></tr></table></figure><p>JDK 5.0以后：采用可变个数形参来定义方法，传入多个同一类型变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void test(int a， String ... books);</span><br></pre></td></tr></table></figure><p>可变个数形参的格式：<code>数据类型 ... 变量名</code></p><p>当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，…..</p><p>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</p><p>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</p><p>可变个数形参在方法的形参中，<em><strong>必须声明在末尾。</strong></em></p><p>可变个数形参在方法的形参中***,最多只能声明一个可变形参***。</p><p><strong>举例说明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show(String)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String ... strs)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show(String ... strs)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不能与上一个方法同时存在</span></span><br><span class="line"><span class="comment">//  public void show(String[] strs)&#123;</span></span><br><span class="line"><span class="comment">//      </span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">// 调用时：可变形参与数组类似</span></span><br><span class="line">test.show(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">test.show(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">test.show();</span><br><span class="line"></span><br><span class="line">test.show(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>6、java值传递机制</p></blockquote><p><strong>针对&#x3D;&#x3D;方法内&#x3D;&#x3D;变量的赋值举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;***********基本数据类型：****************&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">n = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;***********引用数据类型：****************&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Order</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">o1.orderId = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Order</span> <span class="variable">o2</span> <span class="operator">=</span> o1;<span class="comment">//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;o1.orderId = &quot;</span> + o1.orderId + <span class="string">&quot;,o2.orderId = &quot;</span> +o2.orderId);</span><br><span class="line"></span><br><span class="line">o2.orderId = <span class="number">1002</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;o1.orderId = &quot;</span> + o1.orderId + <span class="string">&quot;,o2.orderId = &quot;</span> +o2.orderId);</span><br></pre></td></tr></table></figure><blockquote><p>说明：如果变量是基本数据类型，此时赋值的是变量所保存的数据值。 如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</p></blockquote><hr><p><strong>针对于&#x3D;&#x3D;方法&#x3D;&#x3D;的参数概念</strong></p><p>形参：<em><strong>方法定义时</strong></em>，声明的小括号内的参数 </p><p>实参：<em><strong>方法调用时</strong></em>，实际传递给形参的数据</p><hr><p><strong>Java中参数传递机制：值传递机制</strong></p><p><strong>规则：</strong></p><ul><li>如果参数是<em><strong>基本数据类型</strong></em>，此时实参赋给形参的是实参真实存储的数据值。</li><li>如果参数是<em><strong>引用数据类型</strong></em>，此时实参赋给形参的是实参存储数据的地址值。</li></ul><p><strong>推广：</strong></p><ul><li>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。</li><li>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</li></ul><hr><p><strong>内存解析</strong></p><ul><li>内存结构：栈（局部变量），&#x3D;&#x3D;堆【对象、数组、非static成员变量(属性)】&#x3D;&#x3D;</li><li>变量：成员变量（类变量，实例变量(不以static修饰)）vs 局部变量（方法体内，方法形参变量，构造器，构造器形参，代码块）</li></ul><p>举例一：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/552dc9d0c5284ded8c90d0d9eb1ea86e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>举例二： </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4bc865be8a340d396d95f43a71064b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"> </p><hr><blockquote><p>7、递归方法</p></blockquote><p>递归方法：一个方法体内调用它自身。</p><p>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。 <strong>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环</strong>。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1：计算1-n之间所自然数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2：计算1-n之间所自然数的乘积:n!</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * getSum1(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例3：已知一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),</span></span><br><span class="line"><span class="comment">//其中n是大于0的整数，求f(10)的值。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//          return f(n + 2) - 2 * f(n + 1);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例4：斐波那契数列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例5：汉诺塔问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例6：快排</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>8、方法的重写</p></blockquote><p><strong>什么是方法的重写(override 或 overwrite)？</strong>、</p><p>​子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.</p><p><strong>重写应用</strong>：</p><p>重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法</p><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;&#125;<span class="comment">//求面积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cylinder</span> <span class="keyword">extends</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;&#125;<span class="comment">//求表面积</span></span><br><span class="line">&#125;</span><br><span class="line">**********************************************</span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amt)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheckAccount</span> <span class="keyword">extends</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amt)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>重写规则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符  返回值类型  方法名(形参列表) <span class="keyword">throws</span> 异常的类型&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</p><ol><li>子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</li><li>子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</li></ol><p><strong>特殊情况</strong>：子类不能重写父类中声明为private权限的方法</p><ul><li><strong>返回值类型</strong>：<ul><li>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</li><li>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</li><li>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)</li></ul></li></ul><p><strong>补充：</strong>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p><p><strong>说明：</strong>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写)。</p><p>开发中一般保持子父类一致</p><hr><p><strong>区分方法的重写和重载？</strong></p><ol><li>二者的概念：</li></ol><ul><li>方法的<strong>重写</strong>：<strong>子类继承父类以后</strong>，可以对父类中&#x3D;&#x3D;同名同参数&#x3D;&#x3D;的方法，进行覆盖操作.</li><li>方法的<strong>重载</strong>：<strong>在同一个类中</strong>，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</li></ul><ol><li>重载和重写的具体规则：重载：两同一不同，重写</li><li>重载：不表现为多态性。 重写：表现为多态性。</li><li>从编译和运行的角度看：</li></ol><ul><li>重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</li><li>所以对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；</li><li>而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。</li></ul><hr><h3 id="1-5-4、类的结构之三：构造器"><a href="#1-5-4、类的结构之三：构造器" class="headerlink" title="1.5.4、类的结构之三：构造器"></a>1.5.4、类的结构之三：构造器</h3><blockquote><p>1、构造器（构造方法）：Constructor</p></blockquote><ul><li>构造器的作用：（只要造对象就得用到构造器）<ul><li>创建对象</li><li>初始化对象信息</li></ul></li></ul><hr><blockquote><p>2、使用说明</p></blockquote><ul><li><p>如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器</p></li><li><p>定义构造器的格式：<code>权限修饰符 类名(形参列表)&#123; &#125;</code></p></li><li><p>一个类中定义的<em><strong>多个构造器</strong></em>，彼此构成重载</p></li><li><p>一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</p></li><li><p>一个类中，<em><strong>至少会有一个构造器</strong></em>。</p></li></ul><hr><blockquote><p>3、构造器举例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器不等于方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Person().....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String n)</span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String n,<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    age = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造器默认权限和类的权限一致</li></ul><hr><blockquote><p>4、属性赋值顺序</p></blockquote><p>总结：属性赋值的先后顺序</p><p>① 默认初始化</p><p>② 显式初始化</p><p>③ 构造器中初始化</p><p>④ 通过”对象.方法” 或 “对象.属性”的方式，赋值</p><p>以上操作的先后顺序：① - ② - ③ - ④</p><hr><blockquote><p>5、JavaBean的概念</p></blockquote><p>所谓JavaBean，是指符合如下标准的Java类：</p><ul><li>类是公共的</li><li>一个<em><strong>无参</strong></em>的公共的构造器</li><li>属性，且对应的get、set方法</li></ul><hr><h3 id="1-5-5、类的结构之四：代码块"><a href="#1-5-5、类的结构之四：代码块" class="headerlink" title="1.5.5、类的结构之四：代码块"></a>1.5.5、类的结构之四：代码块</h3><p>代码块（初始化块）</p><blockquote><p>1、代码块的作用</p></blockquote><p>初始化类、对象的信息</p><blockquote><p>2、分类</p></blockquote><p>静态代码块 vs 非静态代码块</p><blockquote><p>3、区别</p></blockquote><p><strong>静态代码块：</strong></p><ul><li>内部可以输出语句</li><li>&#x3D;&#x3D;随着类的加载而执行,而且只执行一次&#x3D;&#x3D;</li><li>&#x3D;&#x3D;作用：初始化类的信息&#x3D;&#x3D;</li><li>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</li><li>静态代码块的执行要优先于非静态代码块的执行</li><li>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</li></ul><p><strong>非静态代码块：</strong></p><ul><li>内部可以输出语句</li><li>&#x3D;&#x3D;随着对象的创建而执行&#x3D;&#x3D;</li><li>&#x3D;&#x3D;每创建一个对象，就执行一次非静态代码块&#x3D;&#x3D;</li><li>&#x3D;&#x3D;作用：可以在创建对象时，对对象的属性等进行初始化&#x3D;&#x3D;</li><li>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</li><li>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</li></ul><p><strong>注意：</strong>实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：由父及子，静态先行。如下图</p><p><img src="/2022/06/13/javaSE/image-20220518015906900.png" alt="image-20220518015906900"> </p><hr><blockquote><p>属性的赋值顺序</p></blockquote><p>① 默认初始化</p><p>② 显式初始化&#x2F;⑤在代码块中赋值</p><p>③ 构造器中初始化</p><p>④ 有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值</p><p>执行的先后顺序：① - ② &#x2F; ⑤ - ③ - ④</p><hr><h3 id="1-5-6、类的结构之五：内部类"><a href="#1-5-6、类的结构之五：内部类" class="headerlink" title="1.5.6、类的结构之五：内部类"></a>1.5.6、类的结构之五：内部类</h3><blockquote><p>1、定义：</p></blockquote><p>Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类。</p><blockquote><p>2、分类：</p></blockquote><ul><li>成员内部类（静态、非静态）</li><li>局部内部类（方法内、代码块内、构造器内）</li></ul><blockquote><p>3、成员内部类的理解</p></blockquote><p><strong>一方面，作为外部类的&#x3D;&#x3D;成员&#x3D;&#x3D;：</strong></p><ul><li>调用外部类的结构</li><li>可以被static修饰</li><li>可以被4种不同的权限修饰</li></ul><p><strong>另一方面，作为一个&#x3D;&#x3D;类&#x3D;&#x3D;：</strong></p><ul><li>类内可以定义属性、方法、构造器等</li><li>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</li><li>可以被abstract修饰</li></ul><hr><blockquote><p>4、成员内部类</p></blockquote><p><strong>创建成员内部类对象</strong>(静态&amp;非静态)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建静态的Dog内部类的实例(静态的成员内部类):</span></span><br><span class="line">Person.<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建非静态的Bird内部类的实例(非静态的成员内部类):</span></span><br><span class="line"><span class="comment">// Person.Bird bird = new Person.Bird();//错误的</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">Person.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> p.<span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br></pre></td></tr></table></figure><p><strong>在成员内部类调用外部类结构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">            System.out.println(Person.<span class="built_in">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line">            <span class="comment">//Person.this.eat();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>局部内部类的使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line"><span class="keyword">public</span> Comparable <span class="title function_">getComparable</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line">    <span class="comment">//方式一：</span></span><br><span class="line">    <span class="comment">//      class MyComparable implements Comparable&#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//          @Override</span></span><br><span class="line">    <span class="comment">//          public int compareTo(Object o) &#123;</span></span><br><span class="line">    <span class="comment">//              return 0;</span></span><br><span class="line">    <span class="comment">//          &#125;</span></span><br><span class="line">    <span class="comment">//          </span></span><br><span class="line">    <span class="comment">//      &#125;</span></span><br><span class="line">    <span class="comment">//      </span></span><br><span class="line">    <span class="comment">//      return new MyComparable();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Comparable</span>()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>成员内部类和局部内部类，在编译以后，都会生成字节码文件。 格式：成员内部类：<code>外部类$内部类名.class</code> 局部内部类：<code>外部类$数字 内部类名.class</code></p><hr><h2 id="1-6、Java关键字的使用"><a href="#1-6、Java关键字的使用" class="headerlink" title="1.6、Java关键字的使用"></a>1.6、Java关键字的使用</h2><h3 id="1、return–跳出"><a href="#1、return–跳出" class="headerlink" title="1、return–跳出"></a>1、return–跳出</h3><ul><li><p>使用在方法体中，用于：① 结束方法② 针对于返回值类型的方法，使用”return 数据”方法返回所要的数据。</p></li><li><p>return关键字后面不可以声明执行语句。</p></li><li><p>在异常处理中try-catch-finally的结构中，如果try或catch中的结构中写了return，但是finally中的结构仍会执行。</p></li></ul><h3 id="2、this–本类的"><a href="#2、this–本类的" class="headerlink" title="2、this–本类的"></a>2、this–本类的</h3><blockquote><p><strong>概述：</strong></p></blockquote><p>this理解为：当前对象 或 当前正在创建的对象，可以调用的结构：<em><strong>属性、方法；构造器</strong></em></p><blockquote><p>使用</p></blockquote><p><strong>2.1 this调用属性、方法：</strong></p><ul><li>在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果<em><strong>方法的形参和类的属性同名时</strong></em>，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li><li>在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果<em><strong>构造器的形参和类的属性同名</strong></em>时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li></ul><p><strong>2.2 this调用构造器：</strong></p><p>① 我们在类的构造器中，可以显式的使用***”this(形参列表)”***方式，调用本类中指定的其他构造器</p><p>② 构造器中不能通过”this(形参列表)”方式调用自己</p><p>③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”</p><p>④ 规定：”this(形参列表)”<em><strong>必须声明在当前构造器的首行</strong></em></p><p>⑤ **构造器内部，最多只能声明一个”this(形参列表)”**，用来调用其他的构造器</p><h3 id="3、super–父类的"><a href="#3、super–父类的" class="headerlink" title="3、super–父类的"></a>3、super–父类的</h3><blockquote><p>概述</p></blockquote><p>super 关键字可以理解为：父类的，可以用来调用的结构：<em><strong>属性、方法、构造器</strong></em></p><ul><li>尤其当子父类出现同名成员时，可以用supe表明调用的是父类中的成员</li><li>super的追溯不仅限于直接父类</li><li>super和this的用法相像，this代表本类对象的引用， super代表父类的内存空间的标识</li></ul><blockquote><p>super使用</p></blockquote><p><strong>2.1super调用属性、方法：</strong></p><p>与this关键字使用方式相同，只不过调用的是父类的属性</p><p><strong>2.2 在子类的方法或构造器中使用</strong></p><p>通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”</p><p><strong>特殊情况</strong></p><ul><li>当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。</li><li>当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。</li></ul><p><strong>super调用构造器</strong></p><p>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</p><p>“super(形参列表)”的使用，必须声明在子类构造器的首行！</p><p>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现</p><p>在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()</p><p>在类的多个构造器中，至少一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</p><p><strong>this和super区别</strong></p><table><thead><tr><th>区别点</th><th>this</th><th>super</th></tr></thead><tbody><tr><td>访问属性</td><td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td><td>直接访问父类中的属性</td></tr><tr><td>调用方法</td><td>访问本类中的方法，如果本类没有此方法则从父类中继续查找</td><td>直接访问父类中的方法</td></tr><tr><td>调用构造器</td><td>调用本类构造器，必须放在构造器的首行</td><td>调用父类构造器，必须放在子类构造器的首行</td></tr></tbody></table><h3 id="4、package-x2F-import"><a href="#4、package-x2F-import" class="headerlink" title="4、package&#x2F;import"></a>4、package&#x2F;import</h3><blockquote><p>package</p><p>概述</p></blockquote><ol><li>为了更好的实现项目中类的管理，提供包的概念</li><li>使用package声明类或接口所属的包，声明在源文件的首行</li><li>包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”</li><li>每”.”一次，就代表一层文件目录</li></ol><blockquote><p>包结构应用举例</p></blockquote><p><strong>MVC设计模式：</strong></p><p><img src="/2022/06/13/javaSE/image-20220518210058219.png" alt="image-20220518210058219"> &#x3D;&#x3D;</p><blockquote><p>&#x3D;&#x3D;JDK中主要的包介绍&#x3D;&#x3D;</p></blockquote><ul><li><p>java. lang–包含一些Java语言的核心类，如 String、Math、 integer、 System和Thread，提供常用功能</p></li><li><p>java. net–包含执行与网络相关的操作的类和接口</p></li><li><p>java.io–包含能提供多种输入&#x2F;输出功能的类</p></li><li><p>java util–包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。</p></li><li><p>java. text–包含了一些java格式化相关的类</p></li><li><p>java.sql–包含了java进行JDBC数据库编程的相关类&#x2F;接口</p></li><li><p>java. awt–包含了构成抽象窗口工具集 (abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面GU）。 B&#x2F;S C&#x2F;S</p></li></ul><blockquote><p>import的使用</p></blockquote><p>在源文件中显式的使用import结构导入指定包下的类、接口</p><p>声明在包的声明和类的声明之间</p><p>如果需要导入多个结构，则并列写出即可</p><p>可以使用”xxx.*”的方式，表示可以导入xxx包下的所结构</p><p>如果使用的类或接口是java.lang包下定义的，则可以省略import结构</p><p>如果使用的类或接口是本包下定义的，则可以省略import结构</p><p>如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。</p><p>使用”xxx.*”方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入</p><p>import static:导入指定类或接口中的静态结构:属性或方法。</p><h3 id="5、static–静态的"><a href="#5、static–静态的" class="headerlink" title="5、static–静态的"></a>5、static–静态的</h3><blockquote><p>概述</p></blockquote><p>static主要用来修饰类的内部结构，如：属性、方法、代码块、内部类</p><blockquote><p>使用</p></blockquote><blockquote><p><strong>修饰属性：静态变量（类变量）</strong></p></blockquote><p>属性是否使用static修饰，可分为：静态属性 vs 非静态属性(实例变量)</p><ul><li>实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</li><li>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</li></ul><p><strong>static修饰属性的其他说明</strong></p><ul><li>&#x3D;&#x3D;静态变量随着类的加载而加载&#x3D;&#x3D;。可以通过”类.静态变量”的方式进行调用</li><li>静态变量的加载要早于对象的创建。</li><li>由于&#x3D;&#x3D;类只会加载一次&#x3D;&#x3D;，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</li></ul><p>静态属性举例：<code>System.out;Math.PI</code></p><p><strong>静态变量内存解析：</strong></p><p><img src="/2022/06/13/javaSE/image-20220519070741195.png" alt="image-20220519070741195"> </p><blockquote><p>修饰方法：静态方法、类方法</p></blockquote><ul><li>随着类的加载而加载，可以通过”类.静态方法”的方式进行调用</li><li>静态方法中，只能调用静态的方法或属性</li><li>非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</li></ul><p><strong>使用的注意点：</strong></p><ul><li>在静态的方法内，不能使用this关键字、super关键字</li><li>关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。</li></ul><blockquote><p>如何判定属性和方法应该使用static关键字</p></blockquote><p><strong>关于属性：</strong></p><ul><li>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</li><li>类中的常量也常常声明为static</li></ul><p><strong>关于方法：</strong></p><ul><li>操作静态属性的方法，通常设置为static的</li><li>工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</li></ul><p><strong>使用举例：</strong>记录创建的圆的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//自动赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">()</span>&#123;</span><br><span class="line">id = init++;</span><br><span class="line">total++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>();</span><br><span class="line"><span class="comment">//id = init++;</span></span><br><span class="line"><span class="comment">//total++;</span></span><br><span class="line"><span class="built_in">this</span>.radius = radius;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> total;<span class="comment">//记录创建的圆的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">init</span> <span class="operator">=</span> <span class="number">1001</span>;<span class="comment">//static声明的属性被所对象所共享</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRadius</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRadius</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getTotal</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>单例模式</p></blockquote><h4 id="设计模式的说明："><a href="#设计模式的说明：" class="headerlink" title="设计模式的说明："></a><strong>设计模式的说明：</strong></h4><p>设计模式是在大量的实践中总结和理论化之后优化的代码结构、编程风格、以及解决问题的思考方式</p><p><strong>常用设计模式</strong>–23种经典设计模式<strong>（标黄表示接触过的）</strong></p><ul><li>创建型模式，5种：工厂方法模式、抽象工厂模式、&#x3D;&#x3D;单例模式&#x3D;&#x3D;【饿汉+懒汉】、建造者模式、原型模式。</li><li>结构型模式，7种：适配器模式、装饰器模式、&#x3D;&#x3D;代理模式&#x3D;&#x3D;【AOP】、外观模式、桥接模式、组合模式、享元模式。</li><li>行为型模式，11种：策略模式、&#x3D;&#x3D;模板方法模式&#x3D;&#x3D;【抽象类,JDBCTemlate】、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><p><strong>单例模式：</strong></p><p>采取一定的方法保证在整个软件系统中，对某个类只能存在一个实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思想：(静态变量随着类的加载而加载，用static修饰属性，由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">饿汉式<span class="number">1</span>：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.内部创建类的对象</span></span><br><span class="line"><span class="comment">//4.要求此对象也必须声明为静态的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">饿汉式<span class="number">2</span>：使用了静态代码块</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line"><span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line"><span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>饿汉和懒汉方式的对比</strong></p><ul><li>饿汉式：上来就创建对象（对象创建在类中，类一加载则就会创建对象）<ul><li>坏处：对象加载时间过长。</li><li>好处：饿汉式是线程安全的</li></ul></li><li>懒汉式：什么时候用什么时候造对象（对象不初始化，定义为null先）<ul><li>好处：延迟对象的创建。</li><li>目前的写法坏处：线程不安全。—&gt;到多线程内容时，再修改</li></ul></li></ul><h3 id="6、final–最终的"><a href="#6、final–最终的" class="headerlink" title="6、final–最终的"></a>6、final–最终的</h3><p><strong>可以用来修饰：类、方法、变量</strong></p><ul><li><p>final 用来修饰一个类:此类不能被其他类所继承。</p><ul><li>比如：String类、System类、StringBuffer类</li></ul></li><li><p>final 用来修饰方法：表明此方法不可以被重写</p><ul><li>比如：Object类中getClass();</li></ul></li><li><p>final 用来修饰变量：此时的”变量”就称为是一个常量</p><ul><li>final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化</li><li>final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</li></ul></li><li><p>static final 用来修饰属性：全局常量</p></li></ul><h3 id="7、abstract–抽象的"><a href="#7、abstract–抽象的" class="headerlink" title="7、abstract–抽象的"></a>7、abstract–抽象的</h3><blockquote><p>abstract概述</p></blockquote><p>abstract: 抽象的，可以用来修饰：类、方法</p><blockquote><p>使用</p></blockquote><p><strong>abstract修饰类：抽象类</strong></p><ul><li>&#x3D;&#x3D;此类不能实例化&#x3D;&#x3D;</li><li>&#x3D;&#x3D;抽象类中一定有构造器&#x3D;&#x3D;，便于子类实例化时调用（涉及：子类对象实例化的全过程）</li><li>开发中，都会提供抽象类的子类，&#x3D;&#x3D;让子类对象实例化&#x3D;&#x3D;，完成相关的操作 —&gt;&#x3D;&#x3D;抽象的使用前提：继承性&#x3D;&#x3D;</li></ul><p> <strong>abstract修饰方法：抽象方法</strong></p><ul><li>抽象方法&#x3D;&#x3D;只有方法的声明，没方法体&#x3D;&#x3D;</li><li>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</li><li>若子类重写了父类中的所的抽象方法后，此子类方可实例化</li><li>若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</li></ul><blockquote><p><strong>注意点：</strong></p></blockquote><ul><li>abstract不能用来修饰：属性、构造器等结构</li><li>abstract不能用来修饰私有方法、静态方法（&#x3D;&#x3D;静态方法不能被重写，抽象方法不能调用&#x3D;&#x3D;）、final的方法、final的类</li><li>&#x3D;&#x3D;抽象方法权限修饰符不能为private&#x3D;&#x3D;</li></ul><p><strong>应用举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交通工具父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">()</span>;<span class="comment">//计算燃料效率的抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">()</span>;<span class="comment">//计算行驶距离的抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//卡车子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Truck</span> <span class="keyword">extends</span> <span class="title class_">Vehiclel</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">( )</span>&#123;<span class="comment">//写出计算卡车的燃料效率的具体方法&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">( )</span>&#123;<span class="comment">//写出计算卡车行驶距离的具体方法&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//驳船子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RiverBarge</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">( )</span>&#123;<span class="comment">//写出计算驳船的燃料效率的具体方法&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">( )</span>&#123;<span class="comment">//写出计算驳船行驶距离的具体方法&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GeometricObject</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">GeometricObject</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IO流中设计到的抽象类：InputStream&#x2F;OutputStream &#x2F; Reader &#x2F;Writer。在其内部定义了抽象的read()、write()方法。</p></blockquote><hr><blockquote><p>模板方法设计模式</p></blockquote><p><strong>解决的问题：</strong></p><p>在软件开发中，实现一个算法时，整体步骤固定、通用，这些步骤在父类已经写好了，但是某些部分易变，那么这些易变的部分就可以抽象出来，供不同子类实现。这就是一种模板模式。</p><p><strong>应用举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算某段代码执行所需要花费的时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">spendTime</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.code();<span class="comment">//不确定的部分、易变的部分</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubTemplate</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= Math.sqrt(i);j++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">isFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestTemplate</span> <span class="variable">testTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestTemplate</span>();</span><br><span class="line">        <span class="comment">//调用父类抽象类中的普通公用方法</span></span><br><span class="line">        testTemplate.spendTime();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>应用场景</p></blockquote><p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有</p><ul><li>数据库访问的封装</li><li>Junt单元测试</li><li>JavaWeb的 Servlet中关于 doGet&#x2F;doPost方法调用</li><li>Hibernate中模板程序</li><li>Spring中 JDBCTemlate、 Hibernate Template等</li></ul><hr><h3 id="8、interface–接口"><a href="#8、interface–接口" class="headerlink" title="8、interface–接口"></a>8、interface–接口</h3><blockquote><p>概述</p></blockquote><ul><li>接口使用Interface定义</li><li>Java中，接口和类是并列的两个结构</li></ul><blockquote><p>Interface关键字使用说明</p></blockquote><ul><li><p>如何定义接口：定义接口中的成员</p></li><li><p>接口中不能定义构造器的！意味着接口不可以实例化。</p></li><li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.</p><ul><li>如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化</li><li>如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</li></ul></li><li><p>&#x3D;&#x3D;Java类可以实现多个接口 —&gt;弥补了Java单继承性的局限性&#x3D;&#x3D;</p><ul><li>格式：class AA extends BB implements CC,DD,EE</li></ul></li><li><p>接口与接口之间可以继承，而且可以多继承</p></li><li><p>&#x3D;&#x3D;接口的具体使用，体现多态性&#x3D;&#x3D;【类的继承关系，方法的重写】</p></li><li><p>接口，实际上可以看做是一种规范</p></li></ul><p><strong>应用举例：</strong>不同的设备通过USB口接入电脑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferData</span><span class="params">(USB usb)</span>&#123;</span><br><span class="line">        <span class="comment">//USB usb = new Flash();</span></span><br><span class="line">        <span class="type">USB</span> <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">usb.start();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;具体传输数据的细节&quot;</span>);</span><br><span class="line"></span><br><span class="line">usb.stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"><span class="comment">//常量：定义了长、宽、最大最小的传输速度等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flash</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘开启工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机开启工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用总结</strong></p><ol><li>接口使用上也满足多态性</li><li>接口，实际上就是定义了一种规范</li><li>开发中，体会面向接口编程！</li></ol><blockquote><p>面向接口编程思想</p></blockquote><p><img src="/2022/06/13/javaSE/image-20220519103703021.png" alt="image-20220519103703021"> </p><p>面向接口编程：我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个 数据库厂商的API。</p><blockquote><p>Java8关于接口的新规范</p></blockquote><p>JDK7及以前：只能定义全局常量和抽象方法</p><ul><li>全局常量：public static final的，书写时可以省略不写</li><li>抽象方法：public abstract的</li></ul><p>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</p><ul><li><p>Java8中，可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。</p></li><li><p>静态方法：使用 static关键字修饰。</p><p>可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像 Collection&#x2F;co| ections或者Path&#x2F; Paths这样成对的接口和类。</p></li><li><p>默认方法：默认方法使用 default关键字修饰。</p></li><li><p>可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性比如：java8API中对 Collection、List、 Comparator等接口提供了丰富的默认方法。</p></li></ul><blockquote><p>总结</p></blockquote><p>知识点1：接口中定义的静态方法，只能通过接口来调用。</p><p>知识点2：通过实现类的对象，可以调用接口中的默认方法。</p><p>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</p><p>知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt;类优先原则</p><p>知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</p><p>那么在实现类没重写此方法的情况下，报错。–&gt;接口冲突。</p><p>这就需要我们必须在实现类中重写此方法</p><p>知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>&#123;</span><br><span class="line">method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line"><span class="built_in">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line"><span class="comment">//调用接口中的默认方法</span></span><br><span class="line">CompareA.<span class="built_in">super</span>.method3();</span><br><span class="line">CompareB.<span class="built_in">super</span>.method3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象类和接口的异同？</strong> </p><p>相同点：&#x3D;&#x3D;都不能实例化；都可以被继承；都可以包含抽象方法的。&#x3D;&#x3D;</p><p>不同点：</p><p>​抽象类：有构造器。接口：没有构造器</p><p>​1）把抽象类和接口(java7,java8,java9)的定义、内部结构解释说明</p><p>​2）类：单继承性；接口：多实现</p><blockquote><p>代理模式</p></blockquote><p>为其他对象提供一种代理，以控制对这个对象的访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> <span class="keyword">implements</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;真实的服务器访问网络&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyServer</span> <span class="keyword">implements</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> NetWork work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProxyServer</span><span class="params">(NetWork work)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.work = work;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;联网之前的检查工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span> &#123;</span><br><span class="line">check();</span><br><span class="line"></span><br><span class="line">work.browse();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyServer</span> <span class="variable">proxyServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyServer</span>(<span class="keyword">new</span> <span class="title class_">Server</span>());</span><br><span class="line">        proxyServer.browse();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong></p><ul><li>安全代理：屏蔽对真实角色的直接访问</li><li>远程代理：通过代理类处理远程方法调用（RM）</li><li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象 比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用 proxy来进行大图片的打开。</li></ul><p><strong>分类</strong></p><ul><li>静态代理（静态定义代理类）</li><li>动态代理（动态生成代理类）JDK自带的动态代理，需要反射等知识</li></ul><blockquote><p>工厂设计模式</p></blockquote><p><strong>解决的问题</strong></p><p>实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p><p><strong>具体模式：</strong></p><ul><li>简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</li><li>工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品)</li><li>抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)</li></ul><hr><h1 id="二、java高级"><a href="#二、java高级" class="headerlink" title="二、java高级"></a>二、java高级</h1><h2 id="2-1、枚举类-amp-注解"><a href="#2-1、枚举类-amp-注解" class="headerlink" title="2.1、枚举类&amp;注解"></a>2.1、枚举类&amp;注解</h2><h3 id="2-2-1、枚举类的使用"><a href="#2-2-1、枚举类的使用" class="headerlink" title="2.2.1、枚举类的使用"></a>2.2.1、枚举类的使用</h3><blockquote><p>枚举类说明</p></blockquote><ol><li><p>枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类</p></li><li><p>当需要定义一组常量时，强烈建议使用枚举类</p></li><li><p>枚举类的实现：</p><p>JDK 5.0以前需要自定义</p><p>JDK 5.0后新增enum关键字用于定义枚举类</p></li><li><p>如果枚举类中只一个对象，则可以作为单例模式的实现方式。</p></li><li><p>枚举类的属性：</p><p>枚举类对象的属性不应允许被改动，所以应该使用 private final修饰 枚举类的使用 private final修饰的属性应该在构造器中为其赋值 若枚举类显式的定义了带参数的构造器，则在列出枚举值时也必须对应的传入参数</p></li></ol><blockquote><p>自定义枚举类</p></blockquote><p><strong>步骤：</strong></p><ol><li>&#x3D;&#x3D;私有化构造器，保证<strong>不能在类的外部创建其对象</strong>&#x3D;&#x3D;；</li><li>在类的内部创建枚举类的示例。声明为：public static final；</li><li>对象如果有实例变量，应该声明为private final，并在构造器中初始化；</li></ol><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//1.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.其他诉求1：提供toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Test:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(SeasonEnum.SPRING);<span class="comment">//SeasonEnum&#123;seasonName=&#x27;春天&#x27;, seasonDesc=&#x27;春暖花开&#x27;&#125;</span></span><br><span class="line">        System.out.println(SeasonEnum.SPRING.getSeasonDesc());</span><br><span class="line">        System.out.println(SeasonEnum.SPRING.getSeasonName());</span><br><span class="line">        System.out.println(SeasonEnum2.AUTUMN.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JDK5.0新增使用enum定义枚举类</p></blockquote><p><strong>使用说明：</strong></p><ul><li>使用enum定义的枚举类默认继承了 <code>java.lang.Enum</code> 类，因此不能再继承其他类</li><li>枚举类的&#x3D;&#x3D;构造器只能使用private权限修饰符&#x3D;&#x3D;</li><li>枚举类的所有实例必须在枚举类中显式列出(<code>,</code> 分隔 <code>;</code> 结尾)。列出的实例系统会自动添加<code>public static final</code> 修饰</li><li>&#x3D;&#x3D;必须在枚举类的第一行声明枚举类对象&#x3D;&#x3D;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> &#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(SeasonEnum2.SPRING);</span><br><span class="line">        System.out.println(SeasonEnum2.AUTUMN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Enum类的常用方法</strong></p><p><code>values()</code>方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</p><p><code>valueOf(String str)</code>：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”.如不是，会有运行时异常 <code>IllegalArgumentException</code></p><p><code>toString()</code>：返回当前枚举类对象常量的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season1</span> <span class="variable">summer</span> <span class="operator">=</span> Season1.SUMMER;</span><br><span class="line"><span class="comment">//toString():返回枚举类对象的名称</span></span><br><span class="line">System.out.println(summer.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(Season1.class.getSuperclass());</span></span><br><span class="line">System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line"><span class="comment">//values():返回所的枚举类对象构成的数组</span></span><br><span class="line">Season1[] values = Season1.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">    System.out.println(values[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">Thread.State[] values1 = Thread.State.values();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values1.length; i++) &#123;</span><br><span class="line">    System.out.println(values1[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//valueOf(String objName):返回枚举类中对象名是objName的对象。</span></span><br><span class="line"><span class="type">Season1</span> <span class="variable">winter</span> <span class="operator">=</span> Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line"><span class="comment">//如果没objName的枚举类对象，则抛异常：IllegalArgumentException</span></span><br><span class="line"><span class="comment">//        Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);</span></span><br><span class="line">System.out.println(winter);</span><br></pre></td></tr></table></figure><p><strong>用Enum类定义的枚举类对象分别实现接口：</strong></p><ol><li>和普通Java类一样，&#x3D;&#x3D;枚举类可以实现一个或多个接口&#x3D;&#x3D;</li><li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</li><li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2、注解的使用"><a href="#2-2-2、注解的使用" class="headerlink" title="2.2.2、注解的使用"></a>2.2.2、注解的使用</h3><blockquote><p>注解的理解</p></blockquote><p>① jdk 5.0 新增的功能</p><p>② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation,程序员可以在不改变原逻辑的情况下, 在源文件中嵌入一些补充信息。</p><p>③ Annotation可以像修饰符一样使用，可以用来修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在Annotation的 <code>name = value</code> 对中。</p><p>④ 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE&#x2F;Android 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗 代码和XML配置等。</p><p>⑤&#x3D;&#x3D;框架 &#x3D; 注解 + 反射机制 + 设计模式&#x3D;&#x3D;</p><blockquote><p>注解的使用示例</p></blockquote><p>使用 Annotation时要在其前面增加 <code>@</code> 符号，并把该 Annotation当成个修饰符使用。用于修饰它支持的程序元素</p><p><strong>示例一：生成文档相关的注解</strong></p><ul><li><p><code>@author</code> 标明开发该类模块的作者，多个作者之间使用，分割 <code>@version</code> 标明该类模块的版本；</p></li><li><p><code>@see</code> 参考转向，也就是相关主题；</p></li><li><p><code>@since</code> 从哪个版本开始增加的；</p></li><li><p><code>@param</code> 对方法中某参数的说明，如果没有参数就不能写 <code> @return</code> 对方法返回值的说明，如果方法的返回值类型是 <code>void</code> 就不能写 <code>@exception</code> 对方法可能抛出的异常进行说明，如果方法没有用 <code>throws</code> 显式抛出的异常就不能写；</p></li><li><p>其中 <code>@param</code> 、 <code>@return</code> 和 <code>@exception</code> 这三个标记都是只用于方法的。</p></li><li><p><code>@param</code> 的格式要求：<code>@param</code> 形参名形参类型形参说明；</p></li><li><p><code>@return</code> 的格式要求：<code>@return</code> 返回值类型返回值说明；</p></li><li><p><code>@exception</code> 的格式要求：<code>@exception</code> 异常类型异常说明；</p></li><li><p><code>@param</code> 和 <code>@exception</code> 可以并列多个；</p></li></ul><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> bruce</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@project</span>_name JavaSenior</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span>_name com.bruce.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-04-26 10:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *程序的主方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 传入命令行参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求圆形面积</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> radius 所求面积的半径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 面积值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例二：在编译时进行格式检查(JDK内置的个基本注解)</strong></p><ul><li><code>@Override</code>: 限定重写父类方法, 该注解只能用于方法；</li><li><code>@Deprecated</code>: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的择；</li><li><code>@SuppressWarnings</code>: 抑制编译器警告；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mian</span> <span class="params">(String [] args)</span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarning(&quot;unused&quot;)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;过时的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;重写的toString方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例三：跟踪代码依赖性，实现替代配置文件功能</strong></p><p>在使用Spring框架时会大量用到注解驱动开发。</p><blockquote><p>自定义注解</p></blockquote><p><strong>参照 <code>@SuppressWarnings</code> 定义</strong></p><ol><li>注解声明为：<code>@interface</code></li><li>内部定义成员，通常使用value表示</li><li>可以指定成员的默认值，使用default定义</li><li>如果自定义注解没成员，表明是一个标识作用。</li></ol><p><strong>说明：</strong></p><ul><li>如果注解有成员，在使用注解时，需要指明成员的值。</li><li>自定义注解必须配上注解的信息处理流程(使用反射)才意义。</li><li>自定义注解通过都会指明两个元注解：<code>@Retention</code>、<code>@Target</code></li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>元注解</p></blockquote><p>对现有的注解进行解释说明的注解。</p><p>JDK 5.0 提供的4种元注解：</p><p><code>@Retention</code>：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为）\RUNTIME只有声明为RUNTIME生命周期的注解，才能通过反射获取。</p><p><code>@Target</code>:用于指定被修饰的 Annotation 能用于修饰哪些程序元素 </p><p><img src="/2022/06/13/javaSE/image-20220522140737579.png" alt="image-20220522140737579"> </p><p><code>@Documented</code>:表示所修饰的注解在被javadoc解析时，保留下来。</p><p><code>@Inherited</code>:被它修饰的 Annotation 将具继承性。</p><blockquote><p>获取注解信息</p></blockquote><p>通过发射来进行获取、调用。</p><p>前提：要求此注解的元注解Retention中声明的生命周期状态为：RUNTIME.</p><blockquote><p>JDK8.0中注解新特性</p></blockquote><p>可重复注解、类型注解</p><p><strong>可重复注解：</strong></p><p>① 在MyAnnotation上声明 <code>@Repeatable</code>，成员值为 <code>MyAnnotations.class</code></p><p>② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。</p><p><strong>类型注解：</strong></p><p><code>ElementType.TYPE_PARAMETER</code> 表示该注解能写在类型变量的声明语句中（如：泛型声明。）</p><p><code>ElementType.TYPE_USE</code> 表示该注解能写在使用类型的任何语句中。</p><h2 id="2-2、java集合"><a href="#2-2、java集合" class="headerlink" title="2.2、java集合"></a>2.2、java集合</h2><h3 id="2-2-1、集合与数组"><a href="#2-2-1、集合与数组" class="headerlink" title="2.2.1、集合与数组"></a>2.2.1、集合与数组</h3><blockquote><p>集合与数组存储数据概述</p></blockquote><p>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 说明：此时的存储，&#x3D;&#x3D;主要指的是<strong>内存层面的存储</strong>&#x3D;&#x3D;，&#x3D;&#x3D;不涉及到持久化的存储&#x3D;&#x3D;（.txt,.jpg,.avi，数据库中)</p><blockquote><p>数组的存储特点</p></blockquote><p>一旦初始化以后，其长度确定；数组一旦定义好后，其元素类型确定；<br>我们只能操作制定类型的数据。</p><p>例如：<code>String[] str</code>、<code>int[] arr</code>、<code>Object[] arr2</code></p><blockquote><p>数组存储的弊端</p></blockquote><ol><li>数组一旦初始化之后，长度不可修改</li><li>数组提供的方法有限，对于添加，删除，插入数据等操作，非常不便，且效率不高</li><li>获取数组中实际元素个数的需求，数组没有现成的方法可用</li><li>&#x3D;&#x3D;<strong>数组</strong>&#x3D;&#x3D;存储的特点：&#x3D;&#x3D;<strong>有序、可重复</strong>&#x3D;&#x3D;；对无序不可重复的需求不能满足。</li></ol><blockquote><p>集合存储优点</p></blockquote><ul><li>解决数组存储数据的弊端</li></ul><blockquote><p>集合的分类</p></blockquote><p>Java的集合可分为Collection和Map两种体系</p><ul><li><strong>Collection</strong>接口：<strong>单列数据</strong>，定义了存储一组对象的方法的集合<ul><li><strong>List</strong>：元素&#x3D;&#x3D;有序、可重复&#x3D;&#x3D;的集合</li><li><strong>Set</strong>：元素&#x3D;&#x3D;无序、不可重复&#x3D;&#x3D;的集合</li></ul></li><li><strong>Map</strong>接口：<strong>双列数据</strong>，保存具有&#x3D;&#x3D;映射关系“key-value键值对”&#x3D;&#x3D;的集合</li></ul><blockquote><p>集合的框架结构</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">     |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span><br><span class="line">           |----ArrayList：作为List接口的主要实现类，线程不安全的，效率高;底层采用Object[] elementData数组存储</span><br><span class="line">           |----LinkedList：对于频繁的插入删除操作，使用此类效率比ArrayList效率高底层采用双向链表存储</span><br><span class="line">           |----Vector：作为List的古老实现类，线程安全的，效率低;底层采用Object[]数组存储</span><br><span class="line">           </span><br><span class="line">     |----Set接口：存储无序的、不可重复的数据   --&gt;数学概念上的“集合”</span><br><span class="line">           |----HashSet：作为Set接口主要实现类;线程不安全;可以存<span class="literal">null</span>值</span><br><span class="line">           |----LinkedHashSet：作为HashSet的子类;遍历其内部数据时，可以按照添加顺序遍历;对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">           |----TreeSet：可以按照添加对象的指定属性，进行排序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)</span><br><span class="line">     |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储<span class="literal">null</span>的key和value</span><br><span class="line">          |----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。</span><br><span class="line">                    原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</span><br><span class="line">                    对于频繁的遍历操作，此类执行效率高于HashMap。</span><br><span class="line">     |----TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序</span><br><span class="line">                      底层使用红黑树</span><br><span class="line">     |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储<span class="literal">null</span>的key和value</span><br><span class="line">          |----Properties:常用来处理配置文件。key和value都是String类型</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-2、Collection接口"><a href="#2-2-2、Collection接口" class="headerlink" title="2.2.2、Collection接口"></a>2.2.2、Collection接口</h3><ul><li><p>Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和 Queue集合。</p></li><li><p>JDK不提供此接口的任何直接实现，而是提供更具体的子接口（如：Set和List）实现。</p></li><li><p>在JDK 5.0之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object类型处理；从JDK 5.0增加了泛型以后，Java集合可以记住容器中对象的数据类型。</p></li></ul><blockquote><p>单列集合框架结构</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">     |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span><br><span class="line">           |----ArrayList：作为List接口的主要实现类，线程不安全的，效率高;底层采用Object[] elementData数组存储</span><br><span class="line">           |----LinkedList：对于频繁的插入删除操作，使用此类效率比ArrayList效率高底层采用双向链表存储</span><br><span class="line">           |----Vector：作为List的古老实现类，线程安全的，效率低;底层采用Object[]数组存储</span><br><span class="line">           </span><br><span class="line">     |----Set接口：存储无序的、不可重复的数据   --&gt;数学概念上的“集合”</span><br><span class="line">           |----HashSet：作为Set接口主要实现类;线程不安全;可以存<span class="literal">null</span>值</span><br><span class="line">           |----LinkedHashSet：作为HashSet的子类;遍历其内部数据时，可以按照添加顺序遍历;对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">           |----TreeSet：可以按照添加对象的指定属性，进行排序。</span><br></pre></td></tr></table></figure><p>图示：</p><p><img src="/2022/06/13/javaSE/image-20220522150831530.png" alt="image-20220522150831530"> </p><blockquote><p>Collection接口常用方法</p></blockquote><ol><li>添加<ul><li>add(Object obj)</li><li>addAll(Collection coll)</li></ul></li><li>获取有效元素个数<ul><li>int size()</li></ul></li><li>清空集合<ul><li>void clear()</li></ul></li><li>是否为空集合<ul><li>boolean isEmpty()</li></ul></li><li>是否包含某个元素<ul><li>boolean contains(Object obj)：通过元素的equals()方法来判断是否是同一个对象</li><li>boolean contains(Collection coll)：也是调用元素的equals方法来比较的。用两个集合的元素逐一比较</li></ul></li><li>删除<ul><li>boolean remove(Object obj)：通过元素的equals方法判断是否要删除的那个元素，只会删除找到的第一个元素</li><li>boolean removeAll(Collection coll)：取当前集合的差集</li></ul></li><li>取两个集合的交集<ul><li>boolean retainAll(Collection coll)：把交集的结果存到当前集合中，不影响coll集合</li></ul></li><li>集合是否相等<ul><li>boolean equals(Object obj)</li></ul></li><li>集合数组互转<ul><li>集合–&gt;数组：<code>Object[] toArray();</code></li><li>数组–&gt;集合：<code>Arrays.asList(new int[]&#123;123, 345&#125;);</code></li></ul></li><li>获取集合对象的哈希值<ul><li>hashCode()</li></ul></li><li>遍历<ul><li>iterator()：返回迭代器对象，用于集合遍历</li></ul></li></ol><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">//1.add(Object e):将元素添加到集合中</span></span><br><span class="line">    collection.add(<span class="string">&quot;ZZ&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    collection.add(<span class="number">123</span>);</span><br><span class="line">    collection.add(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="comment">//2.size():获取添加元素的个数</span></span><br><span class="line">    System.out.println(collection.size());<span class="comment">//5</span></span><br><span class="line">    <span class="comment">//3.addAll(Collection coll1):将coll1集合中的元素添加到当前集合中</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    collection1.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    collection1.add(<span class="number">213</span>);</span><br><span class="line">    collection.addAll(collection1);</span><br><span class="line">    System.out.println(collection.size());<span class="comment">//9</span></span><br><span class="line">    <span class="comment">//调用collection1中的toString()方法输出</span></span><br><span class="line">    System.out.println(collection);<span class="comment">//[ZZ, AA, BB, 123, Tue Apr 28 09:22:34 CST 2020, 213, 213]</span></span><br><span class="line">    <span class="comment">//4.clear():清空集合元素</span></span><br><span class="line">    collection1.clear();</span><br><span class="line">    System.out.println(collection1.size());<span class="comment">//0</span></span><br><span class="line">    System.out.println(collection1);<span class="comment">//[]</span></span><br><span class="line">    <span class="comment">//5.isEmpty():判断当前集合是否为空</span></span><br><span class="line">    System.out.println(collection1.isEmpty());<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//6.contains(Object obj):判断当前集合中是否包含obj</span></span><br><span class="line">    <span class="comment">//判断时需要调用obj对象所在类的equals()方法</span></span><br><span class="line">    System.out.println(coll.contains(<span class="number">123</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>)));<span class="comment">//true</span></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">23</span>)));<span class="comment">//false</span></span><br><span class="line">    <span class="comment">//7.containsAll(Collection coll1):判断形参coll1中的元素是否都存在当前集合中</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">4566</span>);</span><br><span class="line">    System.out.println(coll.containsAll(coll1));<span class="comment">//flase</span></span><br><span class="line">    <span class="comment">//8.remove(Object obj):从当前集合中移除obj元素</span></span><br><span class="line">    coll.remove(<span class="number">123</span>);</span><br><span class="line">    System.out.println(coll);<span class="comment">//[456, Person&#123;name=&#x27;Tom&#x27;, age=23&#125;, Person&#123;name=&#x27;Jarry&#x27;, age=34&#125;, false]</span></span><br><span class="line">    <span class="comment">//9.removeAll(Collection coll1):差集：从当前集合中和coll1中所有的元素</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">456</span>, <span class="literal">false</span>);</span><br><span class="line">    coll.removeAll(coll2);</span><br><span class="line">    System.out.println(coll);<span class="comment">//[Person&#123;name=&#x27;Tom&#x27;, age=23&#125;, Person&#123;name=&#x27;Jarry&#x27;, age=34&#125;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//10.retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，并返回给当前集合</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">345</span>, <span class="number">456</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> coll.retainAll(coll1);</span><br><span class="line">    System.out.println(b);<span class="comment">//true</span></span><br><span class="line">    System.out.println(coll);<span class="comment">//[123, 456]</span></span><br><span class="line">    <span class="comment">//11.equals(Object obj):返回true需要当前集合和形参集合的元素相同</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll2.add(<span class="number">123</span>);</span><br><span class="line">    coll2.add(<span class="number">456</span>);</span><br><span class="line">    System.out.println(coll.equals(coll2));<span class="comment">//true</span></span><br><span class="line">    <span class="comment">//12.hashCode():返回当前对象的哈希值</span></span><br><span class="line">    System.out.println(coll.hashCode());<span class="comment">//5230</span></span><br><span class="line">    <span class="comment">//13.集合---&gt;数组:toArray()</span></span><br><span class="line">    Object[] array = coll.toArray();</span><br><span class="line">    <span class="keyword">for</span> (Object obj : array) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//14.数组---&gt;集合:调用Arrays类的静态方法asList()</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; ints = Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">345</span>&#125;);</span><br><span class="line">    System.out.println(ints.size());<span class="comment">//1</span></span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    System.out.println(strings);<span class="comment">//[AA, BB, CC]</span></span><br><span class="line">    <span class="comment">//15.iteratoriterator():返回Iterator接口的实例，用于遍历集合元素。</span></span><br><span class="line">            <span class="comment">//迭代器遍历</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> list1.iterator();<span class="comment">//创建一个迭代器</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Collection集合与数组间的转换</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//集合 ---&gt;数组：toArray()</span></span><br><span class="line">Object[] arr = coll.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展：数组 ---&gt;集合:调用Arrays类的静态方法asList(T ... t)</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr1</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr1.size());<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr2</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr2.size());<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>使用 Collection 集合存储对象，要求对象所属的类满足：</p><ul><li>向 Collection 接口的实现类的对象中添加数据 obj 时，要求 obj 所在类要重写 <code>equals()</code>。</li></ul><h3 id="2-2-3、Iterator接口和foreach的循环"><a href="#2-2-3、Iterator接口和foreach的循环" class="headerlink" title="2.2.3、Iterator接口和foreach的循环"></a>2.2.3、Iterator接口和foreach的循环</h3><blockquote><p>遍历Collection的两种方式：</p></blockquote><p>① 使用迭代器Iterator</p><p>② foreach循环（或增强for循环）</p><blockquote><p>java.utils包下定义的迭代器接口：iterator</p></blockquote><p><strong>说明：</strong></p><p>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。 GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</p><p><strong>作用：</strong></p><p>遍历Collection集合元素</p><p><strong>如何获取实例：</strong></p><p><code>coll.iterator()</code>：返回一个实例</p><p><strong>遍历代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"><span class="comment">//hasNext():判断是否还下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="comment">//next():①指针下移 ②将下移以后集合位置上的元素返回</span></span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图示说明：</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2459e96817c4abe98f9e25ac8d70c45~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200427150811299"> </p><p><strong>iterator中remove()方法的使用：</strong></p><ul><li><p>测试Iterator中的 <code>remove()</code></p></li><li><p>如果还未调用 <code>next()</code> 或在上一次调用 <code>next()</code> 方法之后已经调用了 <code>remove()</code> 方法，再调用 remove 都会报 <code>IllegalStateException</code>。</p></li><li><p>内部定义了 <code>remove()</code>,&#x3D;&#x3D;可以<strong>在遍历的时候</strong>，删除集合中的元素&#x3D;&#x3D;。此方法不同于集合直接调用<code>remove()</code></p></li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    coll.add(<span class="string">&quot;Tom&quot;</span></span><br><span class="line">            );</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除集合中&quot;Tom&quot;</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">//            iterator.remove();</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">            <span class="comment">//                iterator.remove();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将指针重新放到头部，遍历集合</span></span><br><span class="line">    iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JDK5.0新特性：增强for循环（foreach）</p></blockquote><p><strong>1、遍历集合举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for(集合元素的类型 局部变量 : 集合对象)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>内部仍然调用了迭代器。</p><p><strong>2、遍历数组举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//for(数组元素的类型 局部变量 : 数组对象)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-4、Collection子接口：List接口"><a href="#2-2-4、Collection子接口：List接口" class="headerlink" title="2.2.4、Collection子接口：List接口"></a>2.2.4、Collection子接口：List接口</h3><blockquote><p>存储数据特点：</p></blockquote><p>存储&#x3D;&#x3D;有序的、可重复&#x3D;&#x3D;的数据</p><ul><li><p>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</p></li><li><p>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</p></li><li><p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</p></li><li><p>JDK AP中List接口的实现类常用的有：ArrayList、LinkedList和 Vector.</p></li></ul><blockquote><p>常用方法：</p></blockquote><p>List除了从 Collection集合继承的方法外，List集合里添加了一些&#x3D;&#x3D;根据索引来操作集合元素&#x3D;&#x3D;的方法。</p><p><code>void add(int index, Object ele)</code>:在index位置插入ele元素</p><p><code>boolean addAll(int index, Collection eles)</code>:从index位置开始将eles中的所有元素添加进来</p><p><code>Object get(int index)</code>:获取指定index位置的元素</p><p><code>int indexOf(Object obj)</code>:返回obj在集合中首次出现的位置</p><p><code>int lastIndexOf(Object obj)</code>:返回obj在当前集合中末次出现的位置</p><p><code>Object remove(int index)</code>:移除指定index位置的元素，并返回此元素</p><p><code>Object set(int index, Object ele)</code>:设置指定index位置的元素为ele</p><p><code>List subList(int fromIndex, int toIndex)</code>:返回从fromIndex到toIndex位置的子集合</p><p><strong>总结：</strong></p><ul><li><p>增：<code>add(Object obj)</code></p></li><li><p>删：<code>remove(int index)</code> &#x2F; <code>remove(Object obj)</code></p></li><li><p>改：<code>set(int index, Object ele)</code></p></li><li><p>查：<code>get(int index)</code></p></li><li><p>插：<code>add(int index, Object ele)</code></p></li><li><p>长度：<code>size()</code></p></li><li><p>遍历： ① Iterator迭代器方式 ② foreach（增强for循环） ③ 普通的循环</p></li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    <span class="comment">//int indexOf(Object obj):返回obj在集合中首次出现的位置。如果不存在，返回-1.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(<span class="number">4567</span>);</span><br><span class="line">    System.out.println(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置。如果不存在，返回-1.</span></span><br><span class="line">    System.out.println(list.lastIndexOf(<span class="number">456</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object set(int index, Object ele):设置指定index位置的元素为ele</span></span><br><span class="line">    list.set(<span class="number">1</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的左闭右开区间的子集合</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">subList</span> <span class="operator">=</span> list.subList(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    System.out.println(subList);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//void add(int index, Object ele):在index位置插入ele元素</span></span><br><span class="line">    list.add(<span class="number">1</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    list.addAll(list1);</span><br><span class="line">    <span class="comment">//        list.add(list1);</span></span><br><span class="line">    System.out.println(list.size());<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object get(int index):获取指定index位置的元素</span></span><br><span class="line">    System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>常用实现类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> 常用实现类：</span><br><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">  |----List接口：存储序的、可重复的数据。  --&gt;“动态”数组,替换原的数组</span><br><span class="line">      |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</span><br><span class="line">      |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</span><br><span class="line">      |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</span><br></pre></td></tr></table></figure><p><strong>ArrayList</strong></p><ul><li>ArrayList是List接口的典型实现类，主要实现类</li><li>本质上，ArrayList是对象引用的一个”可变长度“数组</li><li>ArrayList的JDK1.8之前与之后实现的区别：<ul><li><strong>JDK1.7</strong>：ArrayList像饿汉式，<strong>直接创建</strong>一个初始容量为10的数组</li><li><strong>JDK 1.8</strong>：ArrayList像懒汉式，<strong>一开始创建一个长度为0的数组</strong>，<strong>当添加第一个元素时再创建一个始容量为10的数组</strong></li></ul></li><li><code>Arrays.asList(...)</code>方法返回的List集合，既不是 ArrayList实例，也不是Vector实例。<code>Arrays.asList(...)</code>返回值是一个固定长度的List集合</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">345</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//iterator()遍历ArrayList集合</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedList</strong></p><ul><li>对于频繁的<strong>插入</strong>【<code>add(int index, Object ele)</code>】和<strong>删除</strong>【<code>remove(int index)</code> &#x2F; <code>remove(Object obj)</code>】元素操作，建议使用LinkedList类，效率更高</li><li>新增方法：<ul><li>void addFirst(Object obj)</li><li>void addLast(Object obj)</li><li>Object getFirst()</li><li>Object getLast()</li><li>Object removeFirest()</li><li>Object removeLast()</li></ul></li><li>LinkedList：双向链表，内部没有声明数组，定义了Node类型的First、Last，用于记录首末元素，同时，定义内部类Node,作为LinkedList中保存的基本数据结构。Node除了保存数据，还定义了两个变量：<ul><li>prev：记录前一个元素的位置</li><li>next：记录下一个元素的位置</li></ul></li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    linkedList.add(<span class="number">123</span>);</span><br><span class="line">    linkedList.add(<span class="number">345</span>);</span><br><span class="line">    linkedList.add(<span class="number">2342</span>);</span><br><span class="line">    linkedList.add(<span class="string">&quot;DDD&quot;</span>);</span><br><span class="line">    linkedList.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> linkedList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>源码分析</p></blockquote><p><strong>1、ArrayList源码分析</strong></p><p><strong>Jdk7.0情况下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//elementData[0] = new Integer(123);</span></span><br><span class="line">...</span><br><span class="line">list.add(<span class="number">11</span>);<span class="comment">//如果此次的添加导致底层elementData数组容量不够，则扩容。</span></span><br></pre></td></tr></table></figure><ul><li>默认情况下，扩容为原来容量的1.5倍，同时将原有数组中的数据复制到新的数组中。</li><li>结论：建议开发中使用带参的构造器：<code>ArrayList list = new ArrayList(int capacity)</code></li></ul><p><strong>jdk8.0中ArrayList的变化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//底层Object[] elementData初始化为&#123;&#125;.并没创建长度为10的数组</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>后续的添加和扩容操作与JDK 7.0 无异。</p><p><strong>小结：</strong></p><p>JDK 7.0中的ArrayList的对象的创建类似于单例的饿汉式，<br>JDK 8.0中的ArrayList的对象的创建类似于单例的懒汉式，&#x3D;&#x3D;延迟了数组的创建，节省内存。&#x3D;&#x3D;</p><hr><p><strong>2、LinkedList源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(); <span class="comment">//内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//将123封装到Node中，创建了Node对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其中，Node定义为：体现了LinkedList的双向链表的说法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>3、Vector的源码分析</strong></p><ul><li><p>Vector是一个古老的集合，JDK 1.0就有了。大多数操作与ArrayList相同，区别在于Vector是线程安全的</p></li><li><p>在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免选择使用。</p></li><li><p>JDK 7.0和JDK 8.0中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</p></li><li><p>在扩容方面，默认扩容为原来的数组长度的2倍。</p></li></ul><blockquote><p>存储元素的要求</p></blockquote><p>添加的对象，所在的类要重写equals()；</p><blockquote><p>面试题</p></blockquote><p>请问 ArrayList&#x2F;LinkedList&#x2F;Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？ Vector和 ArrayList的最大区别？</p><ul><li>ArrayList和LinkedList的异同<ul><li>二者都是线程不安全的，相比线程安全的Vector，ArrayList执行效率高。</li><li>ArrayLists实现了基于动态数组的数据结构，LinkedList是基于链表的数据结构。</li><li>对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针</li><li>对于插入add和删除remove操作，LinkedList占优势，双向链表结构</li></ul></li><li>ArrayList和Vector的区别<ul><li>唯一区别在于Vector是同步类，线程安全</li></ul></li><li>Vector每次扩容请求是其大小的2倍空间，ArrayList是1.5倍。</li></ul><h3 id="2-2-5、Collection子接口：Set接口"><a href="#2-2-5、Collection子接口：Set接口" class="headerlink" title="2.2.5、Collection子接口：Set接口"></a>2.2.5、Collection子接口：Set接口</h3><ul><li><p>Set接口是Collection的子接口，set接口没有提供额外的方法</p></li><li><p>Set集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set集合中，则添加操作失败。（多用于过滤操作，去掉重复数据）     </p></li><li><p>Set判断两个对象是否相同不是使用&#x3D;&#x3D;运算符，而是根据equals()方法</p></li></ul><blockquote><p>存储的数据特点</p></blockquote><p>用于存放&#x3D;&#x3D;无序的、不可重复&#x3D;&#x3D;的元素</p><p>以HashSet为例说明：</p><ol><li>无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。</li><li>不可重复性：保证添加的元素照equals()判断时，不能返回true.即：相同的元素只能添加一个。</li></ol><h3 id="2-2-6、Map接口"><a href="#2-2-6、Map接口" class="headerlink" title="2.2.6、Map接口"></a>2.2.6、Map接口</h3><h3 id="2-2-7、Collection工具类的使用"><a href="#2-2-7、Collection工具类的使用" class="headerlink" title="2.2.7、Collection工具类的使用"></a>2.2.7、Collection工具类的使用</h3><h3 id="2-2-8、数据结构简述"><a href="#2-2-8、数据结构简述" class="headerlink" title="2.2.8、数据结构简述"></a>2.2.8、数据结构简述</h3><h2 id="2-3、泛型"><a href="#2-3、泛型" class="headerlink" title="2.3、泛型"></a>2.3、泛型</h2><h2 id="2-4、IO流"><a href="#2-4、IO流" class="headerlink" title="2.4、IO流"></a>2.4、IO流</h2><h2 id="2-5、多线程"><a href="#2-5、多线程" class="headerlink" title="2.5、多线程"></a>2.5、多线程</h2><h3 id="2-5-1、程序、进程、线程"><a href="#2-5-1、程序、进程、线程" class="headerlink" title="2.5.1、程序、进程、线程"></a>2.5.1、程序、进程、线程</h3><blockquote><p>程序</p></blockquote><p>概念：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。</p><blockquote><p>进程</p></blockquote><p>概念：&#x3D;&#x3D;程序的一次执行过程，或是正在运行的一个程序&#x3D;&#x3D;。 说明：进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域。</p><blockquote><p>线程</p></blockquote><p>概念：进程可进一步细化为线程，是一个程序内部的一条执行路径。 说明：线程作为调度和执行的单位，每个线程拥独立的运行栈和程序计数器(pc)，线程切换的开销小。</p><p><img src="/2022/06/13/javaSE/image-20220519214024983.png" alt="image-20220519214024983"> </p><p><strong>内存结构：</strong></p><p><img src="/2022/06/13/javaSE/image-20220519214035442.png" alt="image-20220519214035442"> </p><p><strong>说明：</strong></p><p>进程可以细化为多个线程。 </p><ul><li><p>&#x3D;&#x3D;<strong>每个</strong>线程，拥有自己<strong>独立</strong>的：<strong>栈、程序计数器</strong>&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;<strong>多个</strong>线程，<strong>共享</strong>同一个进程中的结构：<strong>方法区、堆</strong>。&#x3D;&#x3D;</p></li></ul><h3 id="2-5-2、并行与并发"><a href="#2-5-2、并行与并发" class="headerlink" title="2.5.2、并行与并发"></a>2.5.2、并行与并发</h3><blockquote><p>单核CPU与多核CPU</p></blockquote><ul><li><p>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。涉及到CPU处理线程的方式，CPU在单位时间（也就是说一个时间片内）内只能处理一个线程，于是就将其他的线程设置为阻塞状态，加入到阻塞队列中，等到处理完成当前线程后从就绪队列中取出新的线程进行处理，由于切换和处理时间很快用户感知不到于是用户便认为CPU在同一时间内处理多个线程。</p></li><li><p>多核CPU，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</p></li><li><p>一个Java应用程序java.exe，其实至少三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</p></li></ul><blockquote><p>并行与并发的理解</p></blockquote><p>并行：&#x3D;&#x3D;多个&#x3D;&#x3D;CPU&#x3D;&#x3D;同时&#x3D;&#x3D;执行&#x3D;&#x3D;多个任务&#x3D;&#x3D;。比如：多个人同时<strong>做&#x3D;&#x3D;不同&#x3D;&#x3D;的事</strong>。</p><p>并发：&#x3D;&#x3D;一个&#x3D;&#x3D;CPU（采用时间片）同时执行多个任务。比如：多个人同时<strong>做&#x3D;&#x3D;同一&#x3D;&#x3D;件事</strong>。</p><p><strong>为什么要使用多线程</strong></p><p>当我们在进行商品抢购的时候，在支付按钮上总是有个计时器在进行倒计时，但是我们此时仍然可以进行商品信息的查看，这个计时器和我们浏览商品信息的线程是同时进行的，这样也就实现了抢购场景，增加了用户的体验。</p><blockquote><p>多线程程序优点</p></blockquote><ol><li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</li><li>提高计算机系统CPU的利用率。</li><li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。</li></ol><blockquote><p>应用场景</p></blockquote><ol><li>程序需要<strong>同时</strong>执行两个或多个任务。</li><li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等</li><li>需要一些后台运行的程序时</li></ol><h3 id="2-5-3、Thread类"><a href="#2-5-3、Thread类" class="headerlink" title="2.5.3、Thread类"></a>2.5.3、Thread类</h3><p>Java语言的JVM允许程序运行多个线程，它通过 java. lang.Thread类来体现</p><blockquote><p>Thread类特性</p></blockquote><p>每个线程都是通过某个特定 Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体 &#x3D;&#x3D;通过该 Thread对象的 **start()**方法来启动这个线程，而非直接调用run()；&#x3D;&#x3D;</p><blockquote><p>构造器</p></blockquote><ul><li><p>Thread()：创建新的 Thread对象</p></li><li><p>Thread（String threadName）：创建线程并指定线程实例名</p></li><li><p>Thread（Runnable target）：指定创建线程的目标对象，它实现了 Runnable接口中的run方法</p></li><li><p>Thread（Runnable target， String name）：创建新的 Thread对象</p></li></ul><blockquote><p>创建多线程的两种方式</p></blockquote><p><strong>1、继承Thread类</strong></p><ol><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</li><li>创建Thread类的子类的对象</li><li>通过此对象调用start()：①启动当前线程 ② 调用当前线程的run()</li></ol><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.继承Thread类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.重run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//3.新建Thread对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//4.调用start方法</span></span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ol><li>我们启动一个线程，&#x3D;&#x3D;必须调用start()&#x3D;&#x3D;，不能调用run()的方式启动线程。 如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start().（注意后面的点）</li><li>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式</li><li>&#x3D;&#x3D;run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。&#x3D;&#x3D;</li><li>想要启动多线程，必须调用 start方法。</li><li>&#x3D;&#x3D;一个线程对象只能调用一次 start()方法启动&#x3D;&#x3D;，如果重复调用了，则将抛出异常“lllegalThreadStateException”.</li></ol><p><img src="/2022/06/13/javaSE/image-20220519233135707.png" alt="image-20220519233135707"> </p><p><strong>2、实现Runnable接口</strong></p><ol><li>创建一个实现了Runnable接口的类</li><li>实现类去实现Runnable中的抽象方法：run()</li><li>创建实现类的对象<br><code>RunnableTest runnableTest = new RunnableTest();</code></li><li>&#x3D;&#x3D;将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象&#x3D;&#x3D;<br><code>Thread thread = new Thread(runnableTest);</code></li><li>通过Thread类的对象调用start()<br><code>thread.start();</code></li></ol><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3. 创建实现类的对象</span></span><br><span class="line">        <span class="type">RunnableTest</span> <span class="variable">runnableTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableTest</span>();</span><br><span class="line">        <span class="comment">//4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableTest);</span><br><span class="line">        <span class="comment">//5. 通过Thread类的对象调用start()</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两种方式的对比：</strong></p><p>开发中优先选择：实现Runnable接口的方式</p><p><strong>原因：</strong></p><ol><li>实现的方式没类的单继承性的局限性</li><li>实现的方式更适合来处理多个线程共享数据的情况。</li></ol><p><strong>联系：</strong>Thread类也是实现了Runnable接口的：<code>public class Thread implements Runnable</code></p><p><strong>相同点：</strong>两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 目前两种方式，要想启动线程，都是调用的Thread类中的start()。</p><blockquote><p>采用创建匿名类的方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Thread类的匿名子类的方式</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Thread类常用方法</p></blockquote><p><strong>常用方法</strong></p><ul><li><p>start():启动当前线程；调用当前线程的run()，只有Thread类和他的子类才能调用start()方法</p></li><li><p>run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</p></li><li><p>currentThread():静态方法，返回执行当前代码的线程</p><ul><li>getName():获取当前线程的名字</li><li>setName():设置当前线程的名字</li></ul></li><li><p>yield():释放当前cpu的执行权</p></li><li><p>join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。</p></li><li><p>stop():已过时。当执行此方法时，强制结束当前线程。</p></li><li><p>sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。</p></li><li><p>isAlive():判断当前线程是否存活</p></li></ul><p><strong>线程的优先级：</strong></p><ul><li>MAX_PRIORITY：10</li><li>MIN _PRIORITY：1</li><li>NORM_PRIORITY：5 –&gt;默认优先级</li></ul><p>获取和设置当前线程的优先级：</p><ul><li>getPriority():获取线程的优先级</li><li>setPriority(int p):设置线程的优先级</li></ul><p><strong>说明：</strong>高优先级的线程要抢占低优先级线程CPU的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。</p><p><strong>线程通信</strong>：wait() &#x2F; notify() &#x2F; notifyAll() :此三个方法定义在Object类中的。</p><p><strong>线程的分类</strong></p><ul><li>守护线程，如：垃圾回收线程，依赖于主线程而存在</li><li>用户线程，如：main方法的线程</li></ul><blockquote><p>Thread类的生命周期</p></blockquote><p><strong>线程的五种状态</strong></p><ul><li>新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。</li><li>就绪：处于新建状态的线程被start()后，将进入线程队列，等待CPU时间片，此时已经具备了运行条件，只是未分配到CPU资源。</li><li>运行：当就绪的线程被调度，并获得CPU资源时，并进入运行状态，run()方法定义了线程的操作和功能。</li><li>阻塞：在某种特殊情况下，被人为挂起，或执行输入输出操作时，让出CPU并临时终止自己执行，进入阻塞状态。</li><li>死亡：线程完成了它的全部工作，或线程被提前强制性停止，或出现异常导致结束。</li></ul><p><img src="/2022/06/13/javaSE/image-20220520004930246.png" alt="image-20220520004930246"> </p><p><strong>说明：</strong></p><ol><li>生命周期关注两个概念：状态、相应的方法</li><li>关注：状态a–&gt;状态b:哪些方法执行了（回调方法） 某个方法主动调用：状态a–&gt;状态b</li><li>阻塞：临时状态，不可以作为最终状态</li><li>死亡：最终状态。</li></ol><h3 id="2-5-4、线程的同步机制"><a href="#2-5-4、线程的同步机制" class="headerlink" title="2.5.4、线程的同步机制"></a>2.5.4、线程的同步机制</h3><blockquote><p>背景</p></blockquote><p>例子：创建个窗口卖票，总票数为100张.使用实现Runnable接口的方式</p><ul><li>问题：卖票过程中，出现了重票、错票 –&gt;出现了线程的安全问题</li><li>问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。</li><li>如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。</li></ul><blockquote><p>Java解决方案</p></blockquote><p>在Java中，我们通过同步机制，来解决线程的安全问题。</p><p><strong>方式一：同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;<span class="comment">//同步监视器就是需要同步线程的公共对象</span></span><br><span class="line">   <span class="comment">//需要被同步的代码</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li>操作共享数据的代码，即为需要被同步的代码。 –&gt;不能包含代码多了，也不能包含代码少了。</li><li>&#x3D;&#x3D;共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong>同步监视器</strong>，俗称：锁。任何一个类的对象，都可以充当锁。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;要求多个线程必须要共用同一把锁。&#x3D;&#x3D;</li></ol><ul><li>在<strong>实现Runnable接口</strong>创建多线程的方式中，我们可以<strong>考虑使用this充当同步监视器</strong>。</li><li>在<strong>继承Thread类</strong>创建多线程的方式中，慎用this充当同步监视器，<strong>考虑使用当前类充当同步监视器</strong>。</li></ul><p><strong>代码示例：</strong></p><p><strong>1、实现Runnable接口形式同步代码块：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tick</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号窗口买票，票号为：&quot;</span> + tick--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        thread3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承Thread类形式同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">//这里注意要static修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tick</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ticket2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            <span class="comment">//synchronized (Ticket2.class) &#123;//通过反射调用当前类</span></span><br><span class="line">                <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号窗口买票，票号为&quot;</span> + tick--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line"></span><br><span class="line">        ticket1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        ticket2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        ticket3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ticket1.start();</span><br><span class="line">        ticket2.start();</span><br><span class="line">        ticket3.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式二：同步方法</strong></p><p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String namer)</span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tick</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isFlag) &#123;</span><br><span class="line">            show();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;<span class="comment">//同步show方法，继承Thread类方法一样，只需同步方法即可，同时需要给方法加static关键字，确保不会创建多个对象</span></span><br><span class="line">        <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号窗口买票，票号为：&quot;</span> + tick--);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isFlag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket3</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket3</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        thread3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式三：Lock锁–jdk5.0新增</strong></p><p>从JDK 5.0开始，Java提供了更强大的线程同步机制–通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</p><p>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p><p>&#x3D;&#x3D;ReentrantLock&#x3D;&#x3D;类实现了Lock，它拥有与 synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是 <strong>Reentrantlock</strong>，可以显式加锁、释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//1.实例化ReentrantLock对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReenTrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReenTrantLook</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span> <span class="params">()</span>&#123;</span><br><span class="line">        lock.lock<span class="comment">//2.先加锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//保证线程同步的代码</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();<span class="comment">//3.后解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：如果同步代码块有异常，要将unlock()写入finally语句块中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//1.实例化ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//2.调用锁定方法lock()</span></span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：售票，票号为：&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//3.调用解锁方法：unlock()</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Window</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>同步方法的总结</p></blockquote><p>在《 Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他仼务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。</p><p><strong>synchronized的锁是什么</strong>：</p><ol><li>任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）</li><li><strong>同步方法的锁</strong>：&#x3D;&#x3D;静态方法（类名.class）&#x3D;&#x3D;、&#x3D;&#x3D;非静态方法（this）&#x3D;&#x3D;</li><li><strong>同步代码块</strong>：自己指定，很多时候也是指定为this或类名.class</li></ol><p><strong>注意点：</strong></p><ol><li>必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全</li><li>&#x3D;&#x3D;一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎）&#x3D;&#x3D;</li><li><strong>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</strong></li><li>&#x3D;&#x3D;非静态的<strong>同步方法</strong>，同步监视器是：this&#x3D;&#x3D;</li><li>&#x3D;&#x3D;静态的<strong>同步方法</strong>，同步监视器是：当前类本身&#x3D;&#x3D;</li></ol><hr><blockquote><p>同步的范围</p></blockquote><p><strong>如何找问题，即代码是否存在线程安全？（非常重要)</strong></p><p>（1）明确哪些代码是多线程运行的代码</p><p>（2）明确多个线程是否有共享数据</p><p>（3）明确多线程运行代码中是否有多条语句操作共享数据</p><p><strong>如何解决呢？（非常重要）</strong></p><p>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。 &#x3D;&#x3D;即所有操作共享数据的这些语句都要放在同步范围中&#x3D;&#x3D;</p><p><strong>注意点：</strong></p><p>范围太小：没锁住所有有安全问题的代码 范围太大：没发挥多线程的功能。</p><blockquote><p>面试题</p></blockquote><p><strong>1. synchronized 与 Lock的异同？</strong></p><ul><li>相同：二者都可以解决线程安全问题</li><li>不同：<ul><li>synchronized机制在执行完相应的同步代码之后，会自动释放同步监视器</li><li>Lock需要手动启动同步（lock()）,同时结束同步也需要手动的实现（unlock()）</li></ul></li><li>使用的优先顺序<ul><li>Lock–&gt;同步代码块（已经进入了方法体，分配了相应资源）–&gt;同步方法（在方法体之外）</li></ul></li><li>利弊：<ul><li>同步的方式解决了线程安全问题</li><li>操作代码的时，只能一个线程参与，其他线程等待；相当于一个单线程的过程，效率低</li></ul></li></ul><p><strong>2. Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同</strong></p><p>利用同步锁的方式，有三种方式：&#x3D;&#x3D;同步代码块&#x3D;&#x3D;，&#x3D;&#x3D;同步方法&#x3D;&#x3D;，&#x3D;&#x3D;lock()&#x3D;&#x3D;方法;</p><p><strong>3. synchronized和Lock方式解决线程安全问题的对比</strong></p><ul><li>相同：都可以解决线程安全问题</li><li>不同：<ul><li>synchronized机制，在执行完相应的同步代码之后，会自动释放同步监视器。</li><li>Lock需要手动启动同步lock()；结束同步的话也需要手动实现unlock();</li></ul></li></ul><hr><blockquote><p>线程安全的单例模式（饿汉单例为线程安全）</p></blockquote><p><strong>使用同步机制将单例模式中的&#x3D;&#x3D;懒汉式改写为线程安全&#x3D;&#x3D;的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">使用同步机制将单例模式中的懒汉式改写为线程安全的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//方式一：效率稍差</span></span><br><span class="line"><span class="comment">//        synchronized (Bank.class) &#123;</span></span><br><span class="line"><span class="comment">//            if(instance == null)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                instance = new Bank();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            return instance;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//方式二：效率更高</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Bank.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>死锁问题</p></blockquote><p>1、死锁的理解：不同的线程都在占用对方需要同步的资源不放弃，都在等待对方放弃自己需要同步的资源，就形成了线程的锁</p><p>2、说明：</p><ul><li>出现死锁后不会出现异常，不会出现提示，只是所有的线程处于阻塞状态，无法继续</li><li>我们使用同步时，要避免出现死锁</li></ul><p><strong>死锁举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line"></span><br><span class="line">                s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                s2.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line">                    s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(s1);</span><br><span class="line">                    System.out.println(s2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line"></span><br><span class="line">                s1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">                s2.append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line">                    s1.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(s1);</span><br><span class="line">                    System.out.println(s2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-5、线程通讯"><a href="#2-5-5、线程通讯" class="headerlink" title="2.5.5、线程通讯"></a>2.5.5、线程通讯</h3><p><strong>为了解决线程死锁问题，引入了线程通讯</strong></p><blockquote><p>线程通讯涉及到的三个方法</p></blockquote><ul><li>wait()：执行此方法，表示当前线程进入阻塞状态，并释放同步监视器（释放锁）</li><li>notify()：执行此方法，表示唤醒被wait（阻塞）的线程；若多个线程被wait，那么久唤醒优先级高的那个。</li><li>notifyAll()：执行此方法，表示唤醒所有wait（阻塞）的线程</li></ul><p><strong>说明：</strong></p><ul><li><p>wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。</p></li><li><p>wait()，notify()，notifyAll()三个方法的&#x3D;&#x3D;<strong>调用者必须是</strong>同步代码块或同步方法中的<strong>同步监视器</strong>。&#x3D;&#x3D;<br>否则，会出现IllegalMonitorStateException异常</p></li><li><p>wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。</p></li></ul><p><strong>代码示例：</strong></p><p>使用两个线程打印 1-100，线程1, 线程2 交替打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                object.notify();<span class="comment">//调用notify()方法唤醒线程</span></span><br><span class="line">                <span class="keyword">if</span> (number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="comment">//线程休眠</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + number);</span><br><span class="line">                    number++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();<span class="comment">//打印输出一次后调用wait()方法将线程阻塞</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommunicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;线程1:&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;线程2:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>面试题：</strong></p></blockquote><p><strong>问：sleep()和wait()的异同点</strong></p><p>相同点：都是起到阻塞线程的作用，一旦执行，使线程进入阻塞状态</p><p>不同点：1、声明位置不同，sleep()是Thread声明；wait()是Object类（同步监视器）声明</p><p>​2、调用要求不同，sleep()可在任何需要的场调用；wait()必须在同步代码块活同步方法中调用</p><p>​3、关于是否会释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会  释放锁。</p><blockquote><p>释放锁的操作</p></blockquote><ul><li><p>当前线程的同步方法、同步代码块执行结束</p></li><li><p>当前线程在同步代码块、同步方法中遇到 break、 return终止了该代码块该方法的继续执行。</p></li><li><p>当前线程在同步代码块、同步方法中出现了未处理的Error或 Exception，导致异常结束。</p></li><li><p>当前线程在同步代码块、同步方法中执行了线程对象的 wait()方法，当前线程暂停，并释放锁</p></li></ul><blockquote><p>不会释放锁的操作</p></blockquote><ul><li>线程在执行同步代码块或同步方法时，程序调用了<code>Thread.sleep()</code>、<code>Thread.yield()</code>暂停了当前线程的执行</li><li>线程在执行同步代码块或同步方法时，<strong>其他线程</strong>调用了该线程的<code>suspend()</code>方法，将该线程挂起，该线程不会释放锁（同步监视器）</li><li>应尽量避免使用 <code>suspend()</code>和 <code>resume()</code>来控制线程</li></ul><h3 id="2-5-6、JDK5-0新增线程创建方式"><a href="#2-5-6、JDK5-0新增线程创建方式" class="headerlink" title="2.5.6、JDK5.0新增线程创建方式"></a>2.5.6、JDK5.0新增线程创建方式</h3><blockquote><p>新增方式一、实现Callable接口</p></blockquote><p><strong>实现方法：</strong></p><ol><li>创建一个实现Callable的实现类</li><li>实现call方法，将此线程需要执行的操作声明在call()中</li><li>创建Callable接口实现类的对象<br><code>NumThread numThread = new NumThread();</code></li><li>将此Callable接口实现类的对象作为传递到**&#x3D;&#x3D;FutureTask&#x3D;&#x3D;**构造器中，创建FutureTask的对象<br><code>FutureTask futureTask = new FutureTask(numThread);</code></li><li>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()<br><code>new Thread(futureTask).start();</code></li><li>获取Callable中call方法的返回值<br><code>Object sum = futureTask.get();</code></li></ol><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</strong></p><ol><li>call()可以返回值的。</li><li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li><li>Callable是支持泛型的</li></ol><blockquote><p>方式二、使用线程池</p></blockquote><p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程对性能影响很大。</p><p><strong>解决方法</strong></p><p>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。</p><p><strong>实现方法</strong></p><p>1、提供指定数量的线程池</p><p>2、执行指定的线程操作。提供实现Runnable接口或Callable接口实现类对象。</p><p>3、关闭连接池</p><p><strong>相关API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JDK <span class="number">5.0</span>起提供了线程池相关AP|： Executor Service和 Executors</span><br><span class="line"></span><br><span class="line">Executor Service：真正的线程池接口。常见子类 Thread Poolexecutor</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command）：执行任务/命令，没有返回值，一般用来执行Runnable</span></span><br><span class="line"><span class="params">&lt;T&gt; Future&lt;T&gt; submit（Callable&lt;T&gt;task）：执行任务，有返回值，一般又来执行Callable</span></span><br><span class="line"><span class="params"><span class="keyword">void</span> shutdown()</span>：关闭连接池</span><br><span class="line"></span><br><span class="line">Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</span><br><span class="line">Executors. newCachedThreadPool()：创建一个可根据需要创建新线程的线程池</span><br><span class="line">Executors.newFⅸedthreadPool(n)；创建一个可重用固定线程数的线程池</span><br><span class="line">EXecutors. newSingleThreadEXecutor()：创建一个只有一个线程的线程池</span><br><span class="line">Executors. <span class="keyword">new</span> <span class="title class_">thread</span> Poo(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</span><br></pre></td></tr></table></figure><p>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池<br>Executors. **newCachedThreadPool()**：&#x3D;&#x3D;创建一个可根据需要创建新线程的线程池&#x3D;&#x3D;<br>Executors.**newFⅸedthreadPool(n)**；&#x3D;&#x3D;创建一个可重用固定线程数的线程池&#x3D;&#x3D;<br>EXecutors. **newSingleThreadEXecutor()**：&#x3D;&#x3D;创建一个只有一个线程的线程池&#x3D;&#x3D;<br>Executors. new thread Poo(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//        service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//        service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用线程池的好处：</strong></p><ol><li><p>提高响应速度（减少了创建新线程的时间）</p></li><li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p></li><li><p>便于线程管理</p><p>corePoolSize：核心池的大小</p><p>maximumPoolSize：最大线程数</p><p>keepAliveTime：线程没任务时最多保持多长时间后会终止</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>创建多线程的方式：</p></blockquote><p>1、继承Thread类（其本质也是实现Runnable方法）<br>2、实现Runnable方法<br>3、创建匿名类new Thread(){&#x2F;&#x2F;重写run()}.start();<br>–jdk5新增两种线程创建方式<br>4、实现Callable接口<br>5、使用线程池</p><blockquote><p>线程安全问题–同步机制（同步监视器）（同步锁）</p></blockquote><p>同步代码块、同步方法、ReentrantLock&#x3D;&#x3D;&gt;lock(),unlock()【finally中执行】</p><blockquote><p>死锁问题–线程通讯</p></blockquote><p>wait();noitfy();notifyAll();</p><h2 id="2-6、java常用类"><a href="#2-6、java常用类" class="headerlink" title="2.6、java常用类"></a>2.6、java常用类</h2><h3 id="2-6-1、String类"><a href="#2-6-1、String类" class="headerlink" title="2.6.1、String类"></a>2.6.1、String类</h3><p><code>java.lang.String</code> 类的使用</p><blockquote><p>概述</p></blockquote><p>String:字符串，使用一对””引起来表示。</p><ol><li><p>String声明为final的，不可被继承</p></li><li><p>String 实现了 <code>Serializable</code> 接口：表示字符串是支持序列化的。 实现了  <code>Comparable</code> 接口：表示String可以比较大小</p></li><li><p>String内部定义了 <code>final char[] value</code> 用于存储字符串数据</p></li><li><p>String:代表不可变的字符序列。简称：不可变性。</p><p><strong>体现：</strong></p><p>4.1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</p><p>4.2.当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p><p>4.3.当调用String的 <code>replace()</code> 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p></li><li><p>通过字面量的方式（区别于new给一个字符串赋值，此时的字符串值声明在字符串常量池中)。</p></li><li><p>字符串常量池中，是不会存储相同内容的字符串的(使用String类的equals()比较，返回true)。</p></li></ol><blockquote><p>String 的特性</p></blockquote><p>String类：代表字符串。Java程序中的所有字符串字面值（如”abc”）都作为此类的实例实现。 &#x3D;&#x3D;String是一个final类&#x3D;&#x3D;，代表&#x3D;&#x3D;不可变&#x3D;&#x3D;的字符序列。 &#x3D;&#x3D;字符串是常量&#x3D;&#x3D;，用双引号引起来表示。&#x3D;&#x3D;它们的值在创建之后不能更改。&#x3D;&#x3D; String对象的字符内容是存储在一个字符数组vaue[]中的。</p><p><strong>String源码构造器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>1、String的不可变性</strong></p></blockquote><p>当&#x3D;&#x3D;对字符串重新赋值&#x3D;&#x3D;时，&#x3D;&#x3D;需要<strong>重新指定内存区域</strong>赋值&#x3D;&#x3D;，不能使用原有的value进行赋值。</p><p>当对新的字符串&#x3D;&#x3D;进行连接&#x3D;&#x3D;操作时，也&#x3D;&#x3D;需要<strong>重新指定内存区域</strong>赋值&#x3D;&#x3D;，不能使用原有的value进行赋值。</p><p>当&#x3D;&#x3D;调用String的 <code>replace()</code> 方法修改指定字符或字符串&#x3D;&#x3D;时，也需要&#x3D;&#x3D;重新<strong>指定内存区域</strong>赋值&#x3D;&#x3D;，不能使用原有的value进行赋值。</p><p><strong>代码举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//通过字面量的定义方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false 比较s1与s2的地址值</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1);<span class="comment">//hello</span></span><br><span class="line">System.out.println(s2);<span class="comment">//def</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s3 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">System.out.println(s3);<span class="comment">//abcdef</span></span><br><span class="line">System.out.println(s2);<span class="comment">//def</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span><span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4.replace(<span class="string">&quot;t&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">System.out.println(s4);<span class="comment">//test</span></span><br><span class="line">System.out.println(s5);<span class="comment">//besb</span></span><br></pre></td></tr></table></figure><p><strong>图示解析：</strong></p><p><img src="/2022/06/13/javaSE/image-20220521133042924.png" alt="image-20220521133042924"> </p><blockquote><p><strong>2、String实例化方法</strong></p></blockquote><p><strong>实现方式说明：</strong></p><ul><li>方式一：通过字面量定义的方式</li><li>方式二：通过new + 构造器的方式</li></ul><p><strong>问：</strong><code>String s = new String(&quot;abc&quot;);</code> 方式创建对象，在内存中创建了几个对象？</p><p><strong>答：</strong>两个:一个是堆空间中new结构，另一个是<code>char[]</code>对应的常量池中的数据：”abc”</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="comment">//通过new + 构造器的方式:此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><code>String str1=“abc”;</code> 与 <code>String str2= new String(“abc”);</code> 的区别?</p><ul><li><strong>字符串常量存储在字符串常量池，</strong>目的是共享</li><li><strong>字符串非常量对象存储在堆中</strong></li></ul><p><img src="/2022/06/13/javaSE/image-20220521135018230.png" alt="image-20220521135018230"> </p><p><img src="/2022/06/13/javaSE/image-20220521135031470.png" alt="image-20220521135031470"></p><blockquote><p>字符串拼接方法赋值比较</p></blockquote><p><strong>说明：</strong></p><ol><li>&#x3D;&#x3D;常量与常量的拼接结果在常量池&#x3D;&#x3D;。且&#x3D;&#x3D;常量池中<strong>不会存在相同内容的常量</strong>&#x3D;&#x3D;。</li><li>&#x3D;&#x3D;只要<strong>其中一个是变量</strong>，结果就在<strong>堆</strong>中。&#x3D;&#x3D;</li><li>如果拼接的结果调用 <code>intern()</code> 方法，返回值就在常量池中</li></ol><p><strong>代码示例</strong>ll</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();<span class="comment">//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop”</span></span><br><span class="line">System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">****************************</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;<span class="comment">//s4:常量</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s1 == s5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>内存解析：</strong></p><p><img src="/2022/06/13/javaSE/image-20220521140647520.png" alt="image-20220521140647520"> </p><blockquote><p>String使用陷阱</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;a&quot;</span>；</span><br></pre></td></tr></table></figure><p>说明：在字符串常量池中创建了一个字面量为”a”的字符串。</p><p>s1&#x3D;s1+”b”</p><p>说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+”b”（也就是”ab”）。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。</p><p><code>String s2=&quot;ab&quot;;</code> 说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。</p><p><code>String s3=&quot;a&quot;+&quot;b&quot;;</code> 说明：s3指向字符串常量池中已经创建的”ab”的字符串。</p><p><code>String s4=s1.intern(); </code>说明：堆空间的S1对象在调用 intern()之后，会将常量池中已经存在的”ab”字符串赋值给s4。</p><blockquote><p>String 类常用方法</p></blockquote><p><strong>1、字符串操作</strong></p><p><code>int length()</code>：返回字符串的长度： <code>return value.length</code></p><p><code>char charAt(int index)</code>： 返回某索引处的字符 <code>return value[index]</code></p><p><code>boolean isEmpty()</code>：判断是否是空字符串：<code>return value.length == 0</code></p><p><code>String toLowerCase()</code>：使用默认语言环境，将 String 中的所字符转换为小写</p><p><code>String toUpperCase()</code>：使用默认语言环境，将 String 中的所字符转换为大写</p><p><code>String trim()</code>：返回字符串的副本，忽略前导空白和尾部空白</p><p><code>boolean equals(Object obj)</code>：比较字符串的内容是否相同</p><p><code>boolean equalsIgnoreCase(String anotherString)</code>：与 <code>equals()</code> 方法类似，忽略大小写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String concat(String str)`：将指定字符串连接到此字符串的结尾。 等价于用 `+</span><br></pre></td></tr></table></figure><p><code>int compareTo(String anotherString)</code>：比较两个字符串的大小</p><p><code>String substring(int beginIndex)</code>：返回一个新的字符串，它是此字符串的从beginIndex 开始截取到最后的一个子字符串。</p><p><code>String substring(int beginIndex, int endIndex)</code> ：返回一个新字符串，它是此字符串从 beginIndex 开始截取到 endIndex (不包含)的一个子字符串。</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;helloword&quot;</span>;</span><br><span class="line">    System.out.println(s1.length());<span class="comment">//9</span></span><br><span class="line">    System.out.println(s1.charAt(<span class="number">4</span>));<span class="comment">//o</span></span><br><span class="line">    System.out.println(s1.isEmpty());<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;HELLOword&quot;</span>;</span><br><span class="line">    System.out.println(s2.toLowerCase());<span class="comment">//hellowod</span></span><br><span class="line">    System.out.println(s2.toUpperCase());<span class="comment">//HELLOWORD</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot; hello word &quot;</span>;</span><br><span class="line">    System.out.println(s3.trim());<span class="comment">//hello word</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;helloword&quot;</span>;</span><br><span class="line">    System.out.println(s4.equals(s1));<span class="comment">//true</span></span><br><span class="line">    System.out.println(s4.equalsIgnoreCase(s2));<span class="comment">//true</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    System.out.println(s5.compareTo(s4));<span class="comment">//-4 相等时返回0，小的时候返回负数</span></span><br><span class="line">    System.out.println(s4.compareTo(s1));<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s4.substring(<span class="number">5</span>));<span class="comment">//word [</span></span><br><span class="line">    System.out.println(s4.substring(<span class="number">5</span>, <span class="number">9</span>));<span class="comment">//word,取值范围，前闭后开[)【从0开始】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断字符</strong></p><p><code>boolean endsWith(String suffix)</code>：测试此字符串是否以指定的后缀结束</p><p><code>boolean startsWith(String prefix)</code>：测试此字符串是否以指定的前缀开始</p><p><code>boolean startsWith(String prefix, int toffset)</code>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    System.out.println(s1.endsWith(<span class="string">&quot;EE&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(s1.startsWith(<span class="string">&quot;a&quot;</span>));<span class="comment">//false</span></span><br><span class="line">    System.out.println(s1.startsWith(<span class="string">&quot;EE&quot;</span>, <span class="number">4</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、查找字符串中的字符</strong></p><p><code>boolean contains(CharSequence s)：</code>当且仅当此字符串包含指定的 char 值序列时，返回 true</p><p><code>int indexOf(String str)</code>：返回指定子字符串在此字符串中第一次出现处的索引</p><p><code>int indexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</p><p><code>int lastIndexOf(String str)</code>：返回指定子字符串在此字符串中最右边出现处的索引</p><p><code>int lastIndexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</p><p><strong>注：</strong><code>indexOf</code> 和 <code>lastIndexOf</code> 方法如果&#x3D;&#x3D;未找到&#x3D;&#x3D;都是&#x3D;&#x3D;返回 <strong>-1</strong>&#x3D;&#x3D;</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        String s2=<span class="string">&quot;hello word&quot;</span>;</span><br><span class="line">        System.out.println(s2.length());<span class="comment">//10</span></span><br><span class="line">        System.out.println(s2.contains(<span class="string">&quot;o&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(s2.indexOf(<span class="string">&quot;o&quot;</span>));<span class="comment">//4</span></span><br><span class="line">        <span class="comment">//从指定索引处开始，取后面的字符，返回指定字符串的索引</span></span><br><span class="line">        System.out.println(s2.indexOf(<span class="string">&quot;o&quot;</span>, <span class="number">5</span>));<span class="comment">//7</span></span><br><span class="line">        <span class="comment">//返回指定字符串，最后出现的索引</span></span><br><span class="line">        System.out.println(s2.lastIndexOf(<span class="string">&quot;o&quot;</span>));<span class="comment">//7</span></span><br><span class="line">        <span class="comment">//从指定索引处开始，取前面的字符，反向取最近字符索引</span></span><br><span class="line">        System.out.println(s2.lastIndexOf(<span class="string">&quot;o&quot;</span>, <span class="number">9</span>));<span class="comment">//7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、字符串操作方法</strong></p><p><strong>替换</strong>：</p><ul><li><code>String replace(char oldChar, char newChar)</code>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。</li><li><code>String replace(CharSequence target, CharSequence replacement)</code>：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。</li><li><code>String replaceAll(String regex, String replacement)</code>：使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。</li><li><code>String replaceFirst(String regex, String replacement)</code>：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</li></ul><p><strong>匹配</strong>:</p><ul><li><code>boolean matches(String regex)</code>：告知此字符串是否匹配给定的正则表达式。</li></ul><p><strong>切片</strong>：</p><ul><li><code>String[] split(String regex)</code>：根据给定正则表达式的匹配拆分此字符串。</li><li><code>String[] split(String regex, int limit)</code>：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;北京你好，你好北京&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str1.replace(<span class="string">&#x27;北&#x27;</span>, <span class="string">&#x27;南&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(str1);<span class="comment">//北京你好，你好北京</span></span><br><span class="line">    System.out.println(str2);<span class="comment">//南京你好，你好南京</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str1.replace(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">    System.out.println(str3);<span class="comment">//上海你好，你好上海</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************************&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;12hello34world5java7891mysql456&quot;</span>;</span><br><span class="line">    <span class="comment">//把字符串中的数字替换成,，如果结果中开头和结尾有，的话去掉</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> str.replaceAll(<span class="string">&quot;\\d+&quot;</span>, <span class="string">&quot;,&quot;</span>).replaceAll(<span class="string">&quot;^,|,$&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    System.out.println(string);<span class="comment">//hello,world,java,mysql</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************************&quot;</span>);</span><br><span class="line">    str = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">    <span class="comment">//判断str字符串中是否全部有数字组成，即有1-n个数字组成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> str.matches(<span class="string">&quot;\\d+&quot;</span>);</span><br><span class="line">    System.out.println(matches);<span class="comment">//true</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> <span class="string">&quot;0571-4534289&quot;</span>;</span><br><span class="line">    <span class="comment">//判断这是否是一个杭州的固定电话</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> tel.matches(<span class="string">&quot;0571-\\d&#123;7,8&#125;&quot;</span>);</span><br><span class="line">    System.out.println(result);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************************&quot;</span>);</span><br><span class="line">    str = <span class="string">&quot;hello|world|java&quot;</span>;</span><br><span class="line">    String[] strs = str.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        System.out.println(strs[i]);<span class="comment">//依次输出hello word java</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    str2 = <span class="string">&quot;hello.world.java&quot;</span>;</span><br><span class="line">    String[] strs2 = str2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs2.length; i++) &#123;</span><br><span class="line">        System.out.println(strs2[i]);<span class="comment">//依次输出hello word java</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>String与其他结构的转换</p></blockquote><p><strong>1、String与基本数据类型、包装类之间的转换</strong></p><ul><li>String 转–&gt;基本数据类型、包装类 ；&#x3D;&#x3D;&gt; 调用包装类静态方法：<code>parseXxx(str)</code><ul><li>例：<code>Integer.parseInt(str);</code></li></ul></li><li>基本数据类型、包装类 转–&gt;String；&#x3D;&#x3D;&gt; 调用String重载的 <code>String.valueOf(xxx)</code><ul><li>例：<code>Stirng.valueOf(int)</code></li></ul></li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringToBasic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    System.out.println(i == <span class="number">123</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">456</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(j);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(s.equals(<span class="string">&quot;456&quot;</span>));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、与字符数组之间的转换</strong></p><ul><li>String –&gt; char[]:调用String的 <code>toCharArray()</code> </li><li>char[] –&gt; String:调用String的构造器<code>new String(charArray)</code></li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BasicToString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;helloword&quot;</span>;</span><br><span class="line">    <span class="type">char</span>[] chars = s1.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        System.out.println(chars[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] charArray = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    System.out.println(s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、与字节数组之间的转换</strong></p><ul><li><p>编码：String –&gt; byte[]:调用String的 <code>getBytes()</code></p><ul><li>字符串 –&gt;字节 (看得懂 —&gt;看不懂的二进制数据)</li></ul></li><li><p>解码：byte[] –&gt; String:调用String的构造器<code>new String(gbks,&quot;gbk&quot;)</code></p><ul><li>编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂）</li></ul></li></ul><p>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringToByteTest</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span><span class="string">&quot;你好java世界&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] bytesArray = s1.getBytes();<span class="comment">//使用默认字符集编码</span></span><br><span class="line">    System.out.println(Arrays.toString(bytesArray));<span class="comment">//[-28, -67, -96, -27, -91, -67, 106, 97, 118, 97, -28, -72, -106, -25, -107, -116]</span></span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] gbks = s1.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk编码集合</span></span><br><span class="line">    System.out.println(Arrays.toString(gbks));<span class="comment">//[-60, -29, -70, -61, 106, 97, 118, 97, -54, -64, -67, -25]</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String str1=<span class="keyword">new</span> <span class="title class_">String</span>(bytesArray);<span class="comment">//使用默认字符进行解码</span></span><br><span class="line">    System.out.println(str1);<span class="comment">//你好java世界</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks);<span class="comment">//使用默认字符对gbk编码进行解码</span></span><br><span class="line">    System.out.println(str2);<span class="comment">//���java����解码错误，出现中文乱码,原因：编码和解码不一致</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks,<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk格式进行解码</span></span><br><span class="line">    System.out.println(str3);<span class="comment">//你好java世界，解码正确，原因：编码和解码一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、与StringBuffer、StringBuilder之间的转换</strong></p><ul><li>String –&gt;StringBuffer、StringBuilder: 调用StringBuffer、StringBuilder构造器<ul><li><code>new StringBuffer(str1);</code></li><li><code>new StringBuilder(str1);</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringToStringBufferTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span><span class="string">&quot;helloword&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str1);</span><br><span class="line">    System.out.println(stringBuffer);<span class="comment">//helloword</span></span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str1);</span><br><span class="line">    System.out.println(stringBuilder);<span class="comment">//helloword</span></span><br><span class="line"></span><br><span class="line">    stringBuffer.append(<span class="string">&quot;isStringBuffer&quot;</span>);</span><br><span class="line">    System.out.println(stringBuffer);<span class="comment">//hellowordandgood</span></span><br><span class="line"></span><br><span class="line">    stringBuilder.append(<span class="string">&quot;isStringBuider&quot;</span>);</span><br><span class="line">    System.out.println(stringBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>StringBuffer、StringBuilder –&gt;String:<ul><li>调用String构造器<code>new String(str)</code></li><li>StringBuffer、StringBuilder的<code>toString()</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringBuiderOrStringBufferToStringTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello StringBuffer&quot;</span>);</span><br><span class="line">    System.out.println(sb1);</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello StringBuider&quot;</span>);</span><br><span class="line">    System.out.println(sb2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb1);</span><br><span class="line">    System.out.println(str1);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb2);</span><br><span class="line">    System.out.println(str2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">    System.out.println(sb1.toString());</span><br><span class="line">    System.out.println(sb2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、JVM字符串常量池存放位置</strong></p><p>jdk 1.6 (jdk 6.0 ,java 6.0):字符串常量池存储在方法区（永久区）</p><p>jdk 1.7:字符串常量池存储在堆空间</p><p>jdk 1.8:字符串常量池存储在方法区（元空间）</p><p><strong>6、常见算法题目考察</strong></p><p>1、模拟一个trim方法，去除字符串两端的空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">myTrim</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录从前往后首次索引位置不是空格的位置索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> str.length() - <span class="number">1</span>;<span class="comment">//记录从后往前首次索引位置不是空格的位置索引</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; str.charAt(start) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; str.charAt(end) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(start) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse1</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1.转换成char型数组</span></span><br><span class="line">        <span class="type">char</span>[] charArray = str.toCharArray();</span><br><span class="line">        <span class="comment">//2.进行反转操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> charArray[i];</span><br><span class="line">            charArray[i] = charArray[j];</span><br><span class="line">            charArray[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.返回值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="comment">//分析：整个字符串分为三部分不反转的、反转的、不反转的</span></span><br><span class="line"><span class="comment">//先将前面不反转的部分取出来，将反转的部分取出后进行拼接</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse2</span><span class="params">(String string, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(string != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//第一部分</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> string.substring(<span class="number">0</span>, start);</span><br><span class="line">    <span class="comment">//第二部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end; i &gt;= start; i--) &#123;</span><br><span class="line">        newStr += string.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三部分</span></span><br><span class="line">    newStr += string.substring(end + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//拼接操作</span></span><br><span class="line">    <span class="keyword">return</span> newStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三,使用StringBuffer或StringBuilder替换String优化</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse3</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="comment">//1.新建StringBuffer</span></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str.length());</span><br><span class="line">    <span class="comment">//2.第一部分</span></span><br><span class="line">    stringBuffer.append(str.substring(<span class="number">0</span>, start));</span><br><span class="line">    <span class="comment">//3.第二部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end; i &gt;= start; i--) &#123;</span><br><span class="line">        stringBuffer.append(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.第三部分</span></span><br><span class="line">    stringBuffer.append(str.substring(end + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//5.拼接操作</span></span><br><span class="line">    <span class="keyword">return</span> stringBuffer.toString();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、获取一个字符串在另一个字符串中出现的次数。 比如：获取“ ab”在 “abkkcadkabkebfkabkskab” 中出现的次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(String mainStr, String subStr)</span> &#123;</span><br><span class="line">    <span class="comment">//1.判断主串和部分串的大小</span></span><br><span class="line">    <span class="keyword">if</span> (mainStr.length() &gt;= subStr.length()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//2.在主串中取出子串下标，并将新的下标赋值给主串，统计量加1</span></span><br><span class="line">        <span class="comment">//            while ((index = mainStr.indexOf(subStr) )!= -1)&#123;</span></span><br><span class="line">        <span class="comment">//                count++;</span></span><br><span class="line">        <span class="comment">////从已经找到的子串的下一个开始</span></span><br><span class="line">        <span class="comment">//                mainStr = mainStr.substring(index + subStr.length());</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line">        <span class="comment">//改进，不再新建字符串，只做位置比对</span></span><br><span class="line">        <span class="keyword">while</span> ((index = mainStr.indexOf(subStr, index)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            index += subStr.length();</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、获取两个字符串中最大相同子串。比如： str1 &#x3D; “abcwerthelloyuiodef“;str2 &#x3D; “cvhellobnm” 提示：将短的那个串进行长度依次递减的子串与较长的串比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只存在一个子串的情况</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getMaxSameSubString</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="comment">//1.判断两个字串的大小</span></span><br><span class="line">    <span class="keyword">if</span> (str1 != <span class="literal">null</span> &amp;&amp; str2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">maxStr</span> <span class="operator">=</span> (str1.length() &gt;= str2.length()) ? str1 : str2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">minStr</span> <span class="operator">=</span> (str1.length() &lt; str2.length()) ? str1 : str2;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> minStr.length();</span><br><span class="line">        <span class="comment">//2.用小的依次去比对大的子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;<span class="comment">//这层for循环用来确定需要比对的字符次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = len - i; y &lt;= len; x++, y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (maxStr.contains(minStr.substring(x, y))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> minStr.substring(x, y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存在多个相同子串的情况</span></span><br><span class="line"><span class="comment">// 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便</span></span><br><span class="line"><span class="keyword">public</span> String [] getMaxSameSubStrings(String str1, String str2) &#123;</span><br><span class="line">    <span class="comment">//1.先比较出两个子串的大小</span></span><br><span class="line">    <span class="keyword">if</span> (str1 != <span class="literal">null</span> &amp;&amp; str2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">maxStr</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str1 : str2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">minStr</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str2 : str1;</span><br><span class="line">        <span class="comment">//2.用小的去依次匹配大的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> minStr.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = len - i; y &lt;= len; x++,y++ )&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">subString</span> <span class="operator">=</span> minStr.substring(x,y);</span><br><span class="line">                <span class="comment">//3.取出匹配到的子串</span></span><br><span class="line">                <span class="keyword">if</span> (maxStr.contains(subString))&#123;</span><br><span class="line">                    stringBuffer.append(subString+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(stringBuffer);</span></span><br><span class="line">            <span class="keyword">if</span> (stringBuffer.length() != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String [] split = stringBuffer.toString().replaceAll(<span class="string">&quot;,$&quot;</span>,<span class="string">&quot;&quot;</span>).split(<span class="string">&quot;\\,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> split;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、对字符串中字符进行自然顺序排序。 提示：</p><ol><li>字符串变成字符数组。</li><li>对数组排序，择，冒泡，<code>Arrays.sort()</code>;</li><li>将排序后的数组变成字符串。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello java&quot;</span>;</span><br><span class="line">    <span class="type">char</span>[] charArray = str1.toCharArray();</span><br><span class="line"></span><br><span class="line">    Arrays.sort(charArray);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    System.out.println(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-2、StringBuffer和StringBulider"><a href="#2-6-2、StringBuffer和StringBulider" class="headerlink" title="2.6.2、StringBuffer和StringBulider"></a>2.6.2、StringBuffer和StringBulider</h3><blockquote><p>StringBuffer</p></blockquote><p><strong>概述：</strong></p><p><code>java.lang.String.Buffer</code> 代表可变的字符序列，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。 很多方法与 String相同 作为参数传递时，方法内部可以改变值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>[] value;<span class="comment">//value没有final声明，value可以不断扩容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> count;<span class="comment">//count记录有效字符个数</span></span><br></pre></td></tr></table></figure><ul><li>StringBuffer类不同于String，&#x3D;&#x3D;其对象必须使用构造器生成&#x3D;&#x3D;</li><li>有三个构造器<ul><li><code>StringBuffer()</code>：初始容量为16的字符串缓冲区</li><li><code>StringBuffer(int size)</code>：构造指定容量的字符串缓冲区</li><li><code>StringBuffer(String str)</code>：将内容初始化为指定字符串内容</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s= <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我喜欢学习&quot;</span>)；</span><br><span class="line">StringBuffer buffer= <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;我喜欢学习&quot;</span>)；</span><br><span class="line">buffer. append(<span class="string">&quot;数学&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/06/13/javaSE/image-20220521203327349.png" alt="image-20220521203327349"> </p><p><strong>常用方法：</strong></p><ol><li><code>StringBuffer append(xxx)</code>：提供了很多的 <code>append()</code> 方法，用于进行字符串拼接</li><li><code>StringBuffer delete(int start,int end)</code>：删除指定位置的内容</li><li><code>StringBuffer replace(int start, int end, String str)</code>：把[start,end)位置替换为str</li><li><code>StringBuffer insert(int offset, xxx)</code>：在指定位置插入xxx</li><li><code>StringBuffer reverse()</code> ：把当前字符序列逆转</li></ol><p>当 append和insert时，如果原来vaue数组长度不够，可扩容。 如上这些方法支持方法链操作。 方法链的原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>public int indexOf(String str)</code>：返回子串的下标</p><p><code>public String substring(int start,int end)</code>:返回一个从start开始到end索引结束的左闭右开区间的子字符串</p><p><code>public int length()</code>：获取字符串的长度</p><p><code>public char charAt(int n )</code>：返回指定位置的字符</p><p><code>public void setCharAt(int n ,char ch)</code>：设置指定位置的字符</p><p><strong>总结：</strong></p><p>增：<code>append(xxx)</code> ；</p><p>删：<code>delete(int start,int end)</code> ；</p><p>改：<code>setCharAt(int n ,char ch) </code>&#x2F;<code> replace(int start, int end, String str)</code> ；</p><p>查：<code>charAt(int n )</code> ；</p><p>插：<code>insert(int offset, xxx)</code> ；</p><p>长度：<code>length()</code>;</p><p>遍历：<code>for() + charAt() </code>&#x2F;<code> toString()</code>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stringBufferMethodTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    System.out.println(s1);</span><br><span class="line"></span><br><span class="line">    System.out.println(s1.append(<span class="string">&quot;1&quot;</span>));<span class="comment">//abc1</span></span><br><span class="line">    System.out.println(s1.delete(<span class="number">0</span>, <span class="number">1</span>));<span class="comment">//bc1</span></span><br><span class="line">    System.out.println(s1.replace(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>));<span class="comment">//helloc1</span></span><br><span class="line">    System.out.println(s1.insert(<span class="number">3</span>, <span class="string">&quot;v&quot;</span>));<span class="comment">//helvloc1</span></span><br><span class="line">    System.out.println(s1.reverse());<span class="comment">//1colvleh</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>StringBuilder</p></blockquote><p>StringBuilder和 StringBuffer非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样，只是&#x3D;&#x3D;StringBuilder类没有加线程锁&#x3D;&#x3D;，&#x3D;&#x3D;执行效率更高&#x3D;&#x3D;。</p><p><strong>1、String、StringBuffer、StringBuilder三者的对比</strong></p><p>String:不可变的字符序列；底层使用 <code>char[]</code> 存储；占用内存（会不断的创建和回收对象）</p><p>StringBuffer:可变的字符序列；线程安全的，效率低；线程安全；底层使用char[]存储；</p><p>StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；线程不安全；底层使用 <code>char[]</code> 存储</p><p><strong>注意：</strong>作为参数传递的话，方法内部String不会改变其值， StringBuffer和 StringBuilder会改变其值。</p><p><strong>2、StringBuffer与StringBuilder的内存解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//char[] value = new char[0];</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();<span class="comment">//char[] value = new char[16];底层创建了一个长度是16的数组。</span></span><br><span class="line">System.out.println(sb1.length());<span class="comment">//</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br></pre></td></tr></table></figure><p><strong>StringBuffer构造器源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题1. <code>System.out.println(sb2.length());//3</code></p><p>问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。 默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。</p><p>指导意义：开发中建议大家使用：<code>StringBuffer(int capacity)</code> 或 <code>StringBuilder(int capacity)</code></p><p> <strong>对比String、StringBuffer、StringBuilder三者的执行效率</strong></p><ul><li>从高到低排列：StringBuilder &gt; StringBuffer &gt; String</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始设置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//开始对比</span></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        buffer.append(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        builder.append(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        text = text + i;</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;String的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-3、JDK8-0之前的日期时间API"><a href="#2-6-3、JDK8-0之前的日期时间API" class="headerlink" title="2.6.3、JDK8.0之前的日期时间API"></a>2.6.3、JDK8.0之前的日期时间API</h3><blockquote><p>java.lang.System类</p></blockquote><p>System类提供的 <code>public static long currentTimeMillis()</code> 用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。(时间戳) 此方法适于计算时间差。</p><p><strong>计算世界时间的主要标准有</strong>：</p><ul><li>UTC（Coordinated Universal Time）</li><li>GMT（Greenwich Mean Time）</li><li>CST（Central Standard Time）</li></ul><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取系统当前时间：System类中的currentTimeMillis()</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span></span><br><span class="line"><span class="comment">//称为时间戳</span></span><br><span class="line">System.out.println(time);</span><br></pre></td></tr></table></figure><blockquote><p>java.util.Date类</p></blockquote><p>表示特定的瞬间，精确到毫秒</p><p><strong>构造器</strong></p><p><code>Date()</code>:使用无参的构造器创建对象可以获取本地当前时间</p><p><code>Date(long date)</code></p><p><strong>常用方法</strong></p><p><code>getTime()</code>：返回自1970年1月1日00：00：00GMT以来此Date对象表示的毫秒数</p><p><code>tostring()</code>：把此Date对象转换为以下形式的 String</p><ul><li><p>dow mon dd</p></li><li><p>hh: mm:ss zzz yyyy</p><p>其中：doW是一周中的某一天（Sun，Mon，Tue，Wed，Thu，Fri，Sat），zzz是时间标准。 其它很多方法都过时了</p></li></ul><blockquote><p>java.util.Date类与java.sql.Date 类</p></blockquote><p><strong>1、两个构造器的使用</strong></p><ul><li>构造器一：<code>new Date()</code>：创建一个对应当前时间的Date对象</li><li>构造器二：<code>new Date(15872745176L)</code>：创建指定毫秒数的Date对象</li></ul><p><strong>2、两个方法的使用</strong></p><ul><li><code>toString()</code>:显示当前的年、月、日、时、分、秒</li><li><code>getTime()</code>:获取当前Date对象对应的毫秒数。（时间戳）</li></ul><p><strong>3、<code>java.sql.Date</code> 对应着数据库中的日期类型的变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dateTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    System.out.println(date1.toString());<span class="comment">//Sun Apr 19 13:35:12 CST 2020</span></span><br><span class="line">    System.out.println(date1.getTime());<span class="comment">//1587274512876</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">15872745176L</span>);</span><br><span class="line">    System.out.println(date2.toString());</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建java.sql.Date对象</span></span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">date3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">1587274512876L</span>);</span><br><span class="line">    System.out.println(date3.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//第一种方式，存在问题：java.util.Date cannot be cast to java.sql.Date</span></span><br><span class="line">    <span class="comment">//        java.sql.Date date6 = (java.sql.Date) date4;</span></span><br><span class="line">    <span class="comment">//        System.out.println(date6);</span></span><br><span class="line">    <span class="comment">//第二种方式</span></span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">date5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date4.getTime());</span><br><span class="line">    System.out.println(date5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>java.text.SimpleDateFormat 类</p></blockquote><p>Date类的API不易于国际化，大部分被废弃了， <code>java.text.SimpleDateFormat</code> 类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</p><p>它允许进行格式化：日期→文本、解析：文本→日期</p><p><strong>实例化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>格式化：</strong></p><p>​<code>SimpleDateFormat()</code>：默认的模式和语言环境创建对象</p><p>​<code>public SimpleDateFormat(String pattern)</code>：该构造方法可以用参数 pattern指定的格式创建一个对象，该对象调用：</p><p>​<code>public String format(Datedate)</code>：方法&#x3D;&#x3D;格式化时间对象date&#x3D;&#x3D;</p><p><strong>解析</strong>：</p><p>​ <code>public Date parse(String source)</code>：从给定字符串的开始&#x3D;&#x3D;解析文本&#x3D;&#x3D;，以生成个日期</p><p><strong>SimpleDateFormat对日期Date类的格式化和解析</strong></p><ul><li><p>格式化：<code>format(date1)</code>日期 —&gt;字符串</p></li><li><p>解析：<code>parse(&quot;2020-04-20 14:20:下午&quot;)</code>格式化的逆过程，字符串 —&gt; 日期</p></li></ul><p><strong>SimpleDateFormat的实例化:new + 构造器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:aa&quot;</span>);</span><br><span class="line"><span class="comment">//格式化format</span></span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(date1);</span><br><span class="line">System.out.println(format.toString());<span class="comment">//2020-09-19 02:09:下午</span></span><br><span class="line"><span class="comment">//解析parse</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> simpleDateFormat.parse(<span class="string">&quot;2020-04-20 14:20:下午&quot;</span>);</span><br><span class="line">System.out.println(date2.toString());<span class="comment">//Tue Jan 21 02:20:00 CST 2020</span></span><br></pre></td></tr></table></figure><p><img src="/2022/06/13/javaSE/image-20220521220849369.png" alt="image-20220521220849369"> </p><p><strong>练习：</strong>将字符串”2020-09-08”转换为 <code>java.sql.Date</code> 格式的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="comment">//将字符串&quot;2020-09-08&quot;转换为 java.sql.Date 格式的时间</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="comment">//文本解析成utilDate</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">utilDate</span> <span class="operator">=</span> simpleDateFormat.parse(<span class="string">&quot;2020-09-08&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;utilDate==&gt;&quot;</span>+utilDate.toString());<span class="comment">//utilDate==&gt;Tue Sep 08 00:00:00 CST 2020</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//utilDate转sqlDate</span></span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">sqlDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(utilDate.getTime());</span><br><span class="line">    System.out.println(<span class="string">&quot;sqlDate==&gt;&quot;</span>+sqlDate);<span class="comment">//sqlDate==&gt;2020-09-08</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Calendar类：日历类、抽象类</p></blockquote><p>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。</p><ul><li><p>获取 Calenda实例的方法 使用 Calendar.getInstance()方法 调用它的子类 GregorianCalendarl的构造器。</p></li><li><p>一个 Calendar的实例是系统时间的抽象表示，通过 get(int field)方法来取得想要的时间信息。 比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY、MINUTE、SECOND</p></li></ul><p><strong>注意：</strong> 获取月份时：一月是0，二月是1，以此类推，12月是11 获取星期时：周日是1，周一是2，。。。周六是7</p><p><strong>实例化</strong></p><ul><li>创建其子类(GregorianCalendar)的对象</li><li>调用其静态方法 <code>getInstance()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br></pre></td></tr></table></figure><p><strong>常用方法</strong></p><p><code>get()</code>:获取日期</p><p><code>set()</code>:设置日期</p><p><code>add()</code>:添加、修改日期</p><p><code>getTime</code>:日历类–&gt;Date</p><p><code>setTime</code>:Date–&gt;日历类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//        System.out.println(calendar.getClass());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.常用方法</span></span><br><span class="line"><span class="comment">//get()</span></span><br><span class="line"><span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);<span class="comment">//获取本月第几天</span></span><br><span class="line">System.out.println(days);</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_YEAR));<span class="comment">//获取本年第几天</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set()</span></span><br><span class="line"><span class="comment">//calendar可变性</span></span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH,<span class="number">22</span>);<span class="comment">//设置本月第几天</span></span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br><span class="line"></span><br><span class="line"><span class="comment">//add()</span></span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH,-<span class="number">3</span>);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br><span class="line"></span><br><span class="line"><span class="comment">//getTime():日历类---&gt; Date</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">//setTime():Date ---&gt; 日历类</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">calendar.setTime(date1);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure><h3 id="2-6-4、JDK8-0中新的日期时间类"><a href="#2-6-4、JDK8-0中新的日期时间类" class="headerlink" title="2.6.4、JDK8.0中新的日期时间类"></a>2.6.4、JDK8.0中新的日期时间类</h3><blockquote><p>日期时间API的迭代</p></blockquote><p>第一代：jdk 1.0 Date类</p><p>第二代：jdk 1.1 Calendar类，一定程度上替换Date类</p><p>第三代：jdk 1.8 提出了新的一套API</p><blockquote><p>前两代的问题</p></blockquote><p>可变性：像日期和时间这样的类应该是不可变的。</p><p>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</p><p>格式化：格式化只对Date用，Calendar则不行。 此外，它们也不是线程安全的；不能处理闰秒等。</p><p>Java 8.0中新引入的java.time API:</p><p>Java 8.0吸收了Joda-Time的精华，以一个新的开始为Java创建优秀的APl。新的java.time中包含了所有关于本地日期(LocalDate)、本地时间(Localtime)、本地日期时间(LocalDate time)、时区(ZonedDate time)和持续时间(Duration)的类。历史悠久的Date类新增了tolnstant()方法用于把Date转换成新的表示形式。这些新增的本地化时间日期API大大简化了日期时间和本地化的管理。</p><blockquote><p>Java8.0中新的日期时间API涉及的包</p></blockquote><p><img src="/2022/06/13/javaSE/image-20220521223213524.png" alt="image-20220521223213524"> </p><blockquote><p> 本地日期、本地时间、本地日期时间的使用：</p></blockquote><ul><li>LocalDate &#x2F; LocalTime &#x2F; LocalDateTime</li></ul><p><strong>说明：</strong></p><p>① 分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p><p>② LocalDateTime相较于LocalDate、LocalTime，使用频率要高</p><p>③ 类似于Calendar</p><p><strong>常用方法</strong></p><p><img src="/2022/06/13/javaSE/image-20220521223543707.png" alt="image-20220521223543707"> </p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//now():获取当前的日期、时间、日期时间</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    System.out.println(localDate);<span class="comment">//2020-04-21</span></span><br><span class="line">    System.out.println(localTime);<span class="comment">//18:52:54.929</span></span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:52:54.929</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//of():设置指定的年、月、日、时、分、秒。没有偏移量</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">12</span>);</span><br><span class="line">    System.out.println(localDateTime1);<span class="comment">//2020-10-06T12:13:12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//getXxx()：获取相关的属性</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfMonth());<span class="comment">//21</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfWeek());<span class="comment">//TUESDAY</span></span><br><span class="line">    System.out.println(localDateTime.getMonth());<span class="comment">//APRIL</span></span><br><span class="line">    System.out.println(localDateTime.getMonthValue());<span class="comment">//4</span></span><br><span class="line">    System.out.println(localDateTime.getMinute());<span class="comment">//52</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//体现不可变性</span></span><br><span class="line">    <span class="comment">//withXxx():设置相关的属性</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> localDate.withDayOfMonth(<span class="number">22</span>);</span><br><span class="line">    System.out.println(localDate);<span class="comment">//2020-04-21</span></span><br><span class="line">    System.out.println(localDate1);<span class="comment">//2020-04-22</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime2</span> <span class="operator">=</span> localDateTime.withHour(<span class="number">4</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:59:17.484</span></span><br><span class="line">    System.out.println(localDateTime2);<span class="comment">//2020-04-21T04:59:17.484</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不可变性</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime3</span> <span class="operator">=</span> localDateTime.plusMonths(<span class="number">3</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:59:17.484</span></span><br><span class="line">    System.out.println(localDateTime3);<span class="comment">//2020-07-21T18:59:17.484</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime4</span> <span class="operator">=</span> localDateTime.minusDays(<span class="number">6</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:59:17.484</span></span><br><span class="line">    System.out.println(localDateTime4);<span class="comment">//2020-04-15T18:59:17.484</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间点：Instant</p></blockquote><p><strong>说明：</strong></p><p>① 时间线上的一个瞬时点。 概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC开始的秒数。）</p><p>② 类似于 <code>java.util.Date</code> 类</p><p><strong>常用方法：</strong></p><p><img src="/2022/06/13/javaSE/image-20220521223718589.png" alt="image-20220521223718589"> </p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//now():获取本初子午线对应的标准时间</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">    System.out.println(instant);<span class="comment">//2020-04-21T11:03:21.469Z</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加时间的偏移量</span></span><br><span class="line">    <span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span> <span class="operator">=</span> instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    System.out.println(offsetDateTime);<span class="comment">//2020-04-21T19:03:21.469+08:00</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数  ---&gt; Date类的getTime()</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">milli</span> <span class="operator">=</span> instant.toEpochMilli();</span><br><span class="line">    System.out.println(milli);<span class="comment">//1587467105795</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ofEpochMilli():通过给定的毫秒数，获取Instant实例  --&gt;Date(long millis)</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.ofEpochMilli(<span class="number">1587467105795L</span>);</span><br><span class="line">    System.out.println(instant1);<span class="comment">//2020-04-21T11:05:05.795Z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>日期时间格式化类：DateTimeFormatter</p></blockquote><p> <strong>说明：</strong></p><p>① 格式化或解析日期、时间</p><p>② 类似于 <code>SimpleDateFormat</code></p><p><strong>常用方法：</strong></p><ol><li>实例化方式： 预定义的标准格式。如：<code>ISO\_LOCAL\_DATE\_TIME;</code></li></ol><ul><li>ISO_LOCAL_DATE;ISO_LOCAL_TIME 本地化相关的格式：</li><li>如：<code>ofLocalizedDateTime(FormatStyle.LONG) </code></li><li>自定义的格式：如：<code>ofPattern(“yyyy-MM-dd hh:mm:ss”)</code></li></ul><p><img src="/2022/06/13/javaSE/image-20220521224008828.png" alt="image-20220521224008828"> </p><p><strong>特别的：</strong>自定义的格式。如：<code>ofPattern(“yyyy-MM-dd hh:mm:ss”)</code></p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//        方式一：预定义的标准格式。</span></span><br><span class="line">    <span class="comment">//        如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">    <span class="comment">//格式化:日期--&gt;字符串</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> formatter.format(localDateTime);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T19:13:13.530</span></span><br><span class="line">    System.out.println(str1);<span class="comment">//2020-04-21T19:13:13.53</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析：字符串 --&gt;日期</span></span><br><span class="line">    <span class="type">TemporalAccessor</span> <span class="variable">parse</span> <span class="operator">=</span> formatter.parse(<span class="string">&quot;2000-04-21T19:13:13.53&quot;</span>);</span><br><span class="line">    System.out.println(parse);<span class="comment">//&#123;&#125;,ISO resolved to 2000-04-21T19:13:13.530</span></span><br><span class="line">    <span class="comment">//        方式二：</span></span><br><span class="line">    <span class="comment">//        本地化相关的格式。如：ofLocalizedDateTime()</span></span><br><span class="line">    <span class="comment">//        FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter1</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> formatter1.format(localDateTime);</span><br><span class="line">    System.out.println(str2);<span class="comment">//2020年4月21日 下午07时16分57秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//      本地化相关的格式。如：ofLocalizedDate()</span></span><br><span class="line">    <span class="comment">//      FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter2</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM);</span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> formatter2.format(LocalDate.now());</span><br><span class="line">    System.out.println(str3);<span class="comment">//2020-4-21</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//       重点： 方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter3</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">Str4</span> <span class="operator">=</span> formatter3.format(LocalDateTime.now());</span><br><span class="line">    System.out.println(Str4);<span class="comment">//2020-04-21 07:24:04</span></span><br><span class="line"></span><br><span class="line">    <span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> formatter3.parse(<span class="string">&quot;2020-02-03 05:23:06&quot;</span>);</span><br><span class="line">    System.out.println(accessor);<span class="comment">//&#123;SecondOfMinute=6, HourOfAmPm=5, NanoOfSecond=0, MicroOfSecond=0, MinuteOfHour=23, MilliOfSecond=0&#125;,ISO resolved to 2020-02-03</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他API的使用</p></blockquote><p><img src="/2022/06/13/javaSE/image-20220521224218705.png" alt="image-20220521224218705"> </p><p><strong>1、带时区的日期时间</strong></p><p>ZonedDateTime &#x2F; ZoneId</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZoneId:类中包含了所的时区信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//getAvailableZoneIds():获取所的ZoneId</span></span><br><span class="line">    Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">    <span class="keyword">for</span>(String s : zoneIds)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取“Asia/Tokyo”时区对应的时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Tokyo&quot;</span>));</span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ZonedDateTime:带时区的日期时间</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//now():获取本时区的ZonedDateTime对象</span></span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">    System.out.println(zonedDateTime);</span><br><span class="line">    <span class="comment">//now(ZoneId id):获取指定时区的ZonedDateTime对象</span></span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime1</span> <span class="operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Tokyo&quot;</span>));</span><br><span class="line">    System.out.println(zonedDateTime1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、时间间隔</strong></p><p>Duration–用于计算两个“时间”间隔，以秒和纳秒为基准</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">localTime1</span> <span class="operator">=</span> LocalTime.of(<span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line">    <span class="comment">//between():静态方法，返回Duration对象，表示两个时间的间隔</span></span><br><span class="line">    <span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(localTime1, localTime);</span><br><span class="line">    System.out.println(duration);</span><br><span class="line"></span><br><span class="line">    System.out.println(duration.getSeconds());</span><br><span class="line">    System.out.println(duration.getNano());</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2017</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Duration</span> <span class="variable">duration1</span> <span class="operator">=</span> Duration.between(localDateTime1, localDateTime);</span><br><span class="line">    System.out.println(duration1.toDays());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、日期间隔</strong></p><p>Period –用于计算两个“日期”间隔，以年、月、日衡量</p><p><img src="/2022/06/13/javaSE/image-20220521224507834.png" alt="image-20220521224507834"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2028</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(localDate, localDate1);</span><br><span class="line">    System.out.println(period);</span><br><span class="line"></span><br><span class="line">    System.out.println(period.getYears());</span><br><span class="line">    System.out.println(period.getMonths());</span><br><span class="line">    System.out.println(period.getDays());</span><br><span class="line"></span><br><span class="line">    <span class="type">Period</span> <span class="variable">period1</span> <span class="operator">=</span> period.withYears(<span class="number">2</span>);</span><br><span class="line">    System.out.println(period1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、日期时间校正器<code>TemporalAdjuster</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取当前日期的下一个周日是哪天？</span></span><br><span class="line">    <span class="type">TemporalAdjuster</span> <span class="variable">temporalAdjuster</span> <span class="operator">=</span> TemporalAdjusters.next(DayOfWeek.SUNDAY);</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now().with(temporalAdjuster);</span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取下一个工作日是哪天？</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now().with(<span class="keyword">new</span> <span class="title class_">TemporalAdjuster</span>()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Temporal <span class="title function_">adjustInto</span><span class="params">(Temporal temporal)</span> &#123;</span><br><span class="line">            <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> (LocalDate)temporal;</span><br><span class="line">            <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.FRIDAY))&#123;</span><br><span class="line">                <span class="keyword">return</span> date.plusDays(<span class="number">3</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.SATURDAY))&#123;</span><br><span class="line">                <span class="keyword">return</span> date.plusDays(<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> date.plusDays(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;下一个工作日是：&quot;</span> + localDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、新的日期API与原来API的转化问题</strong></p><p><img src="/2022/06/13/javaSE/image-20220521224846067.png" alt="image-20220521224846067"></p><h3 id="2-6-5、Java比较器"><a href="#2-6-5、Java比较器" class="headerlink" title="2.6.5、Java比较器"></a>2.6.5、Java比较器</h3><blockquote><p>使用背景</p></blockquote><ul><li><p>Java中的对象，正常情况下，只能进行比较：<code>==</code> 或 <code>!=</code>。不能使用 <code>&gt;</code> 或 <code>&lt;</code> 的</p></li><li><p>但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。</p></li><li><p>如何实现？使用两个接口中的任何一个：Comparable（自然排序） 或 Comparator（定制排序）</p></li></ul><blockquote><p>Comparable（自然排序）</p></blockquote><ol><li>像 String 或包装类等实现了Comparable接口，重写了 <code>compareTo(obj)</code> 方法，给出了比较两个对象大小的方式。</li></ol><p>像 String 或包装类重写 <code>compareTo()</code> 方法以后，进行了从小到大的排列</p><ol start="2"><li><p>重写 <code>compareTo(obj)</code> 的规则： 如果当前对象this大于形参对象obj，则返回正整数， 如果当前对象this小于形参对象obj，则返回负整数， 如果当前对象this等于形参对象obj，则返回零。</p></li><li><p>对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写  <code>compareTo(obj)</code> 方法。在<code> compareTo(obj)</code> 方法中指明如何排序</p></li><li><p>Comparable的典型实现：(&#x3D;&#x3D;默认都是<strong>从小到大</strong>排列的&#x3D;&#x3D;) String：按照字符串中字符的Uincode值进行比较 ;Character：按照字符的 Unicode值来进行比较 数值类型对应的包装类以及 BigInteger、BigDecimal：按照它们对应的数值大小进行比较 Boolean：true对应的包装类实例大于false对应的包装类实例 Date、Time等：后面的日期时间比前面的日期时间大</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span>  <span class="title class_">Comparable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指明商品比较大小的方式:照价格从低到高排序,再照产品名称从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//        System.out.println(&quot;**************&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods)o;</span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//                return 0;</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line">            <span class="comment">//           return Double.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//        return 0;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter、setter、toString()、构造器：省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定制排序：使用Comparator接口</p></blockquote><ol><li>背景：</li></ol><p>当元素的类型没实现 <code>java.lang.Comparable</code> 接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序</p><ol start="2"><li>重写 <code>compare(Object o1,Object o2)</code> 方法，比较o1和o2的大小：</li></ol><ul><li>如果方法返回正整数，则表示o1大于o2；</li><li>如果返回0，表示相等；</li><li>返回负整数，表示o1小于o2。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">          <span class="comment">//指明商品比较大小的方式:照产品名称从低到高排序,再照价格从高到低排序</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">              <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">                  <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods)o1;</span><br><span class="line">                  <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods)o2;</span><br><span class="line">                  <span class="keyword">if</span>(g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                      <span class="keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());</span><br><span class="line">                  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                      <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Goods</span>();</span><br><span class="line">      g1.setName(<span class="string">&quot;xx&quot;</span>);</span><br><span class="line">      g1.setPrice(<span class="number">9.9</span>);</span><br><span class="line">      <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Goods</span>();</span><br><span class="line">      g2.setName(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">      g2.setPrice(<span class="number">99.99</span>);</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">      com.compare(g1,g2);</span><br></pre></td></tr></table></figure><p><strong>两种排序方式对比</strong></p><ul><li>Comparable接口的方式是一定的，保证Comparable接口实现类的对象在任何位置都可以比较大小。</li><li>Comparator接口属于临时性的比较。</li></ul><h3 id="2-6-6、其他常用类"><a href="#2-6-6、其他常用类" class="headerlink" title="2.6.6、其他常用类"></a>2.6.6、其他常用类</h3><blockquote><p>System类</p></blockquote><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。</p><p>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</p><p><strong>成员方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">native</span> <span class="type">long</span> <span class="title function_">currentTimeMillis</span><span class="params">()</span>：</span><br></pre></td></tr></table></figure><p>该方法的作用是&#x3D;&#x3D;返回当前的计算机时间&#x3D;&#x3D;，时间的表达格式为当前计算机时间和GMT时间（格林威治时间）1970年1月1号0时0分0秒所差的毫秒数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br></pre></td></tr></table></figure><p>该方法的作用是&#x3D;&#x3D;退出程序&#x3D;&#x3D;。其中 status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">gc</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>该方法的作用是请求系统进行&#x3D;&#x3D;垃圾回收&#x3D;&#x3D;。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getProperty</span><span class="params">(String key)</span></span><br></pre></td></tr></table></figure><p>该方法的作用是&#x3D;&#x3D;获得系统中属性名为key的属性对应的值&#x3D;&#x3D;。系统中常见的属性名以及属性的作用如下表所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b00d883e59204e80855556b458c56548~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200421114933166"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">javaVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;java的version:&quot;</span> + javaVersion);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">javaHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.home&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;java的home:&quot;</span> + javaHome);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;os的name:&quot;</span> + osName);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">osVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.version&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;os的version:&quot;</span> + osVersion);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user的name:&quot;</span> + userName);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">userHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user的home:&quot;</span> + userHome);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user的dir:&quot;</span> + userDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Math类</p></blockquote><p><code>java.lang.Math</code> 提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型</p><p><img src="/2022/06/13/javaSE/image-20220522002127236.png" alt="image-20220522002127236"> </p><blockquote><p><strong>BigInteger类、BigDecimal类</strong></p></blockquote><p><strong>BigInteger</strong></p><p><code>java.math </code>包的BigInteger可以表示不可变的任意精度的整数。</p><p>BigInteger提供所有Java的基本整数操作符的对应物，并提供 <code>java.lang.Math</code> 的所有相关方法。另外，BigInteger还提供以下运算：模算术、GCD计算、质数测试、素数生成、位操作以及一些其他操作。</p><p>构造器： <code>BigInteger(String val)</code>：根据字符串构建 BigInteger对象</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546e8ddf062840e5ac1dcb88e86a7d4b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200421115521295"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1243324112234324324325235245346567657653&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    System.out.println(bi);</span><br><span class="line">    <span class="comment">//         System.out.println(bd.divide(bd2));</span></span><br><span class="line">    System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">    System.out.println(bd.divide(bd2, <span class="number">25</span>, BigDecimal.ROUND_HALF_UP));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BigDecimal</strong></p><p>要求数字精度比较高，用到 <code>java.math.BigDecimal</code> 类</p><p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p><p><strong>构造器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BigDecimal</span><span class="params">(<span class="type">double</span> val)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BigDecimal</span><span class="params">(String val)</span></span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">add</span><span class="params">(BigDecimal augend)</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">subtract</span><span class="params">(BigDecimal subtrahend)</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">multiply</span><span class="params">(BigDecimal multiplicand)</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal divisor， <span class="type">int</span> scale， <span class="type">int</span> rounding Mode)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1243324112234324324325235245346567657653&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    System.out.println(bi);</span><br><span class="line">    <span class="comment">//         System.out.println(bd.divide(bd2));</span></span><br><span class="line">    System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">    System.out.println(bd.divide(bd2, <span class="number">25</span>, BigDecimal.ROUND_HALF_UP));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7、java反射机制"><a href="#2-7、java反射机制" class="headerlink" title="2.7、java反射机制"></a>2.7、java反射机制</h2><h2 id="2-8、网络编程"><a href="#2-8、网络编程" class="headerlink" title="2.8、网络编程"></a>2.8、网络编程</h2><h2 id="2-9、java8-amp-Lambda表达式-amp-Stream-API的使用"><a href="#2-9、java8-amp-Lambda表达式-amp-Stream-API的使用" class="headerlink" title="2.9、java8&amp;Lambda表达式&amp;Stream API的使用"></a>2.9、java8&amp;Lambda表达式&amp;Stream API的使用</h2><h2 id="2-10、java9-amp-10-amp-11-新特性"><a href="#2-10、java9-amp-10-amp-11-新特性" class="headerlink" title="2.10、java9&amp;10&amp;11 新特性"></a>2.10、java9&amp;10&amp;11 新特性</h2><h1 id="三、java技术拓展"><a href="#三、java技术拓展" class="headerlink" title="三、java技术拓展"></a>三、java技术拓展</h1><h2 id="3-1、数据结构"><a href="#3-1、数据结构" class="headerlink" title="3.1、数据结构"></a>3.1、数据结构</h2><h2 id="3-2、常用算法"><a href="#3-2、常用算法" class="headerlink" title="3.2、常用算法"></a>3.2、常用算法</h2><h2 id="3-3、常用设计模式"><a href="#3-3、常用设计模式" class="headerlink" title="3.3、常用设计模式"></a>3.3、常用设计模式</h2><h2 id="3-4、JVM"><a href="#3-4、JVM" class="headerlink" title="3.4、JVM"></a>3.4、JVM</h2>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署Hexo显示Permission Denied的解决方法</title>
      <link href="/2022/06/11/deploy-hexo/"/>
      <url>/2022/06/11/deploy-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><h3 id="查看-config-yml-中git的配置-和GitHub的ssh配置"><a href="#查看-config-yml-中git的配置-和GitHub的ssh配置" class="headerlink" title="查看_config.yml 中git的配置,和GitHub的ssh配置"></a>查看_config.yml 中git的配置,和GitHub的ssh配置</h3><p> _config.yml 中git的配置如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:start-spt/start-spt.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><h3 id="第一步检查无误后-仍然存在问题-删除deploy-git-重新以下-操作"><a href="#第一步检查无误后-仍然存在问题-删除deploy-git-重新以下-操作" class="headerlink" title="第一步检查无误后,仍然存在问题,删除deploy_git,重新以下,操作"></a>第一步检查无误后,仍然存在问题,删除deploy_git,重新以下,操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 构建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/06/11/hello-world/"/>
      <url>/2022/06/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
